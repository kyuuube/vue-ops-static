(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[26],{

/***/ 162:
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/_@antv_hierarchy@0.6.2@@antv/hierarchy/build/hierarchy.js\":\n/*!********************************************************************************!*\\\n  !*** ./node_modules/_@antv_hierarchy@0.6.2@@antv/hierarchy/build/hierarchy.js ***!\n  \\********************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assign = __webpack_require__(7);\n\nmodule.exports = {\n  assign: assign\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar hierarchy = __webpack_require__(3);\n\nvar Layout = /*#__PURE__*/function () {\n  function Layout(root, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var me = this;\n    me.options = options;\n    me.rootNode = hierarchy(root, options);\n  }\n\n  var _proto = Layout.prototype;\n\n  _proto.execute = function execute() {\n    throw new Error('please override this method');\n  };\n\n  return Layout;\n}();\n\nmodule.exports = Layout;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar separateTree = __webpack_require__(4);\n\nvar VALID_DIRECTIONS = ['LR', // left to right\n'RL', // right to left\n'TB', // top to bottom\n'BT', // bottom to top\n'H', // horizontal\n'V' // vertical\n];\nvar HORIZONTAL_DIRECTIONS = ['LR', 'RL', 'H'];\n\nvar isHorizontal = function isHorizontal(direction) {\n  return HORIZONTAL_DIRECTIONS.indexOf(direction) > -1;\n};\n\nvar DEFAULT_DIRECTION = VALID_DIRECTIONS[0];\n\nmodule.exports = function (root, options, layoutAlgrithm) {\n  var direction = options.direction || DEFAULT_DIRECTION;\n  options.isHorizontal = isHorizontal(direction);\n\n  if (direction && VALID_DIRECTIONS.indexOf(direction) === -1) {\n    throw new TypeError(\"Invalid direction: \" + direction);\n  }\n\n  if (direction === VALID_DIRECTIONS[0]) {\n    // LR\n    layoutAlgrithm(root, options);\n  } else if (direction === VALID_DIRECTIONS[1]) {\n    // RL\n    layoutAlgrithm(root, options);\n    root.right2left();\n  } else if (direction === VALID_DIRECTIONS[2]) {\n    // TB\n    layoutAlgrithm(root, options);\n  } else if (direction === VALID_DIRECTIONS[3]) {\n    // BT\n    layoutAlgrithm(root, options);\n    root.bottom2top();\n  } else if (direction === VALID_DIRECTIONS[4] || direction === VALID_DIRECTIONS[5]) {\n    // H or V\n    // separate into left and right trees\n    var _separateTree = separateTree(root, options),\n        left = _separateTree.left,\n        right = _separateTree.right; // do layout for left and right trees\n\n\n    layoutAlgrithm(left, options);\n    layoutAlgrithm(right, options);\n    options.isHorizontal ? left.right2left() : left.bottom2top(); // combine left and right trees\n\n    right.translate(left.x - right.x, left.y - right.y); // translate root\n\n    root.x = left.x;\n    root.y = right.y;\n    var bb = root.getBoundingBox();\n\n    if (options.isHorizontal) {\n      if (bb.top < 0) {\n        root.translate(0, -bb.top);\n      }\n    } else {\n      if (bb.left < 0) {\n        root.translate(-bb.left, 0);\n      }\n    }\n  } // fixed root position, default value is true\n\n\n  var fixedRoot = options.fixedRoot;\n  if (fixedRoot === undefined) fixedRoot = true;\n\n  if (fixedRoot) {\n    root.translate(-(root.x + root.width / 2 + root.hgap), -(root.y + root.height / 2 + root.vgap));\n  }\n\n  return root;\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* eslint-disable no-cond-assign */\nvar util = __webpack_require__(0);\n\nvar PEM = 18;\nvar DEFAULT_HEIGHT = PEM * 2;\nvar DEFAULT_GAP = PEM;\nvar DEFAULT_OPTIONS = {\n  getId: function getId(d) {\n    return d.id || d.name;\n  },\n  getHGap: function getHGap(d) {\n    return d.hgap || DEFAULT_GAP;\n  },\n  getVGap: function getVGap(d) {\n    return d.vgap || DEFAULT_GAP;\n  },\n  getChildren: function getChildren(d) {\n    return d.children;\n  },\n  getHeight: function getHeight(d) {\n    return d.height || DEFAULT_HEIGHT;\n  },\n  getWidth: function getWidth(d) {\n    var name = d.name || ' ';\n    return d.width || name.split('').length * PEM; // FIXME DO NOT get width like this\n  }\n};\n\nfunction Node(data, options) {\n  var me = this;\n  me.vgap = me.hgap = 0;\n  if (data instanceof Node) return data;\n  me.data = data;\n  /*\n   * Gaps: filling space between nodes\n   * (x, y) ----------------------\n   * |            vgap            |\n   * |    --------------------    h\n   * | h |                    |   e\n   * | g |                    |   i\n   * | a |                    |   g\n   * | p |                    |   h\n   * |   ---------------------    t\n   * |                            |\n   *  -----------width------------\n   */\n\n  var hgap = options.getHGap(data);\n  var vgap = options.getVGap(data);\n  me.width = options.getWidth(data);\n  me.height = options.getHeight(data);\n  me.id = options.getId(data);\n  me.x = me.y = 0;\n  me.depth = 0;\n\n  if (!me.children) {\n    me.children = [];\n  }\n\n  me.addGap(hgap, vgap);\n  return me;\n}\n\nutil.assign(Node.prototype, {\n  isRoot: function isRoot() {\n    return this.depth === 0;\n  },\n  isLeaf: function isLeaf() {\n    return this.children.length === 0;\n  },\n  addGap: function addGap(hgap, vgap) {\n    var me = this;\n    me.hgap += hgap;\n    me.vgap += vgap;\n    me.width += 2 * hgap;\n    me.height += 2 * vgap;\n  },\n  eachNode: function eachNode(callback) {\n    // Depth First traverse\n    var me = this;\n    var nodes = [me];\n    var current;\n\n    while (current = nodes.pop()) {\n      callback(current);\n      nodes = nodes.concat(current.children);\n    }\n  },\n  DFTraverse: function DFTraverse(callback) {\n    // Depth First traverse\n    this.eachNode(callback);\n  },\n  BFTraverse: function BFTraverse(callback) {\n    // Breadth First traverse\n    var me = this;\n    var nodes = [me];\n    var current;\n\n    while (current = nodes.shift()) {\n      callback(current);\n      nodes = nodes.concat(current.children);\n    }\n  },\n  getBoundingBox: function getBoundingBox() {\n    // BBox for just one tree node\n    var bb = {\n      left: Number.MAX_VALUE,\n      top: Number.MAX_VALUE,\n      width: 0,\n      height: 0\n    };\n    this.eachNode(function (node) {\n      bb.left = Math.min(bb.left, node.x);\n      bb.top = Math.min(bb.top, node.y);\n      bb.width = Math.max(bb.width, node.x + node.width);\n      bb.height = Math.max(bb.height, node.y + node.height);\n    });\n    return bb;\n  },\n  // translate\n  translate: function translate(tx, ty) {\n    if (tx === void 0) {\n      tx = 0;\n    }\n\n    if (ty === void 0) {\n      ty = 0;\n    }\n\n    this.eachNode(function (node) {\n      node.x += tx;\n      node.y += ty;\n    });\n  },\n  right2left: function right2left() {\n    var me = this;\n    var bb = me.getBoundingBox();\n    me.eachNode(function (node) {\n      node.x = node.x - (node.x - bb.left) * 2 - node.width; // node.x = - node.x;\n    });\n    me.translate(bb.width, 0);\n  },\n  bottom2top: function bottom2top() {\n    var me = this;\n    var bb = me.getBoundingBox();\n    me.eachNode(function (node) {\n      node.y = node.y - (node.y - bb.top) * 2 - node.height; // node.y = - node.y;\n    });\n    me.translate(0, bb.height);\n  }\n});\n\nfunction hierarchy(data, options, isolated) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  var root = new Node(data, options);\n  var nodes = [root];\n  var node;\n\n  if (!isolated && !data.collapsed) {\n    while (node = nodes.pop()) {\n      if (!node.data.collapsed) {\n        var children = options.getChildren(node.data);\n        var length = children ? children.length : 0;\n        node.children = new Array(length);\n\n        if (children && length) {\n          for (var i = 0; i < length; i++) {\n            var child = new Node(children[i], options);\n            node.children[i] = child;\n            nodes.push(child);\n            child.parent = node;\n            child.depth = node.depth + 1;\n          }\n        }\n      }\n    }\n  }\n\n  return root;\n}\n\nmodule.exports = hierarchy;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar hierarchy = __webpack_require__(3);\n\nmodule.exports = function (root, options) {\n  // separate into left and right trees\n  var left = hierarchy(root.data, options, true); // root only\n\n  var right = hierarchy(root.data, options, true); // root only\n  // automatically\n\n  var treeSize = root.children.length;\n  var rightTreeSize = Math.round(treeSize / 2); // separate left and right tree by meta data\n\n  var getSide = options.getSide || function (child, index) {\n    if (index < rightTreeSize) {\n      return 'right';\n    }\n\n    return 'left';\n  };\n\n  for (var i = 0; i < treeSize; i++) {\n    var child = root.children[i];\n    var side = getSide(child, i);\n\n    if (side === 'right') {\n      right.children.push(child);\n    } else {\n      left.children.push(child);\n    }\n  }\n\n  left.eachNode(function (node) {\n    if (!node.isRoot()) {\n      node.side = 'left';\n    }\n  });\n  right.eachNode(function (node) {\n    if (!node.isRoot()) {\n      node.side = 'right';\n    }\n  });\n  return {\n    left: left,\n    right: right\n  };\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar hierarchy = {\n  compactBox: __webpack_require__(6),\n  dendrogram: __webpack_require__(9),\n  indented: __webpack_require__(11),\n  mindmap: __webpack_require__(13)\n};\nmodule.exports = hierarchy;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar TreeLayout = __webpack_require__(1);\n\nvar nonLayeredTidyTree = __webpack_require__(8);\n\nvar doTreeLayout = __webpack_require__(2);\n\nvar util = __webpack_require__(0);\n\nvar CompactBoxTreeLayout = /*#__PURE__*/function (_TreeLayout) {\n  _inheritsLoose(CompactBoxTreeLayout, _TreeLayout);\n\n  function CompactBoxTreeLayout() {\n    return _TreeLayout.apply(this, arguments) || this;\n  }\n\n  var _proto = CompactBoxTreeLayout.prototype;\n\n  _proto.execute = function execute() {\n    var me = this;\n    return doTreeLayout(me.rootNode, me.options, nonLayeredTidyTree);\n  };\n\n  return CompactBoxTreeLayout;\n}(TreeLayout);\n\nvar DEFAULT_OPTIONS = {};\n\nfunction compactBoxLayout(root, options) {\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  return new CompactBoxTreeLayout(root, options).execute();\n}\n\nmodule.exports = compactBoxLayout;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nfunction _mix(dist, obj) {\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && key !== 'constructor' && obj[key] !== undefined) {\n      dist[key] = obj[key];\n    }\n  }\n}\n\nvar mix = function mix(dist, src1, src2, src3) {\n  if (src1) _mix(dist, src1);\n  if (src2) _mix(dist, src2);\n  if (src3) _mix(dist, src3);\n  return dist;\n};\n\nmodule.exports = mix;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n// wrap tree node\nfunction WrappedTree(w, h, y, c) {\n  if (c === void 0) {\n    c = [];\n  }\n\n  var me = this; // size\n\n  me.w = w || 0;\n  me.h = h || 0; // position\n\n  me.y = y || 0;\n  me.x = 0; // children\n\n  me.c = c || [];\n  me.cs = c.length; // modified\n\n  me.prelim = 0;\n  me.mod = 0;\n  me.shift = 0;\n  me.change = 0; // left/right tree\n\n  me.tl = null;\n  me.tr = null; // extreme left/right tree\n\n  me.el = null;\n  me.er = null; // modified left/right tree\n\n  me.msel = 0;\n  me.mser = 0;\n}\n\nWrappedTree.fromNode = function (root, isHorizontal) {\n  if (!root) return null;\n  var children = [];\n  root.children.forEach(function (child) {\n    children.push(WrappedTree.fromNode(child, isHorizontal));\n  });\n  if (isHorizontal) return new WrappedTree(root.height, root.width, root.x, children);\n  return new WrappedTree(root.width, root.height, root.y, children);\n}; // node utils\n\n\nfunction moveRight(node, move, isHorizontal) {\n  if (isHorizontal) {\n    node.y += move;\n  } else {\n    node.x += move;\n  }\n\n  node.children.forEach(function (child) {\n    moveRight(child, move, isHorizontal);\n  });\n}\n\nfunction getMin(node, isHorizontal) {\n  var res = isHorizontal ? node.y : node.x;\n  node.children.forEach(function (child) {\n    res = Math.min(getMin(child, isHorizontal), res);\n  });\n  return res;\n}\n\nfunction normalize(node, isHorizontal) {\n  var min = getMin(node, isHorizontal);\n  moveRight(node, -min, isHorizontal);\n}\n\nfunction convertBack(converted\n/* WrappedTree */\n, root\n/* TreeNode */\n, isHorizontal) {\n  if (isHorizontal) {\n    root.y = converted.x;\n  } else {\n    root.x = converted.x;\n  }\n\n  converted.c.forEach(function (child, i) {\n    convertBack(child, root.children[i], isHorizontal);\n  });\n}\n\nfunction layer(node, isHorizontal, d) {\n  if (d === void 0) {\n    d = 0;\n  }\n\n  if (isHorizontal) {\n    node.x = d;\n    d += node.width;\n  } else {\n    node.y = d;\n    d += node.height;\n  }\n\n  node.children.forEach(function (child) {\n    layer(child, isHorizontal, d);\n  });\n}\n\nmodule.exports = function (root, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var isHorizontal = options.isHorizontal;\n\n  function firstWalk(t) {\n    if (t.cs === 0) {\n      setExtremes(t);\n      return;\n    }\n\n    firstWalk(t.c[0]);\n    var ih = updateIYL(bottom(t.c[0].el), 0, null);\n\n    for (var i = 1; i < t.cs; ++i) {\n      firstWalk(t.c[i]);\n      var min = bottom(t.c[i].er);\n      separate(t, i, ih);\n      ih = updateIYL(min, i, ih);\n    }\n\n    positionRoot(t);\n    setExtremes(t);\n  }\n\n  function setExtremes(t) {\n    if (t.cs === 0) {\n      t.el = t;\n      t.er = t;\n      t.msel = t.mser = 0;\n    } else {\n      t.el = t.c[0].el;\n      t.msel = t.c[0].msel;\n      t.er = t.c[t.cs - 1].er;\n      t.mser = t.c[t.cs - 1].mser;\n    }\n  }\n\n  function separate(t, i, ih) {\n    var sr = t.c[i - 1];\n    var mssr = sr.mod;\n    var cl = t.c[i];\n    var mscl = cl.mod;\n\n    while (sr !== null && cl !== null) {\n      if (bottom(sr) > ih.low) ih = ih.nxt;\n      var dist = mssr + sr.prelim + sr.w - (mscl + cl.prelim);\n\n      if (dist > 0) {\n        mscl += dist;\n        moveSubtree(t, i, ih.index, dist);\n      }\n\n      var sy = bottom(sr);\n      var cy = bottom(cl);\n\n      if (sy <= cy) {\n        sr = nextRightContour(sr);\n        if (sr !== null) mssr += sr.mod;\n      }\n\n      if (sy >= cy) {\n        cl = nextLeftContour(cl);\n        if (cl !== null) mscl += cl.mod;\n      }\n    }\n\n    if (!sr && !!cl) {\n      setLeftThread(t, i, cl, mscl);\n    } else if (!!sr && !cl) {\n      setRightThread(t, i, sr, mssr);\n    }\n  }\n\n  function moveSubtree(t, i, si, dist) {\n    t.c[i].mod += dist;\n    t.c[i].msel += dist;\n    t.c[i].mser += dist;\n    distributeExtra(t, i, si, dist);\n  }\n\n  function nextLeftContour(t) {\n    return t.cs === 0 ? t.tl : t.c[0];\n  }\n\n  function nextRightContour(t) {\n    return t.cs === 0 ? t.tr : t.c[t.cs - 1];\n  }\n\n  function bottom(t) {\n    return t.y + t.h;\n  }\n\n  function setLeftThread(t, i, cl, modsumcl) {\n    var li = t.c[0].el;\n    li.tl = cl;\n    var diff = modsumcl - cl.mod - t.c[0].msel;\n    li.mod += diff;\n    li.prelim -= diff;\n    t.c[0].el = t.c[i].el;\n    t.c[0].msel = t.c[i].msel;\n  }\n\n  function setRightThread(t, i, sr, modsumsr) {\n    var ri = t.c[i].er;\n    ri.tr = sr;\n    var diff = modsumsr - sr.mod - t.c[i].mser;\n    ri.mod += diff;\n    ri.prelim -= diff;\n    t.c[i].er = t.c[i - 1].er;\n    t.c[i].mser = t.c[i - 1].mser;\n  }\n\n  function positionRoot(t) {\n    t.prelim = (t.c[0].prelim + t.c[0].mod + t.c[t.cs - 1].mod + t.c[t.cs - 1].prelim + t.c[t.cs - 1].w) / 2 - t.w / 2;\n  }\n\n  function secondWalk(t, modsum) {\n    modsum += t.mod;\n    t.x = t.prelim + modsum;\n    addChildSpacing(t);\n\n    for (var i = 0; i < t.cs; i++) {\n      secondWalk(t.c[i], modsum);\n    }\n  }\n\n  function distributeExtra(t, i, si, dist) {\n    if (si !== i - 1) {\n      var nr = i - si;\n      t.c[si + 1].shift += dist / nr;\n      t.c[i].shift -= dist / nr;\n      t.c[i].change -= dist - dist / nr;\n    }\n  }\n\n  function addChildSpacing(t) {\n    var d = 0;\n    var modsumdelta = 0;\n\n    for (var i = 0; i < t.cs; i++) {\n      d += t.c[i].shift;\n      modsumdelta += d + t.c[i].change;\n      t.c[i].mod += modsumdelta;\n    }\n  }\n\n  function updateIYL(low, index, ih) {\n    while (ih !== null && low >= ih.low) {\n      ih = ih.nxt;\n    }\n\n    return {\n      low: low,\n      index: index,\n      nxt: ih\n    };\n  } // do layout\n\n\n  layer(root, isHorizontal);\n  var wt = WrappedTree.fromNode(root, isHorizontal);\n  firstWalk(wt);\n  secondWalk(wt, 0);\n  convertBack(wt, root, isHorizontal);\n  normalize(root, isHorizontal);\n  return root;\n};\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar TreeLayout = __webpack_require__(1);\n\nvar dendrogram = __webpack_require__(10);\n\nvar doTreeLayout = __webpack_require__(2);\n\nvar util = __webpack_require__(0);\n\nvar DendrogramLayout = /*#__PURE__*/function (_TreeLayout) {\n  _inheritsLoose(DendrogramLayout, _TreeLayout);\n\n  function DendrogramLayout() {\n    return _TreeLayout.apply(this, arguments) || this;\n  }\n\n  var _proto = DendrogramLayout.prototype;\n\n  _proto.execute = function execute() {\n    var me = this;\n    me.rootNode.width = 0;\n    return doTreeLayout(me.rootNode, me.options, dendrogram);\n  };\n\n  return DendrogramLayout;\n}(TreeLayout);\n\nvar DEFAULT_OPTIONS = {};\n\nfunction dendrogramLayout(root, options) {\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  return new DendrogramLayout(root, options).execute();\n}\n\nmodule.exports = dendrogramLayout;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// wrap tree node\n// TODO considering size\nvar util = __webpack_require__(0);\n\nfunction WrappedTree(height, children) {\n  if (height === void 0) {\n    height = 0;\n  }\n\n  if (children === void 0) {\n    children = [];\n  }\n\n  var me = this;\n  me.x = me.y = 0;\n  me.leftChild = me.rightChild = null;\n  me.height = 0;\n  me.children = children;\n}\n\nvar DEFAULT_OPTIONS = {\n  isHorizontal: true,\n  nodeSep: 20,\n  nodeSize: 20,\n  rankSep: 200,\n  subTreeSep: 10\n};\n\nfunction convertBack(converted\n/* WrappedTree */\n, root\n/* TreeNode */\n, isHorizontal) {\n  if (isHorizontal) {\n    root.x = converted.x;\n    root.y = converted.y;\n  } else {\n    root.x = converted.y;\n    root.y = converted.x;\n  }\n\n  converted.children.forEach(function (child, i) {\n    convertBack(child, root.children[i], isHorizontal);\n  });\n}\n\nmodule.exports = function (root, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  var maxDepth = 0;\n\n  function wrappedTreeFromNode(n) {\n    if (!n) return null;\n    n.width = 0;\n\n    if (n.depth && n.depth > maxDepth) {\n      maxDepth = n.depth; // get the max depth\n    }\n\n    var children = n.children;\n    var childrenCount = children.length;\n    var t = new WrappedTree(n.height, []);\n    children.forEach(function (child, i) {\n      var childWT = wrappedTreeFromNode(child);\n      t.children.push(childWT);\n\n      if (i === 0) {\n        // t.leftChild = childWT.leftChild ? childWT.leftChild : childWT\n        t.leftChild = childWT;\n      }\n\n      if (i === childrenCount - 1) {\n        // t.rightChild = childWT.rightChild ? childWT.rightChild : childWT\n        t.rightChild = childWT;\n      }\n    });\n    t.originNode = n;\n    t.isLeaf = n.isLeaf();\n    return t;\n  }\n\n  function getDrawingDepth(t) {\n    if (t.isLeaf || t.children.length === 0) {\n      t.drawingDepth = maxDepth;\n    } else {\n      var depths = t.children.map(function (child) {\n        return getDrawingDepth(child);\n      });\n      var minChildDepth = Math.min.apply(null, depths);\n      t.drawingDepth = minChildDepth - 1;\n    }\n\n    return t.drawingDepth;\n  }\n\n  var prevLeaf;\n\n  function position(t) {\n    t.x = t.drawingDepth * options.rankSep;\n\n    if (t.isLeaf) {\n      t.y = 0;\n\n      if (prevLeaf) {\n        t.y = prevLeaf.y + prevLeaf.height + options.nodeSep;\n\n        if (t.originNode.parent !== prevLeaf.originNode.parent) {\n          t.y += options.subTreeSep;\n        }\n      }\n\n      prevLeaf = t;\n    } else {\n      t.children.forEach(function (child) {\n        position(child);\n      });\n      t.y = (t.leftChild.y + t.rightChild.y) / 2;\n    }\n  } // wrap node\n\n\n  var wt = wrappedTreeFromNode(root); // get depth for drawing\n\n  getDrawingDepth(wt); // get position\n\n  position(wt); // get x, y\n\n  convertBack(wt, root, options.isHorizontal);\n  return root;\n};\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar TreeLayout = __webpack_require__(1);\n\nvar indentedTree = __webpack_require__(12);\n\nvar separateTree = __webpack_require__(4);\n\nvar util = __webpack_require__(0);\n\nvar VALID_DIRECTIONS = ['LR', // left to right\n'RL', // right to left\n'H' // horizontal\n];\nvar DEFAULT_DIRECTION = VALID_DIRECTIONS[0];\n\nvar IndentedLayout = /*#__PURE__*/function (_TreeLayout) {\n  _inheritsLoose(IndentedLayout, _TreeLayout);\n\n  function IndentedLayout() {\n    return _TreeLayout.apply(this, arguments) || this;\n  }\n\n  var _proto = IndentedLayout.prototype;\n\n  _proto.execute = function execute() {\n    var me = this;\n    var options = me.options;\n    var root = me.rootNode;\n    options.isHorizontal = true;\n    var indent = options.indent;\n    var direction = options.direction || DEFAULT_DIRECTION;\n\n    if (direction && VALID_DIRECTIONS.indexOf(direction) === -1) {\n      throw new TypeError(\"Invalid direction: \" + direction);\n    }\n\n    if (direction === VALID_DIRECTIONS[0]) {\n      // LR\n      indentedTree(root, indent);\n    } else if (direction === VALID_DIRECTIONS[1]) {\n      // RL\n      indentedTree(root, indent);\n      root.right2left();\n    } else if (direction === VALID_DIRECTIONS[2]) {\n      // H\n      // separate into left and right trees\n      var _separateTree = separateTree(root, options),\n          left = _separateTree.left,\n          right = _separateTree.right;\n\n      indentedTree(left, indent);\n      left.right2left();\n      indentedTree(right, indent);\n      var bbox = left.getBoundingBox();\n      right.translate(bbox.width, 0);\n      root.x = right.x - root.width / 2;\n    }\n\n    return root;\n  };\n\n  return IndentedLayout;\n}(TreeLayout);\n\nvar DEFAULT_OPTIONS = {};\n\nfunction indentedLayout(root, options) {\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  return new IndentedLayout(root, options).execute();\n}\n\nmodule.exports = indentedLayout;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\nvar DEFAULT_INDENT = 20;\n\nfunction positionNode(node, previousNode, dx) {\n  node.x += dx * node.depth;\n  node.y = previousNode ? previousNode.y + previousNode.height : 0;\n}\n\nmodule.exports = function (root, indent) {\n  if (indent === void 0) {\n    indent = DEFAULT_INDENT;\n  }\n\n  var previousNode = null;\n  root.eachNode(function (node) {\n    positionNode(node, previousNode, indent);\n    previousNode = node;\n  });\n};\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar TreeLayout = __webpack_require__(1);\n\nvar mindmap = __webpack_require__(14);\n\nvar doTreeLayout = __webpack_require__(2);\n\nvar util = __webpack_require__(0);\n\nvar MindmapLayout = /*#__PURE__*/function (_TreeLayout) {\n  _inheritsLoose(MindmapLayout, _TreeLayout);\n\n  function MindmapLayout() {\n    return _TreeLayout.apply(this, arguments) || this;\n  }\n\n  var _proto = MindmapLayout.prototype;\n\n  _proto.execute = function execute() {\n    var me = this;\n    return doTreeLayout(me.rootNode, me.options, mindmap);\n  };\n\n  return MindmapLayout;\n}(TreeLayout);\n\nvar DEFAULT_OPTIONS = {};\n\nfunction mindmapLayout(root, options) {\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  return new MindmapLayout(root, options).execute();\n}\n\nmodule.exports = mindmapLayout;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar util = __webpack_require__(0);\n\nfunction secondWalk(node, options) {\n  var totalHeight = 0;\n\n  if (!node.children.length) {\n    totalHeight = node.height;\n  } else {\n    node.children.forEach(function (c) {\n      totalHeight += secondWalk(c, options);\n    });\n  }\n\n  node._subTreeSep = options.getSubTreeSep(node.data);\n  node.totalHeight = Math.max(node.height, totalHeight) + 2 * node._subTreeSep;\n  return node.totalHeight;\n}\n\nfunction thirdWalk(node) {\n  var children = node.children;\n  var len = children.length;\n\n  if (len) {\n    children.forEach(function (c) {\n      thirdWalk(c);\n    });\n    var first = children[0];\n    var last = children[len - 1];\n    var childrenHeight = last.y - first.y + last.height;\n    var childrenTotalHeight = 0;\n    children.forEach(function (child) {\n      childrenTotalHeight += child.totalHeight;\n    });\n\n    if (childrenHeight > node.height) {\n      // 当子节点总高度大于父节点高度\n      node.y = first.y + childrenHeight / 2 - node.height / 2;\n    } else if (children.length !== 1 || node.height > childrenTotalHeight) {\n      // 多于一个子节点或者父节点大于所有子节点的总高度\n      var offset = node.y + (node.height - childrenHeight) / 2 - first.y;\n      children.forEach(function (c) {\n        c.translate(0, offset);\n      });\n    } else {\n      // 只有一个子节点\n      node.y = (first.y + first.height / 2 + last.y + last.height / 2) / 2 - node.height / 2;\n    }\n  }\n}\n\nvar DEFAULT_OPTIONS = {\n  getSubTreeSep: function getSubTreeSep() {\n    return 0;\n  }\n};\n\nmodule.exports = function (root, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  root.parent = {\n    x: 0,\n    width: 0,\n    height: 0,\n    y: 0\n  }; // first walk\n\n  root.BFTraverse(function (node) {\n    node.x = node.parent.x + node.parent.width; // simply get x\n  });\n  root.parent = null; // second walk\n\n  secondWalk(root, options); // assign sub tree totalHeight\n  // adjusting\n  // separating nodes\n\n  root.startY = 0;\n  root.y = root.totalHeight / 2 - root.height / 2;\n  root.eachNode(function (node) {\n    var children = node.children;\n    var len = children.length;\n\n    if (len) {\n      var first = children[0];\n      first.startY = node.startY + node._subTreeSep;\n\n      if (len === 1) {\n        first.y = node.y + node.height / 2 - first.height / 2;\n      } else {\n        first.y = first.startY + first.totalHeight / 2 - first.height / 2;\n\n        for (var i = 1; i < len; i++) {\n          var c = children[i];\n          c.startY = children[i - 1].startY + children[i - 1].totalHeight;\n          c.y = c.startY + c.totalHeight / 2 - c.height / 2;\n        }\n      }\n    }\n  }); // third walk\n\n  thirdWalk(root);\n};\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=hierarchy.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/augment.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/augment.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mix_1 = __webpack_require__(/*! ./mix */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/mix.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nvar augment = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var c = args[0];\n    for (var i = 1; i < args.length; i++) {\n        var obj = args[i];\n        if (is_function_1.default(obj)) {\n            obj = obj.prototype;\n        }\n        mix_1.default(c.prototype, obj);\n    }\n};\nexports.default = augment;\n//# sourceMappingURL=augment.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/cache.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/cache.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * k-v 存储\n */\nvar default_1 = /** @class */ (function () {\n    function default_1() {\n        this.map = {};\n    }\n    default_1.prototype.has = function (key) {\n        return this.map[key] !== undefined;\n    };\n    default_1.prototype.get = function (key, def) {\n        var v = this.map[key];\n        return v === undefined ? def : v;\n    };\n    default_1.prototype.set = function (key, value) {\n        this.map[key] = value;\n    };\n    default_1.prototype.clear = function () {\n        this.map = {};\n    };\n    default_1.prototype.delete = function (key) {\n        delete this.map[key];\n    };\n    default_1.prototype.size = function () {\n        return Object.keys(this.map).length;\n    };\n    return default_1;\n}());\nexports.default = default_1;\n//# sourceMappingURL=cache.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/clamp.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/clamp.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar clamp = function (a, min, max) {\n    if (a < min) {\n        return min;\n    }\n    else if (a > max) {\n        return max;\n    }\n    return a;\n};\nexports.default = clamp;\n//# sourceMappingURL=clamp.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/clear-animation-frame.js\":\n/*!********************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/clear-animation-frame.js ***!\n  \\********************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction cancelAnimationFrame(handler) {\n    var method = window.cancelAnimationFrame ||\n        window.webkitCancelAnimationFrame ||\n        // @ts-ignore\n        window.mozCancelAnimationFrame ||\n        // @ts-ignore\n        window.msCancelAnimationFrame ||\n        clearTimeout;\n    method(handler);\n}\nexports.default = cancelAnimationFrame;\n;\n//# sourceMappingURL=clear-animation-frame.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/clone.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/clone.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar clone = function (obj) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n    var rst;\n    if (is_array_1.default(obj)) {\n        rst = [];\n        for (var i = 0, l = obj.length; i < l; i++) {\n            if (typeof obj[i] === 'object' && obj[i] != null) {\n                rst[i] = clone(obj[i]);\n            }\n            else {\n                rst[i] = obj[i];\n            }\n        }\n    }\n    else {\n        rst = {};\n        for (var k in obj) {\n            if (typeof obj[k] === 'object' && obj[k] != null) {\n                rst[k] = clone(obj[k]);\n            }\n            else {\n                rst[k] = obj[k];\n            }\n        }\n    }\n    return rst;\n};\nexports.default = clone;\n//# sourceMappingURL=clone.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/contains.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/contains.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nvar contains = function (arr, value) {\n    if (!is_array_like_1.default(arr)) {\n        return false;\n    }\n    return arr.indexOf(value) > -1;\n};\nexports.default = contains;\n//# sourceMappingURL=contains.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/debounce.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/debounce.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction debounce(func, wait, immediate) {\n    var timeout;\n    return function () {\n        var context = this, args = arguments;\n        var later = function () {\n            timeout = null;\n            if (!immediate) {\n                func.apply(context, args);\n            }\n        };\n        var callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            func.apply(context, args);\n        }\n    };\n}\nexports.default = debounce;\n//# sourceMappingURL=debounce.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/deep-mix.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/deep-mix.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_plain_object_1 = __webpack_require__(/*! ./is-plain-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-plain-object.js\");\nvar MAX_MIX_LEVEL = 5;\nfunction _deepMix(dist, src, level, maxLevel) {\n    level = level || 0;\n    maxLevel = maxLevel || MAX_MIX_LEVEL;\n    for (var key in src) {\n        if (src.hasOwnProperty(key)) {\n            var value = src[key];\n            if (value !== null && is_plain_object_1.default(value)) {\n                if (!is_plain_object_1.default(dist[key])) {\n                    dist[key] = {};\n                }\n                if (level < maxLevel) {\n                    _deepMix(dist[key], value, level + 1, maxLevel);\n                }\n                else {\n                    dist[key] = src[key];\n                }\n            }\n            else if (is_array_1.default(value)) {\n                dist[key] = [];\n                dist[key] = dist[key].concat(value);\n            }\n            else if (value !== undefined) {\n                dist[key] = value;\n            }\n        }\n    }\n}\n// todo 重写\nvar deepMix = function (rst) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < args.length; i += 1) {\n        _deepMix(rst, args[i]);\n    }\n    return rst;\n};\nexports.default = deepMix;\n//# sourceMappingURL=deep-mix.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/difference.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/difference.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar filter_1 = __webpack_require__(/*! ./filter */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/filter.js\");\nvar contains_1 = __webpack_require__(/*! ./contains */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/contains.js\");\n/**\n * Flattens `array` a single level deep.\n *\n * @param {Array} arr The array to inspect.\n * @param {Array} values The values to exclude.\n * @return {Array} Returns the new array of filtered values.\n * @example\n * difference([2, 1], [2, 3]);  // => [1]\n */\nvar difference = function (arr, values) {\n    if (values === void 0) { values = []; }\n    return filter_1.default(arr, function (value) { return !contains_1.default(values, value); });\n};\nexports.default = difference;\n//# sourceMappingURL=difference.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_object_1 = __webpack_require__(/*! ./is-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object.js\");\nfunction each(elements, func) {\n    if (!elements) {\n        return;\n    }\n    var rst;\n    if (is_array_1.default(elements)) {\n        for (var i = 0, len = elements.length; i < len; i++) {\n            rst = func(elements[i], i);\n            if (rst === false) {\n                break;\n            }\n        }\n    }\n    else if (is_object_1.default(elements)) {\n        for (var k in elements) {\n            if (elements.hasOwnProperty(k)) {\n                rst = func(elements[k], k);\n                if (rst === false) {\n                    break;\n                }\n            }\n        }\n    }\n}\nexports.default = each;\n//# sourceMappingURL=each.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/ends-with.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/ends-with.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_string_1 = __webpack_require__(/*! ./is-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js\");\nfunction endsWith(arr, e) {\n    return (is_array_1.default(arr) || is_string_1.default(arr)) ? arr[arr.length - 1] === e : false;\n}\nexports.default = endsWith;\n//# sourceMappingURL=ends-with.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/every.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/every.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 只要有一个不满足条件就返回 false\n * @param arr\n * @param func\n */\nvar every = function (arr, func) {\n    for (var i = 0; i < arr.length; i++) {\n        if (!func(arr[i], i))\n            return false;\n    }\n    return true;\n};\nexports.default = every;\n//# sourceMappingURL=every.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/extend.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/extend.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mix_1 = __webpack_require__(/*! ./mix */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/mix.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nvar extend = function (subclass, superclass, overrides, staticOverrides) {\n    // 如果只提供父类构造函数，则自动生成子类构造函数\n    if (!is_function_1.default(superclass)) {\n        overrides = superclass;\n        superclass = subclass;\n        subclass = function () { };\n    }\n    var create = Object.create ?\n        function (proto, c) {\n            return Object.create(proto, {\n                constructor: {\n                    value: c\n                }\n            });\n        } :\n        function (proto, c) {\n            function Tmp() { }\n            Tmp.prototype = proto;\n            var o = new Tmp();\n            o.constructor = c;\n            return o;\n        };\n    var superObj = create(superclass.prototype, subclass); // new superclass(),//实例化父类作为子类的prototype\n    subclass.prototype = mix_1.default(superObj, subclass.prototype); // 指定子类的prototype\n    subclass.superclass = create(superclass.prototype, superclass);\n    mix_1.default(superObj, overrides);\n    mix_1.default(subclass, staticOverrides);\n    return subclass;\n};\nexports.default = extend;\n//# sourceMappingURL=extend.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/filter.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/filter.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nvar filter = function (arr, func) {\n    if (!is_array_like_1.default(arr)) {\n        return arr;\n    }\n    var result = [];\n    each_1.default(arr, function (value, index) {\n        if (func(value, index)) {\n            result.push(value);\n        }\n    });\n    return result;\n};\nexports.default = filter;\n//# sourceMappingURL=filter.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/find-index.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/find-index.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction findIndex(arr, predicate, fromIndex) {\n    if (fromIndex === void 0) { fromIndex = 0; }\n    for (var i = fromIndex; i < arr.length; i++) {\n        if (predicate(arr[i], i)) {\n            // 找到终止循环\n            return i;\n        }\n    }\n    return -1;\n}\nexports.default = findIndex;\n//# sourceMappingURL=find-index.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/find.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/find.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nvar is_match_1 = __webpack_require__(/*! ./is-match */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-match.js\");\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_plain_object_1 = __webpack_require__(/*! ./is-plain-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-plain-object.js\");\nfunction find(arr, predicate) {\n    if (!is_array_1.default(arr))\n        return null;\n    var _predicate;\n    if (is_function_1.default(predicate)) {\n        _predicate = predicate;\n    }\n    if (is_plain_object_1.default(predicate)) {\n        _predicate = function (a) { return is_match_1.default(a, predicate); };\n    }\n    if (_predicate) {\n        for (var i = 0; i < arr.length; i += 1) {\n            if (_predicate(arr[i])) {\n                return arr[i];\n            }\n        }\n    }\n    return null;\n}\nexports.default = find;\n//# sourceMappingURL=find.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/first-value.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/first-value.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_nil_1 = __webpack_require__(/*! ./is-nil */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\");\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar firstValue = function (data, name) {\n    var rst = null;\n    for (var i = 0; i < data.length; i++) {\n        var obj = data[i];\n        var value = obj[name];\n        if (!is_nil_1.default(value)) {\n            if (is_array_1.default(value)) {\n                rst = value[0]; // todo 这里是否应该使用递归，调用 firstValue @绝云\n            }\n            else {\n                rst = value;\n            }\n            break;\n        }\n    }\n    return rst;\n};\nexports.default = firstValue;\n//# sourceMappingURL=first-value.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/fixed-base.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/fixed-base.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fixedBase = function (v, base) {\n    var str = base.toString();\n    var index = str.indexOf('.');\n    if (index === -1) {\n        return Math.round(v);\n    }\n    var length = str.substr(index + 1).length;\n    if (length > 20) {\n        length = 20;\n    }\n    return parseFloat(v.toFixed(length));\n};\nexports.default = fixedBase;\n//# sourceMappingURL=fixed-base.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/flatten-deep.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/flatten-deep.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\n/**\n * Flattens `array` a single level deep.\n *\n * @param {Array} arr The array to flatten.\n * @param {Array} result The array to return.\n * @return {Array} Returns the new flattened array.\n * @example\n *\n * flattenDeep([1, [2, [3, [4]], 5]]);  // => [1, 2, 3, 4, 5]\n */\nvar flattenDeep = function (arr, result) {\n    if (result === void 0) { result = []; }\n    if (!is_array_1.default(arr)) {\n        result.push(arr);\n    }\n    else {\n        for (var i = 0; i < arr.length; i += 1) {\n            flattenDeep(arr[i], result);\n        }\n    }\n    return result;\n};\nexports.default = flattenDeep;\n//# sourceMappingURL=flatten-deep.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/flatten.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/flatten.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\n/**\n * Flattens `array` a single level deep.\n *\n * @param {Array} arr The array to flatten.\n * @return {Array} Returns the new flattened array.\n * @example\n *\n * flatten([1, [2, [3, [4]], 5]]);  // => [1, 2, [3, [4]], 5]\n */\nvar flatten = function (arr) {\n    if (!is_array_1.default(arr)) {\n        return [];\n    }\n    var rst = [];\n    for (var i = 0; i < arr.length; i++) {\n        rst = rst.concat(arr[i]);\n    }\n    return rst;\n};\nexports.default = flatten;\n//# sourceMappingURL=flatten.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/for-in.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/for-in.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nexports.default = each_1.default;\n//# sourceMappingURL=for-in.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-range.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-range.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar filter_1 = __webpack_require__(/*! ./filter */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/filter.js\");\nvar getRange = function (values) {\n    // 存在 NaN 时，min,max 判定会出问题\n    values = filter_1.default(values, function (v) {\n        return !isNaN(v);\n    });\n    if (!values.length) { // 如果没有数值则直接返回0\n        return {\n            min: 0,\n            max: 0\n        };\n    }\n    if (is_array_1.default(values[0])) {\n        var tmp = [];\n        for (var i = 0; i < values.length; i++) {\n            tmp = tmp.concat(values[i]);\n        }\n        values = tmp;\n    }\n    var max = Math.max.apply(null, values);\n    var min = Math.min.apply(null, values);\n    return {\n        min: min,\n        max: max\n    };\n};\nexports.default = getRange;\n//# sourceMappingURL=get-range.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-type.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-type.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar toString = {}.toString;\nvar getType = function (value) {\n    return toString.call(value).replace(/^\\[object /, '').replace(/]$/, '');\n};\nexports.default = getType;\n//# sourceMappingURL=get-type.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-wrap-behavior.js\":\n/*!****************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-wrap-behavior.js ***!\n  \\****************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 获取封装的事件\n * @protected\n * @param  {Object} obj   对象\n * @param  {String} action 事件名称\n * @return {Function}        返回事件处理函数\n */\nfunction getWrapBehavior(obj, action) {\n    return obj['_wrap_' + action];\n}\nexports.default = getWrapBehavior;\n//# sourceMappingURL=get-wrap-behavior.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/get.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_string_1 = __webpack_require__(/*! ./is-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js\");\n/**\n * https://github.com/developit/dlv/blob/master/index.js\n * @param obj\n * @param key\n * @param defaultValue\n */\nexports.default = (function (obj, key, defaultValue) {\n    var p = 0;\n    var keyArr = is_string_1.default(key) ? key.split('.') : key;\n    while (obj && p < keyArr.length) {\n        obj = obj[keyArr[p++]];\n    }\n    return (obj === undefined || p < keyArr.length) ? defaultValue : obj;\n});\n//# sourceMappingURL=get.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/group-by.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/group-by.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction groupBy(data, condition) {\n    if (!condition || !is_array_1.default(data)) {\n        return {};\n    }\n    var result = {};\n    // 兼容方法和 字符串的写法\n    var predicate = is_function_1.default(condition) ? condition : function (item) { return item[condition]; };\n    var key;\n    each_1.default(data, function (item) {\n        key = predicate(item);\n        if (hasOwnProperty.call(result, key)) {\n            result[key].push(item);\n        }\n        else {\n            result[key] = [item];\n        }\n    });\n    return result;\n}\nexports.default = groupBy;\n//# sourceMappingURL=group-by.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/group-to-map.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/group-to-map.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nvar group_by_1 = __webpack_require__(/*! ./group-by */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/group-by.js\");\nvar groupToMap = function (data, condition) {\n    if (!condition) {\n        return {\n            0: data\n        };\n    }\n    if (!is_function_1.default(condition)) {\n        var paramsCondition_1 = is_array_1.default(condition) ? condition : condition.replace(/\\s+/g, '').split('*');\n        condition = function (row) {\n            var unique = '_'; // 避免出现数字作为Key的情况，会进行按照数字的排序\n            for (var i = 0, l = paramsCondition_1.length; i < l; i++) {\n                unique += row[paramsCondition_1[i]] && row[paramsCondition_1[i]].toString();\n            }\n            return unique;\n        };\n    }\n    var groups = group_by_1.default(data, condition);\n    return groups;\n};\nexports.default = groupToMap;\n//# sourceMappingURL=group-to-map.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/group.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/group.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar group_to_map_1 = __webpack_require__(/*! ./group-to-map */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/group-to-map.js\");\nexports.default = (function (data, condition) {\n    if (!condition) {\n        // 没有条件，则自身改成数组\n        return [data];\n    }\n    var groups = group_to_map_1.default(data, condition);\n    var array = [];\n    for (var i in groups) {\n        array.push(groups[i]);\n    }\n    return array;\n});\n//# sourceMappingURL=group.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/has-key.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/has-key.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar has_1 = __webpack_require__(/*! ./has */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/has.js\");\nexports.default = has_1.default;\n//# sourceMappingURL=has-key.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/has-value.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/has-value.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar contains_1 = __webpack_require__(/*! ./contains */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/contains.js\");\nvar values_1 = __webpack_require__(/*! ./values */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/values.js\");\nexports.default = (function (obj, value) { return contains_1.default(values_1.default(obj), value); });\n//# sourceMappingURL=has-value.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/has.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/has.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = (function (obj, key) { return obj.hasOwnProperty(key); });\n//# sourceMappingURL=has.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/head.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/head.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nfunction head(o) {\n    if (is_array_like_1.default(o)) {\n        return o[0];\n    }\n    return undefined;\n}\nexports.default = head;\n//# sourceMappingURL=head.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/identity.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/identity.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = (function (v) { return v; });\n//# sourceMappingURL=identity.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index-of.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/index-of.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nvar indexOf = function (arr, obj) {\n    if (!is_array_like_1.default(arr)) {\n        return -1;\n    }\n    var m = Array.prototype.indexOf;\n    if (m) {\n        return m.call(arr, obj);\n    }\n    var index = -1;\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] === obj) {\n            index = i;\n            break;\n        }\n    }\n    return index;\n};\nexports.default = indexOf;\n//# sourceMappingURL=index-of.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// array\nvar contains_1 = __webpack_require__(/*! ./contains */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/contains.js\");\nexports.contains = contains_1.default;\nexports.includes = contains_1.default;\nvar difference_1 = __webpack_require__(/*! ./difference */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/difference.js\");\nexports.difference = difference_1.default;\nvar find_1 = __webpack_require__(/*! ./find */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/find.js\");\nexports.find = find_1.default;\nvar find_index_1 = __webpack_require__(/*! ./find-index */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/find-index.js\");\nexports.findIndex = find_index_1.default;\nvar first_value_1 = __webpack_require__(/*! ./first-value */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/first-value.js\");\nexports.firstValue = first_value_1.default;\nvar flatten_1 = __webpack_require__(/*! ./flatten */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/flatten.js\");\nexports.flatten = flatten_1.default;\nvar flatten_deep_1 = __webpack_require__(/*! ./flatten-deep */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/flatten-deep.js\");\nexports.flattenDeep = flatten_deep_1.default;\nvar get_range_1 = __webpack_require__(/*! ./get-range */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-range.js\");\nexports.getRange = get_range_1.default;\nvar pull_1 = __webpack_require__(/*! ./pull */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/pull.js\");\nexports.pull = pull_1.default;\nvar pull_at_1 = __webpack_require__(/*! ./pull-at */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/pull-at.js\");\nexports.pullAt = pull_at_1.default;\nvar reduce_1 = __webpack_require__(/*! ./reduce */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/reduce.js\");\nexports.reduce = reduce_1.default;\nvar remove_1 = __webpack_require__(/*! ./remove */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/remove.js\");\nexports.remove = remove_1.default;\nvar sort_by_1 = __webpack_require__(/*! ./sort-by */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/sort-by.js\");\nexports.sortBy = sort_by_1.default;\nvar union_1 = __webpack_require__(/*! ./union */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/union.js\");\nexports.union = union_1.default;\nvar uniq_1 = __webpack_require__(/*! ./uniq */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/uniq.js\");\nexports.uniq = uniq_1.default;\nvar values_of_key_1 = __webpack_require__(/*! ./values-of-key */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/values-of-key.js\");\nexports.valuesOfKey = values_of_key_1.default;\nvar head_1 = __webpack_require__(/*! ./head */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/head.js\");\nexports.head = head_1.default;\nvar last_1 = __webpack_require__(/*! ./last */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/last.js\");\nexports.last = last_1.default;\nvar starts_with_1 = __webpack_require__(/*! ./starts-with */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/starts-with.js\");\nexports.startsWith = starts_with_1.default;\nvar ends_with_1 = __webpack_require__(/*! ./ends-with */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/ends-with.js\");\nexports.endsWith = ends_with_1.default;\nvar filter_1 = __webpack_require__(/*! ./filter */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/filter.js\");\nexports.filter = filter_1.default;\nvar every_1 = __webpack_require__(/*! ./every */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/every.js\");\nexports.every = every_1.default;\nvar some_1 = __webpack_require__(/*! ./some */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/some.js\");\nexports.some = some_1.default;\nvar group_1 = __webpack_require__(/*! ./group */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/group.js\");\nexports.group = group_1.default;\nvar group_by_1 = __webpack_require__(/*! ./group-by */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/group-by.js\");\nexports.groupBy = group_by_1.default;\nvar group_to_map_1 = __webpack_require__(/*! ./group-to-map */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/group-to-map.js\");\nexports.groupToMap = group_to_map_1.default;\n// event\nvar get_wrap_behavior_1 = __webpack_require__(/*! ./get-wrap-behavior */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-wrap-behavior.js\");\nexports.getWrapBehavior = get_wrap_behavior_1.default;\nvar wrap_behavior_1 = __webpack_require__(/*! ./wrap-behavior */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/wrap-behavior.js\");\nexports.wrapBehavior = wrap_behavior_1.default;\n// format\nvar number2color_1 = __webpack_require__(/*! ./number2color */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/number2color.js\");\nexports.number2color = number2color_1.default;\nvar parse_radius_1 = __webpack_require__(/*! ./parse-radius */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/parse-radius.js\");\nexports.parseRadius = parse_radius_1.default;\n// math\nvar clamp_1 = __webpack_require__(/*! ./clamp */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/clamp.js\");\nexports.clamp = clamp_1.default;\nvar fixed_base_1 = __webpack_require__(/*! ./fixed-base */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/fixed-base.js\");\nexports.fixedBase = fixed_base_1.default;\nvar is_decimal_1 = __webpack_require__(/*! ./is-decimal */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-decimal.js\");\nexports.isDecimal = is_decimal_1.default;\nvar is_even_1 = __webpack_require__(/*! ./is-even */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-even.js\");\nexports.isEven = is_even_1.default;\nvar is_integer_1 = __webpack_require__(/*! ./is-integer */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-integer.js\");\nexports.isInteger = is_integer_1.default;\nvar is_negative_1 = __webpack_require__(/*! ./is-negative */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-negative.js\");\nexports.isNegative = is_negative_1.default;\nvar is_number_equal_1 = __webpack_require__(/*! ./is-number-equal */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number-equal.js\");\nexports.isNumberEqual = is_number_equal_1.default;\nvar is_odd_1 = __webpack_require__(/*! ./is-odd */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-odd.js\");\nexports.isOdd = is_odd_1.default;\nvar is_positive_1 = __webpack_require__(/*! ./is-positive */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-positive.js\");\nexports.isPositive = is_positive_1.default;\nvar max_by_1 = __webpack_require__(/*! ./max-by */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/max-by.js\");\nexports.maxBy = max_by_1.default;\nvar min_by_1 = __webpack_require__(/*! ./min-by */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/min-by.js\");\nexports.minBy = min_by_1.default;\nvar mod_1 = __webpack_require__(/*! ./mod */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/mod.js\");\nexports.mod = mod_1.default;\nvar to_degree_1 = __webpack_require__(/*! ./to-degree */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-degree.js\");\nexports.toDegree = to_degree_1.default;\nvar to_integer_1 = __webpack_require__(/*! ./to-integer */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-integer.js\");\nexports.toInteger = to_integer_1.default;\nvar to_radian_1 = __webpack_require__(/*! ./to-radian */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-radian.js\");\nexports.toRadian = to_radian_1.default;\n// object\nvar for_in_1 = __webpack_require__(/*! ./for-in */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/for-in.js\");\nexports.forIn = for_in_1.default;\nvar has_1 = __webpack_require__(/*! ./has */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/has.js\");\nexports.has = has_1.default;\nvar has_key_1 = __webpack_require__(/*! ./has-key */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/has-key.js\");\nexports.hasKey = has_key_1.default;\nvar has_value_1 = __webpack_require__(/*! ./has-value */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/has-value.js\");\nexports.hasValue = has_value_1.default;\nvar keys_1 = __webpack_require__(/*! ./keys */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/keys.js\");\nexports.keys = keys_1.default;\nvar is_match_1 = __webpack_require__(/*! ./is-match */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-match.js\");\nexports.isMatch = is_match_1.default;\nvar values_1 = __webpack_require__(/*! ./values */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/values.js\");\nexports.values = values_1.default;\n// string\nvar lower_case_1 = __webpack_require__(/*! ./lower-case */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/lower-case.js\");\nexports.lowerCase = lower_case_1.default;\nvar lower_first_1 = __webpack_require__(/*! ./lower-first */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/lower-first.js\");\nexports.lowerFirst = lower_first_1.default;\nvar substitute_1 = __webpack_require__(/*! ./substitute */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/substitute.js\");\nexports.substitute = substitute_1.default;\nvar upper_case_1 = __webpack_require__(/*! ./upper-case */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/upper-case.js\");\nexports.upperCase = upper_case_1.default;\nvar upper_first_1 = __webpack_require__(/*! ./upper-first */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/upper-first.js\");\nexports.upperFirst = upper_first_1.default;\n// type\nvar get_type_1 = __webpack_require__(/*! ./get-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-type.js\");\nexports.getType = get_type_1.default;\nvar is_arguments_1 = __webpack_require__(/*! ./is-arguments */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-arguments.js\");\nexports.isArguments = is_arguments_1.default;\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nexports.isArray = is_array_1.default;\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nexports.isArrayLike = is_array_like_1.default;\nvar is_boolean_1 = __webpack_require__(/*! ./is-boolean */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-boolean.js\");\nexports.isBoolean = is_boolean_1.default;\nvar is_date_1 = __webpack_require__(/*! ./is-date */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-date.js\");\nexports.isDate = is_date_1.default;\nvar is_error_1 = __webpack_require__(/*! ./is-error */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-error.js\");\nexports.isError = is_error_1.default;\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nexports.isFunction = is_function_1.default;\nvar is_finite_1 = __webpack_require__(/*! ./is-finite */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-finite.js\");\nexports.isFinite = is_finite_1.default;\nvar is_nil_1 = __webpack_require__(/*! ./is-nil */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\");\nexports.isNil = is_nil_1.default;\nvar is_null_1 = __webpack_require__(/*! ./is-null */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-null.js\");\nexports.isNull = is_null_1.default;\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\nexports.isNumber = is_number_1.default;\nvar is_object_1 = __webpack_require__(/*! ./is-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object.js\");\nexports.isObject = is_object_1.default;\nvar is_object_like_1 = __webpack_require__(/*! ./is-object-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object-like.js\");\nexports.isObjectLike = is_object_like_1.default;\nvar is_plain_object_1 = __webpack_require__(/*! ./is-plain-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-plain-object.js\");\nexports.isPlainObject = is_plain_object_1.default;\nvar is_prototype_1 = __webpack_require__(/*! ./is-prototype */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-prototype.js\");\nexports.isPrototype = is_prototype_1.default;\nvar is_reg_exp_1 = __webpack_require__(/*! ./is-reg-exp */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-reg-exp.js\");\nexports.isRegExp = is_reg_exp_1.default;\nvar is_string_1 = __webpack_require__(/*! ./is-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js\");\nexports.isString = is_string_1.default;\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nexports.isType = is_type_1.default;\nvar is_undefined_1 = __webpack_require__(/*! ./is-undefined */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-undefined.js\");\nexports.isUndefined = is_undefined_1.default;\nvar is_element_1 = __webpack_require__(/*! ./is-element */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-element.js\");\nexports.isElement = is_element_1.default;\nvar request_animation_frame_1 = __webpack_require__(/*! ./request-animation-frame */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/request-animation-frame.js\");\nexports.requestAnimationFrame = request_animation_frame_1.default;\nvar clear_animation_frame_1 = __webpack_require__(/*! ./clear-animation-frame */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/clear-animation-frame.js\");\nexports.clearAnimationFrame = clear_animation_frame_1.default;\n// other\nvar augment_1 = __webpack_require__(/*! ./augment */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/augment.js\");\nexports.augment = augment_1.default;\nvar clone_1 = __webpack_require__(/*! ./clone */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/clone.js\");\nexports.clone = clone_1.default;\nvar debounce_1 = __webpack_require__(/*! ./debounce */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/debounce.js\");\nexports.debounce = debounce_1.default;\nvar memoize_1 = __webpack_require__(/*! ./memoize */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/memoize.js\");\nexports.memoize = memoize_1.default;\nvar deep_mix_1 = __webpack_require__(/*! ./deep-mix */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/deep-mix.js\");\nexports.deepMix = deep_mix_1.default;\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nexports.each = each_1.default;\nvar extend_1 = __webpack_require__(/*! ./extend */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/extend.js\");\nexports.extend = extend_1.default;\nvar index_of_1 = __webpack_require__(/*! ./index-of */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index-of.js\");\nexports.indexOf = index_of_1.default;\nvar is_empty_1 = __webpack_require__(/*! ./is-empty */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-empty.js\");\nexports.isEmpty = is_empty_1.default;\nvar is_equal_1 = __webpack_require__(/*! ./is-equal */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-equal.js\");\nexports.isEqual = is_equal_1.default;\nvar is_equal_with_1 = __webpack_require__(/*! ./is-equal-with */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-equal-with.js\");\nexports.isEqualWith = is_equal_with_1.default;\nvar map_1 = __webpack_require__(/*! ./map */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/map.js\");\nexports.map = map_1.default;\nvar map_values_1 = __webpack_require__(/*! ./map-values */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/map-values.js\");\nexports.mapValues = map_values_1.default;\nvar mix_1 = __webpack_require__(/*! ./mix */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/mix.js\");\nexports.mix = mix_1.default;\nexports.assign = mix_1.default;\nvar get_1 = __webpack_require__(/*! ./get */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get.js\");\nexports.get = get_1.default;\nvar set_1 = __webpack_require__(/*! ./set */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/set.js\");\nexports.set = set_1.default;\nvar pick_1 = __webpack_require__(/*! ./pick */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/pick.js\");\nexports.pick = pick_1.default;\nvar throttle_1 = __webpack_require__(/*! ./throttle */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/throttle.js\");\nexports.throttle = throttle_1.default;\nvar to_array_1 = __webpack_require__(/*! ./to-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-array.js\");\nexports.toArray = to_array_1.default;\nvar to_string_1 = __webpack_require__(/*! ./to-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-string.js\");\nexports.toString = to_string_1.default;\nvar unique_id_1 = __webpack_require__(/*! ./unique-id */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/unique-id.js\");\nexports.uniqueId = unique_id_1.default;\nvar noop_1 = __webpack_require__(/*! ./noop */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/noop.js\");\nexports.noop = noop_1.default;\nvar identity_1 = __webpack_require__(/*! ./identity */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/identity.js\");\nexports.identity = identity_1.default;\nvar size_1 = __webpack_require__(/*! ./size */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/size.js\");\nexports.size = size_1.default;\n// 不知道为什么，需要把这个 export，不然 ts 会报类型错误\nvar cache_1 = __webpack_require__(/*! ./cache */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/cache.js\");\nexports.Cache = cache_1.default;\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-arguments.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-arguments.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 是否是参数类型\n *\n * @param {Object} value 测试的值\n * @return {Boolean}\n */\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nvar isArguments = function (value) {\n    return is_type_1.default(value, 'Arguments');\n};\nexports.default = isArguments;\n//# sourceMappingURL=is-arguments.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\":\n/*!************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js ***!\n  \\************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isArrayLike = function (value) {\n    /**\n     * isArrayLike([1, 2, 3]) => true\n     * isArrayLike(document.body.children) => true\n     * isArrayLike('abc') => true\n     * isArrayLike(Function) => false\n     */\n    return value !== null && typeof value !== 'function' && isFinite(value.length);\n};\nexports.default = isArrayLike;\n//# sourceMappingURL=is-array-like.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nexports.default = (function (value) {\n    return Array.isArray ?\n        Array.isArray(value) :\n        is_type_1.default(value, 'Array');\n});\n//# sourceMappingURL=is-array.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-boolean.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-boolean.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 是否是布尔类型\n *\n * @param {Object} value 测试的值\n * @return {Boolean}\n */\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nvar isBoolean = function (value) {\n    return is_type_1.default(value, 'Boolean');\n};\nexports.default = isBoolean;\n//# sourceMappingURL=is-boolean.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-date.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-date.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nvar isDate = function (value) {\n    return is_type_1.default(value, 'Date');\n};\nexports.default = isDate;\n//# sourceMappingURL=is-date.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-decimal.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-decimal.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\nvar isDecimal = function (num) {\n    return is_number_1.default(num) && num % 1 !== 0;\n};\nexports.default = isDecimal;\n//# sourceMappingURL=is-decimal.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-element.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-element.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 判断是否HTML元素\n * @return {Boolean} 是否HTML元素\n */\nvar isElement = function (o) {\n    return o instanceof Element || o instanceof HTMLDocument;\n};\nexports.default = isElement;\n//# sourceMappingURL=is-element.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-empty.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-empty.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_nil_1 = __webpack_require__(/*! ./is-nil */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\");\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nvar get_type_1 = __webpack_require__(/*! ./get-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-type.js\");\nvar is_prototype_1 = __webpack_require__(/*! ./is-prototype */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-prototype.js\");\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction isEmpty(value) {\n    /**\n     * isEmpty(null) => true\n     * isEmpty() => true\n     * isEmpty(true) => true\n     * isEmpty(1) => true\n     * isEmpty([1, 2, 3]) => false\n     * isEmpty('abc') => false\n     * isEmpty({ a: 1 }) => false\n     */\n    if (is_nil_1.default(value)) {\n        return true;\n    }\n    if (is_array_like_1.default(value)) {\n        return !value.length;\n    }\n    var type = get_type_1.default(value);\n    if (type === 'Map' || type === 'Set') {\n        return !value.size;\n    }\n    if (is_prototype_1.default(value)) {\n        return !Object.keys(value).length;\n    }\n    for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.default = isEmpty;\n//# sourceMappingURL=is-empty.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-equal-with.js\":\n/*!************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-equal-with.js ***!\n  \\************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nvar is_equal_1 = __webpack_require__(/*! ./is-equal */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-equal.js\");\n/**\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [fn] The function to customize comparisons.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * function isGreeting(value) {\n *   return /^h(?:i|ello)$/.test(value);\n * }\n *\n * function customizer(objValue, othValue) {\n *   if (isGreeting(objValue) && isGreeting(othValue)) {\n *     return true;\n *   }\n * }\n *\n * var array = ['hello', 'goodbye'];\n * var other = ['hi', 'goodbye'];\n *\n * isEqualWith(array, other, customizer);  // => true\n */\nexports.default = (function (value, other, fn) {\n    if (!is_function_1.default(fn)) {\n        return is_equal_1.default(value, other);\n    }\n    return !!fn(value, other);\n});\n//# sourceMappingURL=is-equal-with.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-equal.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-equal.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_object_like_1 = __webpack_require__(/*! ./is-object-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object-like.js\");\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nvar is_string_1 = __webpack_require__(/*! ./is-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js\");\nvar isEqual = function (value, other) {\n    if (value === other) {\n        return true;\n    }\n    if (!value || !other) {\n        return false;\n    }\n    if (is_string_1.default(value) || is_string_1.default(other)) {\n        return false;\n    }\n    if (is_array_like_1.default(value) || is_array_like_1.default(other)) {\n        if (value.length !== other.length) {\n            return false;\n        }\n        var rst = true;\n        for (var i = 0; i < value.length; i++) {\n            rst = isEqual(value[i], other[i]);\n            if (!rst) {\n                break;\n            }\n        }\n        return rst;\n    }\n    if (is_object_like_1.default(value) || is_object_like_1.default(other)) {\n        var valueKeys = Object.keys(value);\n        var otherKeys = Object.keys(other);\n        if (valueKeys.length !== otherKeys.length) {\n            return false;\n        }\n        var rst = true;\n        for (var i = 0; i < valueKeys.length; i++) {\n            rst = isEqual(value[valueKeys[i]], other[valueKeys[i]]);\n            if (!rst) {\n                break;\n            }\n        }\n        return rst;\n    }\n    return false;\n};\nexports.default = isEqual;\n//# sourceMappingURL=is-equal.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-error.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-error.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 是否是参数类型\n *\n * @param {Object} value 测试的值\n * @return {Boolean}\n */\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nvar isError = function (value) {\n    return is_type_1.default(value, 'Error');\n};\nexports.default = isError;\n//# sourceMappingURL=is-error.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-even.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-even.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\nvar isEven = function (num) {\n    return is_number_1.default(num) && num % 2 === 0;\n};\nexports.default = isEven;\n//# sourceMappingURL=is-even.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-finite.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-finite.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 判断是否为有限数\n * @return {Boolean}\n */\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\nfunction default_1(value) {\n    return is_number_1.default(value) && isFinite(value);\n}\nexports.default = default_1;\n//# sourceMappingURL=is-finite.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 是否为函数\n * @param  {*} fn 对象\n * @return {Boolean}  是否函数\n */\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nexports.default = (function (value) {\n    return is_type_1.default(value, 'Function');\n});\n//# sourceMappingURL=is-function.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-integer.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-integer.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\nvar isInteger = Number.isInteger ? Number.isInteger : function (num) {\n    return is_number_1.default(num) && num % 1 === 0;\n};\nexports.default = isInteger;\n//# sourceMappingURL=is-integer.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-match.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-match.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_nil_1 = __webpack_require__(/*! ./is-nil */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\");\nvar keys_1 = __webpack_require__(/*! ./keys */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/keys.js\");\nfunction isMatch(obj, attrs) {\n    var _keys = keys_1.default(attrs);\n    var length = _keys.length;\n    if (is_nil_1.default(obj))\n        return !length;\n    for (var i = 0; i < length; i += 1) {\n        var key = _keys[i];\n        if (attrs[key] !== obj[key] || !(key in obj)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.default = isMatch;\n//# sourceMappingURL=is-match.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-negative.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-negative.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\nvar isNegative = function (num) {\n    return is_number_1.default(num) && num < 0;\n};\nexports.default = isNegative;\n//# sourceMappingURL=is-negative.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// isFinite,\nvar isNil = function (value) {\n    /**\n     * isNil(null) => true\n     * isNil() => true\n     */\n    return value === null || value === undefined;\n};\nexports.default = isNil;\n//# sourceMappingURL=is-nil.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-null.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-null.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isNull = function (value) {\n    return value === null;\n};\nexports.default = isNull;\n//# sourceMappingURL=is-null.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number-equal.js\":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number-equal.js ***!\n  \\**************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PRECISION = 0.00001; // numbers less than this is considered as 0\nfunction isNumberEqual(a, b, precision) {\n    if (precision === void 0) { precision = PRECISION; }\n    return Math.abs((a - b)) < precision;\n}\nexports.default = isNumberEqual;\n;\n//# sourceMappingURL=is-number-equal.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 判断是否数字\n * @return {Boolean} 是否数字\n */\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nvar isNumber = function (value) {\n    return is_type_1.default(value, 'Number');\n};\nexports.default = isNumber;\n//# sourceMappingURL=is-number.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object-like.js\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object-like.js ***!\n  \\*************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isObjectLike = function (value) {\n    /**\n     * isObjectLike({}) => true\n     * isObjectLike([1, 2, 3]) => true\n     * isObjectLike(Function) => false\n     * isObjectLike(null) => false\n     */\n    return typeof value === 'object' && value !== null;\n};\nexports.default = isObjectLike;\n//# sourceMappingURL=is-object-like.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = (function (value) {\n    /**\n     * isObject({}) => true\n     * isObject([1, 2, 3]) => true\n     * isObject(Function) => true\n     * isObject(null) => false\n     */\n    var type = typeof value;\n    return value !== null && type === 'object' || type === 'function';\n});\n//# sourceMappingURL=is-object.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-odd.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-odd.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\nvar isOdd = function (num) {\n    return is_number_1.default(num) && num % 2 !== 0;\n};\nexports.default = isOdd;\n//# sourceMappingURL=is-odd.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-plain-object.js\":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-plain-object.js ***!\n  \\**************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_object_like_1 = __webpack_require__(/*! ./is-object-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object-like.js\");\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nvar isPlainObject = function (value) {\n    /**\n     * isObjectLike(new Foo) => false\n     * isObjectLike([1, 2, 3]) => false\n     * isObjectLike({ x: 0, y: 0 }) => true\n     * isObjectLike(Object.create(null)) => true\n     */\n    if (!is_object_like_1.default(value) || !is_type_1.default(value, 'Object')) {\n        return false;\n    }\n    if (Object.getPrototypeOf(value) === null) {\n        return true;\n    }\n    var proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(value) === proto;\n};\nexports.default = isPlainObject;\n//# sourceMappingURL=is-plain-object.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-positive.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-positive.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\nvar isPositive = function (num) {\n    return is_number_1.default(num) && num > 0;\n};\nexports.default = isPositive;\n//# sourceMappingURL=is-positive.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-prototype.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-prototype.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar objectProto = Object.prototype;\nvar isPrototype = function (value) {\n    var Ctor = value && value.constructor;\n    var proto = (typeof Ctor === 'function' && Ctor.prototype) || objectProto;\n    return value === proto;\n};\nexports.default = isPrototype;\n//# sourceMappingURL=is-prototype.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-reg-exp.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-reg-exp.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nvar isRegExp = function (str) {\n    return is_type_1.default(str, 'RegExp');\n};\nexports.default = isRegExp;\n//# sourceMappingURL=is-reg-exp.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nexports.default = (function (str) {\n    return is_type_1.default(str, 'String');\n});\n//# sourceMappingURL=is-string.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar toString = {}.toString;\nvar isType = function (value, type) { return toString.call(value) === '[object ' + type + ']'; };\nexports.default = isType;\n//# sourceMappingURL=is-type.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-undefined.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-undefined.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isUndefined = function (value) {\n    return value === undefined;\n};\nexports.default = isUndefined;\n//# sourceMappingURL=is-undefined.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/keys.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/keys.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nvar keys = Object.keys ? function (obj) { return Object.keys(obj); } : function (obj) {\n    var result = [];\n    each_1.default(obj, function (value, key) {\n        if (!(is_function_1.default(obj) && key === 'prototype')) {\n            result.push(key);\n        }\n    });\n    return result;\n};\nexports.default = keys;\n//# sourceMappingURL=keys.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/last.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/last.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nfunction last(o) {\n    if (is_array_like_1.default(o)) {\n        var arr = o;\n        return arr[arr.length - 1];\n    }\n    return undefined;\n}\nexports.default = last;\n//# sourceMappingURL=last.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/lower-case.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/lower-case.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar to_string_1 = __webpack_require__(/*! ./to-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-string.js\");\nvar lowerCase = function (str) {\n    return to_string_1.default(str).toLowerCase();\n};\nexports.default = lowerCase;\n//# sourceMappingURL=lower-case.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/lower-first.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/lower-first.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar to_string_1 = __webpack_require__(/*! ./to-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-string.js\");\nvar lowerFirst = function (value) {\n    var str = to_string_1.default(value);\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\nexports.default = lowerFirst;\n//# sourceMappingURL=lower-first.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/map-values.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/map-values.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_nil_1 = __webpack_require__(/*! ./is-nil */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\");\nvar is_object_1 = __webpack_require__(/*! ./is-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object.js\");\nvar identity = function (v) { return v; };\nexports.default = (function (object, func) {\n    if (func === void 0) { func = identity; }\n    var r = {};\n    if (is_object_1.default(object) && !is_nil_1.default(object)) {\n        Object.keys(object).forEach(function (key) {\n            // @ts-ignore\n            r[key] = func(object[key], key);\n        });\n    }\n    return r;\n});\n//# sourceMappingURL=map-values.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/map.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/map.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nvar map = function (arr, func) {\n    if (!is_array_like_1.default(arr)) {\n        // @ts-ignore\n        return arr;\n    }\n    var result = [];\n    each_1.default(arr, function (value, index) {\n        result.push(func(value, index));\n    });\n    return result;\n};\nexports.default = map;\n//# sourceMappingURL=map.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/max-by.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/max-by.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\n/**\n * @param {Array} arr The array to iterate over.\n * @param {Function} [fn] The iteratee invoked per element.\n * @return {*} Returns the maximum value.\n * @example\n *\n * var objects = [{ 'n': 1 }, { 'n': 2 }];\n *\n * maxBy(objects, function(o) { return o.n; });\n * // => { 'n': 2 }\n *\n * maxBy(objects, 'n');\n * // => { 'n': 2 }\n */\nexports.default = (function (arr, fn) {\n    if (!is_array_1.default(arr)) {\n        return undefined;\n    }\n    var max = arr[0];\n    var maxData;\n    if (is_function_1.default(fn)) {\n        maxData = fn(arr[0]);\n    }\n    else {\n        maxData = arr[0][fn];\n    }\n    var data;\n    each_1.default(arr, function (val) {\n        if (is_function_1.default(fn)) {\n            data = fn(val);\n        }\n        else {\n            data = val[fn];\n        }\n        if (data > maxData) {\n            max = val;\n            maxData = data;\n        }\n    });\n    return max;\n});\n//# sourceMappingURL=max-by.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/memoize.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/memoize.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\n/**\n * _.memoize(calColor);\n * _.memoize(calColor, (...args) => args[0]);\n * @param f\n * @param resolver\n */\nexports.default = (function (f, resolver) {\n    if (!is_function_1.default(f)) {\n        throw new TypeError('Expected a function');\n    }\n    var memoized = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // 使用方法构造 key，如果不存在 resolver，则直接取第一个参数作为 key\n        var key = resolver ? resolver.apply(this, args) : args[0];\n        var cache = memoized.cache;\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        var result = f.apply(this, args);\n        // 缓存起来\n        cache.set(key, result);\n        return result;\n    };\n    memoized.cache = new Map();\n    return memoized;\n});\n//# sourceMappingURL=memoize.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/min-by.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/min-by.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\n/**\n * @param {Array} arr The array to iterate over.\n * @param {Function} [fn] The iteratee invoked per element.\n * @return {*} Returns the minimum value.\n * @example\n *\n * var objects = [{ 'n': 1 }, { 'n': 2 }];\n *\n * minBy(objects, function(o) { return o.n; });\n * // => { 'n': 1 }\n *\n * minBy(objects, 'n');\n * // => { 'n': 1 }\n */\nexports.default = (function (arr, fn) {\n    if (!is_array_1.default(arr)) {\n        return undefined;\n    }\n    var min = arr[0];\n    var minData;\n    if (is_function_1.default(fn)) {\n        minData = fn(arr[0]);\n    }\n    else {\n        minData = arr[0][fn];\n    }\n    var data;\n    each_1.default(arr, function (val) {\n        if (is_function_1.default(fn)) {\n            data = fn(val);\n        }\n        else {\n            data = val[fn];\n        }\n        if (data < minData) {\n            min = val;\n            minData = data;\n        }\n    });\n    return min;\n});\n//# sourceMappingURL=min-by.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/mix.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/mix.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// FIXME: Mutable param should be forbidden in static lang.\nfunction _mix(dist, obj) {\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key) && key !== 'constructor' && obj[key] !== undefined) {\n            dist[key] = obj[key];\n        }\n    }\n}\nfunction mix(dist, src1, src2, src3) {\n    if (src1)\n        _mix(dist, src1);\n    if (src2)\n        _mix(dist, src2);\n    if (src3)\n        _mix(dist, src3);\n    return dist;\n}\nexports.default = mix;\n//# sourceMappingURL=mix.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/mod.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/mod.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mod = function (n, m) {\n    return ((n % m) + m) % m;\n};\nexports.default = mod;\n//# sourceMappingURL=mod.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/noop.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/noop.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = (function () { });\n//# sourceMappingURL=noop.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/number2color.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/number2color.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar numColorCache = {};\nfunction numberToColor(num) {\n    // 增加缓存\n    var color = numColorCache[num];\n    if (!color) {\n        var str = num.toString(16);\n        for (var i = str.length; i < 6; i++) {\n            str = '0' + str;\n        }\n        color = '#' + str;\n        numColorCache[num] = color;\n    }\n    return color;\n}\nexports.default = numberToColor;\n//# sourceMappingURL=number2color.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/parse-radius.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/parse-radius.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nfunction parseRadius(radius) {\n    var r1 = 0, r2 = 0, r3 = 0, r4 = 0;\n    if (is_array_1.default(radius)) {\n        if (radius.length === 1) {\n            r1 = r2 = r3 = r4 = radius[0];\n        }\n        else if (radius.length === 2) {\n            r1 = r3 = radius[0];\n            r2 = r4 = radius[1];\n        }\n        else if (radius.length === 3) {\n            r1 = radius[0];\n            r2 = r4 = radius[1];\n            r3 = radius[2];\n        }\n        else {\n            r1 = radius[0];\n            r2 = radius[1];\n            r3 = radius[2];\n            r4 = radius[3];\n        }\n    }\n    else {\n        r1 = r2 = r3 = r4 = radius;\n    }\n    return {\n        r1: r1,\n        r2: r2,\n        r3: r3,\n        r4: r4\n    };\n}\nexports.default = parseRadius;\n//# sourceMappingURL=parse-radius.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/pick.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/pick.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_plain_object_1 = __webpack_require__(/*! ./is-plain-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-plain-object.js\");\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexports.default = (function (object, keys) {\n    if (object === null || !is_plain_object_1.default(object)) {\n        return {};\n    }\n    var result = {};\n    each_1.default(keys, function (key) {\n        if (hasOwnProperty.call(object, key)) {\n            result[key] = object[key];\n        }\n    });\n    return result;\n});\n//# sourceMappingURL=pick.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/pull-at.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/pull-at.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nvar splice = Array.prototype.splice;\nvar pullAt = function pullAt(arr, indexes) {\n    if (!is_array_like_1.default(arr)) {\n        return [];\n    }\n    var length = arr ? indexes.length : 0;\n    var last = length - 1;\n    while (length--) {\n        var previous = void 0;\n        var index = indexes[length];\n        if (length === last || index !== previous) {\n            previous = index;\n            splice.call(arr, index, 1);\n        }\n    }\n    return arr;\n};\nexports.default = pullAt;\n//# sourceMappingURL=pull-at.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/pull.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/pull.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrPrototype = Array.prototype;\nvar splice = arrPrototype.splice;\nvar indexOf = arrPrototype.indexOf;\nvar pull = function (arr) {\n    var values = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        values[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < values.length; i++) {\n        var value = values[i];\n        var fromIndex = -1;\n        while ((fromIndex = indexOf.call(arr, value)) > -1) {\n            splice.call(arr, fromIndex, 1);\n        }\n    }\n    return arr;\n};\nexports.default = pull;\n//# sourceMappingURL=pull.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/reduce.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/reduce.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_plain_object_1 = __webpack_require__(/*! ./is-plain-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-plain-object.js\");\nvar reduce = function (arr, fn, init) {\n    if (!is_array_1.default(arr) && !is_plain_object_1.default(arr)) {\n        return arr;\n    }\n    var result = init;\n    each_1.default(arr, function (data, i) {\n        result = fn(result, data, i);\n    });\n    return result;\n};\nexports.default = reduce;\n//# sourceMappingURL=reduce.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/remove.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/remove.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nvar pull_at_1 = __webpack_require__(/*! ./pull-at */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/pull-at.js\");\nvar remove = function (arr, predicate) {\n    /**\n     * const arr = [1, 2, 3, 4]\n     * const evens = remove(arr, n => n % 2 == 0)\n     * console.log(arr) // => [1, 3]\n     * console.log(evens) // => [2, 4]\n     */\n    var result = [];\n    if (!is_array_like_1.default(arr)) {\n        return result;\n    }\n    var i = -1;\n    var indexes = [];\n    var length = arr.length;\n    while (++i < length) {\n        var value = arr[i];\n        if (predicate(value, i, arr)) {\n            result.push(value);\n            indexes.push(i);\n        }\n    }\n    pull_at_1.default(arr, indexes);\n    return result;\n};\nexports.default = remove;\n//# sourceMappingURL=remove.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/request-animation-frame.js\":\n/*!**********************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/request-animation-frame.js ***!\n  \\**********************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction requestAnimationFrame(fn) {\n    var method = window.requestAnimationFrame ||\n        window.webkitRequestAnimationFrame ||\n        // @ts-ignore\n        window.mozRequestAnimationFrame ||\n        // @ts-ignore\n        window.msRequestAnimationFrame ||\n        function (f) {\n            return setTimeout(f, 16);\n        };\n    return method(fn);\n}\nexports.default = requestAnimationFrame;\n;\n//# sourceMappingURL=request-animation-frame.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/set.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/set.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_object_1 = __webpack_require__(/*! ./is-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object.js\");\nvar is_string_1 = __webpack_require__(/*! ./is-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js\");\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\n/**\n * https://github.com/developit/dlv/blob/master/index.js\n * @param obj\n * @param path\n * @param value\n */\nexports.default = (function (obj, path, value) {\n    var o = obj;\n    var keyArr = is_string_1.default(path) ? path.split('.') : path;\n    keyArr.forEach(function (key, idx) {\n        // 不是最后一个\n        if (idx < keyArr.length - 1) {\n            if (!is_object_1.default(o[key])) {\n                o[key] = is_number_1.default(keyArr[idx + 1]) ? [] : {};\n            }\n            o = o[key];\n        }\n        else {\n            o[key] = value;\n        }\n    });\n    return obj;\n});\n//# sourceMappingURL=set.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/size.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/size.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_nil_1 = __webpack_require__(/*! ./is-nil */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\");\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nfunction size(o) {\n    if (is_nil_1.default(o)) {\n        return 0;\n    }\n    if (is_array_like_1.default(o)) {\n        return o.length;\n    }\n    return Object.keys(o).length;\n}\nexports.default = size;\n//# sourceMappingURL=size.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/some.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/some.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 只要有一个满足条件就返回 true\n * @param arr\n * @param func\n */\nvar some = function (arr, func) {\n    for (var i = 0; i < arr.length; i++) {\n        if (func(arr[i], i))\n            return true;\n    }\n    return false;\n};\nexports.default = some;\n//# sourceMappingURL=some.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/sort-by.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/sort-by.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_string_1 = __webpack_require__(/*! ./is-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nfunction sortBy(arr, key) {\n    var comparer;\n    if (is_function_1.default(key)) {\n        comparer = function (a, b) { return key(a) - key(b); };\n    }\n    else {\n        var keys_1 = [];\n        if (is_string_1.default(key)) {\n            keys_1.push(key);\n        }\n        else if (is_array_1.default(key)) {\n            keys_1 = key;\n        }\n        comparer = function (a, b) {\n            for (var i = 0; i < keys_1.length; i += 1) {\n                var prop = keys_1[i];\n                if (a[prop] > b[prop]) {\n                    return 1;\n                }\n                if (a[prop] < b[prop]) {\n                    return -1;\n                }\n            }\n            return 0;\n        };\n    }\n    arr.sort(comparer);\n    return arr;\n}\nexports.default = sortBy;\n//# sourceMappingURL=sort-by.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/starts-with.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/starts-with.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_string_1 = __webpack_require__(/*! ./is-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js\");\nfunction startsWith(arr, e) {\n    return (is_array_1.default(arr) || is_string_1.default(arr)) ? arr[0] === e : false;\n}\nexports.default = startsWith;\n//# sourceMappingURL=starts-with.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/substitute.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/substitute.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction substitute(str, o) {\n    if (!str || !o) {\n        return str;\n    }\n    return str.replace(/\\\\?\\{([^{}]+)\\}/g, function (match, name) {\n        if (match.charAt(0) === '\\\\') {\n            return match.slice(1);\n        }\n        return (o[name] === undefined) ? '' : o[name];\n    });\n}\nexports.default = substitute;\n//# sourceMappingURL=substitute.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/throttle.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/throttle.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = (function (func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options)\n        options = {};\n    var later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout)\n            context = args = null;\n    };\n    var throttled = function () {\n        var now = Date.now();\n        if (!previous && options.leading === false)\n            previous = now;\n        var remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            result = func.apply(context, args);\n            if (!timeout)\n                context = args = null;\n        }\n        else if (!timeout && options.trailing !== false) {\n            timeout = setTimeout(later, remaining);\n        }\n        return result;\n    };\n    throttled.cancel = function () {\n        clearTimeout(timeout);\n        previous = 0;\n        timeout = context = args = null;\n    };\n    return throttled;\n});\n//# sourceMappingURL=throttle.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-array.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-array.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nexports.default = (function (value) {\n    return is_array_like_1.default(value) ? Array.prototype.slice.call(value) : [];\n});\n//# sourceMappingURL=to-array.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-degree.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-degree.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEGREE = 180 / Math.PI;\nvar toDegree = function (radian) {\n    return DEGREE * radian;\n};\nexports.default = toDegree;\n//# sourceMappingURL=to-degree.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-integer.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-integer.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = parseInt;\n//# sourceMappingURL=to-integer.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-radian.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-radian.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar RADIAN = Math.PI / 180;\nvar toRadian = function (degree) {\n    return RADIAN * degree;\n};\nexports.default = toRadian;\n//# sourceMappingURL=to-radian.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-string.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-string.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_nil_1 = __webpack_require__(/*! ./is-nil */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\");\nexports.default = (function (value) {\n    if (is_nil_1.default(value))\n        return '';\n    return value.toString();\n});\n//# sourceMappingURL=to-string.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/union.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/union.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar uniq_1 = __webpack_require__(/*! ./uniq */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/uniq.js\");\nvar union = function () {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    return uniq_1.default([].concat.apply([], sources));\n};\nexports.default = union;\n//# sourceMappingURL=union.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/uniq.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/uniq.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar contains_1 = __webpack_require__(/*! ./contains */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/contains.js\");\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar uniq = function (arr) {\n    var resultArr = [];\n    each_1.default(arr, function (item) {\n        if (!contains_1.default(resultArr, item)) {\n            resultArr.push(item);\n        }\n    });\n    return resultArr;\n};\nexports.default = uniq;\n//# sourceMappingURL=uniq.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/unique-id.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/unique-id.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar map = {};\nexports.default = (function (prefix) {\n    prefix = prefix || 'g';\n    if (!map[prefix]) {\n        map[prefix] = 1;\n    }\n    else {\n        map[prefix] += 1;\n    }\n    return prefix + map[prefix];\n});\n//# sourceMappingURL=unique-id.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/upper-case.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/upper-case.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar to_string_1 = __webpack_require__(/*! ./to-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-string.js\");\nvar upperCase = function (str) {\n    return to_string_1.default(str).toUpperCase();\n};\nexports.default = upperCase;\n//# sourceMappingURL=upper-case.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/upper-first.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/upper-first.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar to_string_1 = __webpack_require__(/*! ./to-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-string.js\");\nvar upperFirst = function (value) {\n    var str = to_string_1.default(value);\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\nexports.default = upperFirst;\n//# sourceMappingURL=upper-first.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/values-of-key.js\":\n/*!************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/values-of-key.js ***!\n  \\************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_nil_1 = __webpack_require__(/*! ./is-nil */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\");\nexports.default = (function (data, name) {\n    var rst = [];\n    var tmpMap = {};\n    data.forEach(function (obj) {\n        var value = obj[name];\n        if (!is_nil_1.default(value)) {\n            // flatten\n            if (!is_array_1.default(value)) {\n                value = [value];\n            }\n            each_1.default(value, function (val) {\n                // unique\n                if (!tmpMap[val]) {\n                    rst.push(val);\n                    tmpMap[val] = true;\n                }\n            });\n        }\n    });\n    return rst;\n});\n//# sourceMappingURL=values-of-key.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/values.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/values.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\n// @ts-ignore\nvar values = Object.values ? function (obj) { return Object.values(obj); } : function (obj) {\n    var result = [];\n    each_1.default(obj, function (value, key) {\n        if (!(is_function_1.default(obj) && key === 'prototype')) {\n            result.push(value);\n        }\n    });\n    return result;\n};\nexports.default = values;\n//# sourceMappingURL=values.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/wrap-behavior.js\":\n/*!************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/wrap-behavior.js ***!\n  \\************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 封装事件，便于使用上下文this,和便于解除事件时使用\n * @protected\n * @param  {Object} obj   对象\n * @param  {String} action 事件名称\n * @return {Function}        返回事件处理函数\n */\nfunction wrapBehavior(obj, action) {\n    if (obj['_wrap_' + action]) {\n        return obj['_wrap_' + action];\n    }\n    var method = function (e) {\n        obj[action](e);\n    };\n    obj['_wrap_' + action] = method;\n    return method;\n}\nexports.default = wrapBehavior;\n//# sourceMappingURL=wrap-behavior.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_abs-svg-path@0.1.1@abs-svg-path/index.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_abs-svg-path@0.1.1@abs-svg-path/index.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n\nmodule.exports = absolutize\n\n/**\n * redefine `path` with absolute coordinates\n *\n * @param {Array} path\n * @return {Array}\n */\n\nfunction absolutize(path){\n\tvar startX = 0\n\tvar startY = 0\n\tvar x = 0\n\tvar y = 0\n\n\treturn path.map(function(seg){\n\t\tseg = seg.slice()\n\t\tvar type = seg[0]\n\t\tvar command = type.toUpperCase()\n\n\t\t// is relative\n\t\tif (type != command) {\n\t\t\tseg[0] = command\n\t\t\tswitch (type) {\n\t\t\t\tcase 'a':\n\t\t\t\t\tseg[6] += x\n\t\t\t\t\tseg[7] += y\n\t\t\t\t\tbreak\n\t\t\t\tcase 'v':\n\t\t\t\t\tseg[1] += y\n\t\t\t\t\tbreak\n\t\t\t\tcase 'h':\n\t\t\t\t\tseg[1] += x\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tfor (var i = 1; i < seg.length;) {\n\t\t\t\t\t\tseg[i++] += x\n\t\t\t\t\t\tseg[i++] += y\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update cursor state\n\t\tswitch (command) {\n\t\t\tcase 'Z':\n\t\t\t\tx = startX\n\t\t\t\ty = startY\n\t\t\t\tbreak\n\t\t\tcase 'H':\n\t\t\t\tx = seg[1]\n\t\t\t\tbreak\n\t\t\tcase 'V':\n\t\t\t\ty = seg[1]\n\t\t\t\tbreak\n\t\t\tcase 'M':\n\t\t\t\tx = startX = seg[1]\n\t\t\t\ty = startY = seg[2]\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tx = seg[seg.length - 2]\n\t\t\t\ty = seg[seg.length - 1]\n\t\t}\n\n\t\treturn seg\n\t})\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-array/ v1.2.4 Copyright 2018 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports) :\n        undefined;\n}(this, (function (exports) {\n    'use strict';\n    function ascending(a, b) {\n        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n    }\n    function bisector(compare) {\n        if (compare.length === 1)\n            compare = ascendingComparator(compare);\n        return {\n            left: function (a, x, lo, hi) {\n                if (lo == null)\n                    lo = 0;\n                if (hi == null)\n                    hi = a.length;\n                while (lo < hi) {\n                    var mid = lo + hi >>> 1;\n                    if (compare(a[mid], x) < 0)\n                        lo = mid + 1;\n                    else\n                        hi = mid;\n                }\n                return lo;\n            },\n            right: function (a, x, lo, hi) {\n                if (lo == null)\n                    lo = 0;\n                if (hi == null)\n                    hi = a.length;\n                while (lo < hi) {\n                    var mid = lo + hi >>> 1;\n                    if (compare(a[mid], x) > 0)\n                        hi = mid;\n                    else\n                        lo = mid + 1;\n                }\n                return lo;\n            }\n        };\n    }\n    function ascendingComparator(f) {\n        return function (d, x) {\n            return ascending(f(d), x);\n        };\n    }\n    var ascendingBisect = bisector(ascending);\n    var bisectRight = ascendingBisect.right;\n    var bisectLeft = ascendingBisect.left;\n    function pairs(array, f) {\n        if (f == null)\n            f = pair;\n        var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);\n        while (i < n)\n            pairs[i] = f(p, p = array[++i]);\n        return pairs;\n    }\n    function pair(a, b) {\n        return [a, b];\n    }\n    function cross(values0, values1, reduce) {\n        var n0 = values0.length, n1 = values1.length, values = new Array(n0 * n1), i0, i1, i, value0;\n        if (reduce == null)\n            reduce = pair;\n        for (i0 = i = 0; i0 < n0; ++i0) {\n            for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {\n                values[i] = reduce(value0, values1[i1]);\n            }\n        }\n        return values;\n    }\n    function descending(a, b) {\n        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n    }\n    function number(x) {\n        return x === null ? NaN : +x;\n    }\n    function variance(values, valueof) {\n        var n = values.length, m = 0, i = -1, mean = 0, value, delta, sum = 0;\n        if (valueof == null) {\n            while (++i < n) {\n                if (!isNaN(value = number(values[i]))) {\n                    delta = value - mean;\n                    mean += delta / ++m;\n                    sum += delta * (value - mean);\n                }\n            }\n        }\n        else {\n            while (++i < n) {\n                if (!isNaN(value = number(valueof(values[i], i, values)))) {\n                    delta = value - mean;\n                    mean += delta / ++m;\n                    sum += delta * (value - mean);\n                }\n            }\n        }\n        if (m > 1)\n            return sum / (m - 1);\n    }\n    function deviation(array, f) {\n        var v = variance(array, f);\n        return v ? Math.sqrt(v) : v;\n    }\n    function extent(values, valueof) {\n        var n = values.length, i = -1, value, min, max;\n        if (valueof == null) {\n            while (++i < n) { // Find the first comparable value.\n                if ((value = values[i]) != null && value >= value) {\n                    min = max = value;\n                    while (++i < n) { // Compare the remaining values.\n                        if ((value = values[i]) != null) {\n                            if (min > value)\n                                min = value;\n                            if (max < value)\n                                max = value;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            while (++i < n) { // Find the first comparable value.\n                if ((value = valueof(values[i], i, values)) != null && value >= value) {\n                    min = max = value;\n                    while (++i < n) { // Compare the remaining values.\n                        if ((value = valueof(values[i], i, values)) != null) {\n                            if (min > value)\n                                min = value;\n                            if (max < value)\n                                max = value;\n                        }\n                    }\n                }\n            }\n        }\n        return [min, max];\n    }\n    var array = Array.prototype;\n    var slice = array.slice;\n    var map = array.map;\n    function constant(x) {\n        return function () {\n            return x;\n        };\n    }\n    function identity(x) {\n        return x;\n    }\n    function range(start, stop, step) {\n        start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n        var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range = new Array(n);\n        while (++i < n) {\n            range[i] = start + i * step;\n        }\n        return range;\n    }\n    var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);\n    function ticks(start, stop, count) {\n        var reverse, i = -1, n, ticks, step;\n        stop = +stop, start = +start, count = +count;\n        if (start === stop && count > 0)\n            return [start];\n        if (reverse = stop < start)\n            n = start, start = stop, stop = n;\n        if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step))\n            return [];\n        if (step > 0) {\n            start = Math.ceil(start / step);\n            stop = Math.floor(stop / step);\n            ticks = new Array(n = Math.ceil(stop - start + 1));\n            while (++i < n)\n                ticks[i] = (start + i) * step;\n        }\n        else {\n            start = Math.floor(start * step);\n            stop = Math.ceil(stop * step);\n            ticks = new Array(n = Math.ceil(start - stop + 1));\n            while (++i < n)\n                ticks[i] = (start - i) / step;\n        }\n        if (reverse)\n            ticks.reverse();\n        return ticks;\n    }\n    function tickIncrement(start, stop, count) {\n        var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);\n        return power >= 0\n            ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n            : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n    }\n    function tickStep(start, stop, count) {\n        var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;\n        if (error >= e10)\n            step1 *= 10;\n        else if (error >= e5)\n            step1 *= 5;\n        else if (error >= e2)\n            step1 *= 2;\n        return stop < start ? -step1 : step1;\n    }\n    function sturges(values) {\n        return Math.ceil(Math.log(values.length) / Math.LN2) + 1;\n    }\n    function histogram() {\n        var value = identity, domain = extent, threshold = sturges;\n        function histogram(data) {\n            var i, n = data.length, x, values = new Array(n);\n            for (i = 0; i < n; ++i) {\n                values[i] = value(data[i], i, data);\n            }\n            var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold(values, x0, x1);\n            // Convert number of thresholds into uniform thresholds.\n            if (!Array.isArray(tz)) {\n                tz = tickStep(x0, x1, tz);\n                tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive\n            }\n            // Remove any thresholds outside the domain.\n            var m = tz.length;\n            while (tz[0] <= x0)\n                tz.shift(), --m;\n            while (tz[m - 1] > x1)\n                tz.pop(), --m;\n            var bins = new Array(m + 1), bin;\n            // Initialize bins.\n            for (i = 0; i <= m; ++i) {\n                bin = bins[i] = [];\n                bin.x0 = i > 0 ? tz[i - 1] : x0;\n                bin.x1 = i < m ? tz[i] : x1;\n            }\n            // Assign data to bins by value, ignoring any outside the domain.\n            for (i = 0; i < n; ++i) {\n                x = values[i];\n                if (x0 <= x && x <= x1) {\n                    bins[bisectRight(tz, x, 0, m)].push(data[i]);\n                }\n            }\n            return bins;\n        }\n        histogram.value = function (_) {\n            return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(_), histogram) : value;\n        };\n        histogram.domain = function (_) {\n            return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant([_[0], _[1]]), histogram) : domain;\n        };\n        histogram.thresholds = function (_) {\n            return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;\n        };\n        return histogram;\n    }\n    function quantile(values, p, valueof) {\n        if (valueof == null)\n            valueof = number;\n        if (!(n = values.length))\n            return;\n        if ((p = +p) <= 0 || n < 2)\n            return +valueof(values[0], 0, values);\n        if (p >= 1)\n            return +valueof(values[n - 1], n - 1, values);\n        var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);\n        return value0 + (value1 - value0) * (i - i0);\n    }\n    function freedmanDiaconis(values, min, max) {\n        values = map.call(values, number).sort(ascending);\n        return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));\n    }\n    function scott(values, min, max) {\n        return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));\n    }\n    function max(values, valueof) {\n        var n = values.length, i = -1, value, max;\n        if (valueof == null) {\n            while (++i < n) { // Find the first comparable value.\n                if ((value = values[i]) != null && value >= value) {\n                    max = value;\n                    while (++i < n) { // Compare the remaining values.\n                        if ((value = values[i]) != null && value > max) {\n                            max = value;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            while (++i < n) { // Find the first comparable value.\n                if ((value = valueof(values[i], i, values)) != null && value >= value) {\n                    max = value;\n                    while (++i < n) { // Compare the remaining values.\n                        if ((value = valueof(values[i], i, values)) != null && value > max) {\n                            max = value;\n                        }\n                    }\n                }\n            }\n        }\n        return max;\n    }\n    function mean(values, valueof) {\n        var n = values.length, m = n, i = -1, value, sum = 0;\n        if (valueof == null) {\n            while (++i < n) {\n                if (!isNaN(value = number(values[i])))\n                    sum += value;\n                else\n                    --m;\n            }\n        }\n        else {\n            while (++i < n) {\n                if (!isNaN(value = number(valueof(values[i], i, values))))\n                    sum += value;\n                else\n                    --m;\n            }\n        }\n        if (m)\n            return sum / m;\n    }\n    function median(values, valueof) {\n        var n = values.length, i = -1, value, numbers = [];\n        if (valueof == null) {\n            while (++i < n) {\n                if (!isNaN(value = number(values[i]))) {\n                    numbers.push(value);\n                }\n            }\n        }\n        else {\n            while (++i < n) {\n                if (!isNaN(value = number(valueof(values[i], i, values)))) {\n                    numbers.push(value);\n                }\n            }\n        }\n        return quantile(numbers.sort(ascending), 0.5);\n    }\n    function merge(arrays) {\n        var n = arrays.length, m, i = -1, j = 0, merged, array;\n        while (++i < n)\n            j += arrays[i].length;\n        merged = new Array(j);\n        while (--n >= 0) {\n            array = arrays[n];\n            m = array.length;\n            while (--m >= 0) {\n                merged[--j] = array[m];\n            }\n        }\n        return merged;\n    }\n    function min(values, valueof) {\n        var n = values.length, i = -1, value, min;\n        if (valueof == null) {\n            while (++i < n) { // Find the first comparable value.\n                if ((value = values[i]) != null && value >= value) {\n                    min = value;\n                    while (++i < n) { // Compare the remaining values.\n                        if ((value = values[i]) != null && min > value) {\n                            min = value;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            while (++i < n) { // Find the first comparable value.\n                if ((value = valueof(values[i], i, values)) != null && value >= value) {\n                    min = value;\n                    while (++i < n) { // Compare the remaining values.\n                        if ((value = valueof(values[i], i, values)) != null && min > value) {\n                            min = value;\n                        }\n                    }\n                }\n            }\n        }\n        return min;\n    }\n    function permute(array, indexes) {\n        var i = indexes.length, permutes = new Array(i);\n        while (i--)\n            permutes[i] = array[indexes[i]];\n        return permutes;\n    }\n    function scan(values, compare) {\n        if (!(n = values.length))\n            return;\n        var n, i = 0, j = 0, xi, xj = values[j];\n        if (compare == null)\n            compare = ascending;\n        while (++i < n) {\n            if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {\n                xj = xi, j = i;\n            }\n        }\n        if (compare(xj, xj) === 0)\n            return j;\n    }\n    function shuffle(array, i0, i1) {\n        var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0), t, i;\n        while (m) {\n            i = Math.random() * m-- | 0;\n            t = array[m + i0];\n            array[m + i0] = array[i + i0];\n            array[i + i0] = t;\n        }\n        return array;\n    }\n    function sum(values, valueof) {\n        var n = values.length, i = -1, value, sum = 0;\n        if (valueof == null) {\n            while (++i < n) {\n                if (value = +values[i])\n                    sum += value; // Note: zero and null are equivalent.\n            }\n        }\n        else {\n            while (++i < n) {\n                if (value = +valueof(values[i], i, values))\n                    sum += value;\n            }\n        }\n        return sum;\n    }\n    function transpose(matrix) {\n        if (!(n = matrix.length))\n            return [];\n        for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {\n            for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n                row[j] = matrix[j][i];\n            }\n        }\n        return transpose;\n    }\n    function length(d) {\n        return d.length;\n    }\n    function zip() {\n        return transpose(arguments);\n    }\n    exports.bisect = bisectRight;\n    exports.bisectRight = bisectRight;\n    exports.bisectLeft = bisectLeft;\n    exports.ascending = ascending;\n    exports.bisector = bisector;\n    exports.cross = cross;\n    exports.descending = descending;\n    exports.deviation = deviation;\n    exports.extent = extent;\n    exports.histogram = histogram;\n    exports.thresholdFreedmanDiaconis = freedmanDiaconis;\n    exports.thresholdScott = scott;\n    exports.thresholdSturges = sturges;\n    exports.max = max;\n    exports.mean = mean;\n    exports.median = median;\n    exports.merge = merge;\n    exports.min = min;\n    exports.pairs = pairs;\n    exports.permute = permute;\n    exports.quantile = quantile;\n    exports.range = range;\n    exports.scan = scan;\n    exports.shuffle = shuffle;\n    exports.sum = sum;\n    exports.ticks = ticks;\n    exports.tickIncrement = tickIncrement;\n    exports.tickStep = tickStep;\n    exports.transpose = transpose;\n    exports.variance = variance;\n    exports.zip = zip;\n    Object.defineProperty(exports, '__esModule', { value: true });\n})));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-collection@1.0.7@d3-collection/dist/d3-collection.js\":\n/*!*******************************************************************************!*\\\n  !*** ./node_modules/_d3-collection@1.0.7@d3-collection/dist/d3-collection.js ***!\n  \\*******************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-collection/ v1.0.7 Copyright 2018 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports) :\n        undefined;\n}(this, (function (exports) {\n    'use strict';\n    var prefix = \"$\";\n    function Map() { }\n    Map.prototype = map.prototype = {\n        constructor: Map,\n        has: function (key) {\n            return (prefix + key) in this;\n        },\n        get: function (key) {\n            return this[prefix + key];\n        },\n        set: function (key, value) {\n            this[prefix + key] = value;\n            return this;\n        },\n        remove: function (key) {\n            var property = prefix + key;\n            return property in this && delete this[property];\n        },\n        clear: function () {\n            for (var property in this)\n                if (property[0] === prefix)\n                    delete this[property];\n        },\n        keys: function () {\n            var keys = [];\n            for (var property in this)\n                if (property[0] === prefix)\n                    keys.push(property.slice(1));\n            return keys;\n        },\n        values: function () {\n            var values = [];\n            for (var property in this)\n                if (property[0] === prefix)\n                    values.push(this[property]);\n            return values;\n        },\n        entries: function () {\n            var entries = [];\n            for (var property in this)\n                if (property[0] === prefix)\n                    entries.push({ key: property.slice(1), value: this[property] });\n            return entries;\n        },\n        size: function () {\n            var size = 0;\n            for (var property in this)\n                if (property[0] === prefix)\n                    ++size;\n            return size;\n        },\n        empty: function () {\n            for (var property in this)\n                if (property[0] === prefix)\n                    return false;\n            return true;\n        },\n        each: function (f) {\n            for (var property in this)\n                if (property[0] === prefix)\n                    f(this[property], property.slice(1), this);\n        }\n    };\n    function map(object, f) {\n        var map = new Map;\n        // Copy constructor.\n        if (object instanceof Map)\n            object.each(function (value, key) { map.set(key, value); });\n        // Index array by numeric index or specified key function.\n        else if (Array.isArray(object)) {\n            var i = -1, n = object.length, o;\n            if (f == null)\n                while (++i < n)\n                    map.set(i, object[i]);\n            else\n                while (++i < n)\n                    map.set(f(o = object[i], i, object), o);\n        }\n        // Convert object to map.\n        else if (object)\n            for (var key in object)\n                map.set(key, object[key]);\n        return map;\n    }\n    function nest() {\n        var keys = [], sortKeys = [], sortValues, rollup, nest;\n        function apply(array, depth, createResult, setResult) {\n            if (depth >= keys.length) {\n                if (sortValues != null)\n                    array.sort(sortValues);\n                return rollup != null ? rollup(array) : array;\n            }\n            var i = -1, n = array.length, key = keys[depth++], keyValue, value, valuesByKey = map(), values, result = createResult();\n            while (++i < n) {\n                if (values = valuesByKey.get(keyValue = key(value = array[i]) + \"\")) {\n                    values.push(value);\n                }\n                else {\n                    valuesByKey.set(keyValue, [value]);\n                }\n            }\n            valuesByKey.each(function (values, key) {\n                setResult(result, key, apply(values, depth, createResult, setResult));\n            });\n            return result;\n        }\n        function entries(map$$1, depth) {\n            if (++depth > keys.length)\n                return map$$1;\n            var array, sortKey = sortKeys[depth - 1];\n            if (rollup != null && depth >= keys.length)\n                array = map$$1.entries();\n            else\n                array = [], map$$1.each(function (v, k) { array.push({ key: k, values: entries(v, depth) }); });\n            return sortKey != null ? array.sort(function (a, b) { return sortKey(a.key, b.key); }) : array;\n        }\n        return nest = {\n            object: function (array) { return apply(array, 0, createObject, setObject); },\n            map: function (array) { return apply(array, 0, createMap, setMap); },\n            entries: function (array) { return entries(apply(array, 0, createMap, setMap), 0); },\n            key: function (d) { keys.push(d); return nest; },\n            sortKeys: function (order) { sortKeys[keys.length - 1] = order; return nest; },\n            sortValues: function (order) { sortValues = order; return nest; },\n            rollup: function (f) { rollup = f; return nest; }\n        };\n    }\n    function createObject() {\n        return {};\n    }\n    function setObject(object, key, value) {\n        object[key] = value;\n    }\n    function createMap() {\n        return map();\n    }\n    function setMap(map$$1, key, value) {\n        map$$1.set(key, value);\n    }\n    function Set() { }\n    var proto = map.prototype;\n    Set.prototype = set.prototype = {\n        constructor: Set,\n        has: proto.has,\n        add: function (value) {\n            value += \"\";\n            this[prefix + value] = value;\n            return this;\n        },\n        remove: proto.remove,\n        clear: proto.clear,\n        values: proto.keys,\n        size: proto.size,\n        empty: proto.empty,\n        each: proto.each\n    };\n    function set(object, f) {\n        var set = new Set;\n        // Copy constructor.\n        if (object instanceof Set)\n            object.each(function (value) { set.add(value); });\n        // Otherwise, assume it’s an array.\n        else if (object) {\n            var i = -1, n = object.length;\n            if (f == null)\n                while (++i < n)\n                    set.add(object[i]);\n            else\n                while (++i < n)\n                    set.add(f(object[i], i, object));\n        }\n        return set;\n    }\n    function keys(map) {\n        var keys = [];\n        for (var key in map)\n            keys.push(key);\n        return keys;\n    }\n    function values(map) {\n        var values = [];\n        for (var key in map)\n            values.push(map[key]);\n        return values;\n    }\n    function entries(map) {\n        var entries = [];\n        for (var key in map)\n            entries.push({ key: key, value: map[key] });\n        return entries;\n    }\n    exports.nest = nest;\n    exports.set = set;\n    exports.map = map;\n    exports.keys = keys;\n    exports.values = values;\n    exports.entries = entries;\n    Object.defineProperty(exports, '__esModule', { value: true });\n})));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-composite-projections@1.3.2@d3-composite-projections/d3-composite-projections.js\":\n/*!***********************************************************************************************************!*\\\n  !*** ./node_modules/_d3-composite-projections@1.3.2@d3-composite-projections/d3-composite-projections.js ***!\n  \\***********************************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// http://geoexamples.com/d3-composite-projections/ v1.3.2 Copyright 2019 Roger Veciana i Rovira\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! d3-geo */ \"./node_modules/_d3-geo@1.11.9@d3-geo/dist/d3-geo.js\"), __webpack_require__(/*! d3-path */ \"./node_modules/_d3-path@1.0.9@d3-path/dist/d3-path.js\")) :\n        undefined;\n}(this, (function (exports, d3Geo, d3Path) {\n    'use strict';\n    var epsilon = 1e-6;\n    function noop() { }\n    var x0 = Infinity, y0 = x0, x1 = -x0, y1 = x1;\n    var boundsStream = {\n        point: boundsPoint,\n        lineStart: noop,\n        lineEnd: noop,\n        polygonStart: noop,\n        polygonEnd: noop,\n        result: function () {\n            var bounds = [[x0, y0], [x1, y1]];\n            x1 = y1 = -(y0 = x0 = Infinity);\n            return bounds;\n        }\n    };\n    function boundsPoint(x, y) {\n        if (x < x0)\n            x0 = x;\n        if (x > x1)\n            x1 = x;\n        if (y < y0)\n            y0 = y;\n        if (y > y1)\n            y1 = y;\n    }\n    function fitExtent(projection, extent, object) {\n        var w = extent[1][0] - extent[0][0], h = extent[1][1] - extent[0][1], clip = projection.clipExtent && projection.clipExtent();\n        projection\n            .scale(150)\n            .translate([0, 0]);\n        if (clip != null)\n            projection.clipExtent(null);\n        d3Geo.geoStream(object, projection.stream(boundsStream));\n        var b = boundsStream.result(), k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n        if (clip != null)\n            projection.clipExtent(clip);\n        return projection\n            .scale(k * 150)\n            .translate([x, y]);\n    }\n    function fitSize(projection, size, object) {\n        return fitExtent(projection, [[0, 0], size], object);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n)\n                streams[i].point(x, y); },\n            sphere: function () { var i = -1; while (++i < n)\n                streams[i].sphere(); },\n            lineStart: function () { var i = -1; while (++i < n)\n                streams[i].lineStart(); },\n            lineEnd: function () { var i = -1; while (++i < n)\n                streams[i].lineEnd(); },\n            polygonStart: function () { var i = -1; while (++i < n)\n                streams[i].polygonStart(); },\n            polygonEnd: function () { var i = -1; while (++i < n)\n                streams[i].polygonEnd(); }\n        };\n    }\n    // A composite projection for the United States, configured by default for\n    // 960×500. The projection also works quite well at 960×600 if you change the\n    // scale to 1285 and adjust the translate accordingly. The set of standard\n    // parallels for each region comes from USGS, which is published here:\n    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\n    function albersUsa() {\n        var cache, cacheStream, lower48 = d3Geo.geoAlbers(), lower48Point, alaska = d3Geo.geoConicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n        hawaii = d3Geo.geoConicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n        point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        function albersUsa(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (lower48Point.point(x, y), point)\n                    || (alaskaPoint.point(x, y), point)\n                    || (hawaiiPoint.point(x, y), point);\n        }\n        albersUsa.invert = function (coordinates) {\n            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n                : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n                    : lower48).invert(coordinates);\n        };\n        albersUsa.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n        };\n        albersUsa.precision = function (_) {\n            if (!arguments.length)\n                return lower48.precision();\n            lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n            return reset();\n        };\n        albersUsa.scale = function (_) {\n            if (!arguments.length)\n                return lower48.scale();\n            lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n            return albersUsa.translate(lower48.translate());\n        };\n        albersUsa.translate = function (_) {\n            if (!arguments.length)\n                return lower48.translate();\n            var k = lower48.scale(), x = +_[0], y = +_[1];\n            lower48Point = lower48\n                .translate(_)\n                .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n                .stream(pointStream);\n            alaskaPoint = alaska\n                .translate([x - 0.307 * k, y + 0.201 * k])\n                .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])\n                .stream(pointStream);\n            hawaiiPoint = hawaii\n                .translate([x - 0.205 * k, y + 0.212 * k])\n                .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        albersUsa.fitExtent = function (extent, object) {\n            return fitExtent(albersUsa, extent, object);\n        };\n        albersUsa.fitSize = function (size, object) {\n            return fitSize(albersUsa, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return albersUsa;\n        }\n        albersUsa.drawCompositionBorders = function (context) {\n            var hawaii1 = lower48([-102.91, 26.3]);\n            var hawaii2 = lower48([-104.0, 27.5]);\n            var hawaii3 = lower48([-108.0, 29.1]);\n            var hawaii4 = lower48([-110.0, 29.1]);\n            var alaska1 = lower48([-110.0, 26.7]);\n            var alaska2 = lower48([-112.8, 27.6]);\n            var alaska3 = lower48([-114.3, 30.6]);\n            var alaska4 = lower48([-119.3, 30.1]);\n            context.moveTo(hawaii1[0], hawaii1[1]);\n            context.lineTo(hawaii2[0], hawaii2[1]);\n            context.lineTo(hawaii3[0], hawaii3[1]);\n            context.lineTo(hawaii4[0], hawaii4[1]);\n            context.moveTo(alaska1[0], alaska1[1]);\n            context.lineTo(alaska2[0], alaska2[1]);\n            context.lineTo(alaska3[0], alaska3[1]);\n            context.lineTo(alaska4[0], alaska4[1]);\n        };\n        albersUsa.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return albersUsa.scale(1070);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$1(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n)\n                streams[i].point(x, y); },\n            sphere: function () { var i = -1; while (++i < n)\n                streams[i].sphere(); },\n            lineStart: function () { var i = -1; while (++i < n)\n                streams[i].lineStart(); },\n            lineEnd: function () { var i = -1; while (++i < n)\n                streams[i].lineEnd(); },\n            polygonStart: function () { var i = -1; while (++i < n)\n                streams[i].polygonStart(); },\n            polygonEnd: function () { var i = -1; while (++i < n)\n                streams[i].polygonEnd(); }\n        };\n    }\n    // A composite projection for the United States, configured by default for\n    // 960×500. Also works quite well at 960×600 with scale 1285. The set of\n    // standard parallels for each region comes from USGS, which is published here:\n    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\n    function albersUsaTerritories() {\n        var cache, cacheStream, lower48 = d3Geo.geoAlbers(), lower48Point, alaska = d3Geo.geoConicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n        hawaii = d3Geo.geoConicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n        puertoRico = d3Geo.geoConicEqualArea().rotate([66, 0]).center([0, 18]).parallels([8, 18]), puertoRicoPoint, //Taken from https://bl.ocks.org/mbostock/5629120\n        samoa = d3Geo.geoEquirectangular().rotate([173, 14]), samoaPoint, // EPSG:4169\n        guam = d3Geo.geoEquirectangular().rotate([-145, -16.8]), guamPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        /*\n        var puertoRicoBbox = [[-68.3, 19], [-63.9, 17]];\n        var samoaBbox = [[-171, -14], [-168, -14.8]];\n        var guamBbox = [[144, 20.8], [146.5, 12.7]];\n        */\n        function albersUsa(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (lower48Point.point(x, y), point) ||\n                    (alaskaPoint.point(x, y), point) ||\n                    (hawaiiPoint.point(x, y), point) ||\n                    (puertoRicoPoint.point(x, y), point) ||\n                    (samoaPoint.point(x, y), point) ||\n                    (guamPoint.point(x, y), point);\n        }\n        albersUsa.invert = function (coordinates) {\n            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            /*\n            //How are the return values calculated:\n            console.info(\"******\");\n            var c0 = puertoRico(puertoRicoBbox[0]);\n            var x0 = (c0[0] - t[0]) / k;\n            var y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 puertoRico\", x0 + ' - ' + y0);\n    \n            var c1 = puertoRico(puertoRicoBbox[1]);\n            var x1 = (c1[0] - t[0]) / k;\n            var y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 puertoRico\", x1 + ' - ' + y1);\n    \n            c0 = samoa(samoaBbox[0]);\n            x0 = (c0[0] - t[0]) / k;\n            y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 samoa\", x0 + ' - ' + y0);\n    \n            c1 = samoa(samoaBbox[1]);\n            x1 = (c1[0] - t[0]) / k;\n            y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 samoa\", x1 + ' - ' + y1);\n    \n            c0 = guam(guamBbox[0]);\n            x0 = (c0[0] - t[0]) / k;\n            y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 guam\", x0 + ' - ' + y0);\n    \n            c1 = guam(guamBbox[1]);\n            x1 = (c1[0] - t[0]) / k;\n            y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 guam\", x1 + ' - ' + y1);\n            */\n            return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n                : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n                    : y >= 0.2064 && y < 0.2413 && x >= 0.312 && x < 0.385 ? puertoRico\n                        : y >= 0.09 && y < 0.1197 && x >= -0.4243 && x < -0.3232 ? samoa\n                            : y >= -0.0518 && y < 0.0895 && x >= -0.4243 && x < -0.3824 ? guam\n                                : lower48).invert(coordinates);\n        };\n        albersUsa.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$1([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream), puertoRico.stream(stream), samoa.stream(stream), guam.stream(stream)]);\n        };\n        albersUsa.precision = function (_) {\n            if (!arguments.length) {\n                return lower48.precision();\n            }\n            lower48.precision(_);\n            alaska.precision(_);\n            hawaii.precision(_);\n            puertoRico.precision(_);\n            samoa.precision(_);\n            guam.precision(_);\n            return reset();\n        };\n        albersUsa.scale = function (_) {\n            if (!arguments.length) {\n                return lower48.scale();\n            }\n            lower48.scale(_);\n            alaska.scale(_ * 0.35);\n            hawaii.scale(_);\n            puertoRico.scale(_);\n            samoa.scale(_ * 2);\n            guam.scale(_);\n            return albersUsa.translate(lower48.translate());\n        };\n        albersUsa.translate = function (_) {\n            if (!arguments.length) {\n                return lower48.translate();\n            }\n            var k = lower48.scale(), x = +_[0], y = +_[1];\n            /*\n            var c0 = puertoRico.translate([x + 0.350 * k, y + 0.224 * k])(puertoRicoBbox[0]);\n            var x0 = (x - c0[0]) / k;\n            var y0 = (y - c0[1]) / k;\n        \n            var c1 = puertoRico.translate([x + 0.350 * k, y + 0.224 * k])(puertoRicoBbox[1]);\n            var x1 = (x - c1[0]) / k;\n            var y1 = (y - c1[1]) / k;\n        \n            console.info('puertoRico: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n            console.info('.clipExtent([[x '+\n             (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n             ' * k + epsilon, y '+\n             (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n             ' * k + epsilon],[x '+\n             (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n             ' * k - epsilon, y '+\n             (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n             ' * k - epsilon]])');\n        \n              c0 = samoa.translate([x - 0.492 * k, y + 0.09 * k])(samoaBbox[0]);\n              x0 = (x - c0[0]) / k;\n              y0 = (y - c0[1]) / k;\n        \n              c1 = samoa.translate([x - 0.492 * k, y + 0.09 * k])(samoaBbox[1]);\n              x1 = (x - c1[0]) / k;\n              y1 = (y - c1[1]) / k;\n        \n             console.info('samoa: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n             console.info('.clipExtent([[x '+\n              (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n              ' * k + epsilon, y '+\n              (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n              ' * k + epsilon],[x '+\n              (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n              ' * k - epsilon, y '+\n              (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n              ' * k - epsilon]])');\n        \n              c0 = guam.translate([x - 0.408 * k, y + 0.018 * k])(guamBbox[0]);\n              x0 = (x - c0[0]) / k;\n              y0 = (y - c0[1]) / k;\n        \n              c1 = guam.translate([x - 0.408 * k, y + 0.018 * k])(guamBbox[1]);\n              x1 = (x - c1[0]) / k;\n              y1 = (y - c1[1]) / k;\n        \n             console.info('guam: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n             console.info('.clipExtent([[x '+\n              (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n              ' * k + epsilon, y '+\n              (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n              ' * k + epsilon],[x '+\n              (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n              ' * k - epsilon, y '+\n              (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n              ' * k - epsilon]])');\n              */\n            lower48Point = lower48\n                .translate(_)\n                .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n                .stream(pointStream);\n            alaskaPoint = alaska\n                .translate([x - 0.307 * k, y + 0.201 * k])\n                .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.233 * k - epsilon]])\n                .stream(pointStream);\n            hawaiiPoint = hawaii\n                .translate([x - 0.205 * k, y + 0.212 * k])\n                .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.233 * k - epsilon]])\n                .stream(pointStream);\n            puertoRicoPoint = puertoRico\n                .translate([x + 0.350 * k, y + 0.224 * k])\n                .clipExtent([[x + 0.312 * k + epsilon, y + 0.2064 * k + epsilon], [x + 0.385 * k - epsilon, y + 0.233 * k - epsilon]])\n                .stream(pointStream);\n            samoaPoint = samoa\n                .translate([x - 0.492 * k, y + 0.09 * k])\n                .clipExtent([[x - 0.4243 * k + epsilon, y + 0.0903 * k + epsilon], [x - 0.3233 * k - epsilon, y + 0.1197 * k - epsilon]])\n                .stream(pointStream);\n            guamPoint = guam\n                .translate([x - 0.408 * k, y + 0.018 * k])\n                .clipExtent([[x - 0.4244 * k + epsilon, y - 0.0519 * k + epsilon], [x - 0.3824 * k - epsilon, y + 0.0895 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        albersUsa.fitExtent = function (extent, object) {\n            return fitExtent(albersUsa, extent, object);\n        };\n        albersUsa.fitSize = function (size, object) {\n            return fitSize(albersUsa, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return albersUsa;\n        }\n        albersUsa.drawCompositionBorders = function (context) {\n            /*\n            console.info(\"CLIP EXTENT hawaii: \", hawaii.clipExtent());\n            console.info(\"UL BBOX:\", lower48.invert([hawaii.clipExtent()[0][0], hawaii.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", lower48.invert([hawaii.clipExtent()[1][0], hawaii.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", lower48.invert([hawaii.clipExtent()[1][0], hawaii.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", lower48.invert([hawaii.clipExtent()[0][0], hawaii.clipExtent()[1][1]]));\n        \n            console.info(\"CLIP EXTENT alaska: \", alaska.clipExtent());\n            console.info(\"UL BBOX:\", lower48.invert([alaska.clipExtent()[0][0], alaska.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", lower48.invert([alaska.clipExtent()[1][0], alaska.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", lower48.invert([alaska.clipExtent()[1][0], alaska.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", lower48.invert([alaska.clipExtent()[0][0], alaska.clipExtent()[1][1]]));\n        \n            console.info(\"CLIP EXTENT puertoRico: \", puertoRico.clipExtent());\n            console.info(\"UL BBOX:\", lower48.invert([puertoRico.clipExtent()[0][0], puertoRico.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", lower48.invert([puertoRico.clipExtent()[1][0], puertoRico.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", lower48.invert([puertoRico.clipExtent()[1][0], puertoRico.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", lower48.invert([puertoRico.clipExtent()[0][0], puertoRico.clipExtent()[1][1]]));\n        \n            console.info(\"CLIP EXTENT samoa: \", samoa.clipExtent());\n            console.info(\"UL BBOX:\", lower48.invert([samoa.clipExtent()[0][0], samoa.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", lower48.invert([samoa.clipExtent()[1][0], samoa.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", lower48.invert([samoa.clipExtent()[1][0], samoa.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", lower48.invert([samoa.clipExtent()[0][0], samoa.clipExtent()[1][1]]));\n        \n        \n            console.info(\"CLIP EXTENT guam: \", guam.clipExtent());\n            console.info(\"UL BBOX:\", lower48.invert([guam.clipExtent()[0][0], guam.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", lower48.invert([guam.clipExtent()[1][0], guam.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", lower48.invert([guam.clipExtent()[1][0], guam.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", lower48.invert([guam.clipExtent()[0][0], guam.clipExtent()[1][1]]));\n            */\n            var ulhawaii = lower48([-110.4641, 28.2805]);\n            var urhawaii = lower48([-104.0597, 28.9528]);\n            var ldhawaii = lower48([-103.7049, 25.1031]);\n            var llhawaii = lower48([-109.8337, 24.4531]);\n            var ulalaska = lower48([-124.4745, 28.1407]);\n            var uralaska = lower48([-110.931, 30.8844]);\n            var ldalaska = lower48([-109.8337, 24.4531]);\n            var llalaska = lower48([-122.4628, 21.8562]);\n            var ulpuertoRico = lower48([-76.8579, 25.1544]);\n            var urpuertoRico = lower48([-72.429, 24.2097]);\n            var ldpuertoRico = lower48([-72.8265, 22.7056]);\n            var llpuertoRico = lower48([-77.1852, 23.6392]);\n            var ulsamoa = lower48([-125.0093, 29.7791]);\n            var ursamoa = lower48([-118.5193, 31.3262]);\n            var ldsamoa = lower48([-118.064, 29.6912]);\n            var llsamoa = lower48([-124.4369, 28.169]);\n            var ulguam = lower48([-128.1314, 37.4582]);\n            var urguam = lower48([-125.2132, 38.214]);\n            var ldguam = lower48([-122.3616, 30.5115]);\n            var llguam = lower48([-125.0315, 29.8211]);\n            context.moveTo(ulhawaii[0], ulhawaii[1]);\n            context.lineTo(urhawaii[0], urhawaii[1]);\n            context.lineTo(ldhawaii[0], ldhawaii[1]);\n            context.lineTo(ldhawaii[0], ldhawaii[1]);\n            context.lineTo(llhawaii[0], llhawaii[1]);\n            context.closePath();\n            context.moveTo(ulalaska[0], ulalaska[1]);\n            context.lineTo(uralaska[0], uralaska[1]);\n            context.lineTo(ldalaska[0], ldalaska[1]);\n            context.lineTo(ldalaska[0], ldalaska[1]);\n            context.lineTo(llalaska[0], llalaska[1]);\n            context.closePath();\n            context.moveTo(ulpuertoRico[0], ulpuertoRico[1]);\n            context.lineTo(urpuertoRico[0], urpuertoRico[1]);\n            context.lineTo(ldpuertoRico[0], ldpuertoRico[1]);\n            context.lineTo(ldpuertoRico[0], ldpuertoRico[1]);\n            context.lineTo(llpuertoRico[0], llpuertoRico[1]);\n            context.closePath();\n            context.moveTo(ulsamoa[0], ulsamoa[1]);\n            context.lineTo(ursamoa[0], ursamoa[1]);\n            context.lineTo(ldsamoa[0], ldsamoa[1]);\n            context.lineTo(ldsamoa[0], ldsamoa[1]);\n            context.lineTo(llsamoa[0], llsamoa[1]);\n            context.closePath();\n            context.moveTo(ulguam[0], ulguam[1]);\n            context.lineTo(urguam[0], urguam[1]);\n            context.lineTo(ldguam[0], ldguam[1]);\n            context.lineTo(ldguam[0], ldguam[1]);\n            context.lineTo(llguam[0], llguam[1]);\n            context.closePath();\n        };\n        albersUsa.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return albersUsa.scale(1070);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$2(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for Spain, configured by default for 960×500.\n    function conicConformalSpain() {\n        var cache, cacheStream, iberianPeninsule = d3Geo.geoConicConformal().rotate([5, -38.6]).parallels([0, 60]), iberianPeninsulePoint, canaryIslands = d3Geo.geoConicConformal().rotate([5, -38.6]).parallels([0, 60]), canaryIslandsPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        /*\n        var iberianPeninsuleBbox = [[-11, 46], [4, 35]];\n        var canaryIslandsBbox = [[-19.0, 28.85], [-12.7, 28.1]];\n        */\n        function conicConformalSpain(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (iberianPeninsulePoint.point(x, y), point) ||\n                    (canaryIslandsPoint.point(x, y), point);\n        }\n        conicConformalSpain.invert = function (coordinates) {\n            var k = iberianPeninsule.scale(), t = iberianPeninsule.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= 0.05346 && y < 0.0897 && x >= -0.13388 && x < -0.0322 ? canaryIslands\n                : iberianPeninsule).invert(coordinates);\n        };\n        conicConformalSpain.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$2([iberianPeninsule.stream(cacheStream = stream), canaryIslands.stream(stream)]);\n        };\n        conicConformalSpain.precision = function (_) {\n            if (!arguments.length) {\n                return iberianPeninsule.precision();\n            }\n            iberianPeninsule.precision(_);\n            canaryIslands.precision(_);\n            return reset();\n        };\n        conicConformalSpain.scale = function (_) {\n            if (!arguments.length) {\n                return iberianPeninsule.scale();\n            }\n            iberianPeninsule.scale(_);\n            canaryIslands.scale(_);\n            return conicConformalSpain.translate(iberianPeninsule.translate());\n        };\n        conicConformalSpain.translate = function (_) {\n            if (!arguments.length) {\n                return iberianPeninsule.translate();\n            }\n            var k = iberianPeninsule.scale(), x = +_[0], y = +_[1];\n            /*\n            var c0 = iberianPeninsule(iberianPeninsuleBbox[0]);\n           var x0 = (x - c0[0]) / k;\n           var y0 = (y - c0[1]) / k;\n        \n           var c1 = iberianPeninsule(iberianPeninsuleBbox[1]);\n           var x1 = (x - c1[0]) / k;\n           var y1 = (y - c1[1]) / k;\n        \n           console.info('Iberian Peninsula: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n        \n           c0 = canaryIslands.translate([x + 0.1 * k, y - 0.094 * k])(canaryIslandsBbox[0]);\n           x0 = (x - c0[0]) / k;\n           y0 = (y - c0[1]) / k;\n        \n           c1 = canaryIslands.translate([x + 0.1 * k, y - 0.094 * k])(canaryIslandsBbox[1]);\n           x1 = (x - c1[0]) / k;\n           y1 = (y - c1[1]) / k;\n        \n           console.info('Canry Islands: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           */\n            iberianPeninsulePoint = iberianPeninsule\n                .translate(_)\n                .clipExtent([[x - 0.06857 * k, y - 0.1288 * k], [x + 0.13249 * k, y + 0.06 * k]])\n                .stream(pointStream);\n            canaryIslandsPoint = canaryIslands\n                .translate([x + 0.1 * k, y - 0.094 * k])\n                .clipExtent([[x - 0.1331 * k + epsilon, y + 0.053457 * k + epsilon], [x - 0.0354 * k - epsilon, y + 0.08969 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        conicConformalSpain.fitExtent = function (extent, object) {\n            return fitExtent(conicConformalSpain, extent, object);\n        };\n        conicConformalSpain.fitSize = function (size, object) {\n            return fitSize(conicConformalSpain, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return conicConformalSpain;\n        }\n        conicConformalSpain.drawCompositionBorders = function (context) {\n            /*\n            console.info(\"CLIP EXTENT: \", canaryIslands.clipExtent());\n            console.info(\"UL BBOX:\", iberianPeninsule.invert([canaryIslands.clipExtent()[0][0], canaryIslands.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", iberianPeninsule.invert([canaryIslands.clipExtent()[1][0], canaryIslands.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", iberianPeninsule.invert([canaryIslands.clipExtent()[1][0], canaryIslands.clipExtent()[1][1]]));\n            */\n            var ulCanaryIslands = iberianPeninsule([-14.0346750, 34.965007]);\n            var urCanaryIslands = iberianPeninsule([-7.4208899, 35.536988]);\n            var ldCanaryIslands = iberianPeninsule([-7.3148275, 33.54359]);\n            context.moveTo(ulCanaryIslands[0], ulCanaryIslands[1]);\n            context.lineTo(urCanaryIslands[0], urCanaryIslands[1]);\n            context.lineTo(ldCanaryIslands[0], ldCanaryIslands[1]);\n        };\n        conicConformalSpain.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return conicConformalSpain.scale(2700);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$3(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for Portugal, configured by default for 960×500.\n    function conicConformalPortugal() {\n        var cache, cacheStream, iberianPeninsule = d3Geo.geoConicConformal().rotate([10, -39.3]).parallels([0, 60]), iberianPeninsulePoint, madeira = d3Geo.geoConicConformal().rotate([17, -32.7]).parallels([0, 60]), madeiraPoint, azores = d3Geo.geoConicConformal().rotate([27.8, -38.6]).parallels([0, 60]), azoresPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        /*\n        var iberianPeninsuleBbox = [[-11, 46], [4, 34]];\n        var madeiraBbox = [[-17.85, 33.6], [-16, 32.02]];\n        var azoresBbox = [[-32, 40.529], [-23.98, 35.75]];\n        */\n        function conicConformalPortugal(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (iberianPeninsulePoint.point(x, y), point) ||\n                    (madeiraPoint.point(x, y), point) ||\n                    (azoresPoint.point(x, y), point);\n        }\n        conicConformalPortugal.invert = function (coordinates) {\n            var k = iberianPeninsule.scale(), t = iberianPeninsule.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            /*\n            //How are the return values calculated:\n            console.info(\"******\");\n            var c0 = madeira(madeiraBbox[0]);\n            var x0 = (c0[0] - t[0]) / k;\n            var y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 madeira\", x0 + ' - ' + y0);\n    \n            var c1 = madeira(madeiraBbox[1]);\n            var x1 = (c1[0] - t[0]) / k;\n            var y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 madeira\", x1 + ' - ' + y1);\n    \n            c0 = azores(azoresBbox[0]);\n            x0 = (c0[0] - t[0]) / k;\n            y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 azores\", x0 + ' - ' + y0);\n    \n            c1 = azores(azoresBbox[1]);\n            x1 = (c1[0] - t[0]) / k;\n            y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 azores\", x1 + ' - ' + y1);\n            */\n            return (y >= 0.0093 && y < 0.03678 && x >= -0.03875 && x < -0.0116 ? madeira\n                : y >= -0.0412 && y < 0.0091 && x >= -0.07782 && x < -0.01166 ? azores\n                    : iberianPeninsule).invert(coordinates);\n        };\n        conicConformalPortugal.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$3([iberianPeninsule.stream(cacheStream = stream), madeira.stream(stream), azores.stream(stream)]);\n        };\n        conicConformalPortugal.precision = function (_) {\n            if (!arguments.length) {\n                return iberianPeninsule.precision();\n            }\n            iberianPeninsule.precision(_);\n            madeira.precision(_);\n            azores.precision(_);\n            return reset();\n        };\n        conicConformalPortugal.scale = function (_) {\n            if (!arguments.length) {\n                return iberianPeninsule.scale();\n            }\n            iberianPeninsule.scale(_);\n            madeira.scale(_);\n            azores.scale(_ * 0.6);\n            return conicConformalPortugal.translate(iberianPeninsule.translate());\n        };\n        conicConformalPortugal.translate = function (_) {\n            if (!arguments.length) {\n                return iberianPeninsule.translate();\n            }\n            var k = iberianPeninsule.scale(), x = +_[0], y = +_[1];\n            /*\n            var c0 = iberianPeninsule(iberianPeninsuleBbox[0]);\n           var x0 = (x - c0[0]) / k;\n           var y0 = (y - c0[1]) / k;\n        \n           var c1 = iberianPeninsule(iberianPeninsuleBbox[1]);\n           var x1 = (x - c1[0]) / k;\n           var y1 = (y - c1[1]) / k;\n        \n           console.info('Iberian Peninsula: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           console.info('.clipExtent([[x '+\n            (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n            ' * k, y '+\n            (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n            ' * k],[x '+\n            (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n            ' * k, y '+\n            (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n            ' * k]])');\n        \n           c0 = madeira.translate([x - 0.0265 * k, y + 0.025 * k])(madeiraBbox[0]);\n           x0 = (x - c0[0]) / k;\n           y0 = (y - c0[1]) / k;\n        \n           c1 = madeira.translate([x - 0.0265 * k, y + 0.025 * k])(madeiraBbox[1]);\n           x1 = (x - c1[0]) / k;\n           y1 = (y - c1[1]) / k;\n        \n           console.info('Madeira: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           console.info('.clipExtent([[x '+\n            (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n            ' * k + epsilon, y '+\n            (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n            ' * k + epsilon],[x '+\n            (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n            ' * k - epsilon, y '+\n            (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n            ' * k - epsilon]])');\n        \n            c0 = azores.translate([x - 0.045 * k, y + -0.02 * k])(azoresBbox[0]);\n            x0 = (x - c0[0]) / k;\n            y0 = (y - c0[1]) / k;\n        \n            c1 = azores.translate([x - 0.045 * k, y + -0.02 * k])(azoresBbox[1]);\n            x1 = (x - c1[0]) / k;\n            y1 = (y - c1[1]) / k;\n        \n            console.info('Azores: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n            console.info('.clipExtent([[x '+\n             (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n             ' * k + epsilon, y '+\n             (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n             ' * k + epsilon],[x '+\n             (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n             ' * k - epsilon, y '+\n             (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n             ' * k - epsilon]])');\n             */\n            iberianPeninsulePoint = iberianPeninsule\n                .translate(_)\n                .clipExtent([[x - 0.0115 * k, y - 0.1138 * k], [x + 0.2105 * k, y + 0.0673 * k]])\n                .stream(pointStream);\n            madeiraPoint = madeira\n                .translate([x - 0.0265 * k, y + 0.025 * k])\n                .clipExtent([[x - 0.0388 * k + epsilon, y + 0.0093 * k + epsilon], [x - 0.0116 * k - epsilon, y + 0.0368 * k - epsilon]])\n                .stream(pointStream);\n            azoresPoint = azores\n                .translate([x - 0.045 * k, y + -0.02 * k])\n                .clipExtent([[x - 0.0778 * k + epsilon, y - 0.0413 * k + epsilon], [x - 0.0117 * k - epsilon, y + 0.0091 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        conicConformalPortugal.fitExtent = function (extent, object) {\n            return fitExtent(conicConformalPortugal, extent, object);\n        };\n        conicConformalPortugal.fitSize = function (size, object) {\n            return fitSize(conicConformalPortugal, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return conicConformalPortugal;\n        }\n        conicConformalPortugal.drawCompositionBorders = function (context) {\n            /*\n            console.info(\"CLIP EXTENT MADEIRA: \", madeira.clipExtent());\n            console.info(\"UL BBOX:\", iberianPeninsule.invert([madeira.clipExtent()[0][0], madeira.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", iberianPeninsule.invert([madeira.clipExtent()[1][0], madeira.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", iberianPeninsule.invert([madeira.clipExtent()[1][0], madeira.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", iberianPeninsule.invert([madeira.clipExtent()[0][0], madeira.clipExtent()[1][1]]));\n        \n            console.info(\"CLIP EXTENT AZORES: \", azores.clipExtent());\n            console.info(\"UL BBOX:\", iberianPeninsule.invert([azores.clipExtent()[0][0], azores.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", iberianPeninsule.invert([azores.clipExtent()[1][0], azores.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", iberianPeninsule.invert([azores.clipExtent()[1][0], azores.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", iberianPeninsule.invert([azores.clipExtent()[0][0], azores.clipExtent()[1][1]]));\n            */\n            var ulmadeira = iberianPeninsule([-12.8351, 38.7113]);\n            var urmadeira = iberianPeninsule([-10.8482, 38.7633]);\n            var ldmadeira = iberianPeninsule([-10.8181, 37.2072]);\n            var llmadeira = iberianPeninsule([-12.7345, 37.1573]);\n            var ulazores = iberianPeninsule([-16.0753, 41.4436]);\n            var urazores = iberianPeninsule([-10.9168, 41.6861]);\n            var ldazores = iberianPeninsule([-10.8557, 38.7747]);\n            var llazores = iberianPeninsule([-15.6728, 38.5505]);\n            context.moveTo(ulmadeira[0], ulmadeira[1]);\n            context.lineTo(urmadeira[0], urmadeira[1]);\n            context.lineTo(ldmadeira[0], ldmadeira[1]);\n            context.lineTo(ldmadeira[0], ldmadeira[1]);\n            context.lineTo(llmadeira[0], llmadeira[1]);\n            context.closePath();\n            context.moveTo(ulazores[0], ulazores[1]);\n            context.lineTo(urazores[0], urazores[1]);\n            context.lineTo(ldazores[0], ldazores[1]);\n            context.lineTo(ldazores[0], ldazores[1]);\n            context.lineTo(llazores[0], llazores[1]);\n            context.closePath();\n        };\n        conicConformalPortugal.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return conicConformalPortugal.scale(4200);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$4(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for Ecuador, configured by default for 960×500.\n    function mercatorEcuador() {\n        var cache, cacheStream, mainland = d3Geo.geoMercator().rotate([80, 1.5]), mainlandPoint, galapagos = d3Geo.geoMercator().rotate([90.73, 1]), galapagosPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        /*\n        var mainlandBbox = [[-81.5, 2.7], [-70.0, -6.0]];\n        var galapagosBbox = [[-92.2, 0.58], [-88.8, -1.8]];\n        */\n        function mercatorEcuador(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (mainlandPoint.point(x, y), point) ||\n                    (galapagosPoint.point(x, y), point);\n        }\n        mercatorEcuador.invert = function (coordinates) {\n            var k = mainland.scale(), t = mainland.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            /*\n            //How are the return values calculated:\n            var c0 = galapagos(galapagosBbox[0]);\n            var x0 = (c0[0] - t[0]) / k;\n            var y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 galapagos\", x0 + ' - ' + y0);\n    \n    \n            var c1 = galapagos(galapagosBbox[1]);\n            var x1 = (c1[0] - t[0]) / k;\n            var y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 galapagos\", x1 + ' - ' + y1);\n            */\n            return (y >= -0.0676 && y < -0.026 && x >= -0.0857 && x < -0.0263 ? galapagos\n                : mainland).invert(coordinates);\n        };\n        mercatorEcuador.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$4([mainland.stream(cacheStream = stream), galapagos.stream(stream)]);\n        };\n        mercatorEcuador.precision = function (_) {\n            if (!arguments.length) {\n                return mainland.precision();\n            }\n            mainland.precision(_);\n            galapagos.precision(_);\n            return reset();\n        };\n        mercatorEcuador.scale = function (_) {\n            if (!arguments.length) {\n                return mainland.scale();\n            }\n            mainland.scale(_);\n            galapagos.scale(_);\n            return mercatorEcuador.translate(mainland.translate());\n        };\n        mercatorEcuador.translate = function (_) {\n            if (!arguments.length) {\n                return mainland.translate();\n            }\n            var k = mainland.scale(), x = +_[0], y = +_[1];\n            /*\n            var c0 = mainland(mainlandBbox[0]);\n           var x0 = (x - c0[0]) / k;\n           var y0 = (y - c0[1]) / k;\n        \n           var c1 = mainland(mainlandBbox[1]);\n           var x1 = (x - c1[0]) / k;\n           var y1 = (y - c1[1]) / k;\n        \n           console.info('mainland: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           console.info('.clipExtent([[x '+\n            (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n            ' * k, y '+\n            (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n            ' * k],[x '+\n            (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n            ' * k, y '+\n            (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n            ' * k]])');\n        \n           c0 = galapagos.translate([x - 0.06 * k, y - 0.04 * k])(galapagosBbox[0]);\n           x0 = (x - c0[0]) / k;\n           y0 = (y - c0[1]) / k;\n        \n           c1 = galapagos.translate([x - 0.06 * k, y - 0.04 * k])(galapagosBbox[1]);\n           x1 = (x - c1[0]) / k;\n           y1 = (y - c1[1]) / k;\n        \n           console.info('galapagos: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           console.info('.clipExtent([[x '+\n            (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n            ' * k + epsilon, y '+\n            (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n            ' * k + epsilon],[x '+\n            (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n            ' * k - epsilon, y '+\n            (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n            ' * k - epsilon]])');*/\n            mainlandPoint = mainland\n                .translate(_)\n                .clipExtent([[x - 0.0262 * k, y - 0.0734 * k], [x + 0.1741 * k, y + 0.079 * k]])\n                .stream(pointStream);\n            galapagosPoint = galapagos\n                .translate([x - 0.06 * k, y - 0.04 * k])\n                .clipExtent([[x - 0.0857 * k + epsilon, y - 0.0676 * k + epsilon], [x - 0.0263 * k - epsilon, y - 0.026 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        mercatorEcuador.fitExtent = function (extent, object) {\n            return fitExtent(mercatorEcuador, extent, object);\n        };\n        mercatorEcuador.fitSize = function (size, object) {\n            return fitSize(mercatorEcuador, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return mercatorEcuador;\n        }\n        mercatorEcuador.drawCompositionBorders = function (context) {\n            /*\n            console.info(\"CLIP EXTENT: \", galapagos.clipExtent());\n            console.info(\"UL BBOX:\", mainland.invert([galapagos.clipExtent()[0][0], galapagos.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", mainland.invert([galapagos.clipExtent()[1][0], galapagos.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", mainland.invert([galapagos.clipExtent()[1][0], galapagos.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", mainland.invert([galapagos.clipExtent()[0][0], galapagos.clipExtent()[1][1]]));\n            */\n            var ulgalapagos = mainland([-84.9032, 2.3757]);\n            var urgalapagos = mainland([-81.5047, 2.3708]);\n            var ldgalapagos = mainland([-81.5063, -0.01]);\n            var llgalapagos = mainland([-84.9086, -0.005]);\n            context.moveTo(ulgalapagos[0], ulgalapagos[1]);\n            context.lineTo(urgalapagos[0], urgalapagos[1]);\n            context.lineTo(ldgalapagos[0], ldgalapagos[1]);\n            context.lineTo(llgalapagos[0], llgalapagos[1]);\n            context.closePath();\n        };\n        mercatorEcuador.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return mercatorEcuador.scale(3500);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$5(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for Chile, configured by default for 960×500.\n    function transverseMercatorChile() {\n        var cache, cacheStream, mainland = d3Geo.geoTransverseMercator().rotate([72, 37]), mainlandPoint, antarctic = d3Geo.geoStereographic().rotate([72, 0]), antarcticPoint, juanFernandez = d3Geo.geoMercator().rotate([80, 33.5]), juanFernandezPoint, pascua = d3Geo.geoMercator().rotate([110, 25]), pascuaPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        /*\n        var mainlandBbox = [[-75.5, -15.0], [-32, -49.0]];\n        var antarcticBbox = [[-91.0, -60.0], [-43.0, -90.0]];\n        var juanFernandezBbox = [[-81.0, -33.0], [-78.5, -34.0]];\n        var pascuaBbox = [[-110, -26.6], [-108.7, -27.5]];\n        */\n        function transverseMercatorChile(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (mainlandPoint.point(x, y), point) ||\n                    (antarcticPoint.point(x, y), point) ||\n                    (juanFernandezPoint.point(x, y), point) ||\n                    (pascuaPoint.point(x, y), point);\n        }\n        transverseMercatorChile.invert = function (coordinates) {\n            var k = mainland.scale(), t = mainland.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            /*\n            //How are the return values calculated:\n            console.info(\"******\");\n            var c0 = antarctic(antarcticBbox[0]);\n            var x0 = (c0[0] - t[0]) / k;\n            var y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 antarctic\", x0 + ' - ' + y0);\n    \n            var c1 = antarctic(antarcticBbox[1]);\n            var x1 = (c1[0] - t[0]) / k;\n            var y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 antarctic\", x1 + ' - ' + y1);\n    \n            c0 = juanFernandez(juanFernandezBbox[0]);\n            x0 = (c0[0] - t[0]) / k;\n            y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 juanFernandez\", x0 + ' - ' + y0);\n    \n            c1 = juanFernandez(juanFernandezBbox[1]);\n            x1 = (c1[0] - t[0]) / k;\n            y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 juanFernandez\", x1 + ' - ' + y1);\n    \n            c0 = pascua(pascuaBbox[0]);\n            x0 = (c0[0] - t[0]) / k;\n            y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 pascua\", x0 + ' - ' + y0);\n    \n            c1 = pascua(pascuaBbox[1]);\n            x1 = (c1[0] - t[0]) / k;\n            y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 pascua\", x1 + ' - ' + y1);\n            */\n            return (y >= 0.2582 && y < 0.32 && x >= -0.1036 && x < -0.087 ? antarctic\n                : y >= -0.01298 && y < 0.0133 && x >= -0.11396 && x < -0.05944 ? juanFernandez\n                    : y >= 0.01539 && y < 0.03911 && x >= -0.089 && x < -0.0588 ? pascua\n                        : mainland).invert(coordinates);\n        };\n        transverseMercatorChile.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$5([mainland.stream(cacheStream = stream), antarctic.stream(stream), juanFernandez.stream(stream), pascua.stream(stream)]);\n        };\n        transverseMercatorChile.precision = function (_) {\n            if (!arguments.length) {\n                return mainland.precision();\n            }\n            mainland.precision(_);\n            antarctic.precision(_);\n            juanFernandez.precision(_);\n            pascua.precision(_);\n            return reset();\n        };\n        transverseMercatorChile.scale = function (_) {\n            if (!arguments.length) {\n                return mainland.scale();\n            }\n            mainland.scale(_);\n            antarctic.scale(_ * 0.15);\n            juanFernandez.scale(_ * 1.5);\n            pascua.scale(_ * 1.5);\n            return transverseMercatorChile.translate(mainland.translate());\n        };\n        transverseMercatorChile.translate = function (_) {\n            if (!arguments.length) {\n                return mainland.translate();\n            }\n            var k = mainland.scale(), x = +_[0], y = +_[1];\n            /*\n            var c0 = mainland(mainlandBbox[0]);\n           var x0 = (x - c0[0]) / k;\n           var y0 = (y - c0[1]) / k;\n        \n           var c1 = mainland(mainlandBbox[1]);\n           var x1 = (x - c1[0]) / k;\n           var y1 = (y - c1[1]) / k;\n        \n           console.info('Mainland: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           console.info('.clipExtent([[x '+\n            (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n            ' * k, y '+\n            (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n            ' * k],[x '+\n            (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n            ' * k, y '+\n            (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n            ' * k]])');\n        \n           c0 = antarctic.translate([x - 0.1 * k, y + 0.17 * k])(antarcticBbox[0]);\n           x0 = (x - c0[0]) / k;\n           y0 = (y - c0[1]) / k;\n        \n           c1 = antarctic.translate([x - 0.1 * k, y + 0.17 * k])(antarcticBbox[1]);\n           x1 = (x - c1[0]) / k;\n           y1 = (y - c1[1]) / k;\n        \n           console.info('antarctic: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           console.info('Doesn t work due to -90 latitude!' + '.clipExtent([[x '+\n            (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n            ' * k + epsilon, y '+\n            (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n            ' * k + epsilon],[x '+\n            (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n            ' * k - epsilon, y '+\n            (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n            ' * k - epsilon]])');\n        \n            c0 = juanFernandez.translate([x - 0.092 * k, y -0 * k])(juanFernandezBbox[0]);\n            x0 = (x - c0[0]) / k;\n            y0 = (y - c0[1]) / k;\n        \n            c1 = juanFernandez.translate([x - 0.092 * k, y -0 * k])(juanFernandezBbox[1]);\n            x1 = (x - c1[0]) / k;\n            y1 = (y - c1[1]) / k;\n        \n            console.info('juanFernandez: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n            console.info('.clipExtent([[x '+\n             (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n             ' * k + epsilon, y '+\n             (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n             ' * k + epsilon],[x '+\n             (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n             ' * k - epsilon, y '+\n             (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n             ' * k - epsilon]])');\n        \n             c0 = pascua.translate([x - 0.089 * k, y -0.0265 * k])(pascuaBbox[0]);\n             x0 = (x - c0[0]) / k;\n             y0 = (y - c0[1]) / k;\n        \n             c1 = pascua.translate([x - 0.089 * k, y -0.0265 * k])(pascuaBbox[1]);\n             x1 = (x - c1[0]) / k;\n             y1 = (y - c1[1]) / k;\n        \n             console.info('pascua: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n             console.info('.clipExtent([[x '+\n              (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n              ' * k + epsilon, y '+\n              (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n              ' * k + epsilon],[x '+\n              (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n              ' * k - epsilon, y '+\n              (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n              ' * k - epsilon]])');\n              */\n            mainlandPoint = mainland\n                .translate(_)\n                .clipExtent([[x - 0.059 * k, y - 0.3835 * k], [x + 0.4498 * k, y + 0.3375 * k]])\n                .stream(pointStream);\n            antarcticPoint = antarctic\n                .translate([x - 0.087 * k, y + 0.17 * k])\n                .clipExtent([[x - 0.1166 * k + epsilon, y + 0.2582 * k + epsilon], [x - 0.06 * k - epsilon, y + 0.32 * k - epsilon]])\n                .stream(pointStream);\n            juanFernandezPoint = juanFernandez\n                .translate([x - 0.092 * k, y - 0 * k])\n                .clipExtent([[x - 0.114 * k + epsilon, y - 0.013 * k + epsilon], [x - 0.0594 * k - epsilon, y + 0.0133 * k - epsilon]])\n                .stream(pointStream);\n            pascuaPoint = pascua\n                .translate([x - 0.089 * k, y - 0.0265 * k])\n                .clipExtent([[x - 0.089 * k + epsilon, y + 0.0154 * k + epsilon], [x - 0.0588 * k - epsilon, y + 0.0391 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        transverseMercatorChile.fitExtent = function (extent, object) {\n            return fitExtent(transverseMercatorChile, extent, object);\n        };\n        transverseMercatorChile.fitSize = function (size, object) {\n            return fitSize(transverseMercatorChile, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return transverseMercatorChile;\n        }\n        transverseMercatorChile.drawCompositionBorders = function (context) {\n            /*\n            console.info(\"CLIP EXTENT antarctic: \", antarctic.clipExtent());\n            console.info(\"UL BBOX:\", mainland.invert([antarctic.clipExtent()[0][0], antarctic.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", mainland.invert([antarctic.clipExtent()[1][0], antarctic.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", mainland.invert([antarctic.clipExtent()[1][0], antarctic.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", mainland.invert([antarctic.clipExtent()[0][0], antarctic.clipExtent()[1][1]]));\n        \n            console.info(\"CLIP EXTENT juanFernandez: \", juanFernandez.clipExtent());\n            console.info(\"UL BBOX:\", mainland.invert([juanFernandez.clipExtent()[0][0], juanFernandez.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", mainland.invert([juanFernandez.clipExtent()[1][0], juanFernandez.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", mainland.invert([juanFernandez.clipExtent()[1][0], juanFernandez.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", mainland.invert([juanFernandez.clipExtent()[0][0], juanFernandez.clipExtent()[1][1]]));\n        \n            console.info(\"CLIP EXTENT pascua: \", pascua.clipExtent());\n            console.info(\"UL BBOX:\", mainland.invert([pascua.clipExtent()[0][0], pascua.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", mainland.invert([pascua.clipExtent()[1][0], pascua.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", mainland.invert([pascua.clipExtent()[1][0], pascua.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", mainland.invert([pascua.clipExtent()[0][0], pascua.clipExtent()[1][1]]));\n            */\n            var ulantarctic = mainland([-82.6999, -51.3043]);\n            var urantarctic = mainland([-77.5442, -51.6631]);\n            var ldantarctic = mainland([-78.0254, -55.1860]);\n            var llantarctic = mainland([-83.6106, -54.7785]);\n            var uljuanFernandez = mainland([-80.0638, -35.9840]);\n            var urjuanFernandez = mainland([-76.2153, -36.1811]);\n            var ldjuanFernandez = mainland([-76.2994, -37.6839]);\n            var lljuanFernandez = mainland([-80.2231, -37.4757]);\n            var ulpascua = mainland([-78.442, -37.706]);\n            var urpascua = mainland([-76.263, -37.8054]);\n            var ldpascua = mainland([-76.344, -39.1595]);\n            var llpascua = mainland([-78.5638, -39.0559]);\n            context.moveTo(ulantarctic[0], ulantarctic[1]);\n            context.lineTo(urantarctic[0], urantarctic[1]);\n            context.lineTo(ldantarctic[0], ldantarctic[1]);\n            context.lineTo(ldantarctic[0], ldantarctic[1]);\n            context.lineTo(llantarctic[0], llantarctic[1]);\n            context.closePath();\n            context.moveTo(uljuanFernandez[0], uljuanFernandez[1]);\n            context.lineTo(urjuanFernandez[0], urjuanFernandez[1]);\n            context.lineTo(ldjuanFernandez[0], ldjuanFernandez[1]);\n            context.lineTo(ldjuanFernandez[0], ldjuanFernandez[1]);\n            context.lineTo(lljuanFernandez[0], lljuanFernandez[1]);\n            context.closePath();\n            context.moveTo(ulpascua[0], ulpascua[1]);\n            context.lineTo(urpascua[0], urpascua[1]);\n            context.lineTo(ldpascua[0], ldpascua[1]);\n            context.lineTo(ldpascua[0], ldpascua[1]);\n            context.lineTo(llpascua[0], llpascua[1]);\n            context.closePath();\n        };\n        transverseMercatorChile.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return transverseMercatorChile.scale(700);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$6(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for Portugal, configured by default for 960×500.\n    function conicEquidistantJapan() {\n        var cache, cacheStream, mainland = d3Geo.geoConicEquidistant().rotate([-136, -22]).parallels([40, 34]), mainlandPoint, //gis.stackexchange.com/a/73135\n        hokkaido = d3Geo.geoConicEquidistant().rotate([-146, -26]).parallels([40, 34]), hokkaidoPoint, okinawa = d3Geo.geoConicEquidistant().rotate([-126, -19]).parallels([40, 34]), okinawaPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        /*\n        var mainlandBbox = [[126.0, 41.606], [142.97, 29.97]];\n        var hokkaidoBbox = [[138.7, 45.61], [146.2, 41.2]];\n        var okinawaBbox = [[122.6, 29.0], [130, 23.7]];\n        */\n        function conicEquidistantJapan(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (mainlandPoint.point(x, y), point) ||\n                    (hokkaidoPoint.point(x, y), point) ||\n                    (okinawaPoint.point(x, y), point);\n        }\n        conicEquidistantJapan.invert = function (coordinates) {\n            var k = mainland.scale(), t = mainland.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            /*\n            //How are the return values calculated:\n            console.info(\"******\");\n            var c0 = hokkaido(hokkaidoBbox[0]);\n            var x0 = (c0[0] - t[0]) / k;\n            var y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 hokkaido\", x0 + ' - ' + y0);\n    \n            var c1 = hokkaido(hokkaidoBbox[1]);\n            var x1 = (c1[0] - t[0]) / k;\n            var y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 hokkaido\", x1 + ' - ' + y1);\n    \n            c0 = okinawa(okinawaBbox[0]);\n            x0 = (c0[0] - t[0]) / k;\n            y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 okinawa\", x0 + ' - ' + y0);\n    \n            c1 = okinawa(okinawaBbox[1]);\n            x1 = (c1[0] - t[0]) / k;\n            y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 okinawa\", x1 + ' - ' + y1);\n            */\n            return (y >= -0.10925 && y < -0.02701 && x >= -0.135 && x < -0.0397 ? hokkaido\n                : y >= 0.04713 && y < 0.11138 && x >= -0.03986 && x < 0.051 ? okinawa\n                    : mainland).invert(coordinates);\n        };\n        conicEquidistantJapan.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$6([mainland.stream(cacheStream = stream), hokkaido.stream(stream), okinawa.stream(stream)]);\n        };\n        conicEquidistantJapan.precision = function (_) {\n            if (!arguments.length) {\n                return mainland.precision();\n            }\n            mainland.precision(_);\n            hokkaido.precision(_);\n            okinawa.precision(_);\n            return reset();\n        };\n        conicEquidistantJapan.scale = function (_) {\n            if (!arguments.length) {\n                return mainland.scale();\n            }\n            mainland.scale(_);\n            hokkaido.scale(_);\n            okinawa.scale(_ * 0.7);\n            return conicEquidistantJapan.translate(mainland.translate());\n        };\n        conicEquidistantJapan.translate = function (_) {\n            if (!arguments.length) {\n                return mainland.translate();\n            }\n            var k = mainland.scale(), x = +_[0], y = +_[1];\n            /*\n            var c0 = mainland(mainlandBbox[0]);\n           var x0 = (x - c0[0]) / k;\n           var y0 = (y - c0[1]) / k;\n        \n           var c1 = mainland(mainlandBbox[1]);\n           var x1 = (x - c1[0]) / k;\n           var y1 = (y - c1[1]) / k;\n        \n           console.info('Main: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           console.info('.clipExtent([[x '+\n            (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n            ' * k, y '+\n            (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n            ' * k],[x '+\n            (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n            ' * k, y '+\n            (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n            ' * k]])');\n        \n           c0 = hokkaido.translate([x - 0.0425 * k, y - 0.005 * k])(hokkaidoBbox[0]);\n           x0 = (x - c0[0]) / k;\n           y0 = (y - c0[1]) / k;\n        \n           c1 = hokkaido.translate([x - 0.0425 * k, y - 0.005 * k])(hokkaidoBbox[1]);\n           x1 = (x - c1[0]) / k;\n           y1 = (y - c1[1]) / k;\n        \n           console.info('hokkaido: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           console.info('.clipExtent([[x '+\n            (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n            ' * k + epsilon, y '+\n            (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n            ' * k + epsilon],[x '+\n            (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n            ' * k - epsilon, y '+\n            (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n            ' * k - epsilon]])');\n        \n            c0 = okinawa.translate([x - 0 * k, y + 0 * k])(okinawaBbox[0]);\n            x0 = (x - c0[0]) / k;\n            y0 = (y - c0[1]) / k;\n        \n            c1 = okinawa.translate([x - 0 * k, y + 0 * k])(okinawaBbox[1]);\n            x1 = (x - c1[0]) / k;\n            y1 = (y - c1[1]) / k;\n        \n            console.info('okinawa: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n            console.info('.clipExtent([[x '+\n             (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n             ' * k + epsilon, y '+\n             (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n             ' * k + epsilon],[x '+\n             (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n             ' * k - epsilon, y '+\n             (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n             ' * k - epsilon]])');\n             */\n            mainlandPoint = mainland\n                .translate(_)\n                .clipExtent([[x - 0.1352 * k, y - 0.1091 * k], [x + 0.117 * k, y + 0.098 * k]])\n                .stream(pointStream);\n            hokkaidoPoint = hokkaido\n                .translate([x - 0.0425 * k, y - 0.005 * k])\n                .clipExtent([[x - 0.135 * k + epsilon, y - 0.1093 * k + epsilon], [x - 0.0397 * k - epsilon, y - 0.027 * k - epsilon]])\n                .stream(pointStream);\n            okinawaPoint = okinawa\n                .translate(_)\n                .clipExtent([[x - 0.0399 * k + epsilon, y + 0.0471 * k + epsilon], [x + 0.051 * k - epsilon, y + 0.1114 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        conicEquidistantJapan.fitExtent = function (extent, object) {\n            return fitExtent(conicEquidistantJapan, extent, object);\n        };\n        conicEquidistantJapan.fitSize = function (size, object) {\n            return fitSize(conicEquidistantJapan, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return conicEquidistantJapan;\n        }\n        conicEquidistantJapan.drawCompositionBorders = function (context) {\n            /*\n            console.info(\"CLIP EXTENT hokkaido: \", hokkaido.clipExtent());\n            console.info(\"UL BBOX:\", mainland.invert([hokkaido.clipExtent()[0][0], hokkaido.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", mainland.invert([hokkaido.clipExtent()[1][0], hokkaido.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", mainland.invert([hokkaido.clipExtent()[1][0], hokkaido.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", mainland.invert([hokkaido.clipExtent()[0][0], hokkaido.clipExtent()[1][1]]));\n            */\n            var ulhokkaido = mainland([126.01320483689143, 41.621090310215585]);\n            var urhokkaido = mainland([133.04304387025903, 42.15087523707186]);\n            var ldhokkaido = mainland([133.3021766080688, 37.43975444725098]);\n            var llhokkaido = mainland([126.87889168628224, 36.95488945159779]);\n            var llokinawa = mainland([132.9, 29.8]);\n            var lmokinawa = mainland([134, 33]);\n            var lrokinawa = mainland([139.3, 33.2]);\n            var llrokinawa = mainland([139.16, 30.5]);\n            context.moveTo(ulhokkaido[0], ulhokkaido[1]);\n            context.lineTo(urhokkaido[0], urhokkaido[1]);\n            context.lineTo(ldhokkaido[0], ldhokkaido[1]);\n            context.lineTo(llhokkaido[0], llhokkaido[1]);\n            context.closePath();\n            context.moveTo(llokinawa[0], llokinawa[1]);\n            context.lineTo(lmokinawa[0], lmokinawa[1]);\n            context.lineTo(lrokinawa[0], lrokinawa[1]);\n            context.lineTo(llrokinawa[0], llrokinawa[1]);\n        };\n        conicEquidistantJapan.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return conicEquidistantJapan.scale(2200);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$7(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for France, configured by default for 960×500.\n    function conicConformalFrance() {\n        var cache, cacheStream, europe = d3Geo.geoConicConformal().rotate([-3, -46.2]).parallels([0, 60]), europePoint, guyane = d3Geo.geoMercator().center([-53.2, 3.9]), guyanePoint, martinique = d3Geo.geoMercator().center([-61.03, 14.67]), martiniquePoint, guadeloupe = d3Geo.geoMercator().center([-61.46, 16.14]), guadeloupePoint, saintBarthelemy = d3Geo.geoMercator().center([-62.85, 17.92]), saintBarthelemyPoint, stPierreMiquelon = d3Geo.geoMercator().center([-56.23, 46.93]), stPierreMiquelonPoint, mayotte = d3Geo.geoMercator().center([45.16, -12.8]), mayottePoint, reunion = d3Geo.geoMercator().center([55.52, -21.13]), reunionPoint, nouvelleCaledonie = d3Geo.geoMercator().center([165.8, -21.07]), nouvelleCaledoniePoint, wallisFutuna = d3Geo.geoMercator().center([-178.1, -14.3]), wallisFutunaPoint, polynesie = d3Geo.geoMercator().center([-150.55, -17.11]), polynesiePoint, polynesie2 = d3Geo.geoMercator().center([-150.55, -17.11]), polynesie2Point, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        /*\n        var europeBbox = [[-6.5, 51], [10, 41]];\n        var guyaneBbox = [[-54.5, 6.29], [-50.9, 1.48]];\n        */\n        function conicConformalFrance(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (europePoint.point(x, y), point) ||\n                    (guyanePoint.point(x, y), point) ||\n                    (martiniquePoint.point(x, y), point) ||\n                    (guadeloupePoint.point(x, y), point) ||\n                    (saintBarthelemyPoint.point(x, y), point) ||\n                    (stPierreMiquelonPoint.point(x, y), point) ||\n                    (mayottePoint.point(x, y), point) ||\n                    (reunionPoint.point(x, y), point) ||\n                    (nouvelleCaledoniePoint.point(x, y), point) ||\n                    (wallisFutunaPoint.point(x, y), point) ||\n                    (polynesiePoint.point(x, y), point) ||\n                    (polynesie2Point.point(x, y), point);\n        }\n        conicConformalFrance.invert = function (coordinates) {\n            var k = europe.scale(), t = europe.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= 0.029 && y < 0.0864 && x >= -0.14 && x < -0.0996 ? guyane\n                : y >= 0 && y < 0.029 && x >= -0.14 && x < -0.0996 ? martinique\n                    : y >= -0.032 && y < 0 && x >= -0.14 && x < -0.0996 ? guadeloupe\n                        : y >= -0.052 && y < -0.032 && x >= -0.14 && x < -0.0996 ? saintBarthelemy\n                            : y >= -0.076 && y < 0.052 && x >= -0.14 && x < -0.0996 ? stPierreMiquelon\n                                : y >= -0.076 && y < -0.052 && x >= 0.0967 && x < 0.1371 ? mayotte\n                                    : y >= -0.052 && y < -0.02 && x >= 0.0967 && x < 0.1371 ? reunion\n                                        : y >= -0.02 && y < 0.012 && x >= 0.0967 && x < 0.1371 ? nouvelleCaledonie\n                                            : y >= 0.012 && y < 0.033 && x >= 0.0967 && x < 0.1371 ? wallisFutuna\n                                                : y >= 0.033 && y < 0.0864 && x >= 0.0967 && x < 0.1371 ? polynesie\n                                                    : europe).invert(coordinates);\n        };\n        conicConformalFrance.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$7([europe.stream(cacheStream = stream), guyane.stream(stream), martinique.stream(stream), guadeloupe.stream(stream), saintBarthelemy.stream(stream), stPierreMiquelon.stream(stream), mayotte.stream(stream), reunion.stream(stream), nouvelleCaledonie.stream(stream), wallisFutuna.stream(stream), polynesie.stream(stream), polynesie2.stream(stream)]);\n        };\n        conicConformalFrance.precision = function (_) {\n            if (!arguments.length) {\n                return europe.precision();\n            }\n            europe.precision(_);\n            guyane.precision(_);\n            martinique.precision(_);\n            guadeloupe.precision(_);\n            saintBarthelemy.precision(_);\n            stPierreMiquelon.precision(_);\n            mayotte.precision(_);\n            reunion.precision(_);\n            nouvelleCaledonie.precision(_);\n            wallisFutuna.precision(_);\n            polynesie.precision(_);\n            polynesie2.precision(_);\n            return reset();\n        };\n        conicConformalFrance.scale = function (_) {\n            if (!arguments.length) {\n                return europe.scale();\n            }\n            europe.scale(_);\n            guyane.scale(_ * 0.6);\n            martinique.scale(_ * 1.6);\n            guadeloupe.scale(_ * 1.4);\n            saintBarthelemy.scale(_ * 5);\n            stPierreMiquelon.scale(_ * 1.3);\n            mayotte.scale(_ * 1.6);\n            reunion.scale(_ * 1.2);\n            nouvelleCaledonie.scale(_ * 0.3);\n            wallisFutuna.scale(_ * 2.7);\n            polynesie.scale(_ * 0.5);\n            polynesie2.scale(_ * 0.06);\n            return conicConformalFrance.translate(europe.translate());\n        };\n        conicConformalFrance.translate = function (_) {\n            if (!arguments.length) {\n                return europe.translate();\n            }\n            var k = europe.scale(), x = +_[0], y = +_[1];\n            europePoint = europe\n                .translate(_)\n                .clipExtent([[x - 0.0996 * k, y - 0.0908 * k], [x + 0.0967 * k, y + 0.0864 * k]])\n                .stream(pointStream);\n            guyanePoint = guyane\n                .translate([x - 0.12 * k, y + 0.0575 * k])\n                .clipExtent([[x - 0.14 * k + epsilon, y + 0.029 * k + epsilon], [x - 0.0996 * k - epsilon, y + 0.0864 * k - epsilon]])\n                .stream(pointStream);\n            martiniquePoint = martinique\n                .translate([x - 0.12 * k, y + 0.013 * k])\n                .clipExtent([[x - 0.14 * k + epsilon, y + 0 * k + epsilon], [x - 0.0996 * k - epsilon, y + 0.029 * k - epsilon]])\n                .stream(pointStream);\n            guadeloupePoint = guadeloupe\n                .translate([x - 0.12 * k, y - 0.014 * k])\n                .clipExtent([[x - 0.14 * k + epsilon, y - 0.032 * k + epsilon], [x - 0.0996 * k - epsilon, y + 0 * k - epsilon]])\n                .stream(pointStream);\n            saintBarthelemyPoint = saintBarthelemy\n                .translate([x - 0.12 * k, y - 0.044 * k])\n                .clipExtent([[x - 0.14 * k + epsilon, y - 0.052 * k + epsilon], [x - 0.0996 * k - epsilon, y - 0.032 * k - epsilon]])\n                .stream(pointStream);\n            stPierreMiquelonPoint = stPierreMiquelon\n                .translate([x - 0.12 * k, y - 0.065 * k])\n                .clipExtent([[x - 0.14 * k + epsilon, y - 0.076 * k + epsilon], [x - 0.0996 * k - epsilon, y - 0.052 * k - epsilon]])\n                .stream(pointStream);\n            mayottePoint = mayotte\n                .translate([x + 0.117 * k, y - 0.064 * k])\n                .clipExtent([[x + 0.0967 * k + epsilon, y - 0.076 * k + epsilon], [x + 0.1371 * k - epsilon, y - 0.052 * k - epsilon]])\n                .stream(pointStream);\n            reunionPoint = reunion\n                .translate([x + 0.116 * k, y - 0.0355 * k])\n                .clipExtent([[x + 0.0967 * k + epsilon, y - 0.052 * k + epsilon], [x + 0.1371 * k - epsilon, y - 0.02 * k - epsilon]])\n                .stream(pointStream);\n            nouvelleCaledoniePoint = nouvelleCaledonie\n                .translate([x + 0.116 * k, y - 0.0048 * k])\n                .clipExtent([[x + 0.0967 * k + epsilon, y - 0.02 * k + epsilon], [x + 0.1371 * k - epsilon, y + 0.012 * k - epsilon]])\n                .stream(pointStream);\n            wallisFutunaPoint = wallisFutuna\n                .translate([x + 0.116 * k, y + 0.022 * k])\n                .clipExtent([[x + 0.0967 * k + epsilon, y + 0.012 * k + epsilon], [x + 0.1371 * k - epsilon, y + 0.033 * k - epsilon]])\n                .stream(pointStream);\n            polynesie2Point = polynesie2\n                .translate([x + 0.11 * k, y + 0.045 * k])\n                .clipExtent([[x + 0.0967 * k + epsilon, y + 0.033 * k + epsilon], [x + 0.1371 * k - epsilon, y + 0.06 * k - epsilon]])\n                .stream(pointStream);\n            polynesiePoint = polynesie\n                .translate([x + 0.115 * k, y + 0.075 * k])\n                .clipExtent([[x + 0.0967 * k + epsilon, y + 0.06 * k + epsilon], [x + 0.1371 * k - epsilon, y + 0.0864 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        conicConformalFrance.fitExtent = function (extent, object) {\n            return fitExtent(conicConformalFrance, extent, object);\n        };\n        conicConformalFrance.fitSize = function (size, object) {\n            return fitSize(conicConformalFrance, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return conicConformalFrance;\n        }\n        conicConformalFrance.drawCompositionBorders = function (context) {\n            /*\n            console.log(\"var ul, ur, ld, ll;\");\n            var projs = [guyane, martinique, guadeloupe, saintBarthelemy, stPierreMiquelon, mayotte, reunion, nouvelleCaledonie, wallisFutuna, polynesie, polynesie2];\n            for (var i in projs){\n              var ul = europe.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[0][1]]);\n              var ur = europe.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[0][1]]);\n              var ld = europe.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[1][1]]);\n              var ll = europe.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[1][1]]);\n        \n              console.log(\"ul = europe([\"+ul+\"]);\");\n              console.log(\"ur = europe([\"+ur+\"]);\");\n              console.log(\"ld = europe([\"+ld+\"]);\");\n              console.log(\"ll = europe([\"+ll+\"]);\");\n        \n              console.log(\"context.moveTo(ul[0], ul[1]);\");\n              console.log(\"context.lineTo(ur[0], ur[1]);\");\n              console.log(\"context.lineTo(ld[0], ld[1]);\");\n              console.log(\"context.lineTo(ll[0], ll[1]);\");\n              console.log(\"context.closePath();\");\n        \n            }*/\n            var ul, ur, ld, ll;\n            ul = europe([-7.938886725111036, 43.7219460918835]);\n            ur = europe([-4.832080896458295, 44.12930268549372]);\n            ld = europe([-4.205299743793263, 40.98096346967365]);\n            ll = europe([-7.071796453126152, 40.610037319181444]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([-8.42751373617692, 45.32889452553031]);\n            ur = europe([-5.18599305777107, 45.7566442062976]);\n            ld = europe([-4.832080905154431, 44.129302726751426]);\n            ll = europe([-7.938886737126192, 43.72194613263854]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([-9.012656899657046, 47.127733821030176]);\n            ur = europe([-5.6105244772793155, 47.579777861410626]);\n            ld = europe([-5.185993067168585, 45.756644248170346]);\n            ll = europe([-8.427513749141811, 45.32889456686326]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([-9.405747558985553, 48.26506375557457]);\n            ur = europe([-5.896175018439575, 48.733352850851624]);\n            ld = europe([-5.610524487556043, 47.57977790393761]);\n            ll = europe([-9.012656913808351, 47.127733862971255]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([-9.908436061346974, 49.642448789505856]);\n            ur = europe([-6.262026716233124, 50.131426841787174]);\n            ld = europe([-5.896175029331232, 48.73335289377258]);\n            ll = europe([-9.40574757396393, 48.26506379787767]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([11.996907706504462, 50.16039028163579]);\n            ur = europe([15.649907879773343, 49.68279246765253]);\n            ld = europe([15.156712840526632, 48.30371557625831]);\n            ll = europe([11.64122661754411, 48.761078240546816]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([11.641226606955788, 48.7610781975889]);\n            ur = europe([15.156712825832164, 48.30371553390465]);\n            ld = europe([14.549932166241172, 46.4866532486199]);\n            ll = europe([11.204443787952183, 46.91899233914248]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([11.204443778297161, 46.918992296823646]);\n            ur = europe([14.549932152815039, 46.486653206856396]);\n            ld = europe([13.994409796764009, 44.695833444323256]);\n            ll = europe([10.805306599253848, 45.105133870684924]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([10.805306590412085, 45.10513382903308]);\n            ur = europe([13.99440978444733, 44.695833403183606]);\n            ld = europe([13.654633799024392, 43.53552468558152]);\n            ll = europe([10.561516803980956, 43.930671459798624]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([10.561516795617383, 43.93067141859757]);\n            ur = europe([13.654633787361952, 43.5355246448671]);\n            ld = europe([12.867691604239901, 40.640701985019405]);\n            ll = europe([9.997809515987688, 41.00288343254471]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([10.8, 42.4]);\n            ur = europe([12.8, 42.13]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n        };\n        conicConformalFrance.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return conicConformalFrance.scale(2700);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$8(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for Portugal, configured by default for 960×500.\n    function conicConformalEurope() {\n        var cache, cacheStream, europe = d3Geo.geoConicConformal().rotate([-10, -53]).parallels([0, 60]), europePoint, guadeloupe = d3Geo.geoMercator().center([-61.46, 16.14]), guadeloupePoint, guyane = d3Geo.geoMercator().center([-53.2, 3.9]), guyanePoint, azores = d3Geo.geoConicConformal().rotate([27.8, -38.9]).parallels([0, 60]), azoresPoint, azores2 = d3Geo.geoConicConformal().rotate([25.43, -37.398]).parallels([0, 60]), azores2Point, azores3 = d3Geo.geoConicConformal().rotate([31.17, -39.539]).parallels([0, 60]), azores3Point, madeira = d3Geo.geoConicConformal().rotate([17, -32.7]).parallels([0, 60]), madeiraPoint, canaryIslands = d3Geo.geoConicConformal().rotate([16, -28.5]).parallels([0, 60]), canaryIslandsPoint, martinique = d3Geo.geoMercator().center([-61.03, 14.67]), martiniquePoint, mayotte = d3Geo.geoMercator().center([45.16, -12.8]), mayottePoint, reunion = d3Geo.geoMercator().center([55.52, -21.13]), reunionPoint, malta = d3Geo.geoConicConformal().rotate([-14.4, -35.95]).parallels([0, 60]), maltaPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        /*\n        var europeBbox = [[-6.5, 51], [10, 41]];\n        var guyaneBbox = [[-54.5, 6.29], [-50.9, 1.48]];\n        */\n        function conicConformalEurope(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (europePoint.point(x, y), point) ||\n                    (guyanePoint.point(x, y), point) ||\n                    (martiniquePoint.point(x, y), point) ||\n                    (guadeloupePoint.point(x, y), point) ||\n                    (canaryIslandsPoint.point(x, y), point) ||\n                    (madeiraPoint.point(x, y), point) ||\n                    (mayottePoint.point(x, y), point) ||\n                    (reunionPoint.point(x, y), point) ||\n                    (maltaPoint.point(x, y), point) ||\n                    (azoresPoint.point(x, y), point) ||\n                    (azores2Point.point(x, y), point) ||\n                    (azores3Point.point(x, y), point);\n        }\n        conicConformalEurope.invert = function (coordinates) {\n            var k = europe.scale(), t = europe.translate(), x = (coordinates[0] - (t[0] + 0.08 * k)) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= -0.31 && y < -0.24 && x >= 0.14 && x < 0.24 ? guadeloupe\n                : y >= -0.24 && y < -0.17 && x >= 0.14 && x < 0.24 ? guyane\n                    : y >= -0.17 && y < -0.12 && x >= 0.21 && x < 0.24 ? azores2\n                        : y >= -0.17 && y < -0.14 && x >= 0.14 && x < 0.165 ? azores3\n                            : y >= -0.17 && y < -0.1 && x >= 0.14 && x < 0.24 ? azores\n                                : y >= -0.1 && y < -0.03 && x >= 0.14 && x < 0.24 ? madeira\n                                    : y >= -0.03 && y < 0.04 && x >= 0.14 && x < 0.24 ? canaryIslands\n                                        : y >= -0.31 && y < -0.24 && x >= 0.24 && x < 0.34 ? martinique\n                                            : y >= -0.24 && y < -0.17 && x >= 0.24 && x < 0.34 ? mayotte\n                                                : y >= -0.17 && y < -0.1 && x >= 0.24 && x < 0.34 ? reunion\n                                                    : y >= -0.1 && y < -0.03 && x >= 0.24 && x < 0.34 ? malta\n                                                        : europe).invert(coordinates);\n        };\n        conicConformalEurope.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$8([europe.stream(cacheStream = stream), guyane.stream(stream), martinique.stream(stream), guadeloupe.stream(stream), canaryIslands.stream(stream), madeira.stream(stream), mayotte.stream(stream), reunion.stream(stream), malta.stream(stream), azores.stream(stream), azores2.stream(stream), azores3.stream(stream)]);\n        };\n        conicConformalEurope.precision = function (_) {\n            if (!arguments.length) {\n                return europe.precision();\n            }\n            europe.precision(_);\n            guyane.precision(_);\n            martinique.precision(_);\n            guadeloupe.precision(_);\n            canaryIslands.precision(_);\n            madeira.precision(_);\n            mayotte.precision(_);\n            reunion.precision(_);\n            malta.precision(_);\n            azores.precision(_);\n            azores2.precision(_);\n            azores3.precision(_);\n            return reset();\n        };\n        conicConformalEurope.scale = function (_) {\n            if (!arguments.length) {\n                return europe.scale();\n            }\n            europe.scale(_);\n            guadeloupe.scale(_ * 3);\n            guyane.scale(_ * 0.8);\n            martinique.scale(_ * 3.5);\n            reunion.scale(_ * 2.7);\n            azores.scale(_ * 2);\n            azores2.scale(_ * 2);\n            azores3.scale(_ * 2);\n            madeira.scale(_ * 3);\n            canaryIslands.scale(_);\n            mayotte.scale(_ * 5.5);\n            malta.scale(_ * 6);\n            return conicConformalEurope.translate(europe.translate());\n        };\n        conicConformalEurope.translate = function (_) {\n            if (!arguments.length) {\n                return europe.translate();\n            }\n            var k = europe.scale(), x = +_[0], y = +_[1];\n            europePoint = europe\n                .translate([x - 0.08 * k, y])\n                .clipExtent([[x - 0.51 * k, y - 0.33 * k], [x + 0.5 * k, y + 0.33 * k]])\n                .stream(pointStream);\n            guadeloupePoint = guadeloupe\n                .translate([x + 0.19 * k, y - 0.275 * k])\n                .clipExtent([[x + 0.14 * k + epsilon, y - 0.31 * k + epsilon], [x + 0.24 * k - epsilon, y - 0.24 * k - epsilon]])\n                .stream(pointStream);\n            guyanePoint = guyane\n                .translate([x + 0.19 * k, y - 0.205 * k])\n                .clipExtent([[x + 0.14 * k + epsilon, y - 0.24 * k + epsilon], [x + 0.24 * k - epsilon, y - 0.17 * k - epsilon]])\n                .stream(pointStream);\n            azoresPoint = azores\n                .translate([x + 0.19 * k, y - 0.135 * k])\n                .clipExtent([[x + 0.14 * k + epsilon, y - 0.17 * k + epsilon], [x + 0.24 * k - epsilon, y - 0.1 * k - epsilon]])\n                .stream(pointStream);\n            azores2Point = azores2\n                .translate([x + 0.225 * k, y - 0.147 * k])\n                .clipExtent([[x + 0.21 * k + epsilon, y - 0.17 * k + epsilon], [x + 0.24 * k - epsilon, y - 0.12 * k - epsilon]])\n                .stream(pointStream);\n            azores3Point = azores3\n                .translate([x + 0.153 * k, y - 0.15 * k])\n                .clipExtent([[x + 0.14 * k + epsilon, y - 0.17 * k + epsilon], [x + 0.165 * k - epsilon, y - 0.14 * k - epsilon]])\n                .stream(pointStream);\n            madeiraPoint = madeira\n                .translate([x + 0.19 * k, y - 0.065 * k])\n                .clipExtent([[x + 0.14 * k + epsilon, y - 0.1 * k + epsilon], [x + 0.24 * k - epsilon, y - 0.03 * k - epsilon]])\n                .stream(pointStream);\n            canaryIslandsPoint = canaryIslands\n                .translate([x + 0.19 * k, y + 0.005 * k])\n                .clipExtent([[x + 0.14 * k + epsilon, y - 0.03 * k + epsilon], [x + 0.24 * k - epsilon, y + 0.04 * k - epsilon]])\n                .stream(pointStream);\n            martiniquePoint = martinique\n                .translate([x + 0.29 * k, y - 0.275 * k])\n                .clipExtent([[x + 0.24 * k + epsilon, y - 0.31 * k + epsilon], [x + 0.34 * k - epsilon, y - 0.24 * k - epsilon]])\n                .stream(pointStream);\n            mayottePoint = mayotte\n                .translate([x + 0.29 * k, y - 0.205 * k])\n                .clipExtent([[x + 0.24 * k + epsilon, y - 0.24 * k + epsilon], [x + 0.34 * k - epsilon, y - 0.17 * k - epsilon]])\n                .stream(pointStream);\n            reunionPoint = reunion\n                .translate([x + 0.29 * k, y - 0.135 * k])\n                .clipExtent([[x + 0.24 * k + epsilon, y - 0.17 * k + epsilon], [x + 0.34 * k - epsilon, y - 0.1 * k - epsilon]])\n                .stream(pointStream);\n            maltaPoint = malta\n                .translate([x + 0.29 * k, y - 0.065 * k])\n                .clipExtent([[x + 0.24 * k + epsilon, y - 0.1 * k + epsilon], [x + 0.34 * k - epsilon, y - 0.03 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        conicConformalEurope.fitExtent = function (extent, object) {\n            return fitExtent(conicConformalEurope, extent, object);\n        };\n        conicConformalEurope.fitSize = function (size, object) {\n            return fitSize(conicConformalEurope, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return conicConformalEurope;\n        }\n        conicConformalEurope.drawCompositionBorders = function (context) {\n            /*\n            console.log(\"var ul, ur, ld, ll;\");\n            var projs = [guyane, martinique, guadeloupe, canaryIslands, madeira, mayotte, reunion, malta, azores, azores2, azores3];\n            for (var i in projs){\n              var ul = europe.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[0][1]]);\n              var ur = europe.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[0][1]]);\n              var ld = europe.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[1][1]]);\n              var ll = europe.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[1][1]]);\n        \n              console.log(\"ul = europe([\"+ul+\"]);\");\n              console.log(\"ur = europe([\"+ur+\"]);\");\n              console.log(\"ld = europe([\"+ld+\"]);\");\n              console.log(\"ll = europe([\"+ll+\"]);\");\n        \n              console.log(\"context.moveTo(ul[0], ul[1]);\");\n              console.log(\"context.lineTo(ur[0], ur[1]);\");\n              console.log(\"context.lineTo(ld[0], ld[1]);\");\n              console.log(\"context.lineTo(ll[0], ll[1]);\");\n              console.log(\"context.closePath();\");\n        \n            }*/\n            var ul, ur, ld, ll;\n            ul = europe([42.45755610828648, 63.343658547914934]);\n            ur = europe([52.65837266667029, 59.35045080290929]);\n            ld = europe([47.19754502247785, 56.12653496548117]);\n            ll = europe([37.673034273363044, 59.61638268506111]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([59.41110754003403, 62.35069727399336]);\n            ur = europe([66.75050228640794, 57.11797303636038]);\n            ld = europe([60.236065725110436, 54.63331433818992]);\n            ll = europe([52.65837313153311, 59.350450804599355]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([48.81091130080243, 66.93353402634641]);\n            ur = europe([59.41110730654679, 62.35069740653086]);\n            ld = europe([52.6583728974441, 59.3504509222445]);\n            ll = europe([42.45755631675751, 63.34365868805821]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([31.054198418446475, 52.1080673766184]);\n            ur = europe([39.09869284884117, 49.400700047190554]);\n            ld = europe([36.0580811499175, 46.02944174908498]);\n            ll = europe([28.690508588835726, 48.433126979386415]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([33.977877745912025, 55.849945501331]);\n            ur = europe([42.75328432167726, 52.78455122462353]);\n            ld = europe([39.09869297540224, 49.400700176148625]);\n            ll = europe([31.05419851807008, 52.10806751810923]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([52.658372900759296, 59.35045068526415]);\n            ur = europe([60.23606549583304, 54.63331423800264]);\n            ld = europe([54.6756370953122, 51.892298789399455]);\n            ll = europe([47.19754524788189, 56.126534861222794]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([47.19754506082455, 56.126534735591456]);\n            ur = europe([54.675636900123514, 51.892298681337095]);\n            ld = europe([49.94448648951486, 48.98775484983285]);\n            ll = europe([42.75328468716108, 52.78455126060818]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([42.75328453416769, 52.78455113209101]);\n            ur = europe([49.94448632339758, 48.98775473706457]);\n            ld = europe([45.912339990394315, 45.99361784987003]);\n            ll = europe([39.09869317356607, 49.40070009378711]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([37.673034114296634, 59.61638254183119]);\n            ur = europe([47.197544835420544, 56.126534839849846]);\n            ld = europe([42.75328447467064, 52.78455135314068]);\n            ll = europe([33.977877870363905, 55.849945644671145]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([44.56748486446032, 57.26489367845818]);\n            ld = europe([43.9335791193588, 53.746540942601726]);\n            ll = europe([43, 56]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([37.673034114296634, 59.61638254183119]);\n            ur = europe([40.25902691953466, 58.83002044222639]);\n            ld = europe([38.458270492742024, 57.26232178028002]);\n            ll = europe([35.97754948030156, 58.00266637992386]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n        };\n        conicConformalEurope.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return conicConformalEurope.scale(750);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$9(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for Malaysia, configured by default for 960×500.\n    function mercatorMalaysia() {\n        var cache, cacheStream, peninsular = d3Geo.geoMercator().center([105.25, 4.00]), peninsularPoint, borneo = d3Geo.geoMercator().center([118.65, 2.86]), borneoPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        function mercatorMalaysia(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (peninsularPoint.point(x, y), point) ||\n                    (borneoPoint.point(x, y), point);\n        }\n        mercatorMalaysia.invert = function (coordinates) {\n            var k = peninsular.scale(), t = peninsular.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= -0.0521 && y < 0.0229 && x >= -0.0111 && x < 0.1000 ? borneo\n                : peninsular).invert(coordinates);\n        };\n        mercatorMalaysia.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$9([peninsular.stream(cacheStream = stream), borneo.stream(stream)]);\n        };\n        mercatorMalaysia.precision = function (_) {\n            if (!arguments.length) {\n                return peninsular.precision();\n            }\n            peninsular.precision(_);\n            borneo.precision(_);\n            return reset();\n        };\n        mercatorMalaysia.scale = function (_) {\n            if (!arguments.length) {\n                return peninsular.scale();\n            }\n            peninsular.scale(_);\n            borneo.scale(_ * 0.615);\n            return mercatorMalaysia.translate(peninsular.translate());\n        };\n        mercatorMalaysia.translate = function (_) {\n            if (!arguments.length) {\n                return peninsular.translate();\n            }\n            var k = peninsular.scale(), x = +_[0], y = +_[1];\n            peninsularPoint = peninsular\n                .translate(_)\n                .clipExtent([[x - 0.1100 * k, y - 0.0521 * k], [x - 0.0111 * k, y + 0.0521 * k]])\n                .stream(pointStream);\n            borneoPoint = borneo\n                .translate([x + 0.09000 * k, y - 0.00 * k])\n                .clipExtent([[x - 0.0111 * k + epsilon, y - 0.0521 * k + epsilon], [x + 0.1000 * k - epsilon, y + 0.024 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        mercatorMalaysia.fitExtent = function (extent, object) {\n            return fitExtent(mercatorMalaysia, extent, object);\n        };\n        mercatorMalaysia.fitSize = function (size, object) {\n            return fitSize(mercatorMalaysia, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return mercatorMalaysia;\n        }\n        mercatorMalaysia.drawCompositionBorders = function (context) {\n            var llbor = peninsular([106.3214, 2.0228]);\n            var lmbor = peninsular([105.1843, 2.3761]);\n            var lrbor = peninsular([104.2151, 3.3618]);\n            var llrbor = peninsular([104.2150, 4.5651]);\n            context.moveTo(llbor[0], llbor[1]);\n            context.lineTo(lmbor[0], lmbor[1]);\n            context.lineTo(lrbor[0], lrbor[1]);\n            context.lineTo(llrbor[0], llrbor[1]);\n        };\n        mercatorMalaysia.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return mercatorMalaysia.scale(4800);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$a(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for Equatorial Guinea, configured by default for 960×500.\n    function mercatorEquatorialGuinea() {\n        var cache, cacheStream, continent = d3Geo.geoMercator().rotate([-9.5, -1.5]), continentPoint, bioko = d3Geo.geoMercator().rotate([-8.6, -3.5]), biokoPoint, annobon = d3Geo.geoMercator().rotate([-5.6, 1.45]), annobonPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        function mercatorEquatorialGuinea(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (continentPoint.point(x, y), point) ||\n                    (biokoPoint.point(x, y), point) ||\n                    (annobonPoint.point(x, y), point);\n        }\n        mercatorEquatorialGuinea.invert = function (coordinates) {\n            var k = continent.scale(), t = continent.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= -0.02 && y < 0 && x >= -0.038 && x < -0.005 ? bioko\n                : y >= 0 && y < 0.02 && x >= -0.038 && x < -0.005 ? annobon\n                    : continent).invert(coordinates);\n        };\n        mercatorEquatorialGuinea.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$a([continent.stream(cacheStream = stream), bioko.stream(stream), annobon.stream(stream)]);\n        };\n        mercatorEquatorialGuinea.precision = function (_) {\n            if (!arguments.length) {\n                return continent.precision();\n            }\n            continent.precision(_);\n            bioko.precision(_);\n            annobon.precision(_);\n            return reset();\n        };\n        mercatorEquatorialGuinea.scale = function (_) {\n            if (!arguments.length) {\n                return continent.scale();\n            }\n            continent.scale(_);\n            bioko.scale(_ * 1.5);\n            annobon.scale(_ * 4);\n            return mercatorEquatorialGuinea.translate(continent.translate());\n        };\n        mercatorEquatorialGuinea.translate = function (_) {\n            if (!arguments.length) {\n                return continent.translate();\n            }\n            var k = continent.scale(), x = +_[0], y = +_[1];\n            continentPoint = continent\n                .translate(_)\n                .clipExtent([[x - 0.005 * k, y - 0.02 * k], [x + 0.038 * k, y + 0.02 * k]])\n                .stream(pointStream);\n            biokoPoint = bioko\n                .translate([x - 0.025 * k, y - 0.01 * k])\n                .clipExtent([[x - 0.038 * k + epsilon, y - 0.02 * k + epsilon], [x - 0.005 * k - epsilon, y + 0 * k - epsilon]])\n                .stream(pointStream);\n            annobonPoint = annobon\n                .translate([x - 0.025 * k, y + 0.01 * k])\n                .clipExtent([[x - 0.038 * k + epsilon, y - 0 * k + epsilon], [x - 0.005 * k - epsilon, y + 0.02 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        mercatorEquatorialGuinea.fitExtent = function (extent, object) {\n            return fitExtent(mercatorEquatorialGuinea, extent, object);\n        };\n        mercatorEquatorialGuinea.fitSize = function (size, object) {\n            return fitSize(mercatorEquatorialGuinea, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return mercatorEquatorialGuinea;\n        }\n        mercatorEquatorialGuinea.drawCompositionBorders = function (context) {\n            /*\n            console.log(\"var ul, ur, ld, ll;\");\n            var projs = [continent, bioko, annobon];\n            for (var i in projs){\n              var ul = continent.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[0][1]]);\n              var ur = continent.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[0][1]]);\n              var ld = continent.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[1][1]]);\n              var ll = continent.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[1][1]]);\n        \n              console.log(\"ul = continent([\"+ul+\"]);\");\n              console.log(\"ur = continent([\"+ur+\"]);\");\n              console.log(\"ld = continent([\"+ld+\"]);\");\n              console.log(\"ll = continent([\"+ll+\"]);\");\n        \n              console.log(\"context.moveTo(ul[0], ul[1]);\");\n              console.log(\"context.lineTo(ur[0], ur[1]);\");\n              console.log(\"context.lineTo(ld[0], ld[1]);\");\n              console.log(\"context.lineTo(ll[0], ll[1]);\");\n              console.log(\"context.closePath();\");\n        \n            }*/\n            var ul, ur, ld, ll;\n            ul = continent([9.21327272751682, 2.645820439454123]);\n            ur = continent([11.679126293239872, 2.644755519268689]);\n            ld = continent([11.676845389029227, 0.35307824637606433]);\n            ll = continent([9.213572917774014, 0.35414205204417754]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = continent([7.320873711543669, 2.64475551449975]);\n            ur = continent([9.213272722738658, 2.645820434679803]);\n            ld = continent([9.213422896480349, 1.4999812505283054]);\n            ll = continent([7.322014760520787, 1.4989168878985566]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = continent([7.3220147605302905, 1.4989168783492766]);\n            ur = continent([9.213422896481598, 1.499981240979021]);\n            ld = continent([9.213572912999604, 0.354142056817247]);\n            ll = continent([7.323154615739809, 0.353078251154504]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n        };\n        mercatorEquatorialGuinea.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return mercatorEquatorialGuinea.scale(12000);\n    }\n    function multiplex$b(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) {\n                var i = -1;\n                while (++i < n)\n                    streams[i].point(x, y);\n            },\n            sphere: function () {\n                var i = -1;\n                while (++i < n)\n                    streams[i].sphere();\n            },\n            lineStart: function () {\n                var i = -1;\n                while (++i < n)\n                    streams[i].lineStart();\n            },\n            lineEnd: function () {\n                var i = -1;\n                while (++i < n)\n                    streams[i].lineEnd();\n            },\n            polygonStart: function () {\n                var i = -1;\n                while (++i < n)\n                    streams[i].polygonStart();\n            },\n            polygonEnd: function () {\n                var i = -1;\n                while (++i < n)\n                    streams[i].polygonEnd();\n            }\n        };\n    }\n    function albersUk() {\n        var cache, cacheStream, main = d3Geo.geoAlbers()\n            .rotate([4.4, 0.8])\n            .center([0, 55.4])\n            .parallels([50, 60]), mainPoint, shetland = d3Geo.geoAlbers()\n            .rotate([4.4, 0.8])\n            .center([0, 55.4])\n            .parallels([50, 60]), shetlandPoint, point, pointStream = {\n            point: function (x, y) {\n                point = [x, y];\n            }\n        };\n        function albersUk(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return ((point = null),\n                (mainPoint.point(x, y), point) || (shetlandPoint.point(x, y), point));\n        }\n        albersUk.invert = function (coordinates) {\n            var k = main.scale(), t = main.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= -0.089 && y < 0.06 && x >= 0.029 && x < 0.046\n                ? shetland\n                : main).invert(coordinates);\n        };\n        albersUk.stream = function (stream) {\n            return cache && cacheStream === stream\n                ? cache\n                : (cache = multiplex$b([\n                    main.stream((cacheStream = stream)),\n                    shetland.stream(stream)\n                ]));\n        };\n        albersUk.precision = function (_) {\n            if (!arguments.length)\n                return main.precision();\n            main.precision(_), shetland.precision(_);\n            return reset();\n        };\n        albersUk.scale = function (_) {\n            if (!arguments.length)\n                return main.scale();\n            main.scale(_), shetland.scale(_);\n            return albersUk.translate(main.translate());\n        };\n        albersUk.translate = function (_) {\n            if (!arguments.length)\n                return main.translate();\n            var k = main.scale(), x = +_[0], y = +_[1];\n            mainPoint = main\n                .translate(_)\n                .clipExtent([\n                [x - 0.065 * k, y - 0.089 * k],\n                [x + 0.075 * k, y + 0.089 * k]\n            ])\n                .stream(pointStream);\n            shetlandPoint = shetland\n                .translate([x + 0.01 * k, y + 0.025 * k])\n                .clipExtent([\n                [x + 0.029 * k + epsilon, y - 0.089 * k + epsilon],\n                [x + 0.046 * k - epsilon, y - 0.06 * k - epsilon]\n            ])\n                .stream(pointStream);\n            return reset();\n        };\n        albersUk.fitExtent = function (extent, object) {\n            return fitExtent(albersUk, extent, object);\n        };\n        albersUk.fitSize = function (size, object) {\n            return fitSize(albersUk, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return albersUk;\n        }\n        albersUk.drawCompositionBorders = function (context) {\n            /*var ul = main.invert([\n              shetland.clipExtent()[0][0],\n              shetland.clipExtent()[0][1]\n            ]);\n            var ur = main.invert([\n              shetland.clipExtent()[1][0],\n              shetland.clipExtent()[0][1]\n            ]);\n            var ld = main.invert([\n              shetland.clipExtent()[1][0],\n              shetland.clipExtent()[1][1]\n            ]);\n            var ll = main.invert([\n              shetland.clipExtent()[0][0],\n              shetland.clipExtent()[1][1]\n            ]);\n        \n            console.log(\"ul = main([\" + ul + \"]);\");\n            console.log(\"ur = main([\" + ur + \"]);\");\n            console.log(\"ld = main([\" + ld + \"]);\");\n            console.log(\"ll = main([\" + ll + \"]);\");\n        \n            console.log(\"context.moveTo(ul[0], ul[1]);\");\n            console.log(\"context.lineTo(ur[0], ur[1]);\");\n            console.log(\"context.lineTo(ld[0], ld[1]);\");\n            console.log(\"context.lineTo(ll[0], ll[1]);\");\n            console.log(\"context.closePath();\");*/\n            var ul, ur, ld, ll;\n            ul = main([-1.113205870242365, 59.64920050773357]);\n            ur = main([0.807899092399606, 59.59085836472269]);\n            ld = main([0.5778611961420386, 57.93467822832577]);\n            ll = main([-1.25867782078448, 57.99029450085142]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n        };\n        albersUk.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return albersUk.scale(2800);\n    }\n    exports.geoAlbersUk = albersUk;\n    exports.geoAlbersUsa = albersUsa;\n    exports.geoAlbersUsaTerritories = albersUsaTerritories;\n    exports.geoConicConformalEurope = conicConformalEurope;\n    exports.geoConicConformalFrance = conicConformalFrance;\n    exports.geoConicConformalPortugal = conicConformalPortugal;\n    exports.geoConicConformalSpain = conicConformalSpain;\n    exports.geoConicEquidistantJapan = conicEquidistantJapan;\n    exports.geoMercatorEcuador = mercatorEcuador;\n    exports.geoMercatorEquatorialGuinea = mercatorEquatorialGuinea;\n    exports.geoMercatorMalaysia = mercatorMalaysia;\n    exports.geoTransverseMercatorChile = transverseMercatorChile;\n    Object.defineProperty(exports, '__esModule', { value: true });\n})));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-dsv@1.2.0@d3-dsv/dist/d3-dsv.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_d3-dsv@1.2.0@d3-dsv/dist/d3-dsv.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-dsv/ v1.2.0 Copyright 2019 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports) :\n        undefined;\n}(this, function (exports) {\n    'use strict';\n    var EOL = {}, EOF = {}, QUOTE = 34, NEWLINE = 10, RETURN = 13;\n    function objectConverter(columns) {\n        return new Function(\"d\", \"return {\" + columns.map(function (name, i) {\n            return JSON.stringify(name) + \": d[\" + i + \"] || \\\"\\\"\";\n        }).join(\",\") + \"}\");\n    }\n    function customConverter(columns, f) {\n        var object = objectConverter(columns);\n        return function (row, i) {\n            return f(object(row), i, columns);\n        };\n    }\n    // Compute unique columns in order of discovery.\n    function inferColumns(rows) {\n        var columnSet = Object.create(null), columns = [];\n        rows.forEach(function (row) {\n            for (var column in row) {\n                if (!(column in columnSet)) {\n                    columns.push(columnSet[column] = column);\n                }\n            }\n        });\n        return columns;\n    }\n    function pad(value, width) {\n        var s = value + \"\", length = s.length;\n        return length < width ? new Array(width - length + 1).join(0) + s : s;\n    }\n    function formatYear(year) {\n        return year < 0 ? \"-\" + pad(-year, 6)\n            : year > 9999 ? \"+\" + pad(year, 6)\n                : pad(year, 4);\n    }\n    function formatDate(date) {\n        var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();\n        return isNaN(date) ? \"Invalid Date\"\n            : formatYear(date.getUTCFullYear()) + \"-\" + pad(date.getUTCMonth() + 1, 2) + \"-\" + pad(date.getUTCDate(), 2)\n                + (milliseconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \".\" + pad(milliseconds, 3) + \"Z\"\n                    : seconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \"Z\"\n                        : minutes || hours ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \"Z\"\n                            : \"\");\n    }\n    function dsv(delimiter) {\n        var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"), DELIMITER = delimiter.charCodeAt(0);\n        function parse(text, f) {\n            var convert, columns, rows = parseRows(text, function (row, i) {\n                if (convert)\n                    return convert(row, i - 1);\n                columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n            });\n            rows.columns = columns || [];\n            return rows;\n        }\n        function parseRows(text, f) {\n            var rows = [], // output rows\n            N = text.length, I = 0, // current character index\n            n = 0, // current line number\n            t, // current token\n            eof = N <= 0, // current token followed by EOF?\n            eol = false; // current token followed by EOL?\n            // Strip the trailing newline.\n            if (text.charCodeAt(N - 1) === NEWLINE)\n                --N;\n            if (text.charCodeAt(N - 1) === RETURN)\n                --N;\n            function token() {\n                if (eof)\n                    return EOF;\n                if (eol)\n                    return eol = false, EOL;\n                // Unescape quotes.\n                var i, j = I, c;\n                if (text.charCodeAt(j) === QUOTE) {\n                    while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE)\n                        ;\n                    if ((i = I) >= N)\n                        eof = true;\n                    else if ((c = text.charCodeAt(I++)) === NEWLINE)\n                        eol = true;\n                    else if (c === RETURN) {\n                        eol = true;\n                        if (text.charCodeAt(I) === NEWLINE)\n                            ++I;\n                    }\n                    return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n                }\n                // Find next delimiter or newline.\n                while (I < N) {\n                    if ((c = text.charCodeAt(i = I++)) === NEWLINE)\n                        eol = true;\n                    else if (c === RETURN) {\n                        eol = true;\n                        if (text.charCodeAt(I) === NEWLINE)\n                            ++I;\n                    }\n                    else if (c !== DELIMITER)\n                        continue;\n                    return text.slice(j, i);\n                }\n                // Return last token before EOF.\n                return eof = true, text.slice(j, N);\n            }\n            while ((t = token()) !== EOF) {\n                var row = [];\n                while (t !== EOL && t !== EOF)\n                    row.push(t), t = token();\n                if (f && (row = f(row, n++)) == null)\n                    continue;\n                rows.push(row);\n            }\n            return rows;\n        }\n        function preformatBody(rows, columns) {\n            return rows.map(function (row) {\n                return columns.map(function (column) {\n                    return formatValue(row[column]);\n                }).join(delimiter);\n            });\n        }\n        function format(rows, columns) {\n            if (columns == null)\n                columns = inferColumns(rows);\n            return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join(\"\\n\");\n        }\n        function formatBody(rows, columns) {\n            if (columns == null)\n                columns = inferColumns(rows);\n            return preformatBody(rows, columns).join(\"\\n\");\n        }\n        function formatRows(rows) {\n            return rows.map(formatRow).join(\"\\n\");\n        }\n        function formatRow(row) {\n            return row.map(formatValue).join(delimiter);\n        }\n        function formatValue(value) {\n            return value == null ? \"\"\n                : value instanceof Date ? formatDate(value)\n                    : reFormat.test(value += \"\") ? \"\\\"\" + value.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n                        : value;\n        }\n        return {\n            parse: parse,\n            parseRows: parseRows,\n            format: format,\n            formatBody: formatBody,\n            formatRows: formatRows,\n            formatRow: formatRow,\n            formatValue: formatValue\n        };\n    }\n    var csv = dsv(\",\");\n    var csvParse = csv.parse;\n    var csvParseRows = csv.parseRows;\n    var csvFormat = csv.format;\n    var csvFormatBody = csv.formatBody;\n    var csvFormatRows = csv.formatRows;\n    var csvFormatRow = csv.formatRow;\n    var csvFormatValue = csv.formatValue;\n    var tsv = dsv(\"\\t\");\n    var tsvParse = tsv.parse;\n    var tsvParseRows = tsv.parseRows;\n    var tsvFormat = tsv.format;\n    var tsvFormatBody = tsv.formatBody;\n    var tsvFormatRows = tsv.formatRows;\n    var tsvFormatRow = tsv.formatRow;\n    var tsvFormatValue = tsv.formatValue;\n    function autoType(object) {\n        for (var key in object) {\n            var value = object[key].trim(), number, m;\n            if (!value)\n                value = null;\n            else if (value === \"true\")\n                value = true;\n            else if (value === \"false\")\n                value = false;\n            else if (value === \"NaN\")\n                value = NaN;\n            else if (!isNaN(number = +value))\n                value = number;\n            else if (m = value.match(/^([-+]\\d{2})?\\d{4}(-\\d{2}(-\\d{2})?)?(T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[-+]\\d{2}:\\d{2})?)?$/)) {\n                if (fixtz && !!m[4] && !m[7])\n                    value = value.replace(/-/g, \"/\").replace(/T/, \" \");\n                value = new Date(value);\n            }\n            else\n                continue;\n            object[key] = value;\n        }\n        return object;\n    }\n    // https://github.com/d3/d3-dsv/issues/45\n    var fixtz = new Date(\"2019-01-01T00:00\").getHours() || new Date(\"2019-07-01T00:00\").getHours();\n    exports.autoType = autoType;\n    exports.csvFormat = csvFormat;\n    exports.csvFormatBody = csvFormatBody;\n    exports.csvFormatRow = csvFormatRow;\n    exports.csvFormatRows = csvFormatRows;\n    exports.csvFormatValue = csvFormatValue;\n    exports.csvParse = csvParse;\n    exports.csvParseRows = csvParseRows;\n    exports.dsvFormat = dsv;\n    exports.tsvFormat = tsvFormat;\n    exports.tsvFormatBody = tsvFormatBody;\n    exports.tsvFormatRow = tsvFormatRow;\n    exports.tsvFormatRows = tsvFormatRows;\n    exports.tsvFormatValue = tsvFormatValue;\n    exports.tsvParse = tsvParse;\n    exports.tsvParseRows = tsvParseRows;\n    Object.defineProperty(exports, '__esModule', { value: true });\n}));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-geo-projection@2.1.2@d3-geo-projection/build/d3-geo-projection.js\":\n/*!********************************************************************************************!*\\\n  !*** ./node_modules/_d3-geo-projection@2.1.2@d3-geo-projection/build/d3-geo-projection.js ***!\n  \\********************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-geo-projection/ Version 2.1.2. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! d3-geo */ \"./node_modules/_d3-geo@1.11.9@d3-geo/dist/d3-geo.js\"), __webpack_require__(/*! d3-array */ \"./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js\")) :\n        undefined;\n}(this, (function (exports, d3Geo, d3Array) {\n    'use strict';\n    var abs = Math.abs;\n    var atan = Math.atan;\n    var atan2 = Math.atan2;\n    var cos = Math.cos;\n    var exp = Math.exp;\n    var floor = Math.floor;\n    var log = Math.log;\n    var max = Math.max;\n    var min = Math.min;\n    var pow = Math.pow;\n    var round = Math.round;\n    var sign = Math.sign || function (x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\n    var sin = Math.sin;\n    var tan = Math.tan;\n    var epsilon = 1e-6;\n    var epsilon2 = 1e-12;\n    var pi = Math.PI;\n    var halfPi = pi / 2;\n    var quarterPi = pi / 4;\n    var sqrt1_2 = Math.SQRT1_2;\n    var sqrt2 = sqrt(2);\n    var sqrtPi = sqrt(pi);\n    var tau = pi * 2;\n    var degrees = 180 / pi;\n    var radians = pi / 180;\n    function sinci(x) {\n        return x ? x / Math.sin(x) : 1;\n    }\n    function asin(x) {\n        return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n    }\n    function acos(x) {\n        return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n    }\n    function sqrt(x) {\n        return x > 0 ? Math.sqrt(x) : 0;\n    }\n    function tanh(x) {\n        x = exp(2 * x);\n        return (x - 1) / (x + 1);\n    }\n    function sinh(x) {\n        return (exp(x) - exp(-x)) / 2;\n    }\n    function cosh(x) {\n        return (exp(x) + exp(-x)) / 2;\n    }\n    function arsinh(x) {\n        return log(x + sqrt(x * x + 1));\n    }\n    function arcosh(x) {\n        return log(x + sqrt(x * x - 1));\n    }\n    function airyRaw(beta) {\n        var tanBeta_2 = tan(beta / 2), b = 2 * log(cos(beta / 2)) / (tanBeta_2 * tanBeta_2);\n        function forward(x, y) {\n            var cosx = cos(x), cosy = cos(y), siny = sin(y), cosz = cosy * cosx, k = -((1 - cosz ? log((1 + cosz) / 2) / (1 - cosz) : -0.5) + b / (1 + cosz));\n            return [k * cosy * sin(x), k * siny];\n        }\n        forward.invert = function (x, y) {\n            var r = sqrt(x * x + y * y), z = -beta / 2, i = 50, delta;\n            if (!r)\n                return [0, 0];\n            do {\n                var z_2 = z / 2, cosz_2 = cos(z_2), sinz_2 = sin(z_2), tanz_2 = tan(z_2), lnsecz_2 = log(1 / cosz_2);\n                z -= delta = (2 / tanz_2 * lnsecz_2 - b * tanz_2 - r) / (-lnsecz_2 / (sinz_2 * sinz_2) + 1 - b / (2 * cosz_2 * cosz_2));\n            } while (abs(delta) > epsilon && --i > 0);\n            var sinz = sin(z);\n            return [atan2(x * sinz, r * cos(z)), asin(y * sinz / r)];\n        };\n        return forward;\n    }\n    var airy = function () {\n        var beta = halfPi, m = d3Geo.geoProjectionMutator(airyRaw), p = m(beta);\n        p.radius = function (_) {\n            return arguments.length ? m(beta = _ * radians) : beta * degrees;\n        };\n        return p\n            .scale(179.976)\n            .clipAngle(147);\n    };\n    function aitoffRaw(x, y) {\n        var cosy = cos(y), sincia = sinci(acos(cosy * cos(x /= 2)));\n        return [2 * cosy * sin(x) * sincia, sin(y) * sincia];\n    }\n    // Abort if [x, y] is not within an ellipse centered at [0, 0] with\n    // semi-major axis pi and semi-minor axis pi/2.\n    aitoffRaw.invert = function (x, y) {\n        if (x * x + 4 * y * y > pi * pi + epsilon)\n            return;\n        var x1 = x, y1 = y, i = 25;\n        do {\n            var sinx = sin(x1), sinx_2 = sin(x1 / 2), cosx_2 = cos(x1 / 2), siny = sin(y1), cosy = cos(y1), sin_2y = sin(2 * y1), sin2y = siny * siny, cos2y = cosy * cosy, sin2x_2 = sinx_2 * sinx_2, c = 1 - cos2y * cosx_2 * cosx_2, e = c ? acos(cosy * cosx_2) * sqrt(f = 1 / c) : f = 0, f, fx = 2 * e * cosy * sinx_2 - x, fy = e * siny - y, dxdx = f * (cos2y * sin2x_2 + e * cosy * cosx_2 * sin2y), dxdy = f * (0.5 * sinx * sin_2y - e * 2 * siny * sinx_2), dydx = f * 0.25 * (sin_2y * sinx_2 - e * siny * cos2y * sinx), dydy = f * (sin2y * cosx_2 + e * sin2x_2 * cosy), z = dxdy * dydx - dydy * dxdx;\n            if (!z)\n                break;\n            var dx = (fy * dxdy - fx * dydy) / z, dy = (fx * dydx - fy * dxdx) / z;\n            x1 -= dx, y1 -= dy;\n        } while ((abs(dx) > epsilon || abs(dy) > epsilon) && --i > 0);\n        return [x1, y1];\n    };\n    var aitoff = function () {\n        return d3Geo.geoProjection(aitoffRaw)\n            .scale(152.63);\n    };\n    function armadilloRaw(phi0) {\n        var sinPhi0 = sin(phi0), cosPhi0 = cos(phi0), sPhi0 = phi0 >= 0 ? 1 : -1, tanPhi0 = tan(sPhi0 * phi0), k = (1 + sinPhi0 - cosPhi0) / 2;\n        function forward(lambda, phi) {\n            var cosPhi = cos(phi), cosLambda = cos(lambda /= 2);\n            return [\n                (1 + cosPhi) * sin(lambda),\n                (sPhi0 * phi > -atan2(cosLambda, tanPhi0) - 1e-3 ? 0 : -sPhi0 * 10) + k + sin(phi) * cosPhi0 - (1 + cosPhi) * sinPhi0 * cosLambda // TODO D3 core should allow null or [NaN, NaN] to be returned.\n            ];\n        }\n        forward.invert = function (x, y) {\n            var lambda = 0, phi = 0, i = 50;\n            do {\n                var cosLambda = cos(lambda), sinLambda = sin(lambda), cosPhi = cos(phi), sinPhi = sin(phi), A = 1 + cosPhi, fx = A * sinLambda - x, fy = k + sinPhi * cosPhi0 - A * sinPhi0 * cosLambda - y, dxdLambda = A * cosLambda / 2, dxdPhi = -sinLambda * sinPhi, dydLambda = sinPhi0 * A * sinLambda / 2, dydPhi = cosPhi0 * cosPhi + sinPhi0 * cosLambda * sinPhi, denominator = dxdPhi * dydLambda - dydPhi * dxdLambda, dLambda = (fy * dxdPhi - fx * dydPhi) / denominator / 2, dPhi = (fx * dydLambda - fy * dxdLambda) / denominator;\n                lambda -= dLambda, phi -= dPhi;\n            } while ((abs(dLambda) > epsilon || abs(dPhi) > epsilon) && --i > 0);\n            return sPhi0 * phi > -atan2(cos(lambda), tanPhi0) - 1e-3 ? [lambda * 2, phi] : null;\n        };\n        return forward;\n    }\n    var armadillo = function () {\n        var phi0 = 20 * radians, sPhi0 = phi0 >= 0 ? 1 : -1, tanPhi0 = tan(sPhi0 * phi0), m = d3Geo.geoProjectionMutator(armadilloRaw), p = m(phi0), stream_ = p.stream;\n        p.parallel = function (_) {\n            if (!arguments.length)\n                return phi0 * degrees;\n            tanPhi0 = tan((sPhi0 = (phi0 = _ * radians) >= 0 ? 1 : -1) * phi0);\n            return m(phi0);\n        };\n        p.stream = function (stream) {\n            var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));\n            p.rotate(rotate);\n            rotateStream.sphere = function () {\n                sphereStream.polygonStart(), sphereStream.lineStart();\n                for (var lambda = sPhi0 * -180; sPhi0 * lambda < 180; lambda += sPhi0 * 90)\n                    sphereStream.point(lambda, sPhi0 * 90);\n                while (sPhi0 * (lambda -= phi0) >= -180) { // TODO precision?\n                    sphereStream.point(lambda, sPhi0 * -atan2(cos(lambda * radians / 2), tanPhi0) * degrees);\n                }\n                sphereStream.lineEnd(), sphereStream.polygonEnd();\n            };\n            return rotateStream;\n        };\n        return p\n            .scale(218.695)\n            .center([0, 28.0974]);\n    };\n    function augustRaw(lambda, phi) {\n        var tanPhi = tan(phi / 2), k = sqrt(1 - tanPhi * tanPhi), c = 1 + k * cos(lambda /= 2), x = sin(lambda) * k / c, y = tanPhi / c, x2 = x * x, y2 = y * y;\n        return [\n            4 / 3 * x * (3 + x2 - 3 * y2),\n            4 / 3 * y * (3 + 3 * x2 - y2)\n        ];\n    }\n    augustRaw.invert = function (x, y) {\n        x *= 3 / 8, y *= 3 / 8;\n        if (!x && abs(y) > 1)\n            return null;\n        var x2 = x * x, y2 = y * y, s = 1 + x2 + y2, sin3Eta = sqrt((s - sqrt(s * s - 4 * y * y)) / 2), eta = asin(sin3Eta) / 3, xi = sin3Eta ? arcosh(abs(y / sin3Eta)) / 3 : arsinh(abs(x)) / 3, cosEta = cos(eta), coshXi = cosh(xi), d = coshXi * coshXi - cosEta * cosEta;\n        return [\n            sign(x) * 2 * atan2(sinh(xi) * cosEta, 0.25 - d),\n            sign(y) * 2 * atan2(coshXi * sin(eta), 0.25 + d)\n        ];\n    };\n    var august = function () {\n        return d3Geo.geoProjection(augustRaw)\n            .scale(66.1603);\n    };\n    var sqrt8 = sqrt(8);\n    var phi0 = log(1 + sqrt2);\n    function bakerRaw(lambda, phi) {\n        var phi0 = abs(phi);\n        return phi0 < quarterPi\n            ? [lambda, log(tan(quarterPi + phi / 2))]\n            : [lambda * cos(phi0) * (2 * sqrt2 - 1 / sin(phi0)), sign(phi) * (2 * sqrt2 * (phi0 - quarterPi) - log(tan(phi0 / 2)))];\n    }\n    bakerRaw.invert = function (x, y) {\n        if ((y0 = abs(y)) < phi0)\n            return [x, 2 * atan(exp(y)) - halfPi];\n        var phi = quarterPi, i = 25, delta, y0;\n        do {\n            var cosPhi_2 = cos(phi / 2), tanPhi_2 = tan(phi / 2);\n            phi -= delta = (sqrt8 * (phi - quarterPi) - log(tanPhi_2) - y0) / (sqrt8 - cosPhi_2 * cosPhi_2 / (2 * tanPhi_2));\n        } while (abs(delta) > epsilon2 && --i > 0);\n        return [x / (cos(phi) * (sqrt8 - 1 / sin(phi))), sign(y) * phi];\n    };\n    var baker = function () {\n        return d3Geo.geoProjection(bakerRaw)\n            .scale(112.314);\n    };\n    function berghausRaw(lobes) {\n        var k = 2 * pi / lobes;\n        function forward(lambda, phi) {\n            var p = d3Geo.geoAzimuthalEquidistantRaw(lambda, phi);\n            if (abs(lambda) > halfPi) { // back hemisphere\n                var theta = atan2(p[1], p[0]), r = sqrt(p[0] * p[0] + p[1] * p[1]), theta0 = k * round((theta - halfPi) / k) + halfPi, alpha = atan2(sin(theta -= theta0), 2 - cos(theta)); // angle relative to lobe end\n                theta = theta0 + asin(pi / r * sin(alpha)) - alpha;\n                p[0] = r * cos(theta);\n                p[1] = r * sin(theta);\n            }\n            return p;\n        }\n        forward.invert = function (x, y) {\n            var r = sqrt(x * x + y * y);\n            if (r > halfPi) {\n                var theta = atan2(y, x), theta0 = k * round((theta - halfPi) / k) + halfPi, s = theta > theta0 ? -1 : 1, A = r * cos(theta0 - theta), cotAlpha = 1 / tan(s * acos((A - pi) / sqrt(pi * (pi - 2 * A) + r * r)));\n                theta = theta0 + 2 * atan((cotAlpha + s * sqrt(cotAlpha * cotAlpha - 3)) / 3);\n                x = r * cos(theta), y = r * sin(theta);\n            }\n            return d3Geo.geoAzimuthalEquidistantRaw.invert(x, y);\n        };\n        return forward;\n    }\n    var berghaus = function () {\n        var lobes = 5, m = d3Geo.geoProjectionMutator(berghausRaw), p = m(lobes), projectionStream = p.stream, epsilon$$1 = 1e-2, cr = -cos(epsilon$$1 * radians), sr = sin(epsilon$$1 * radians);\n        p.lobes = function (_) {\n            return arguments.length ? m(lobes = +_) : lobes;\n        };\n        p.stream = function (stream) {\n            var rotate = p.rotate(), rotateStream = projectionStream(stream), sphereStream = (p.rotate([0, 0]), projectionStream(stream));\n            p.rotate(rotate);\n            rotateStream.sphere = function () {\n                sphereStream.polygonStart(), sphereStream.lineStart();\n                for (var i = 0, delta = 360 / lobes, delta0 = 2 * pi / lobes, phi = 90 - 180 / lobes, phi0 = halfPi; i < lobes; ++i, phi -= delta, phi0 -= delta0) {\n                    sphereStream.point(atan2(sr * cos(phi0), cr) * degrees, asin(sr * sin(phi0)) * degrees);\n                    if (phi < -90) {\n                        sphereStream.point(-90, -180 - phi - epsilon$$1);\n                        sphereStream.point(-90, -180 - phi + epsilon$$1);\n                    }\n                    else {\n                        sphereStream.point(90, phi + epsilon$$1);\n                        sphereStream.point(90, phi - epsilon$$1);\n                    }\n                }\n                sphereStream.lineEnd(), sphereStream.polygonEnd();\n            };\n            return rotateStream;\n        };\n        return p\n            .scale(87.8076)\n            .center([0, 17.1875])\n            .clipAngle(180 - 1e-3);\n    };\n    function mollweideBromleyTheta(cp, phi) {\n        var cpsinPhi = cp * sin(phi), i = 30, delta;\n        do\n            phi -= delta = (phi + sin(phi) - cpsinPhi) / (1 + cos(phi));\n        while (abs(delta) > epsilon && --i > 0);\n        return phi / 2;\n    }\n    function mollweideBromleyRaw(cx, cy, cp) {\n        function forward(lambda, phi) {\n            return [cx * lambda * cos(phi = mollweideBromleyTheta(cp, phi)), cy * sin(phi)];\n        }\n        forward.invert = function (x, y) {\n            return y = asin(y / cy), [x / (cx * cos(y)), asin((2 * y + sin(2 * y)) / cp)];\n        };\n        return forward;\n    }\n    var mollweideRaw = mollweideBromleyRaw(sqrt2 / halfPi, sqrt2, pi);\n    var mollweide = function () {\n        return d3Geo.geoProjection(mollweideRaw)\n            .scale(169.529);\n    };\n    var k = 2.00276;\n    var w = 1.11072;\n    function boggsRaw(lambda, phi) {\n        var theta = mollweideBromleyTheta(pi, phi);\n        return [k * lambda / (1 / cos(phi) + w / cos(theta)), (phi + sqrt2 * sin(theta)) / k];\n    }\n    boggsRaw.invert = function (x, y) {\n        var ky = k * y, theta = y < 0 ? -quarterPi : quarterPi, i = 25, delta, phi;\n        do {\n            phi = ky - sqrt2 * sin(theta);\n            theta -= delta = (sin(2 * theta) + 2 * theta - pi * sin(phi)) / (2 * cos(2 * theta) + 2 + pi * cos(phi) * sqrt2 * cos(theta));\n        } while (abs(delta) > epsilon && --i > 0);\n        phi = ky - sqrt2 * sin(theta);\n        return [x * (1 / cos(phi) + w / cos(theta)) / k, phi];\n    };\n    var boggs = function () {\n        return d3Geo.geoProjection(boggsRaw)\n            .scale(160.857);\n    };\n    var parallel1 = function (projectAt) {\n        var phi0 = 0, m = d3Geo.geoProjectionMutator(projectAt), p = m(phi0);\n        p.parallel = function (_) {\n            return arguments.length ? m(phi0 = _ * radians) : phi0 * degrees;\n        };\n        return p;\n    };\n    function sinusoidalRaw(lambda, phi) {\n        return [lambda * cos(phi), phi];\n    }\n    sinusoidalRaw.invert = function (x, y) {\n        return [x / cos(y), y];\n    };\n    var sinusoidal = function () {\n        return d3Geo.geoProjection(sinusoidalRaw)\n            .scale(152.63);\n    };\n    function bonneRaw(phi0) {\n        if (!phi0)\n            return sinusoidalRaw;\n        var cotPhi0 = 1 / tan(phi0);\n        function forward(lambda, phi) {\n            var rho = cotPhi0 + phi0 - phi, e = rho ? lambda * cos(phi) / rho : rho;\n            return [rho * sin(e), cotPhi0 - rho * cos(e)];\n        }\n        forward.invert = function (x, y) {\n            var rho = sqrt(x * x + (y = cotPhi0 - y) * y), phi = cotPhi0 + phi0 - rho;\n            return [rho / cos(phi) * atan2(x, y), phi];\n        };\n        return forward;\n    }\n    var bonne = function () {\n        return parallel1(bonneRaw)\n            .scale(123.082)\n            .center([0, 26.1441])\n            .parallel(45);\n    };\n    function bottomleyRaw(sinPsi) {\n        function forward(lambda, phi) {\n            var rho = halfPi - phi, eta = rho ? lambda * sinPsi * sin(rho) / rho : rho;\n            return [rho * sin(eta) / sinPsi, halfPi - rho * cos(eta)];\n        }\n        forward.invert = function (x, y) {\n            var x1 = x * sinPsi, y1 = halfPi - y, rho = sqrt(x1 * x1 + y1 * y1), eta = atan2(x1, y1);\n            return [(rho ? rho / sin(rho) : 1) * eta / sinPsi, halfPi - rho];\n        };\n        return forward;\n    }\n    var bottomley = function () {\n        var sinPsi = 0.5, m = d3Geo.geoProjectionMutator(bottomleyRaw), p = m(sinPsi);\n        p.fraction = function (_) {\n            return arguments.length ? m(sinPsi = +_) : sinPsi;\n        };\n        return p\n            .scale(158.837);\n    };\n    var bromleyRaw = mollweideBromleyRaw(1, 4 / pi, pi);\n    var bromley = function () {\n        return d3Geo.geoProjection(bromleyRaw)\n            .scale(152.63);\n    };\n    // Azimuthal distance.\n    function distance(dPhi, c1, s1, c2, s2, dLambda) {\n        var cosdLambda = cos(dLambda), r;\n        if (abs(dPhi) > 1 || abs(dLambda) > 1) {\n            r = acos(s1 * s2 + c1 * c2 * cosdLambda);\n        }\n        else {\n            var sindPhi = sin(dPhi / 2), sindLambda = sin(dLambda / 2);\n            r = 2 * asin(sqrt(sindPhi * sindPhi + c1 * c2 * sindLambda * sindLambda));\n        }\n        return abs(r) > epsilon ? [r, atan2(c2 * sin(dLambda), c1 * s2 - s1 * c2 * cosdLambda)] : [0, 0];\n    }\n    // Angle opposite a, and contained between sides of lengths b and c.\n    function angle(b, c, a) {\n        return acos((b * b + c * c - a * a) / (2 * b * c));\n    }\n    // Normalize longitude.\n    function longitude(lambda) {\n        return lambda - 2 * pi * floor((lambda + pi) / (2 * pi));\n    }\n    function chamberlinRaw(p0, p1, p2) {\n        var points = [\n            [p0[0], p0[1], sin(p0[1]), cos(p0[1])],\n            [p1[0], p1[1], sin(p1[1]), cos(p1[1])],\n            [p2[0], p2[1], sin(p2[1]), cos(p2[1])]\n        ];\n        for (var a = points[2], b, i = 0; i < 3; ++i, a = b) {\n            b = points[i];\n            a.v = distance(b[1] - a[1], a[3], a[2], b[3], b[2], b[0] - a[0]);\n            a.point = [0, 0];\n        }\n        var beta0 = angle(points[0].v[0], points[2].v[0], points[1].v[0]), beta1 = angle(points[0].v[0], points[1].v[0], points[2].v[0]), beta2 = pi - beta0;\n        points[2].point[1] = 0;\n        points[0].point[0] = -(points[1].point[0] = points[0].v[0] / 2);\n        var mean = [\n            points[2].point[0] = points[0].point[0] + points[2].v[0] * cos(beta0),\n            2 * (points[0].point[1] = points[1].point[1] = points[2].v[0] * sin(beta0))\n        ];\n        function forward(lambda, phi) {\n            var sinPhi = sin(phi), cosPhi = cos(phi), v = new Array(3), i;\n            // Compute distance and azimuth from control points.\n            for (i = 0; i < 3; ++i) {\n                var p = points[i];\n                v[i] = distance(phi - p[1], p[3], p[2], cosPhi, sinPhi, lambda - p[0]);\n                if (!v[i][0])\n                    return p.point;\n                v[i][1] = longitude(v[i][1] - p.v[1]);\n            }\n            // Arithmetic mean of interception points.\n            var point = mean.slice();\n            for (i = 0; i < 3; ++i) {\n                var j = i == 2 ? 0 : i + 1;\n                var a = angle(points[i].v[0], v[i][0], v[j][0]);\n                if (v[i][1] < 0)\n                    a = -a;\n                if (!i) {\n                    point[0] += v[i][0] * cos(a);\n                    point[1] -= v[i][0] * sin(a);\n                }\n                else if (i == 1) {\n                    a = beta1 - a;\n                    point[0] -= v[i][0] * cos(a);\n                    point[1] -= v[i][0] * sin(a);\n                }\n                else {\n                    a = beta2 - a;\n                    point[0] += v[i][0] * cos(a);\n                    point[1] += v[i][0] * sin(a);\n                }\n            }\n            point[0] /= 3, point[1] /= 3;\n            return point;\n        }\n        return forward;\n    }\n    function pointRadians(p) {\n        return p[0] *= radians, p[1] *= radians, p;\n    }\n    function chamberlinAfrica() {\n        return chamberlin([0, 22], [45, 22], [22.5, -22])\n            .scale(380)\n            .center([22.5, 2]);\n    }\n    function chamberlin(p0, p1, p2) {\n        var c = d3Geo.geoCentroid({ type: \"MultiPoint\", coordinates: [p0, p1, p2] }), R = [-c[0], -c[1]], r = d3Geo.geoRotation(R), p = d3Geo.geoProjection(chamberlinRaw(pointRadians(r(p0)), pointRadians(r(p1)), pointRadians(r(p2)))).rotate(R), center = p.center;\n        delete p.rotate;\n        p.center = function (_) {\n            return arguments.length ? center(r(_)) : r.invert(center());\n        };\n        return p\n            .clipAngle(90);\n    }\n    function collignonRaw(lambda, phi) {\n        var alpha = sqrt(1 - sin(phi));\n        return [(2 / sqrtPi) * lambda * alpha, sqrtPi * (1 - alpha)];\n    }\n    collignonRaw.invert = function (x, y) {\n        var lambda = (lambda = y / sqrtPi - 1) * lambda;\n        return [lambda > 0 ? x * sqrt(pi / lambda) / 2 : 0, asin(1 - lambda)];\n    };\n    var collignon = function () {\n        return d3Geo.geoProjection(collignonRaw)\n            .scale(95.6464)\n            .center([0, 30]);\n    };\n    function craigRaw(phi0) {\n        var tanPhi0 = tan(phi0);\n        function forward(lambda, phi) {\n            return [lambda, (lambda ? lambda / sin(lambda) : 1) * (sin(phi) * cos(lambda) - tanPhi0 * cos(phi))];\n        }\n        forward.invert = tanPhi0 ? function (x, y) {\n            if (x)\n                y *= sin(x) / x;\n            var cosLambda = cos(x);\n            return [x, 2 * atan2(sqrt(cosLambda * cosLambda + tanPhi0 * tanPhi0 - y * y) - cosLambda, tanPhi0 - y)];\n        } : function (x, y) {\n            return [x, asin(x ? y * tan(x) / x : y)];\n        };\n        return forward;\n    }\n    var craig = function () {\n        return parallel1(craigRaw)\n            .scale(249.828)\n            .clipAngle(90);\n    };\n    var sqrt3 = sqrt(3);\n    function crasterRaw(lambda, phi) {\n        return [sqrt3 * lambda * (2 * cos(2 * phi / 3) - 1) / sqrtPi, sqrt3 * sqrtPi * sin(phi / 3)];\n    }\n    crasterRaw.invert = function (x, y) {\n        var phi = 3 * asin(y / (sqrt3 * sqrtPi));\n        return [sqrtPi * x / (sqrt3 * (2 * cos(2 * phi / 3) - 1)), phi];\n    };\n    var craster = function () {\n        return d3Geo.geoProjection(crasterRaw)\n            .scale(156.19);\n    };\n    function cylindricalEqualAreaRaw(phi0) {\n        var cosPhi0 = cos(phi0);\n        function forward(lambda, phi) {\n            return [lambda * cosPhi0, sin(phi) / cosPhi0];\n        }\n        forward.invert = function (x, y) {\n            return [x / cosPhi0, asin(y * cosPhi0)];\n        };\n        return forward;\n    }\n    var cylindricalEqualArea = function () {\n        return parallel1(cylindricalEqualAreaRaw)\n            .parallel(38.58) // acos(sqrt(width / height / pi)) * radians\n            .scale(195.044); // width / (sqrt(width / height / pi) * 2 * pi)\n    };\n    function cylindricalStereographicRaw(phi0) {\n        var cosPhi0 = cos(phi0);\n        function forward(lambda, phi) {\n            return [lambda * cosPhi0, (1 + cosPhi0) * tan(phi / 2)];\n        }\n        forward.invert = function (x, y) {\n            return [x / cosPhi0, atan(y / (1 + cosPhi0)) * 2];\n        };\n        return forward;\n    }\n    var cylindricalStereographic = function () {\n        return parallel1(cylindricalStereographicRaw)\n            .scale(124.75);\n    };\n    function eckert1Raw(lambda, phi) {\n        var alpha = sqrt(8 / (3 * pi));\n        return [\n            alpha * lambda * (1 - abs(phi) / pi),\n            alpha * phi\n        ];\n    }\n    eckert1Raw.invert = function (x, y) {\n        var alpha = sqrt(8 / (3 * pi)), phi = y / alpha;\n        return [\n            x / (alpha * (1 - abs(phi) / pi)),\n            phi\n        ];\n    };\n    var eckert1 = function () {\n        return d3Geo.geoProjection(eckert1Raw)\n            .scale(165.664);\n    };\n    function eckert2Raw(lambda, phi) {\n        var alpha = sqrt(4 - 3 * sin(abs(phi)));\n        return [\n            2 / sqrt(6 * pi) * lambda * alpha,\n            sign(phi) * sqrt(2 * pi / 3) * (2 - alpha)\n        ];\n    }\n    eckert2Raw.invert = function (x, y) {\n        var alpha = 2 - abs(y) / sqrt(2 * pi / 3);\n        return [\n            x * sqrt(6 * pi) / (2 * alpha),\n            sign(y) * asin((4 - alpha * alpha) / 3)\n        ];\n    };\n    var eckert2 = function () {\n        return d3Geo.geoProjection(eckert2Raw)\n            .scale(165.664);\n    };\n    function eckert3Raw(lambda, phi) {\n        var k = sqrt(pi * (4 + pi));\n        return [\n            2 / k * lambda * (1 + sqrt(1 - 4 * phi * phi / (pi * pi))),\n            4 / k * phi\n        ];\n    }\n    eckert3Raw.invert = function (x, y) {\n        var k = sqrt(pi * (4 + pi)) / 2;\n        return [\n            x * k / (1 + sqrt(1 - y * y * (4 + pi) / (4 * pi))),\n            y * k / 2\n        ];\n    };\n    var eckert3 = function () {\n        return d3Geo.geoProjection(eckert3Raw)\n            .scale(180.739);\n    };\n    function eckert4Raw(lambda, phi) {\n        var k = (2 + halfPi) * sin(phi);\n        phi /= 2;\n        for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon; i++) {\n            var cosPhi = cos(phi);\n            phi -= delta = (phi + sin(phi) * (cosPhi + 2) - k) / (2 * cosPhi * (1 + cosPhi));\n        }\n        return [\n            2 / sqrt(pi * (4 + pi)) * lambda * (1 + cos(phi)),\n            2 * sqrt(pi / (4 + pi)) * sin(phi)\n        ];\n    }\n    eckert4Raw.invert = function (x, y) {\n        var A = y * sqrt((4 + pi) / pi) / 2, k = asin(A), c = cos(k);\n        return [\n            x / (2 / sqrt(pi * (4 + pi)) * (1 + c)),\n            asin((k + A * (c + 2)) / (2 + halfPi))\n        ];\n    };\n    var eckert4 = function () {\n        return d3Geo.geoProjection(eckert4Raw)\n            .scale(180.739);\n    };\n    function eckert5Raw(lambda, phi) {\n        return [\n            lambda * (1 + cos(phi)) / sqrt(2 + pi),\n            2 * phi / sqrt(2 + pi)\n        ];\n    }\n    eckert5Raw.invert = function (x, y) {\n        var k = sqrt(2 + pi), phi = y * k / 2;\n        return [\n            k * x / (1 + cos(phi)),\n            phi\n        ];\n    };\n    var eckert5 = function () {\n        return d3Geo.geoProjection(eckert5Raw)\n            .scale(173.044);\n    };\n    function eckert6Raw(lambda, phi) {\n        var k = (1 + halfPi) * sin(phi);\n        for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon; i++) {\n            phi -= delta = (phi + sin(phi) - k) / (1 + cos(phi));\n        }\n        k = sqrt(2 + pi);\n        return [\n            lambda * (1 + cos(phi)) / k,\n            2 * phi / k\n        ];\n    }\n    eckert6Raw.invert = function (x, y) {\n        var j = 1 + halfPi, k = sqrt(j / 2);\n        return [\n            x * 2 * k / (1 + cos(y *= k)),\n            asin((y + sin(y)) / j)\n        ];\n    };\n    var eckert6 = function () {\n        return d3Geo.geoProjection(eckert6Raw)\n            .scale(173.044);\n    };\n    var eisenlohrK = 3 + 2 * sqrt2;\n    function eisenlohrRaw(lambda, phi) {\n        var s0 = sin(lambda /= 2), c0 = cos(lambda), k = sqrt(cos(phi)), c1 = cos(phi /= 2), t = sin(phi) / (c1 + sqrt2 * c0 * k), c = sqrt(2 / (1 + t * t)), v = sqrt((sqrt2 * c1 + (c0 + s0) * k) / (sqrt2 * c1 + (c0 - s0) * k));\n        return [\n            eisenlohrK * (c * (v - 1 / v) - 2 * log(v)),\n            eisenlohrK * (c * t * (v + 1 / v) - 2 * atan(t))\n        ];\n    }\n    eisenlohrRaw.invert = function (x, y) {\n        if (!(p = augustRaw.invert(x / 1.2, y * 1.065)))\n            return null;\n        var lambda = p[0], phi = p[1], i = 20, p;\n        x /= eisenlohrK, y /= eisenlohrK;\n        do {\n            var _0 = lambda / 2, _1 = phi / 2, s0 = sin(_0), c0 = cos(_0), s1 = sin(_1), c1 = cos(_1), cos1 = cos(phi), k = sqrt(cos1), t = s1 / (c1 + sqrt2 * c0 * k), t2 = t * t, c = sqrt(2 / (1 + t2)), v0 = (sqrt2 * c1 + (c0 + s0) * k), v1 = (sqrt2 * c1 + (c0 - s0) * k), v2 = v0 / v1, v = sqrt(v2), vm1v = v - 1 / v, vp1v = v + 1 / v, fx = c * vm1v - 2 * log(v) - x, fy = c * t * vp1v - 2 * atan(t) - y, deltatDeltaLambda = s1 && sqrt1_2 * k * s0 * t2 / s1, deltatDeltaPhi = (sqrt2 * c0 * c1 + k) / (2 * (c1 + sqrt2 * c0 * k) * (c1 + sqrt2 * c0 * k) * k), deltacDeltat = -0.5 * t * c * c * c, deltacDeltaLambda = deltacDeltat * deltatDeltaLambda, deltacDeltaPhi = deltacDeltat * deltatDeltaPhi, A = (A = 2 * c1 + sqrt2 * k * (c0 - s0)) * A * v, deltavDeltaLambda = (sqrt2 * c0 * c1 * k + cos1) / A, deltavDeltaPhi = -(sqrt2 * s0 * s1) / (k * A), deltaxDeltaLambda = vm1v * deltacDeltaLambda - 2 * deltavDeltaLambda / v + c * (deltavDeltaLambda + deltavDeltaLambda / v2), deltaxDeltaPhi = vm1v * deltacDeltaPhi - 2 * deltavDeltaPhi / v + c * (deltavDeltaPhi + deltavDeltaPhi / v2), deltayDeltaLambda = t * vp1v * deltacDeltaLambda - 2 * deltatDeltaLambda / (1 + t2) + c * vp1v * deltatDeltaLambda + c * t * (deltavDeltaLambda - deltavDeltaLambda / v2), deltayDeltaPhi = t * vp1v * deltacDeltaPhi - 2 * deltatDeltaPhi / (1 + t2) + c * vp1v * deltatDeltaPhi + c * t * (deltavDeltaPhi - deltavDeltaPhi / v2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;\n            if (!denominator)\n                break;\n            var deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;\n            lambda -= deltaLambda;\n            phi = max(-halfPi, min(halfPi, phi - deltaPhi));\n        } while ((abs(deltaLambda) > epsilon || abs(deltaPhi) > epsilon) && --i > 0);\n        return abs(abs(phi) - halfPi) < epsilon ? [0, phi] : i && [lambda, phi];\n    };\n    var eisenlohr = function () {\n        return d3Geo.geoProjection(eisenlohrRaw)\n            .scale(62.5271);\n    };\n    var faheyK = cos(35 * radians);\n    function faheyRaw(lambda, phi) {\n        var t = tan(phi / 2);\n        return [lambda * faheyK * sqrt(1 - t * t), (1 + faheyK) * t];\n    }\n    faheyRaw.invert = function (x, y) {\n        var t = y / (1 + faheyK);\n        return [x && x / (faheyK * sqrt(1 - t * t)), 2 * atan(t)];\n    };\n    var fahey = function () {\n        return d3Geo.geoProjection(faheyRaw)\n            .scale(137.152);\n    };\n    function foucautRaw(lambda, phi) {\n        var k = phi / 2, cosk = cos(k);\n        return [2 * lambda / sqrtPi * cos(phi) * cosk * cosk, sqrtPi * tan(k)];\n    }\n    foucautRaw.invert = function (x, y) {\n        var k = atan(y / sqrtPi), cosk = cos(k), phi = 2 * k;\n        return [x * sqrtPi / 2 / (cos(phi) * cosk * cosk), phi];\n    };\n    var foucaut = function () {\n        return d3Geo.geoProjection(foucautRaw)\n            .scale(135.264);\n    };\n    function gilbertForward(point) {\n        return [point[0] / 2, asin(tan(point[1] / 2 * radians)) * degrees];\n    }\n    function gilbertInvert(point) {\n        return [point[0] * 2, 2 * atan(sin(point[1] * radians)) * degrees];\n    }\n    var gilbert = function (projectionType) {\n        if (projectionType == null)\n            projectionType = d3Geo.geoOrthographic;\n        var projection = projectionType(), equirectangular = d3Geo.geoEquirectangular().scale(degrees).precision(0).clipAngle(null).translate([0, 0]); // antimeridian cutting\n        function gilbert(point) {\n            return projection(gilbertForward(point));\n        }\n        if (projection.invert)\n            gilbert.invert = function (point) {\n                return gilbertInvert(projection.invert(point));\n            };\n        gilbert.stream = function (stream) {\n            var s1 = projection.stream(stream), s0 = equirectangular.stream({\n                point: function (lambda, phi) { s1.point(lambda / 2, asin(tan(-phi / 2 * radians)) * degrees); },\n                lineStart: function () { s1.lineStart(); },\n                lineEnd: function () { s1.lineEnd(); },\n                polygonStart: function () { s1.polygonStart(); },\n                polygonEnd: function () { s1.polygonEnd(); }\n            });\n            s0.sphere = s1.sphere;\n            return s0;\n        };\n        function property(name) {\n            gilbert[name] = function (_) {\n                return arguments.length ? (projection[name](_), gilbert) : projection[name]();\n            };\n        }\n        gilbert.rotate = function (_) {\n            return arguments.length ? (equirectangular.rotate(_), gilbert) : equirectangular.rotate();\n        };\n        gilbert.center = function (_) {\n            return arguments.length ? (projection.center(gilbertForward(_)), gilbert) : gilbertInvert(projection.center());\n        };\n        property(\"clipAngle\");\n        property(\"clipExtent\");\n        property(\"scale\");\n        property(\"translate\");\n        property(\"precision\");\n        return gilbert\n            .scale(249.5);\n    };\n    function gingeryRaw(rho, n) {\n        var k = 2 * pi / n, rho2 = rho * rho;\n        function forward(lambda, phi) {\n            var p = d3Geo.geoAzimuthalEquidistantRaw(lambda, phi), x = p[0], y = p[1], r2 = x * x + y * y;\n            if (r2 > rho2) {\n                var r = sqrt(r2), theta = atan2(y, x), theta0 = k * round(theta / k), alpha = theta - theta0, rhoCosAlpha = rho * cos(alpha), k_ = (rho * sin(alpha) - alpha * sin(rhoCosAlpha)) / (halfPi - rhoCosAlpha), s_ = gingeryLength(alpha, k_), e = (pi - rho) / gingeryIntegrate(s_, rhoCosAlpha, pi);\n                x = r;\n                var i = 50, delta;\n                do {\n                    x -= delta = (rho + gingeryIntegrate(s_, rhoCosAlpha, x) * e - r) / (s_(x) * e);\n                } while (abs(delta) > epsilon && --i > 0);\n                y = alpha * sin(x);\n                if (x < halfPi)\n                    y -= k_ * (x - halfPi);\n                var s = sin(theta0), c = cos(theta0);\n                p[0] = x * c - y * s;\n                p[1] = x * s + y * c;\n            }\n            return p;\n        }\n        forward.invert = function (x, y) {\n            var r2 = x * x + y * y;\n            if (r2 > rho2) {\n                var r = sqrt(r2), theta = atan2(y, x), theta0 = k * round(theta / k), dTheta = theta - theta0;\n                x = r * cos(dTheta);\n                y = r * sin(dTheta);\n                var x_halfPi = x - halfPi, sinx = sin(x), alpha = y / sinx, delta = x < halfPi ? Infinity : 0, i = 10;\n                while (true) {\n                    var rhosinAlpha = rho * sin(alpha), rhoCosAlpha = rho * cos(alpha), sinRhoCosAlpha = sin(rhoCosAlpha), halfPi_RhoCosAlpha = halfPi - rhoCosAlpha, k_ = (rhosinAlpha - alpha * sinRhoCosAlpha) / halfPi_RhoCosAlpha, s_ = gingeryLength(alpha, k_);\n                    if (abs(delta) < epsilon2 || !--i)\n                        break;\n                    alpha -= delta = (alpha * sinx - k_ * x_halfPi - y) / (sinx - x_halfPi * 2 * (halfPi_RhoCosAlpha * (rhoCosAlpha + alpha * rhosinAlpha * cos(rhoCosAlpha) - sinRhoCosAlpha) -\n                        rhosinAlpha * (rhosinAlpha - alpha * sinRhoCosAlpha)) / (halfPi_RhoCosAlpha * halfPi_RhoCosAlpha));\n                }\n                r = rho + gingeryIntegrate(s_, rhoCosAlpha, x) * (pi - rho) / gingeryIntegrate(s_, rhoCosAlpha, pi);\n                theta = theta0 + alpha;\n                x = r * cos(theta);\n                y = r * sin(theta);\n            }\n            return d3Geo.geoAzimuthalEquidistantRaw.invert(x, y);\n        };\n        return forward;\n    }\n    function gingeryLength(alpha, k) {\n        return function (x) {\n            var y_ = alpha * cos(x);\n            if (x < halfPi)\n                y_ -= k;\n            return sqrt(1 + y_ * y_);\n        };\n    }\n    // Numerical integration: trapezoidal rule.\n    function gingeryIntegrate(f, a, b) {\n        var n = 50, h = (b - a) / n, s = f(a) + f(b);\n        for (var i = 1, x = a; i < n; ++i)\n            s += 2 * f(x += h);\n        return s * 0.5 * h;\n    }\n    var gingery = function () {\n        var n = 6, rho = 30 * radians, cRho = cos(rho), sRho = sin(rho), m = d3Geo.geoProjectionMutator(gingeryRaw), p = m(rho, n), stream_ = p.stream, epsilon$$1 = 1e-2, cr = -cos(epsilon$$1 * radians), sr = sin(epsilon$$1 * radians);\n        p.radius = function (_) {\n            if (!arguments.length)\n                return rho * degrees;\n            cRho = cos(rho = _ * radians);\n            sRho = sin(rho);\n            return m(rho, n);\n        };\n        p.lobes = function (_) {\n            if (!arguments.length)\n                return n;\n            return m(rho, n = +_);\n        };\n        p.stream = function (stream) {\n            var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));\n            p.rotate(rotate);\n            rotateStream.sphere = function () {\n                sphereStream.polygonStart(), sphereStream.lineStart();\n                for (var i = 0, delta = 2 * pi / n, phi = 0; i < n; ++i, phi -= delta) {\n                    sphereStream.point(atan2(sr * cos(phi), cr) * degrees, asin(sr * sin(phi)) * degrees);\n                    sphereStream.point(atan2(sRho * cos(phi - delta / 2), cRho) * degrees, asin(sRho * sin(phi - delta / 2)) * degrees);\n                }\n                sphereStream.lineEnd(), sphereStream.polygonEnd();\n            };\n            return rotateStream;\n        };\n        return p\n            .rotate([90, -40])\n            .scale(91.7095)\n            .clipAngle(180 - 1e-3);\n    };\n    var ginzburgPolyconicRaw = function (a, b, c, d, e, f, g, h) {\n        if (arguments.length < 8)\n            h = 0;\n        function forward(lambda, phi) {\n            if (!phi)\n                return [a * lambda / pi, 0];\n            var phi2 = phi * phi, xB = a + phi2 * (b + phi2 * (c + phi2 * d)), yB = phi * (e - 1 + phi2 * (f - h + phi2 * g)), m = (xB * xB + yB * yB) / (2 * yB), alpha = lambda * asin(xB / m) / pi;\n            return [m * sin(alpha), phi * (1 + phi2 * h) + m * (1 - cos(alpha))];\n        }\n        forward.invert = function (x, y) {\n            var lambda = pi * x / a, phi = y, deltaLambda, deltaPhi, i = 50;\n            do {\n                var phi2 = phi * phi, xB = a + phi2 * (b + phi2 * (c + phi2 * d)), yB = phi * (e - 1 + phi2 * (f - h + phi2 * g)), p = xB * xB + yB * yB, q = 2 * yB, m = p / q, m2 = m * m, dAlphadLambda = asin(xB / m) / pi, alpha = lambda * dAlphadLambda, xB2 = xB * xB, dxBdPhi = (2 * b + phi2 * (4 * c + phi2 * 6 * d)) * phi, dyBdPhi = e + phi2 * (3 * f + phi2 * 5 * g), dpdPhi = 2 * (xB * dxBdPhi + yB * (dyBdPhi - 1)), dqdPhi = 2 * (dyBdPhi - 1), dmdPhi = (dpdPhi * q - p * dqdPhi) / (q * q), cosAlpha = cos(alpha), sinAlpha = sin(alpha), mcosAlpha = m * cosAlpha, msinAlpha = m * sinAlpha, dAlphadPhi = ((lambda / pi) * (1 / sqrt(1 - xB2 / m2)) * (dxBdPhi * m - xB * dmdPhi)) / m2, fx = msinAlpha - x, fy = phi * (1 + phi2 * h) + m - mcosAlpha - y, deltaxDeltaPhi = dmdPhi * sinAlpha + mcosAlpha * dAlphadPhi, deltaxDeltaLambda = mcosAlpha * dAlphadLambda, deltayDeltaPhi = 1 + dmdPhi - (dmdPhi * cosAlpha - msinAlpha * dAlphadPhi), deltayDeltaLambda = msinAlpha * dAlphadLambda, denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;\n                if (!denominator)\n                    break;\n                lambda -= deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator;\n                phi -= deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;\n            } while ((abs(deltaLambda) > epsilon || abs(deltaPhi) > epsilon) && --i > 0);\n            return [lambda, phi];\n        };\n        return forward;\n    };\n    var ginzburg4Raw = ginzburgPolyconicRaw(2.8284, -1.6988, 0.75432, -0.18071, 1.76003, -0.38914, 0.042555);\n    var ginzburg4 = function () {\n        return d3Geo.geoProjection(ginzburg4Raw)\n            .scale(149.995);\n    };\n    var ginzburg5Raw = ginzburgPolyconicRaw(2.583819, -0.835827, 0.170354, -0.038094, 1.543313, -0.411435, 0.082742);\n    var ginzburg5 = function () {\n        return d3Geo.geoProjection(ginzburg5Raw)\n            .scale(153.93);\n    };\n    var ginzburg6Raw = ginzburgPolyconicRaw(5 / 6 * pi, -0.62636, -0.0344, 0, 1.3493, -0.05524, 0, 0.045);\n    var ginzburg6 = function () {\n        return d3Geo.geoProjection(ginzburg6Raw)\n            .scale(130.945);\n    };\n    function ginzburg8Raw(lambda, phi) {\n        var lambda2 = lambda * lambda, phi2 = phi * phi;\n        return [\n            lambda * (1 - 0.162388 * phi2) * (0.87 - 0.000952426 * lambda2 * lambda2),\n            phi * (1 + phi2 / 12)\n        ];\n    }\n    ginzburg8Raw.invert = function (x, y) {\n        var lambda = x, phi = y, i = 50, delta;\n        do {\n            var phi2 = phi * phi;\n            phi -= delta = (phi * (1 + phi2 / 12) - y) / (1 + phi2 / 4);\n        } while (abs(delta) > epsilon && --i > 0);\n        i = 50;\n        x /= 1 - 0.162388 * phi2;\n        do {\n            var lambda4 = (lambda4 = lambda * lambda) * lambda4;\n            lambda -= delta = (lambda * (0.87 - 0.000952426 * lambda4) - x) / (0.87 - 0.00476213 * lambda4);\n        } while (abs(delta) > epsilon && --i > 0);\n        return [lambda, phi];\n    };\n    var ginzburg8 = function () {\n        return d3Geo.geoProjection(ginzburg8Raw)\n            .scale(131.747);\n    };\n    var ginzburg9Raw = ginzburgPolyconicRaw(2.6516, -0.76534, 0.19123, -0.047094, 1.36289, -0.13965, 0.031762);\n    var ginzburg9 = function () {\n        return d3Geo.geoProjection(ginzburg9Raw)\n            .scale(131.087);\n    };\n    var squareRaw = function (project) {\n        var dx = project(halfPi, 0)[0] - project(-halfPi, 0)[0];\n        function projectSquare(lambda, phi) {\n            var s = lambda > 0 ? -0.5 : 0.5, point = project(lambda + s * pi, phi);\n            point[0] -= s * dx;\n            return point;\n        }\n        if (project.invert)\n            projectSquare.invert = function (x, y) {\n                var s = x > 0 ? -0.5 : 0.5, location = project.invert(x + s * dx, y), lambda = location[0] - s * pi;\n                if (lambda < -pi)\n                    lambda += 2 * pi;\n                else if (lambda > pi)\n                    lambda -= 2 * pi;\n                location[0] = lambda;\n                return location;\n            };\n        return projectSquare;\n    };\n    function gringortenRaw(lambda, phi) {\n        var sLambda = sign(lambda), sPhi = sign(phi), cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(sPhi * phi);\n        lambda = abs(atan2(y, z));\n        phi = asin(x);\n        if (abs(lambda - halfPi) > epsilon)\n            lambda %= halfPi;\n        var point = gringortenHexadecant(lambda > pi / 4 ? halfPi - lambda : lambda, phi);\n        if (lambda > pi / 4)\n            z = point[0], point[0] = -point[1], point[1] = -z;\n        return (point[0] *= sLambda, point[1] *= -sPhi, point);\n    }\n    gringortenRaw.invert = function (x, y) {\n        if (abs(x) > 1)\n            x = sign(x) * 2 - x;\n        if (abs(y) > 1)\n            y = sign(y) * 2 - y;\n        var sx = sign(x), sy = sign(y), x0 = -sx * x, y0 = -sy * y, t = y0 / x0 < 1, p = gringortenHexadecantInvert(t ? y0 : x0, t ? x0 : y0), lambda = p[0], phi = p[1], cosPhi = cos(phi);\n        if (t)\n            lambda = -halfPi - lambda;\n        return [sx * (atan2(sin(lambda) * cosPhi, -sin(phi)) + pi), sy * asin(cos(lambda) * cosPhi)];\n    };\n    function gringortenHexadecant(lambda, phi) {\n        if (phi === halfPi)\n            return [0, 0];\n        var sinPhi = sin(phi), r = sinPhi * sinPhi, r2 = r * r, j = 1 + r2, k = 1 + 3 * r2, q = 1 - r2, z = asin(1 / sqrt(j)), v = q + r * j * z, p2 = (1 - sinPhi) / v, p = sqrt(p2), a2 = p2 * j, a = sqrt(a2), h = p * q, x, i;\n        if (lambda === 0)\n            return [0, -(h + r * a)];\n        var cosPhi = cos(phi), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r + z * k) * drdPhi, dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v), dpdPhi = (0.5 * dp2dPhi) / p, dhdPhi = q * dpdPhi - 2 * r * p * drdPhi, dra2dPhi = r * j * dp2dPhi + p2 * k * drdPhi, mu = -secPhi * drdPhi, nu = -secPhi * dra2dPhi, zeta = -2 * secPhi * dhdPhi, lambda1 = 4 * lambda / pi, delta;\n        // Slower but accurate bisection method.\n        if (lambda > 0.222 * pi || phi < pi / 4 && lambda > 0.175 * pi) {\n            x = (h + r * sqrt(a2 * (1 + r2) - h * h)) / (1 + r2);\n            if (lambda > pi / 4)\n                return [x, x];\n            var x1 = x, x0 = 0.5 * x;\n            x = 0.5 * (x0 + x1), i = 50;\n            do {\n                var g = sqrt(a2 - x * x), f = (x * (zeta + mu * g) + nu * asin(x / a)) - lambda1;\n                if (!f)\n                    break;\n                if (f < 0)\n                    x0 = x;\n                else\n                    x1 = x;\n                x = 0.5 * (x0 + x1);\n            } while (abs(x1 - x0) > epsilon && --i > 0);\n        }\n        // Newton-Raphson.\n        else {\n            x = epsilon, i = 25;\n            do {\n                var x2 = x * x, g2 = sqrt(a2 - x2), zetaMug = zeta + mu * g2, f2 = x * zetaMug + nu * asin(x / a) - lambda1, df = zetaMug + (nu - mu * x2) / g2;\n                x -= delta = g2 ? f2 / df : 0;\n            } while (abs(delta) > epsilon && --i > 0);\n        }\n        return [x, -h - r * sqrt(a2 - x * x)];\n    }\n    function gringortenHexadecantInvert(x, y) {\n        var x0 = 0, x1 = 1, r = 0.5, i = 50;\n        while (true) {\n            var r2 = r * r, sinPhi = sqrt(r), z = asin(1 / sqrt(1 + r2)), v = (1 - r2) + r * (1 + r2) * z, p2 = (1 - sinPhi) / v, p = sqrt(p2), a2 = p2 * (1 + r2), h = p * (1 - r2), g2 = a2 - x * x, g = sqrt(g2), y0 = y + h + r * g;\n            if (abs(x1 - x0) < epsilon2 || --i === 0 || y0 === 0)\n                break;\n            if (y0 > 0)\n                x0 = r;\n            else\n                x1 = r;\n            r = 0.5 * (x0 + x1);\n        }\n        if (!i)\n            return null;\n        var phi = asin(sinPhi), cosPhi = cos(phi), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r + z * (1 + 3 * r2)) * drdPhi, dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v), dpdPhi = 0.5 * dp2dPhi / p, dhdPhi = (1 - r2) * dpdPhi - 2 * r * p * drdPhi, zeta = -2 * secPhi * dhdPhi, mu = -secPhi * drdPhi, nu = -secPhi * (r * (1 + r2) * dp2dPhi + p2 * (1 + 3 * r2) * drdPhi);\n        return [pi / 4 * (x * (zeta + mu * g) + nu * asin(x / sqrt(a2))), phi];\n    }\n    var gringorten = function () {\n        return d3Geo.geoProjection(squareRaw(gringortenRaw))\n            .scale(239.75);\n    };\n    // Returns [sn, cn, dn](u + iv|m).\n    function ellipticJi(u, v, m) {\n        var a, b, c;\n        if (!u) {\n            b = ellipticJ(v, 1 - m);\n            return [\n                [0, b[0] / b[1]],\n                [1 / b[1], 0],\n                [b[2] / b[1], 0]\n            ];\n        }\n        a = ellipticJ(u, m);\n        if (!v)\n            return [[a[0], 0], [a[1], 0], [a[2], 0]];\n        b = ellipticJ(v, 1 - m);\n        c = b[1] * b[1] + m * a[0] * a[0] * b[0] * b[0];\n        return [\n            [a[0] * b[2] / c, a[1] * a[2] * b[0] * b[1] / c],\n            [a[1] * b[1] / c, -a[0] * a[2] * b[0] * b[2] / c],\n            [a[2] * b[1] * b[2] / c, -m * a[0] * a[1] * b[0] / c]\n        ];\n    }\n    // Returns [sn, cn, dn, ph](u|m).\n    function ellipticJ(u, m) {\n        var ai, b, phi, t, twon;\n        if (m < epsilon) {\n            t = sin(u);\n            b = cos(u);\n            ai = m * (u - t * b) / 4;\n            return [\n                t - ai * b,\n                b + ai * t,\n                1 - m * t * t / 2,\n                u - ai\n            ];\n        }\n        if (m >= 1 - epsilon) {\n            ai = (1 - m) / 4;\n            b = cosh(u);\n            t = tanh(u);\n            phi = 1 / b;\n            twon = b * sinh(u);\n            return [\n                t + ai * (twon - u) / (b * b),\n                phi - ai * t * phi * (twon - u),\n                phi + ai * t * phi * (twon + u),\n                2 * atan(exp(u)) - halfPi + ai * (twon - u) / b\n            ];\n        }\n        var a = [1, 0, 0, 0, 0, 0, 0, 0, 0], c = [sqrt(m), 0, 0, 0, 0, 0, 0, 0, 0], i = 0;\n        b = sqrt(1 - m);\n        twon = 1;\n        while (abs(c[i] / a[i]) > epsilon && i < 8) {\n            ai = a[i++];\n            c[i] = (ai - b) / 2;\n            a[i] = (ai + b) / 2;\n            b = sqrt(ai * b);\n            twon *= 2;\n        }\n        phi = twon * a[i] * u;\n        do {\n            t = c[i] * sin(b = phi) / a[i];\n            phi = (asin(t) + phi) / 2;\n        } while (--i);\n        return [sin(phi), t = cos(phi), t / cos(phi - b), phi];\n    }\n    // Calculate F(phi+iPsi|m).\n    // See Abramowitz and Stegun, 17.4.11.\n    function ellipticFi(phi, psi, m) {\n        var r = abs(phi), i = abs(psi), sinhPsi = sinh(i);\n        if (r) {\n            var cscPhi = 1 / sin(r), cotPhi2 = 1 / (tan(r) * tan(r)), b = -(cotPhi2 + m * (sinhPsi * sinhPsi * cscPhi * cscPhi) - 1 + m), c = (m - 1) * cotPhi2, cotLambda2 = (-b + sqrt(b * b - 4 * c)) / 2;\n            return [\n                ellipticF(atan(1 / sqrt(cotLambda2)), m) * sign(phi),\n                ellipticF(atan(sqrt((cotLambda2 / cotPhi2 - 1) / m)), 1 - m) * sign(psi)\n            ];\n        }\n        return [\n            0,\n            ellipticF(atan(sinhPsi), 1 - m) * sign(psi)\n        ];\n    }\n    // Calculate F(phi|m) where m = k² = sin²α.\n    // See Abramowitz and Stegun, 17.6.7.\n    function ellipticF(phi, m) {\n        if (!m)\n            return phi;\n        if (m === 1)\n            return log(tan(phi / 2 + quarterPi));\n        var a = 1, b = sqrt(1 - m), c = sqrt(m);\n        for (var i = 0; abs(c) > epsilon; i++) {\n            if (phi % pi) {\n                var dPhi = atan(b * tan(phi) / a);\n                if (dPhi < 0)\n                    dPhi += pi;\n                phi += dPhi + ~~(phi / pi) * pi;\n            }\n            else\n                phi += phi;\n            c = (a + b) / 2;\n            b = sqrt(a * b);\n            c = ((a = c) - b) / 2;\n        }\n        return phi / (pow(2, i) * a);\n    }\n    function guyouRaw(lambda, phi) {\n        var k_ = (sqrt2 - 1) / (sqrt2 + 1), k = sqrt(1 - k_ * k_), K = ellipticF(halfPi, k * k), f = -1, psi = log(tan(pi / 4 + abs(phi) / 2)), r = exp(f * psi) / sqrt(k_), at = guyouComplexAtan(r * cos(f * lambda), r * sin(f * lambda)), t = ellipticFi(at[0], at[1], k * k);\n        return [-t[1], (phi >= 0 ? 1 : -1) * (0.5 * K - t[0])];\n    }\n    function guyouComplexAtan(x, y) {\n        var x2 = x * x, y_1 = y + 1, t = 1 - x2 - y * y;\n        return [\n            0.5 * ((x >= 0 ? halfPi : -halfPi) - atan2(t, 2 * x)),\n            -0.25 * log(t * t + 4 * x2) + 0.5 * log(y_1 * y_1 + x2)\n        ];\n    }\n    function guyouComplexDivide(a, b) {\n        var denominator = b[0] * b[0] + b[1] * b[1];\n        return [\n            (a[0] * b[0] + a[1] * b[1]) / denominator,\n            (a[1] * b[0] - a[0] * b[1]) / denominator\n        ];\n    }\n    guyouRaw.invert = function (x, y) {\n        var k_ = (sqrt2 - 1) / (sqrt2 + 1), k = sqrt(1 - k_ * k_), K = ellipticF(halfPi, k * k), f = -1, j = ellipticJi(0.5 * K - y, -x, k * k), tn = guyouComplexDivide(j[0], j[1]), lambda = atan2(tn[1], tn[0]) / f;\n        return [\n            lambda,\n            2 * atan(exp(0.5 / f * log(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - halfPi\n        ];\n    };\n    var guyou = function () {\n        return d3Geo.geoProjection(squareRaw(guyouRaw))\n            .scale(151.496);\n    };\n    function hammerRaw(A, B) {\n        if (arguments.length < 2)\n            B = A;\n        if (B === 1)\n            return d3Geo.geoAzimuthalEqualAreaRaw;\n        if (B === Infinity)\n            return hammerQuarticAuthalicRaw;\n        function forward(lambda, phi) {\n            var coordinates = d3Geo.geoAzimuthalEqualAreaRaw(lambda / B, phi);\n            coordinates[0] *= A;\n            return coordinates;\n        }\n        forward.invert = function (x, y) {\n            var coordinates = d3Geo.geoAzimuthalEqualAreaRaw.invert(x / A, y);\n            coordinates[0] *= B;\n            return coordinates;\n        };\n        return forward;\n    }\n    function hammerQuarticAuthalicRaw(lambda, phi) {\n        return [\n            lambda * cos(phi) / cos(phi /= 2),\n            2 * sin(phi)\n        ];\n    }\n    hammerQuarticAuthalicRaw.invert = function (x, y) {\n        var phi = 2 * asin(y / 2);\n        return [\n            x * cos(phi / 2) / cos(phi),\n            phi\n        ];\n    };\n    var hammer = function () {\n        var B = 2, m = d3Geo.geoProjectionMutator(hammerRaw), p = m(B);\n        p.coefficient = function (_) {\n            if (!arguments.length)\n                return B;\n            return m(B = +_);\n        };\n        return p\n            .scale(169.529);\n    };\n    function hammerRetroazimuthalRaw(phi0) {\n        var sinPhi0 = sin(phi0), cosPhi0 = cos(phi0), rotate = hammerRetroazimuthalRotation(phi0);\n        rotate.invert = hammerRetroazimuthalRotation(-phi0);\n        function forward(lambda, phi) {\n            var p = rotate(lambda, phi);\n            lambda = p[0], phi = p[1];\n            var sinPhi = sin(phi), cosPhi = cos(phi), cosLambda = cos(lambda), z = acos(sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosLambda), sinz = sin(z), K = abs(sinz) > epsilon ? z / sinz : 1;\n            return [\n                K * cosPhi0 * sin(lambda),\n                (abs(lambda) > halfPi ? K : -K) // rotate for back hemisphere\n                    * (sinPhi0 * cosPhi - cosPhi0 * sinPhi * cosLambda)\n            ];\n        }\n        forward.invert = function (x, y) {\n            var rho = sqrt(x * x + y * y), sinz = -sin(rho), cosz = cos(rho), a = rho * cosz, b = -y * sinz, c = rho * sinPhi0, d = sqrt(a * a + b * b - c * c), phi = atan2(a * c + b * d, b * c - a * d), lambda = (rho > halfPi ? -1 : 1) * atan2(x * sinz, rho * cos(phi) * cosz + y * sin(phi) * sinz);\n            return rotate.invert(lambda, phi);\n        };\n        return forward;\n    }\n    // Latitudinal rotation by phi0.\n    // Temporary hack until D3 supports arbitrary small-circle clipping origins.\n    function hammerRetroazimuthalRotation(phi0) {\n        var sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);\n        return function (lambda, phi) {\n            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi);\n            return [\n                atan2(y, x * cosPhi0 - z * sinPhi0),\n                asin(z * cosPhi0 + x * sinPhi0)\n            ];\n        };\n    }\n    var hammerRetroazimuthal = function () {\n        var phi0 = 0, m = d3Geo.geoProjectionMutator(hammerRetroazimuthalRaw), p = m(phi0), rotate_ = p.rotate, stream_ = p.stream, circle = d3Geo.geoCircle();\n        p.parallel = function (_) {\n            if (!arguments.length)\n                return phi0 * degrees;\n            var r = p.rotate();\n            return m(phi0 = _ * radians).rotate(r);\n        };\n        // Temporary hack; see hammerRetroazimuthalRotation.\n        p.rotate = function (_) {\n            if (!arguments.length)\n                return (_ = rotate_.call(p), _[1] += phi0 * degrees, _);\n            rotate_.call(p, [_[0], _[1] - phi0 * degrees]);\n            circle.center([-_[0], -_[1]]);\n            return p;\n        };\n        p.stream = function (stream) {\n            stream = stream_(stream);\n            stream.sphere = function () {\n                stream.polygonStart();\n                var epsilon$$1 = 1e-2, ring = circle.radius(90 - epsilon$$1)().coordinates[0], n = ring.length - 1, i = -1, p;\n                stream.lineStart();\n                while (++i < n)\n                    stream.point((p = ring[i])[0], p[1]);\n                stream.lineEnd();\n                ring = circle.radius(90 + epsilon$$1)().coordinates[0];\n                n = ring.length - 1;\n                stream.lineStart();\n                while (--i >= 0)\n                    stream.point((p = ring[i])[0], p[1]);\n                stream.lineEnd();\n                stream.polygonEnd();\n            };\n            return stream;\n        };\n        return p\n            .scale(79.4187)\n            .parallel(45)\n            .clipAngle(180 - 1e-3);\n    };\n    var healpixParallel = 41 + 48 / 36 + 37 / 3600;\n    var healpixLambert = cylindricalEqualAreaRaw(0);\n    function healpixRaw(H) {\n        var phi0 = healpixParallel * radians, dx = collignonRaw(pi, phi0)[0] - collignonRaw(-pi, phi0)[0], y0 = healpixLambert(0, phi0)[1], y1 = collignonRaw(0, phi0)[1], dy1 = sqrtPi - y1, k = tau / H, w = 4 / tau, h = y0 + (dy1 * dy1 * 4) / tau;\n        function forward(lambda, phi) {\n            var point, phi2 = abs(phi);\n            if (phi2 > phi0) {\n                var i = min(H - 1, max(0, floor((lambda + pi) / k)));\n                lambda += pi * (H - 1) / H - i * k;\n                point = collignonRaw(lambda, phi2);\n                point[0] = point[0] * tau / dx - tau * (H - 1) / (2 * H) + i * tau / H;\n                point[1] = y0 + (point[1] - y1) * 4 * dy1 / tau;\n                if (phi < 0)\n                    point[1] = -point[1];\n            }\n            else {\n                point = healpixLambert(lambda, phi);\n            }\n            point[0] *= w, point[1] /= h;\n            return point;\n        }\n        forward.invert = function (x, y) {\n            x /= w, y *= h;\n            var y2 = abs(y);\n            if (y2 > y0) {\n                var i = min(H - 1, max(0, floor((x + pi) / k)));\n                x = (x + pi * (H - 1) / H - i * k) * dx / tau;\n                var point = collignonRaw.invert(x, 0.25 * (y2 - y0) * tau / dy1 + y1);\n                point[0] -= pi * (H - 1) / H - i * k;\n                if (y < 0)\n                    point[1] = -point[1];\n                return point;\n            }\n            return healpixLambert.invert(x, y);\n        };\n        return forward;\n    }\n    function sphere(step) {\n        return {\n            type: \"Polygon\",\n            coordinates: [\n                d3Array.range(-180, 180 + step / 2, step).map(function (x, i) { return [x, i & 1 ? 90 - 1e-6 : healpixParallel]; })\n                    .concat(d3Array.range(180, -180 - step / 2, -step).map(function (x, i) { return [x, i & 1 ? -90 + 1e-6 : -healpixParallel]; }))\n            ]\n        };\n    }\n    var healpix = function () {\n        var H = 4, m = d3Geo.geoProjectionMutator(healpixRaw), p = m(H), stream_ = p.stream;\n        p.lobes = function (_) {\n            return arguments.length ? m(H = +_) : H;\n        };\n        p.stream = function (stream) {\n            var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));\n            p.rotate(rotate);\n            rotateStream.sphere = function () { d3Geo.geoStream(sphere(180 / H), sphereStream); };\n            return rotateStream;\n        };\n        return p\n            .scale(239.75);\n    };\n    function hillRaw(K) {\n        var L = 1 + K, sinBt = sin(1 / L), Bt = asin(sinBt), A = 2 * sqrt(pi / (B = pi + 4 * Bt * L)), B, rho0 = 0.5 * A * (L + sqrt(K * (2 + K))), K2 = K * K, L2 = L * L;\n        function forward(lambda, phi) {\n            var t = 1 - sin(phi), rho, omega;\n            if (t && t < 2) {\n                var theta = halfPi - phi, i = 25, delta;\n                do {\n                    var sinTheta = sin(theta), cosTheta = cos(theta), Bt_Bt1 = Bt + atan2(sinTheta, L - cosTheta), C = 1 + L2 - 2 * L * cosTheta;\n                    theta -= delta = (theta - K2 * Bt - L * sinTheta + C * Bt_Bt1 - 0.5 * t * B) / (2 * L * sinTheta * Bt_Bt1);\n                } while (abs(delta) > epsilon2 && --i > 0);\n                rho = A * sqrt(C);\n                omega = lambda * Bt_Bt1 / pi;\n            }\n            else {\n                rho = A * (K + t);\n                omega = lambda * Bt / pi;\n            }\n            return [\n                rho * sin(omega),\n                rho0 - rho * cos(omega)\n            ];\n        }\n        forward.invert = function (x, y) {\n            var rho2 = x * x + (y -= rho0) * y, cosTheta = (1 + L2 - rho2 / (A * A)) / (2 * L), theta = acos(cosTheta), sinTheta = sin(theta), Bt_Bt1 = Bt + atan2(sinTheta, L - cosTheta);\n            return [\n                asin(x / sqrt(rho2)) * pi / Bt_Bt1,\n                asin(1 - 2 * (theta - K2 * Bt - L * sinTheta + (1 + L2 - 2 * L * cosTheta) * Bt_Bt1) / B)\n            ];\n        };\n        return forward;\n    }\n    var hill = function () {\n        var K = 1, m = d3Geo.geoProjectionMutator(hillRaw), p = m(K);\n        p.ratio = function (_) {\n            return arguments.length ? m(K = +_) : K;\n        };\n        return p\n            .scale(167.774)\n            .center([0, 18.67]);\n    };\n    var sinuMollweidePhi = 0.7109889596207567;\n    var sinuMollweideY = 0.0528035274542;\n    function sinuMollweideRaw(lambda, phi) {\n        return phi > -sinuMollweidePhi\n            ? (lambda = mollweideRaw(lambda, phi), lambda[1] += sinuMollweideY, lambda)\n            : sinusoidalRaw(lambda, phi);\n    }\n    sinuMollweideRaw.invert = function (x, y) {\n        return y > -sinuMollweidePhi\n            ? mollweideRaw.invert(x, y - sinuMollweideY)\n            : sinusoidalRaw.invert(x, y);\n    };\n    var sinuMollweide = function () {\n        return d3Geo.geoProjection(sinuMollweideRaw)\n            .rotate([-20, -55])\n            .scale(164.263)\n            .center([0, -5.4036]);\n    };\n    function homolosineRaw(lambda, phi) {\n        return abs(phi) > sinuMollweidePhi\n            ? (lambda = mollweideRaw(lambda, phi), lambda[1] -= phi > 0 ? sinuMollweideY : -sinuMollweideY, lambda)\n            : sinusoidalRaw(lambda, phi);\n    }\n    homolosineRaw.invert = function (x, y) {\n        return abs(y) > sinuMollweidePhi\n            ? mollweideRaw.invert(x, y + (y > 0 ? sinuMollweideY : -sinuMollweideY))\n            : sinusoidalRaw.invert(x, y);\n    };\n    var homolosine = function () {\n        return d3Geo.geoProjection(homolosineRaw)\n            .scale(152.63);\n    };\n    function pointEqual(a, b) {\n        return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n    }\n    function interpolateLine(coordinates, m) {\n        var i = -1, n = coordinates.length, p0 = coordinates[0], p1, dx, dy, resampled = [];\n        while (++i < n) {\n            p1 = coordinates[i];\n            dx = (p1[0] - p0[0]) / m;\n            dy = (p1[1] - p0[1]) / m;\n            for (var j = 0; j < m; ++j)\n                resampled.push([p0[0] + j * dx, p0[1] + j * dy]);\n            p0 = p1;\n        }\n        resampled.push(p1);\n        return resampled;\n    }\n    function interpolateSphere(lobes) {\n        var coordinates = [], lobe, lambda0, phi0, phi1, lambda2, phi2, i, n = lobes[0].length;\n        // Northern Hemisphere\n        for (i = 0; i < n; ++i) {\n            lobe = lobes[0][i];\n            lambda0 = lobe[0][0], phi0 = lobe[0][1], phi1 = lobe[1][1];\n            lambda2 = lobe[2][0], phi2 = lobe[2][1];\n            coordinates.push(interpolateLine([\n                [lambda0 + epsilon, phi0 + epsilon],\n                [lambda0 + epsilon, phi1 - epsilon],\n                [lambda2 - epsilon, phi1 - epsilon],\n                [lambda2 - epsilon, phi2 + epsilon]\n            ], 30));\n        }\n        // Southern Hemisphere\n        for (i = lobes[1].length - 1; i >= 0; --i) {\n            lobe = lobes[1][i];\n            lambda0 = lobe[0][0], phi0 = lobe[0][1], phi1 = lobe[1][1];\n            lambda2 = lobe[2][0], phi2 = lobe[2][1];\n            coordinates.push(interpolateLine([\n                [lambda2 - epsilon, phi2 - epsilon],\n                [lambda2 - epsilon, phi1 + epsilon],\n                [lambda0 + epsilon, phi1 + epsilon],\n                [lambda0 + epsilon, phi0 - epsilon]\n            ], 30));\n        }\n        return {\n            type: \"Polygon\",\n            coordinates: [d3Array.merge(coordinates)]\n        };\n    }\n    var interrupt = function (project, lobes) {\n        var sphere = interpolateSphere(lobes);\n        lobes = lobes.map(function (lobe) {\n            return lobe.map(function (l) {\n                return [\n                    [l[0][0] * radians, l[0][1] * radians],\n                    [l[1][0] * radians, l[1][1] * radians],\n                    [l[2][0] * radians, l[2][1] * radians]\n                ];\n            });\n        });\n        var bounds = lobes.map(function (lobe) {\n            return lobe.map(function (l) {\n                var x0 = project(l[0][0], l[0][1])[0], x1 = project(l[2][0], l[2][1])[0], y0 = project(l[1][0], l[0][1])[1], y1 = project(l[1][0], l[1][1])[1], t;\n                if (y0 > y1)\n                    t = y0, y0 = y1, y1 = t;\n                return [[x0, y0], [x1, y1]];\n            });\n        });\n        function forward(lambda, phi) {\n            var sign$$1 = phi < 0 ? -1 : +1, lobe = lobes[+(phi < 0)];\n            for (var i = 0, n = lobe.length - 1; i < n && lambda > lobe[i][2][0]; ++i)\n                ;\n            var p = project(lambda - lobe[i][1][0], phi);\n            p[0] += project(lobe[i][1][0], sign$$1 * phi > sign$$1 * lobe[i][0][1] ? lobe[i][0][1] : phi)[0];\n            return p;\n        }\n        // Assumes mutually exclusive bounding boxes for lobes.\n        if (project.invert)\n            forward.invert = function (x, y) {\n                var bound = bounds[+(y < 0)], lobe = lobes[+(y < 0)];\n                for (var i = 0, n = bound.length; i < n; ++i) {\n                    var b = bound[i];\n                    if (b[0][0] <= x && x < b[1][0] && b[0][1] <= y && y < b[1][1]) {\n                        var p = project.invert(x - project(lobe[i][1][0], 0)[0], y);\n                        p[0] += lobe[i][1][0];\n                        return pointEqual(forward(p[0], p[1]), [x, y]) ? p : null;\n                    }\n                }\n            };\n        var p = d3Geo.geoProjection(forward), stream_ = p.stream;\n        p.stream = function (stream) {\n            var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));\n            p.rotate(rotate);\n            rotateStream.sphere = function () { d3Geo.geoStream(sphere, sphereStream); };\n            return rotateStream;\n        };\n        return p;\n    };\n    var lobes = [[\n            [[-180, 0], [-100, 90], [-40, 0]],\n            [[-40, 0], [30, 90], [180, 0]]\n        ], [\n            [[-180, 0], [-160, -90], [-100, 0]],\n            [[-100, 0], [-60, -90], [-20, 0]],\n            [[-20, 0], [20, -90], [80, 0]],\n            [[80, 0], [140, -90], [180, 0]]\n        ]];\n    var boggs$1 = function () {\n        return interrupt(boggsRaw, lobes)\n            .scale(160.857);\n    };\n    var lobes$1 = [[\n            [[-180, 0], [-100, 90], [-40, 0]],\n            [[-40, 0], [30, 90], [180, 0]]\n        ], [\n            [[-180, 0], [-160, -90], [-100, 0]],\n            [[-100, 0], [-60, -90], [-20, 0]],\n            [[-20, 0], [20, -90], [80, 0]],\n            [[80, 0], [140, -90], [180, 0]]\n        ]];\n    var homolosine$1 = function () {\n        return interrupt(homolosineRaw, lobes$1)\n            .scale(152.63);\n    };\n    var lobes$2 = [[\n            [[-180, 0], [-100, 90], [-40, 0]],\n            [[-40, 0], [30, 90], [180, 0]]\n        ], [\n            [[-180, 0], [-160, -90], [-100, 0]],\n            [[-100, 0], [-60, -90], [-20, 0]],\n            [[-20, 0], [20, -90], [80, 0]],\n            [[80, 0], [140, -90], [180, 0]]\n        ]];\n    var mollweide$1 = function () {\n        return interrupt(mollweideRaw, lobes$2)\n            .scale(169.529);\n    };\n    var lobes$3 = [[\n            [[-180, 0], [-90, 90], [0, 0]],\n            [[0, 0], [90, 90], [180, 0]]\n        ], [\n            [[-180, 0], [-90, -90], [0, 0]],\n            [[0, 0], [90, -90], [180, 0]]\n        ]];\n    var mollweideHemispheres = function () {\n        return interrupt(mollweideRaw, lobes$3)\n            .scale(169.529)\n            .rotate([20, 0]);\n    };\n    var lobes$4 = [[\n            [[-180, 35], [-30, 90], [0, 35]],\n            [[0, 35], [30, 90], [180, 35]]\n        ], [\n            [[-180, -10], [-102, -90], [-65, -10]],\n            [[-65, -10], [5, -90], [77, -10]],\n            [[77, -10], [103, -90], [180, -10]]\n        ]];\n    var sinuMollweide$1 = function () {\n        return interrupt(sinuMollweideRaw, lobes$4)\n            .rotate([-20, -55])\n            .scale(164.263)\n            .center([0, -5.4036]);\n    };\n    var lobes$5 = [[\n            [[-180, 0], [-110, 90], [-40, 0]],\n            [[-40, 0], [0, 90], [40, 0]],\n            [[40, 0], [110, 90], [180, 0]]\n        ], [\n            [[-180, 0], [-110, -90], [-40, 0]],\n            [[-40, 0], [0, -90], [40, 0]],\n            [[40, 0], [110, -90], [180, 0]]\n        ]];\n    var sinusoidal$1 = function () {\n        return interrupt(sinusoidalRaw, lobes$5)\n            .scale(152.63)\n            .rotate([-20, 0]);\n    };\n    function kavrayskiy7Raw(lambda, phi) {\n        return [3 / tau * lambda * sqrt(pi * pi / 3 - phi * phi), phi];\n    }\n    kavrayskiy7Raw.invert = function (x, y) {\n        return [tau / 3 * x / sqrt(pi * pi / 3 - y * y), y];\n    };\n    var kavrayskiy7 = function () {\n        return d3Geo.geoProjection(kavrayskiy7Raw)\n            .scale(158.837);\n    };\n    function lagrangeRaw(n) {\n        function forward(lambda, phi) {\n            if (abs(abs(phi) - halfPi) < epsilon)\n                return [0, phi < 0 ? -2 : 2];\n            var sinPhi = sin(phi), v = pow((1 + sinPhi) / (1 - sinPhi), n / 2), c = 0.5 * (v + 1 / v) + cos(lambda *= n);\n            return [\n                2 * sin(lambda) / c,\n                (v - 1 / v) / c\n            ];\n        }\n        forward.invert = function (x, y) {\n            var y0 = abs(y);\n            if (abs(y0 - 2) < epsilon)\n                return x ? null : [0, sign(y) * halfPi];\n            if (y0 > 2)\n                return null;\n            x /= 2, y /= 2;\n            var x2 = x * x, y2 = y * y, t = 2 * y / (1 + x2 + y2); // tanh(nPhi)\n            t = pow((1 + t) / (1 - t), 1 / n);\n            return [\n                atan2(2 * x, 1 - x2 - y2) / n,\n                asin((t - 1) / (t + 1))\n            ];\n        };\n        return forward;\n    }\n    var lagrange = function () {\n        var n = 0.5, m = d3Geo.geoProjectionMutator(lagrangeRaw), p = m(n);\n        p.spacing = function (_) {\n            return arguments.length ? m(n = +_) : n;\n        };\n        return p\n            .scale(124.75);\n    };\n    var pi_sqrt2 = pi / sqrt2;\n    function larriveeRaw(lambda, phi) {\n        return [\n            lambda * (1 + sqrt(cos(phi))) / 2,\n            phi / (cos(phi / 2) * cos(lambda / 6))\n        ];\n    }\n    larriveeRaw.invert = function (x, y) {\n        var x0 = abs(x), y0 = abs(y), lambda = epsilon, phi = halfPi;\n        if (y0 < pi_sqrt2)\n            phi *= y0 / pi_sqrt2;\n        else\n            lambda += 6 * acos(pi_sqrt2 / y0);\n        for (var i = 0; i < 25; i++) {\n            var sinPhi = sin(phi), sqrtcosPhi = sqrt(cos(phi)), sinPhi_2 = sin(phi / 2), cosPhi_2 = cos(phi / 2), sinLambda_6 = sin(lambda / 6), cosLambda_6 = cos(lambda / 6), f0 = 0.5 * lambda * (1 + sqrtcosPhi) - x0, f1 = phi / (cosPhi_2 * cosLambda_6) - y0, df0dPhi = sqrtcosPhi ? -0.25 * lambda * sinPhi / sqrtcosPhi : 0, df0dLambda = 0.5 * (1 + sqrtcosPhi), df1dPhi = (1 + 0.5 * phi * sinPhi_2 / cosPhi_2) / (cosPhi_2 * cosLambda_6), df1dLambda = (phi / cosPhi_2) * (sinLambda_6 / 6) / (cosLambda_6 * cosLambda_6), denom = df0dPhi * df1dLambda - df1dPhi * df0dLambda, dPhi = (f0 * df1dLambda - f1 * df0dLambda) / denom, dLambda = (f1 * df0dPhi - f0 * df1dPhi) / denom;\n            phi -= dPhi;\n            lambda -= dLambda;\n            if (abs(dPhi) < epsilon && abs(dLambda) < epsilon)\n                break;\n        }\n        return [x < 0 ? -lambda : lambda, y < 0 ? -phi : phi];\n    };\n    var larrivee = function () {\n        return d3Geo.geoProjection(larriveeRaw)\n            .scale(97.2672);\n    };\n    function laskowskiRaw(lambda, phi) {\n        var lambda2 = lambda * lambda, phi2 = phi * phi;\n        return [\n            lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)),\n            phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 0.000199025) + phi2 * (0.0998909 + phi2 * -0.0491032))\n        ];\n    }\n    laskowskiRaw.invert = function (x, y) {\n        var lambda = sign(x) * pi, phi = y / 2, i = 50;\n        do {\n            var lambda2 = lambda * lambda, phi2 = phi * phi, lambdaPhi = lambda * phi, fx = lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)) - x, fy = phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 0.000199025) + phi2 * (0.0998909 + phi2 * -0.0491032)) - y, deltaxDeltaLambda = 0.975534 - phi2 * (0.119161 + 3 * lambda2 * 0.0143059 + phi2 * 0.0547009), deltaxDeltaPhi = -lambdaPhi * (2 * 0.119161 + 4 * 0.0547009 * phi2 + 2 * 0.0143059 * lambda2), deltayDeltaLambda = lambdaPhi * (2 * 0.0802894 + 4 * 0.000199025 * lambda2 + 2 * -0.02855 * phi2), deltayDeltaPhi = 1.00384 + lambda2 * (0.0802894 + 0.000199025 * lambda2) + phi2 * (3 * (0.0998909 - 0.02855 * lambda2) - 5 * 0.0491032 * phi2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda, deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;\n            lambda -= deltaLambda, phi -= deltaPhi;\n        } while ((abs(deltaLambda) > epsilon || abs(deltaPhi) > epsilon) && --i > 0);\n        return i && [lambda, phi];\n    };\n    var laskowski = function () {\n        return d3Geo.geoProjection(laskowskiRaw)\n            .scale(139.98);\n    };\n    function littrowRaw(lambda, phi) {\n        return [\n            sin(lambda) / cos(phi),\n            tan(phi) * cos(lambda)\n        ];\n    }\n    littrowRaw.invert = function (x, y) {\n        var x2 = x * x, y2 = y * y, y2_1 = y2 + 1, cosPhi = x\n            ? sqrt1_2 * sqrt((y2_1 - sqrt(x2 * x2 + 2 * x2 * (y2 - 1) + y2_1 * y2_1)) / x2 + 1)\n            : 1 / sqrt(y2_1);\n        return [\n            asin(x * cosPhi),\n            sign(y) * acos(cosPhi)\n        ];\n    };\n    var littrow = function () {\n        return d3Geo.geoProjection(littrowRaw)\n            .scale(144.049)\n            .clipAngle(90 - 1e-3);\n    };\n    function loximuthalRaw(phi0) {\n        var cosPhi0 = cos(phi0), tanPhi0 = tan(quarterPi + phi0 / 2);\n        function forward(lambda, phi) {\n            var y = phi - phi0, x = abs(y) < epsilon ? lambda * cosPhi0\n                : abs(x = quarterPi + phi / 2) < epsilon || abs(abs(x) - halfPi) < epsilon\n                    ? 0 : lambda * y / log(tan(x) / tanPhi0);\n            return [x, y];\n        }\n        forward.invert = function (x, y) {\n            var lambda, phi = y + phi0;\n            return [\n                abs(y) < epsilon ? x / cosPhi0\n                    : (abs(lambda = quarterPi + phi / 2) < epsilon || abs(abs(lambda) - halfPi) < epsilon) ? 0\n                        : x * log(tan(lambda) / tanPhi0) / y,\n                phi\n            ];\n        };\n        return forward;\n    }\n    var loximuthal = function () {\n        return parallel1(loximuthalRaw)\n            .parallel(40)\n            .scale(158.837);\n    };\n    function millerRaw(lambda, phi) {\n        return [lambda, 1.25 * log(tan(quarterPi + 0.4 * phi))];\n    }\n    millerRaw.invert = function (x, y) {\n        return [x, 2.5 * atan(exp(0.8 * y)) - 0.625 * pi];\n    };\n    var miller = function () {\n        return d3Geo.geoProjection(millerRaw)\n            .scale(108.318);\n    };\n    function modifiedStereographicRaw(C) {\n        var m = C.length - 1;\n        function forward(lambda, phi) {\n            var cosPhi = cos(phi), k = 2 / (1 + cosPhi * cos(lambda)), zr = k * cosPhi * sin(lambda), zi = k * sin(phi), i = m, w = C[i], ar = w[0], ai = w[1], t;\n            while (--i >= 0) {\n                w = C[i];\n                ar = w[0] + zr * (t = ar) - zi * ai;\n                ai = w[1] + zr * ai + zi * t;\n            }\n            ar = zr * (t = ar) - zi * ai;\n            ai = zr * ai + zi * t;\n            return [ar, ai];\n        }\n        forward.invert = function (x, y) {\n            var i = 20, zr = x, zi = y;\n            do {\n                var j = m, w = C[j], ar = w[0], ai = w[1], br = 0, bi = 0, t;\n                while (--j >= 0) {\n                    w = C[j];\n                    br = ar + zr * (t = br) - zi * bi;\n                    bi = ai + zr * bi + zi * t;\n                    ar = w[0] + zr * (t = ar) - zi * ai;\n                    ai = w[1] + zr * ai + zi * t;\n                }\n                br = ar + zr * (t = br) - zi * bi;\n                bi = ai + zr * bi + zi * t;\n                ar = zr * (t = ar) - zi * ai - x;\n                ai = zr * ai + zi * t - y;\n                var denominator = br * br + bi * bi, deltar, deltai;\n                zr -= deltar = (ar * br + ai * bi) / denominator;\n                zi -= deltai = (ai * br - ar * bi) / denominator;\n            } while (abs(deltar) + abs(deltai) > epsilon * epsilon && --i > 0);\n            if (i) {\n                var rho = sqrt(zr * zr + zi * zi), c = 2 * atan(rho * 0.5), sinc = sin(c);\n                return [atan2(zr * sinc, rho * cos(c)), rho ? asin(zi * sinc / rho) : 0];\n            }\n        };\n        return forward;\n    }\n    var alaska = [[0.9972523, 0], [0.0052513, -0.0041175], [0.0074606, 0.0048125], [-0.0153783, -0.1968253], [0.0636871, -0.1408027], [0.3660976, -0.2937382]];\n    var gs48 = [[0.98879, 0], [0, 0], [-0.050909, 0], [0, 0], [0.075528, 0]];\n    var gs50 = [[0.9842990, 0], [0.0211642, 0.0037608], [-0.1036018, -0.0575102], [-0.0329095, -0.0320119], [0.0499471, 0.1223335], [0.0260460, 0.0899805], [0.0007388, -0.1435792], [0.0075848, -0.1334108], [-0.0216473, 0.0776645], [-0.0225161, 0.0853673]];\n    var miller$1 = [[0.9245, 0], [0, 0], [0.01943, 0]];\n    var lee = [[0.721316, 0], [0, 0], [-0.00881625, -0.00617325]];\n    function modifiedStereographicAlaska() {\n        return modifiedStereographic(alaska, [152, -64])\n            .scale(1500)\n            .center([-160.908, 62.4864])\n            .clipAngle(25);\n    }\n    function modifiedStereographicGs48() {\n        return modifiedStereographic(gs48, [95, -38])\n            .scale(1000)\n            .clipAngle(55)\n            .center([-96.5563, 38.8675]);\n    }\n    function modifiedStereographicGs50() {\n        return modifiedStereographic(gs50, [120, -45])\n            .scale(359.513)\n            .clipAngle(55)\n            .center([-117.474, 53.0628]);\n    }\n    function modifiedStereographicMiller() {\n        return modifiedStereographic(miller$1, [-20, -18])\n            .scale(209.091)\n            .center([20, 16.7214])\n            .clipAngle(82);\n    }\n    function modifiedStereographicLee() {\n        return modifiedStereographic(lee, [165, 10])\n            .scale(250)\n            .clipAngle(130)\n            .center([-165, -10]);\n    }\n    function modifiedStereographic(coefficients, rotate) {\n        var p = d3Geo.geoProjection(modifiedStereographicRaw(coefficients)).rotate(rotate).clipAngle(90), r = d3Geo.geoRotation(rotate), center = p.center;\n        delete p.rotate;\n        p.center = function (_) {\n            return arguments.length ? center(r(_)) : r.invert(center());\n        };\n        return p;\n    }\n    var sqrt6 = sqrt(6);\n    var sqrt7 = sqrt(7);\n    function mtFlatPolarParabolicRaw(lambda, phi) {\n        var theta = asin(7 * sin(phi) / (3 * sqrt6));\n        return [\n            sqrt6 * lambda * (2 * cos(2 * theta / 3) - 1) / sqrt7,\n            9 * sin(theta / 3) / sqrt7\n        ];\n    }\n    mtFlatPolarParabolicRaw.invert = function (x, y) {\n        var theta = 3 * asin(y * sqrt7 / 9);\n        return [\n            x * sqrt7 / (sqrt6 * (2 * cos(2 * theta / 3) - 1)),\n            asin(sin(theta) * 3 * sqrt6 / 7)\n        ];\n    };\n    var mtFlatPolarParabolic = function () {\n        return d3Geo.geoProjection(mtFlatPolarParabolicRaw)\n            .scale(164.859);\n    };\n    function mtFlatPolarQuarticRaw(lambda, phi) {\n        var k = (1 + sqrt1_2) * sin(phi), theta = phi;\n        for (var i = 0, delta; i < 25; i++) {\n            theta -= delta = (sin(theta / 2) + sin(theta) - k) / (0.5 * cos(theta / 2) + cos(theta));\n            if (abs(delta) < epsilon)\n                break;\n        }\n        return [\n            lambda * (1 + 2 * cos(theta) / cos(theta / 2)) / (3 * sqrt2),\n            2 * sqrt(3) * sin(theta / 2) / sqrt(2 + sqrt2)\n        ];\n    }\n    mtFlatPolarQuarticRaw.invert = function (x, y) {\n        var sinTheta_2 = y * sqrt(2 + sqrt2) / (2 * sqrt(3)), theta = 2 * asin(sinTheta_2);\n        return [\n            3 * sqrt2 * x / (1 + 2 * cos(theta) / cos(theta / 2)),\n            asin((sinTheta_2 + sin(theta)) / (1 + sqrt1_2))\n        ];\n    };\n    var mtFlatPolarQuartic = function () {\n        return d3Geo.geoProjection(mtFlatPolarQuarticRaw)\n            .scale(188.209);\n    };\n    function mtFlatPolarSinusoidalRaw(lambda, phi) {\n        var A = sqrt(6 / (4 + pi)), k = (1 + pi / 4) * sin(phi), theta = phi / 2;\n        for (var i = 0, delta; i < 25; i++) {\n            theta -= delta = (theta / 2 + sin(theta) - k) / (0.5 + cos(theta));\n            if (abs(delta) < epsilon)\n                break;\n        }\n        return [\n            A * (0.5 + cos(theta)) * lambda / 1.5,\n            A * theta\n        ];\n    }\n    mtFlatPolarSinusoidalRaw.invert = function (x, y) {\n        var A = sqrt(6 / (4 + pi)), theta = y / A;\n        if (abs(abs(theta) - halfPi) < epsilon)\n            theta = theta < 0 ? -halfPi : halfPi;\n        return [\n            1.5 * x / (A * (0.5 + cos(theta))),\n            asin((theta / 2 + sin(theta)) / (1 + pi / 4))\n        ];\n    };\n    var mtFlatPolarSinusoidal = function () {\n        return d3Geo.geoProjection(mtFlatPolarSinusoidalRaw)\n            .scale(166.518);\n    };\n    function naturalEarthRaw(lambda, phi) {\n        var phi2 = phi * phi, phi4 = phi2 * phi2;\n        return [\n            lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),\n            phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))\n        ];\n    }\n    naturalEarthRaw.invert = function (x, y) {\n        var phi = y, i = 25, delta;\n        do {\n            var phi2 = phi * phi, phi4 = phi2 * phi2;\n            phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /\n                (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));\n        } while (abs(delta) > epsilon && --i > 0);\n        return [\n            x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),\n            phi\n        ];\n    };\n    var naturalEarth = function () {\n        return d3Geo.geoProjection(naturalEarthRaw)\n            .scale(175.295);\n    };\n    function naturalEarth2Raw(lambda, phi) {\n        var phi2 = phi * phi, phi4 = phi2 * phi2, phi6 = phi2 * phi4;\n        return [\n            lambda * (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 0.00331 * phi6)),\n            phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 0.00396 * phi4))\n        ];\n    }\n    naturalEarth2Raw.invert = function (x, y) {\n        var phi = y, i = 25, delta, phi2, phi4, phi6;\n        do {\n            phi2 = phi * phi;\n            phi4 = phi2 * phi2;\n            phi -= delta = ((phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 0.00396 * phi4))) - y) /\n                (1.01183 + phi4 * phi4 * ((9 * -0.02625) + (11 * 0.01926) * phi2 + (13 * -0.00396) * phi4));\n        } while (abs(delta) > epsilon2 && --i > 0);\n        phi2 = phi * phi;\n        phi4 = phi2 * phi2;\n        phi6 = phi2 * phi4;\n        return [\n            x / (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 0.00331 * phi6)),\n            phi\n        ];\n    };\n    var naturalEarth2 = function () {\n        return d3Geo.geoProjection(naturalEarth2Raw)\n            .scale(175.295);\n    };\n    function nellHammerRaw(lambda, phi) {\n        return [\n            lambda * (1 + cos(phi)) / 2,\n            2 * (phi - tan(phi / 2))\n        ];\n    }\n    nellHammerRaw.invert = function (x, y) {\n        var p = y / 2;\n        for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon; ++i) {\n            var c = cos(y / 2);\n            y -= delta = (y - tan(y / 2) - p) / (1 - 0.5 / (c * c));\n        }\n        return [\n            2 * x / (1 + cos(y)),\n            y\n        ];\n    };\n    var nellHammer = function () {\n        return d3Geo.geoProjection(nellHammerRaw)\n            .scale(152.63);\n    };\n    // Based on Java implementation by Bojan Savric.\n    // https://github.com/OSUCartography/JMapProjLib/blob/master/src/com/jhlabs/map/proj/PattersonProjection.java\n    var pattersonK1 = 1.0148;\n    var pattersonK2 = 0.23185;\n    var pattersonK3 = -0.14499;\n    var pattersonK4 = 0.02406;\n    var pattersonC1 = pattersonK1;\n    var pattersonC2 = 5 * pattersonK2;\n    var pattersonC3 = 7 * pattersonK3;\n    var pattersonC4 = 9 * pattersonK4;\n    var pattersonYmax = 1.790857183;\n    function pattersonRaw(lambda, phi) {\n        var phi2 = phi * phi;\n        return [\n            lambda,\n            phi * (pattersonK1 + phi2 * phi2 * (pattersonK2 + phi2 * (pattersonK3 + pattersonK4 * phi2)))\n        ];\n    }\n    pattersonRaw.invert = function (x, y) {\n        if (y > pattersonYmax)\n            y = pattersonYmax;\n        else if (y < -pattersonYmax)\n            y = -pattersonYmax;\n        var yc = y, delta;\n        do { // Newton-Raphson\n            var y2 = yc * yc;\n            yc -= delta = ((yc * (pattersonK1 + y2 * y2 * (pattersonK2 + y2 * (pattersonK3 + pattersonK4 * y2)))) - y) / (pattersonC1 + y2 * y2 * (pattersonC2 + y2 * (pattersonC3 + pattersonC4 * y2)));\n        } while (abs(delta) > epsilon);\n        return [x, yc];\n    };\n    var patterson = function () {\n        return d3Geo.geoProjection(pattersonRaw)\n            .scale(139.319);\n    };\n    function polyconicRaw(lambda, phi) {\n        if (abs(phi) < epsilon)\n            return [lambda, 0];\n        var tanPhi = tan(phi), k = lambda * sin(phi);\n        return [\n            sin(k) / tanPhi,\n            phi + (1 - cos(k)) / tanPhi\n        ];\n    }\n    polyconicRaw.invert = function (x, y) {\n        if (abs(y) < epsilon)\n            return [x, 0];\n        var k = x * x + y * y, phi = y * 0.5, i = 10, delta;\n        do {\n            var tanPhi = tan(phi), secPhi = 1 / cos(phi), j = k - 2 * y * phi + phi * phi;\n            phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi);\n        } while (abs(delta) > epsilon && --i > 0);\n        tanPhi = tan(phi);\n        return [\n            (abs(y) < abs(phi + 1 / tanPhi) ? asin(x * tanPhi) : sign(x) * (acos(abs(x * tanPhi)) + halfPi)) / sin(phi),\n            phi\n        ];\n    };\n    var polyconic = function () {\n        return d3Geo.geoProjection(polyconicRaw)\n            .scale(103.74);\n    };\n    // Note: 6-element arrays are used to denote the 3x3 affine transform matrix:\n    // [a, b, c,\n    //  d, e, f,\n    //  0, 0, 1] - this redundant row is left out.\n    // Transform matrix for [a0, a1] -> [b0, b1].\n    var matrix = function (a, b) {\n        var u = subtract(a[1], a[0]), v = subtract(b[1], b[0]), phi = angle$1(u, v), s = length(u) / length(v);\n        return multiply([\n            1, 0, a[0][0],\n            0, 1, a[0][1]\n        ], multiply([\n            s, 0, 0,\n            0, s, 0\n        ], multiply([\n            cos(phi), sin(phi), 0,\n            -sin(phi), cos(phi), 0\n        ], [\n            1, 0, -b[0][0],\n            0, 1, -b[0][1]\n        ])));\n    };\n    // Inverts a transform matrix.\n    function inverse(m) {\n        var k = 1 / (m[0] * m[4] - m[1] * m[3]);\n        return [\n            k * m[4], -k * m[1], k * (m[1] * m[5] - m[2] * m[4]),\n            -k * m[3], k * m[0], k * (m[2] * m[3] - m[0] * m[5])\n        ];\n    }\n    // Multiplies two 3x2 matrices.\n    function multiply(a, b) {\n        return [\n            a[0] * b[0] + a[1] * b[3],\n            a[0] * b[1] + a[1] * b[4],\n            a[0] * b[2] + a[1] * b[5] + a[2],\n            a[3] * b[0] + a[4] * b[3],\n            a[3] * b[1] + a[4] * b[4],\n            a[3] * b[2] + a[4] * b[5] + a[5]\n        ];\n    }\n    // Subtracts 2D vectors.\n    function subtract(a, b) {\n        return [a[0] - b[0], a[1] - b[1]];\n    }\n    // Magnitude of a 2D vector.\n    function length(v) {\n        return sqrt(v[0] * v[0] + v[1] * v[1]);\n    }\n    // Angle between two 2D vectors.\n    function angle$1(a, b) {\n        return atan2(a[0] * b[1] - a[1] * b[0], a[0] * b[0] + a[1] * b[1]);\n    }\n    // Creates a polyhedral projection.\n    //  * root: a spanning tree of polygon faces.  Nodes are automatically\n    //    augmented with a transform matrix.\n    //  * face: a function that returns the appropriate node for a given {lambda, phi}\n    //    point (radians).\n    //  * r: rotation angle for final polyhedral net.  Defaults to -pi / 6 (for\n    //    butterflies).\n    var polyhedral = function (root, face, r) {\n        r = r == null ? -pi / 6 : r; // TODO automate\n        recurse(root, { transform: [\n                cos(r), sin(r), 0,\n                -sin(r), cos(r), 0\n            ] });\n        function recurse(node, parent) {\n            node.edges = faceEdges(node.face);\n            // Find shared edge.\n            if (parent.face) {\n                var shared = node.shared = sharedEdge(node.face, parent.face), m = matrix(shared.map(parent.project), shared.map(node.project));\n                node.transform = parent.transform ? multiply(parent.transform, m) : m;\n                // Replace shared edge in parent edges array.\n                var edges = parent.edges;\n                for (var i = 0, n = edges.length; i < n; ++i) {\n                    if (pointEqual$1(shared[0], edges[i][1]) && pointEqual$1(shared[1], edges[i][0]))\n                        edges[i] = node;\n                    if (pointEqual$1(shared[0], edges[i][0]) && pointEqual$1(shared[1], edges[i][1]))\n                        edges[i] = node;\n                }\n                edges = node.edges;\n                for (i = 0, n = edges.length; i < n; ++i) {\n                    if (pointEqual$1(shared[0], edges[i][0]) && pointEqual$1(shared[1], edges[i][1]))\n                        edges[i] = parent;\n                    if (pointEqual$1(shared[0], edges[i][1]) && pointEqual$1(shared[1], edges[i][0]))\n                        edges[i] = parent;\n                }\n            }\n            else {\n                node.transform = parent.transform;\n            }\n            if (node.children) {\n                node.children.forEach(function (child) {\n                    recurse(child, node);\n                });\n            }\n            return node;\n        }\n        function forward(lambda, phi) {\n            var node = face(lambda, phi), point = node.project([lambda * degrees, phi * degrees]), t;\n            if (t = node.transform) {\n                return [\n                    t[0] * point[0] + t[1] * point[1] + t[2],\n                    -(t[3] * point[0] + t[4] * point[1] + t[5])\n                ];\n            }\n            point[1] = -point[1];\n            return point;\n        }\n        // Naive inverse!  A faster solution would use bounding boxes, or even a\n        // polygonal quadtree.\n        if (hasInverse(root))\n            forward.invert = function (x, y) {\n                var coordinates = faceInvert(root, [x, -y]);\n                return coordinates && (coordinates[0] *= radians, coordinates[1] *= radians, coordinates);\n            };\n        function faceInvert(node, coordinates) {\n            var invert = node.project.invert, t = node.transform, point = coordinates;\n            if (t) {\n                t = inverse(t);\n                point = [\n                    t[0] * point[0] + t[1] * point[1] + t[2],\n                    (t[3] * point[0] + t[4] * point[1] + t[5])\n                ];\n            }\n            if (invert && node === faceDegrees(p = invert(point)))\n                return p;\n            var p, children = node.children;\n            for (var i = 0, n = children && children.length; i < n; ++i) {\n                if (p = faceInvert(children[i], coordinates))\n                    return p;\n            }\n        }\n        function faceDegrees(coordinates) {\n            return face(coordinates[0] * radians, coordinates[1] * radians);\n        }\n        var proj = d3Geo.geoProjection(forward), stream_ = proj.stream;\n        proj.stream = function (stream) {\n            var rotate = proj.rotate(), rotateStream = stream_(stream), sphereStream = (proj.rotate([0, 0]), stream_(stream));\n            proj.rotate(rotate);\n            rotateStream.sphere = function () {\n                sphereStream.polygonStart();\n                sphereStream.lineStart();\n                outline(sphereStream, root);\n                sphereStream.lineEnd();\n                sphereStream.polygonEnd();\n            };\n            return rotateStream;\n        };\n        return proj;\n    };\n    function outline(stream, node, parent) {\n        var point, edges = node.edges, n = edges.length, edge, multiPoint = { type: \"MultiPoint\", coordinates: node.face }, notPoles = node.face.filter(function (d) { return abs(d[1]) !== 90; }), b = d3Geo.geoBounds({ type: \"MultiPoint\", coordinates: notPoles }), inside = false, j = -1, dx = b[1][0] - b[0][0];\n        // TODO\n        var c = dx === 180 || dx === 360\n            ? [(b[0][0] + b[1][0]) / 2, (b[0][1] + b[1][1]) / 2]\n            : d3Geo.geoCentroid(multiPoint);\n        // First find the shared edge…\n        if (parent)\n            while (++j < n) {\n                if (edges[j] === parent)\n                    break;\n            }\n        ++j;\n        for (var i = 0; i < n; ++i) {\n            edge = edges[(i + j) % n];\n            if (Array.isArray(edge)) {\n                if (!inside) {\n                    stream.point((point = d3Geo.geoInterpolate(edge[0], c)(epsilon))[0], point[1]);\n                    inside = true;\n                }\n                stream.point((point = d3Geo.geoInterpolate(edge[1], c)(epsilon))[0], point[1]);\n            }\n            else {\n                inside = false;\n                if (edge !== parent)\n                    outline(stream, edge, node);\n            }\n        }\n    }\n    // Tests equality of two spherical points.\n    function pointEqual$1(a, b) {\n        return a && b && a[0] === b[0] && a[1] === b[1];\n    }\n    // Finds a shared edge given two clockwise polygons.\n    function sharedEdge(a, b) {\n        var x, y, n = a.length, found = null;\n        for (var i = 0; i < n; ++i) {\n            x = a[i];\n            for (var j = b.length; --j >= 0;) {\n                y = b[j];\n                if (x[0] === y[0] && x[1] === y[1]) {\n                    if (found)\n                        return [found, x];\n                    found = x;\n                }\n            }\n        }\n    }\n    // Converts an array of n face vertices to an array of n + 1 edges.\n    function faceEdges(face) {\n        var n = face.length, edges = [];\n        for (var a = face[n - 1], i = 0; i < n; ++i)\n            edges.push([a, a = face[i]]);\n        return edges;\n    }\n    function hasInverse(node) {\n        return node.project.invert || node.children && node.children.some(hasInverse);\n    }\n    // TODO generate on-the-fly to avoid external modification.\n    var octahedron = [\n        [0, 90],\n        [-90, 0], [0, 0], [90, 0], [180, 0],\n        [0, -90]\n    ];\n    var octahedron$1 = [\n        [0, 2, 1],\n        [0, 3, 2],\n        [5, 1, 2],\n        [5, 2, 3],\n        [0, 1, 4],\n        [0, 4, 3],\n        [5, 4, 1],\n        [5, 3, 4]\n    ].map(function (face) {\n        return face.map(function (i) {\n            return octahedron[i];\n        });\n    });\n    var butterfly = function (faceProjection) {\n        faceProjection = faceProjection || function (face) {\n            var c = d3Geo.geoCentroid({ type: \"MultiPoint\", coordinates: face });\n            return d3Geo.geoGnomonic().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);\n        };\n        var faces = octahedron$1.map(function (face) {\n            return { face: face, project: faceProjection(face) };\n        });\n        [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function (d, i) {\n            var node = faces[d];\n            node && (node.children || (node.children = [])).push(faces[i]);\n        });\n        return polyhedral(faces[0], function (lambda, phi) {\n            return faces[lambda < -pi / 2 ? phi < 0 ? 6 : 4\n                : lambda < 0 ? phi < 0 ? 2 : 0\n                    : lambda < pi / 2 ? phi < 0 ? 3 : 1\n                        : phi < 0 ? 7 : 5];\n        })\n            .scale(101.858)\n            .center([0, 45]);\n    };\n    var kx = 2 / sqrt(3);\n    function collignonK(a, b) {\n        var p = collignonRaw(a, b);\n        return [p[0] * kx, p[1]];\n    }\n    collignonK.invert = function (x, y) {\n        return collignonRaw.invert(x / kx, y);\n    };\n    var collignon$1 = function (faceProjection) {\n        faceProjection = faceProjection || function (face) {\n            var c = d3Geo.geoCentroid({ type: \"MultiPoint\", coordinates: face });\n            return d3Geo.geoProjection(collignonK).translate([0, 0]).scale(1).rotate(c[1] > 0 ? [-c[0], 0] : [180 - c[0], 180]);\n        };\n        var faces = octahedron$1.map(function (face) {\n            return { face: face, project: faceProjection(face) };\n        });\n        [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function (d, i) {\n            var node = faces[d];\n            node && (node.children || (node.children = [])).push(faces[i]);\n        });\n        return polyhedral(faces[0], function (lambda, phi) {\n            return faces[lambda < -pi / 2 ? phi < 0 ? 6 : 4\n                : lambda < 0 ? phi < 0 ? 2 : 0\n                    : lambda < pi / 2 ? phi < 0 ? 3 : 1\n                        : phi < 0 ? 7 : 5];\n        })\n            .scale(121.906)\n            .center([0, 48.5904]);\n    };\n    var waterman = function (faceProjection) {\n        faceProjection = faceProjection || function (face) {\n            var c = face.length === 6 ? d3Geo.geoCentroid({ type: \"MultiPoint\", coordinates: face }) : face[0];\n            return d3Geo.geoGnomonic().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);\n        };\n        var w5 = octahedron$1.map(function (face) {\n            var xyz = face.map(cartesian), n = xyz.length, a = xyz[n - 1], b, hexagon = [];\n            for (var i = 0; i < n; ++i) {\n                b = xyz[i];\n                hexagon.push(spherical([\n                    a[0] * 0.9486832980505138 + b[0] * 0.31622776601683794,\n                    a[1] * 0.9486832980505138 + b[1] * 0.31622776601683794,\n                    a[2] * 0.9486832980505138 + b[2] * 0.31622776601683794\n                ]), spherical([\n                    b[0] * 0.9486832980505138 + a[0] * 0.31622776601683794,\n                    b[1] * 0.9486832980505138 + a[1] * 0.31622776601683794,\n                    b[2] * 0.9486832980505138 + a[2] * 0.31622776601683794\n                ]));\n                a = b;\n            }\n            return hexagon;\n        });\n        var cornerNormals = [];\n        var parents = [-1, 0, 0, 1, 0, 1, 4, 5];\n        w5.forEach(function (hexagon, j) {\n            var face = octahedron$1[j], n = face.length, normals = cornerNormals[j] = [];\n            for (var i = 0; i < n; ++i) {\n                w5.push([\n                    face[i],\n                    hexagon[(i * 2 + 2) % (2 * n)],\n                    hexagon[(i * 2 + 1) % (2 * n)]\n                ]);\n                parents.push(j);\n                normals.push(cross(cartesian(hexagon[(i * 2 + 2) % (2 * n)]), cartesian(hexagon[(i * 2 + 1) % (2 * n)])));\n            }\n        });\n        var faces = w5.map(function (face) {\n            return {\n                project: faceProjection(face),\n                face: face\n            };\n        });\n        parents.forEach(function (d, i) {\n            var parent = faces[d];\n            parent && (parent.children || (parent.children = [])).push(faces[i]);\n        });\n        function face(lambda, phi) {\n            var cosphi = cos(phi), p = [cosphi * cos(lambda), cosphi * sin(lambda), sin(phi)];\n            var hexagon = lambda < -pi / 2 ? phi < 0 ? 6 : 4\n                : lambda < 0 ? phi < 0 ? 2 : 0\n                    : lambda < pi / 2 ? phi < 0 ? 3 : 1\n                        : phi < 0 ? 7 : 5;\n            var n = cornerNormals[hexagon];\n            return faces[dot(n[0], p) < 0 ? 8 + 3 * hexagon\n                : dot(n[1], p) < 0 ? 8 + 3 * hexagon + 1\n                    : dot(n[2], p) < 0 ? 8 + 3 * hexagon + 2\n                        : hexagon];\n        }\n        return polyhedral(faces[0], face)\n            .scale(110.625)\n            .center([0, 45]);\n    };\n    function dot(a, b) {\n        for (var i = 0, n = a.length, s = 0; i < n; ++i)\n            s += a[i] * b[i];\n        return s;\n    }\n    function cross(a, b) {\n        return [\n            a[1] * b[2] - a[2] * b[1],\n            a[2] * b[0] - a[0] * b[2],\n            a[0] * b[1] - a[1] * b[0]\n        ];\n    }\n    // Converts 3D Cartesian to spherical coordinates (degrees).\n    function spherical(cartesian) {\n        return [\n            atan2(cartesian[1], cartesian[0]) * degrees,\n            asin(max(-1, min(1, cartesian[2]))) * degrees\n        ];\n    }\n    // Converts spherical coordinates (degrees) to 3D Cartesian.\n    function cartesian(coordinates) {\n        var lambda = coordinates[0] * radians, phi = coordinates[1] * radians, cosphi = cos(phi);\n        return [\n            cosphi * cos(lambda),\n            cosphi * sin(lambda),\n            sin(phi)\n        ];\n    }\n    var noop = function () { };\n    var clockwise = function (ring) {\n        if ((n = ring.length) < 4)\n            return false;\n        var i = 0, n, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n        while (++i < n)\n            area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n        return area <= 0;\n    };\n    var contains = function (ring, point) {\n        var x = point[0], y = point[1], contains = false;\n        for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n            var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];\n            if (((yi > y) ^ (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi))\n                contains = !contains;\n        }\n        return contains;\n    };\n    var index = function (object, projection) {\n        var stream = projection.stream, project;\n        if (!stream)\n            throw new Error(\"invalid projection\");\n        switch (object && object.type) {\n            case \"Feature\":\n                project = projectFeature;\n                break;\n            case \"FeatureCollection\":\n                project = projectFeatureCollection;\n                break;\n            default:\n                project = projectGeometry;\n                break;\n        }\n        return project(object, stream);\n    };\n    function projectFeatureCollection(o, stream) {\n        return {\n            type: \"FeatureCollection\",\n            features: o.features.map(function (f) {\n                return projectFeature(f, stream);\n            })\n        };\n    }\n    function projectFeature(o, stream) {\n        return {\n            type: \"Feature\",\n            id: o.id,\n            properties: o.properties,\n            geometry: projectGeometry(o.geometry, stream)\n        };\n    }\n    function projectGeometryCollection(o, stream) {\n        return {\n            type: \"GeometryCollection\",\n            geometries: o.geometries.map(function (o) {\n                return projectGeometry(o, stream);\n            })\n        };\n    }\n    function projectGeometry(o, stream) {\n        if (!o)\n            return null;\n        if (o.type === \"GeometryCollection\")\n            return projectGeometryCollection(o, stream);\n        var sink;\n        switch (o.type) {\n            case \"Point\":\n                sink = sinkPoint;\n                break;\n            case \"MultiPoint\":\n                sink = sinkPoint;\n                break;\n            case \"LineString\":\n                sink = sinkLine;\n                break;\n            case \"MultiLineString\":\n                sink = sinkLine;\n                break;\n            case \"Polygon\":\n                sink = sinkPolygon;\n                break;\n            case \"MultiPolygon\":\n                sink = sinkPolygon;\n                break;\n            case \"Sphere\":\n                sink = sinkPolygon;\n                break;\n            default: return null;\n        }\n        d3Geo.geoStream(o, stream(sink));\n        return sink.result();\n    }\n    var points = [];\n    var lines = [];\n    var sinkPoint = {\n        point: function (x, y) {\n            points.push([x, y]);\n        },\n        result: function () {\n            var result = !points.length ? null\n                : points.length < 2 ? { type: \"Point\", coordinates: points[0] }\n                    : { type: \"MultiPoint\", coordinates: points };\n            points = [];\n            return result;\n        }\n    };\n    var sinkLine = {\n        lineStart: noop,\n        point: function (x, y) {\n            points.push([x, y]);\n        },\n        lineEnd: function () {\n            if (points.length)\n                lines.push(points), points = [];\n        },\n        result: function () {\n            var result = !lines.length ? null\n                : lines.length < 2 ? { type: \"LineString\", coordinates: lines[0] }\n                    : { type: \"MultiLineString\", coordinates: lines };\n            lines = [];\n            return result;\n        }\n    };\n    var sinkPolygon = {\n        polygonStart: noop,\n        lineStart: noop,\n        point: function (x, y) {\n            points.push([x, y]);\n        },\n        lineEnd: function () {\n            var n = points.length;\n            if (n) {\n                do\n                    points.push(points[0].slice());\n                while (++n < 4);\n                lines.push(points), points = [];\n            }\n        },\n        polygonEnd: noop,\n        result: function () {\n            if (!lines.length)\n                return null;\n            var polygons = [], holes = [];\n            // https://github.com/d3/d3/issues/1558\n            lines.forEach(function (ring) {\n                if (clockwise(ring))\n                    polygons.push([ring]);\n                else\n                    holes.push(ring);\n            });\n            holes.forEach(function (hole) {\n                var point = hole[0];\n                polygons.some(function (polygon) {\n                    if (contains(polygon[0], point)) {\n                        polygon.push(hole);\n                        return true;\n                    }\n                }) || polygons.push([hole]);\n            });\n            lines = [];\n            return !polygons.length ? null\n                : polygons.length > 1 ? { type: \"MultiPolygon\", coordinates: polygons }\n                    : { type: \"Polygon\", coordinates: polygons[0] };\n        }\n    };\n    var quincuncial = function (project) {\n        var dx = project(halfPi, 0)[0] - project(-halfPi, 0)[0];\n        function projectQuincuncial(lambda, phi) {\n            var t = abs(lambda) < halfPi, p = project(t ? lambda : lambda > 0 ? lambda - pi : lambda + pi, phi), x = (p[0] - p[1]) * sqrt1_2, y = (p[0] + p[1]) * sqrt1_2;\n            if (t)\n                return [x, y];\n            var d = dx * sqrt1_2, s = x > 0 ^ y > 0 ? -1 : 1;\n            return [s * x - sign(y) * d, s * y - sign(x) * d];\n        }\n        if (project.invert)\n            projectQuincuncial.invert = function (x0, y0) {\n                var x = (x0 + y0) * sqrt1_2, y = (y0 - x0) * sqrt1_2, t = abs(x) < 0.5 * dx && abs(y) < 0.5 * dx;\n                if (!t) {\n                    var d = dx * sqrt1_2, s = x > 0 ^ y > 0 ? -1 : 1, x1 = -s * x0 + (y > 0 ? 1 : -1) * d, y1 = -s * y0 + (x > 0 ? 1 : -1) * d;\n                    x = (-x1 - y1) * sqrt1_2;\n                    y = (x1 - y1) * sqrt1_2;\n                }\n                var p = project.invert(x, y);\n                if (!t)\n                    p[0] += x > 0 ? pi : -pi;\n                return p;\n            };\n        return d3Geo.geoProjection(projectQuincuncial)\n            .rotate([-90, -90, 45])\n            .clipAngle(180 - 1e-3);\n    };\n    var gringorten$1 = function () {\n        return quincuncial(gringortenRaw)\n            .scale(176.423);\n    };\n    var peirce = function () {\n        return quincuncial(guyouRaw)\n            .scale(111.48);\n    };\n    var quantize = function (input, digits) {\n        if (!(0 <= (digits = +digits) && digits <= 20))\n            throw new Error(\"invalid digits\");\n        function quantizePoint(input) {\n            var n = input.length, i = 2, output = new Array(n);\n            output[0] = +input[0].toFixed(digits);\n            output[1] = +input[1].toFixed(digits);\n            while (i < n)\n                output[i] = input[i], ++i;\n            return output;\n        }\n        function quantizePoints(input) {\n            return input.map(quantizePoint);\n        }\n        function quantizePolygon(input) {\n            return input.map(quantizePoints);\n        }\n        function quantizeGeometry(input) {\n            if (input == null)\n                return input;\n            var output;\n            switch (input.type) {\n                case \"GeometryCollection\":\n                    output = { type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry) };\n                    break;\n                case \"Point\":\n                    output = { type: \"Point\", coordinates: quantizePoint(input.coordinates) };\n                    break;\n                case \"MultiPoint\":\n                case \"LineString\":\n                    output = { type: input.type, coordinates: quantizePoints(input.coordinates) };\n                    break;\n                case \"MultiLineString\":\n                case \"Polygon\":\n                    output = { type: input.type, coordinates: quantizePolygon(input.coordinates) };\n                    break;\n                case \"MultiPolygon\":\n                    output = { type: \"MultiPolygon\", coordinates: input.coordinates.map(quantizePolygon) };\n                    break;\n                default: return input;\n            }\n            if (input.bbox != null)\n                output.bbox = input.bbox;\n            return output;\n        }\n        function quantizeFeature(input) {\n            var output = { type: \"Feature\", properties: input.properties, geometry: quantizeGeometry(input.geometry) };\n            if (input.id != null)\n                output.id = input.id;\n            if (input.bbox != null)\n                output.bbox = input.bbox;\n            return output;\n        }\n        if (input != null)\n            switch (input.type) {\n                case \"Feature\": return quantizeFeature(input);\n                case \"FeatureCollection\": {\n                    var output = { type: \"FeatureCollection\", features: input.features.map(quantizeFeature) };\n                    if (input.bbox != null)\n                        output.bbox = input.bbox;\n                    return output;\n                }\n                default: return quantizeGeometry(input);\n            }\n        return input;\n    };\n    function rectangularPolyconicRaw(phi0) {\n        var sinPhi0 = sin(phi0);\n        function forward(lambda, phi) {\n            var A = sinPhi0 ? tan(lambda * sinPhi0 / 2) / sinPhi0 : lambda / 2;\n            if (!phi)\n                return [2 * A, -phi0];\n            var E = 2 * atan(A * sin(phi)), cotPhi = 1 / tan(phi);\n            return [\n                sin(E) * cotPhi,\n                phi + (1 - cos(E)) * cotPhi - phi0\n            ];\n        }\n        // TODO return null for points outside outline.\n        forward.invert = function (x, y) {\n            if (abs(y += phi0) < epsilon)\n                return [sinPhi0 ? 2 * atan(sinPhi0 * x / 2) / sinPhi0 : x, 0];\n            var k = x * x + y * y, phi = 0, i = 10, delta;\n            do {\n                var tanPhi = tan(phi), secPhi = 1 / cos(phi), j = k - 2 * y * phi + phi * phi;\n                phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi);\n            } while (abs(delta) > epsilon && --i > 0);\n            var E = x * (tanPhi = tan(phi)), A = tan(abs(y) < abs(phi + 1 / tanPhi) ? asin(E) * 0.5 : acos(E) * 0.5 + pi / 4) / sin(phi);\n            return [\n                sinPhi0 ? 2 * atan(sinPhi0 * A) / sinPhi0 : 2 * A,\n                phi\n            ];\n        };\n        return forward;\n    }\n    var rectangularPolyconic = function () {\n        return parallel1(rectangularPolyconicRaw)\n            .scale(131.215);\n    };\n    var K = [\n        [0.9986, -0.062],\n        [1.0000, 0.0000],\n        [0.9986, 0.0620],\n        [0.9954, 0.1240],\n        [0.9900, 0.1860],\n        [0.9822, 0.2480],\n        [0.9730, 0.3100],\n        [0.9600, 0.3720],\n        [0.9427, 0.4340],\n        [0.9216, 0.4958],\n        [0.8962, 0.5571],\n        [0.8679, 0.6176],\n        [0.8350, 0.6769],\n        [0.7986, 0.7346],\n        [0.7597, 0.7903],\n        [0.7186, 0.8435],\n        [0.6732, 0.8936],\n        [0.6213, 0.9394],\n        [0.5722, 0.9761],\n        [0.5322, 1.0000]\n    ];\n    K.forEach(function (d) {\n        d[1] *= 1.0144;\n    });\n    function robinsonRaw(lambda, phi) {\n        var i = min(18, abs(phi) * 36 / pi), i0 = floor(i), di = i - i0, ax = (k = K[i0])[0], ay = k[1], bx = (k = K[++i0])[0], by = k[1], cx = (k = K[min(19, ++i0)])[0], cy = k[1], k;\n        return [\n            lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),\n            (phi > 0 ? halfPi : -halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)\n        ];\n    }\n    robinsonRaw.invert = function (x, y) {\n        var yy = y / halfPi, phi = yy * 90, i = min(18, abs(phi / 5)), i0 = max(0, floor(i));\n        do {\n            var ay = K[i0][1], by = K[i0 + 1][1], cy = K[min(19, i0 + 2)][1], u = cy - ay, v = cy - 2 * by + ay, t = 2 * (abs(yy) - by) / u, c = v / u, di = t * (1 - c * t * (1 - 2 * c * t));\n            if (di >= 0 || i0 === 1) {\n                phi = (y >= 0 ? 5 : -5) * (di + i);\n                var j = 50, delta;\n                do {\n                    i = min(18, abs(phi) / 5);\n                    i0 = floor(i);\n                    di = i - i0;\n                    ay = K[i0][1];\n                    by = K[i0 + 1][1];\n                    cy = K[min(19, i0 + 2)][1];\n                    phi -= (delta = (y >= 0 ? halfPi : -halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * degrees;\n                } while (abs(delta) > epsilon2 && --j > 0);\n                break;\n            }\n        } while (--i0 >= 0);\n        var ax = K[i0][0], bx = K[i0 + 1][0], cx = K[min(19, i0 + 2)][0];\n        return [\n            x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),\n            phi * radians\n        ];\n    };\n    var robinson = function () {\n        return d3Geo.geoProjection(robinsonRaw)\n            .scale(152.63);\n    };\n    function satelliteVerticalRaw(P) {\n        function forward(lambda, phi) {\n            var cosPhi = cos(phi), k = (P - 1) / (P - cosPhi * cos(lambda));\n            return [\n                k * cosPhi * sin(lambda),\n                k * sin(phi)\n            ];\n        }\n        forward.invert = function (x, y) {\n            var rho2 = x * x + y * y, rho = sqrt(rho2), sinc = (P - sqrt(1 - rho2 * (P + 1) / (P - 1))) / ((P - 1) / rho + rho / (P - 1));\n            return [\n                atan2(x * sinc, rho * sqrt(1 - sinc * sinc)),\n                rho ? asin(y * sinc / rho) : 0\n            ];\n        };\n        return forward;\n    }\n    function satelliteRaw(P, omega) {\n        var vertical = satelliteVerticalRaw(P);\n        if (!omega)\n            return vertical;\n        var cosOmega = cos(omega), sinOmega = sin(omega);\n        function forward(lambda, phi) {\n            var coordinates = vertical(lambda, phi), y = coordinates[1], A = y * sinOmega / (P - 1) + cosOmega;\n            return [\n                coordinates[0] * cosOmega / A,\n                y / A\n            ];\n        }\n        forward.invert = function (x, y) {\n            var k = (P - 1) / (P - 1 - y * sinOmega);\n            return vertical.invert(k * x, k * y * cosOmega);\n        };\n        return forward;\n    }\n    var satellite = function () {\n        var distance = 2, omega = 0, m = d3Geo.geoProjectionMutator(satelliteRaw), p = m(distance, omega);\n        // As a multiple of radius.\n        p.distance = function (_) {\n            if (!arguments.length)\n                return distance;\n            return m(distance = +_, omega);\n        };\n        p.tilt = function (_) {\n            if (!arguments.length)\n                return omega * degrees;\n            return m(distance, omega = _ * radians);\n        };\n        return p\n            .scale(432.147)\n            .clipAngle(acos(1 / distance) * degrees - 1e-6);\n    };\n    var epsilon$1 = 1e-4;\n    var epsilonInverse = 1e4;\n    var x0 = -180;\n    var x0e = x0 + epsilon$1;\n    var x1 = 180;\n    var x1e = x1 - epsilon$1;\n    var y0 = -90;\n    var y0e = y0 + epsilon$1;\n    var y1 = 90;\n    var y1e = y1 - epsilon$1;\n    function nonempty(coordinates) {\n        return coordinates.length > 0;\n    }\n    function quantize$1(x) {\n        return Math.floor(x * epsilonInverse) / epsilonInverse;\n    }\n    function normalizePoint(y) {\n        return y === y0 || y === y1 ? [0, y] : [x0, quantize$1(y)]; // pole or antimeridian?\n    }\n    function clampPoint(p) {\n        var x = p[0], y = p[1], clamped = false;\n        if (x <= x0e)\n            x = x0, clamped = true;\n        else if (x >= x1e)\n            x = x1, clamped = true;\n        if (y <= y0e)\n            y = y0, clamped = true;\n        else if (y >= y1e)\n            y = y1, clamped = true;\n        return clamped ? [x, y] : p;\n    }\n    function clampPoints(points) {\n        return points.map(clampPoint);\n    }\n    // For each ring, detect where it crosses the antimeridian or pole.\n    function extractFragments(rings, polygon, fragments) {\n        for (var j = 0, m = rings.length; j < m; ++j) {\n            var ring = rings[j].slice();\n            // By default, assume that this ring doesn’t need any stitching.\n            fragments.push({ index: -1, polygon: polygon, ring: ring });\n            for (var i = 0, n = ring.length; i < n; ++i) {\n                var point = ring[i], x = point[0], y = point[1];\n                // If this is an antimeridian or polar point…\n                if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {\n                    ring[i] = clampPoint(point);\n                    // Advance through any antimeridian or polar points…\n                    for (var k = i + 1; k < n; ++k) {\n                        var pointk = ring[k], xk = pointk[0], yk = pointk[1];\n                        if (xk > x0e && xk < x1e && yk > y0e && yk < y1e)\n                            break;\n                    }\n                    // If this was just a single antimeridian or polar point,\n                    // we don’t need to cut this ring into a fragment;\n                    // we can just leave it as-is.\n                    if (k === i + 1)\n                        continue;\n                    // Otherwise, if this is not the first point in the ring,\n                    // cut the current fragment so that it ends at the current point.\n                    // The current point is also normalized for later joining.\n                    if (i) {\n                        var fragmentBefore = { index: -1, polygon: polygon, ring: ring.slice(0, i + 1) };\n                        fragmentBefore.ring[fragmentBefore.ring.length - 1] = normalizePoint(y);\n                        fragments[fragments.length - 1] = fragmentBefore;\n                    }\n                    // If the ring started with an antimeridian fragment,\n                    // we can ignore that fragment entirely.\n                    else\n                        fragments.pop();\n                    // If the remainder of the ring is an antimeridian fragment,\n                    // move on to the next ring.\n                    if (k >= n)\n                        break;\n                    // Otherwise, add the remaining ring fragment and continue.\n                    fragments.push({ index: -1, polygon: polygon, ring: ring = ring.slice(k - 1) });\n                    ring[0] = normalizePoint(ring[0][1]);\n                    i = -1;\n                    n = ring.length;\n                }\n            }\n        }\n    }\n    // Now stitch the fragments back together into rings.\n    function stitchFragments(fragments) {\n        var i, n = fragments.length;\n        // To connect the fragments start-to-end, create a simple index by end.\n        var fragmentByStart = {}, fragmentByEnd = {}, fragment, start, startFragment, end, endFragment;\n        // For each fragment…\n        for (i = 0; i < n; ++i) {\n            fragment = fragments[i];\n            start = fragment.ring[0];\n            end = fragment.ring[fragment.ring.length - 1];\n            // If this fragment is closed, add it as a standalone ring.\n            if (start[0] === end[0] && start[1] === end[1]) {\n                fragment.polygon.push(fragment.ring);\n                fragments[i] = null;\n                continue;\n            }\n            fragment.index = i;\n            fragmentByStart[start] = fragmentByEnd[end] = fragment;\n        }\n        // For each open fragment…\n        for (i = 0; i < n; ++i) {\n            fragment = fragments[i];\n            if (fragment) {\n                start = fragment.ring[0];\n                end = fragment.ring[fragment.ring.length - 1];\n                startFragment = fragmentByEnd[start];\n                endFragment = fragmentByStart[end];\n                delete fragmentByStart[start];\n                delete fragmentByEnd[end];\n                // If this fragment is closed, add it as a standalone ring.\n                if (start[0] === end[0] && start[1] === end[1]) {\n                    fragment.polygon.push(fragment.ring);\n                    continue;\n                }\n                if (startFragment) {\n                    delete fragmentByEnd[start];\n                    delete fragmentByStart[startFragment.ring[0]];\n                    startFragment.ring.pop(); // drop the shared coordinate\n                    fragments[startFragment.index] = null;\n                    fragment = { index: -1, polygon: startFragment.polygon, ring: startFragment.ring.concat(fragment.ring) };\n                    if (startFragment === endFragment) {\n                        // Connect both ends to this single fragment to create a ring.\n                        fragment.polygon.push(fragment.ring);\n                    }\n                    else {\n                        fragment.index = n++;\n                        fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n                    }\n                }\n                else if (endFragment) {\n                    delete fragmentByStart[end];\n                    delete fragmentByEnd[endFragment.ring[endFragment.ring.length - 1]];\n                    fragment.ring.pop(); // drop the shared coordinate\n                    fragment = { index: n++, polygon: endFragment.polygon, ring: fragment.ring.concat(endFragment.ring) };\n                    fragments[endFragment.index] = null;\n                    fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n                }\n                else {\n                    fragment.ring.push(fragment.ring[0]); // close ring\n                    fragment.polygon.push(fragment.ring);\n                }\n            }\n        }\n    }\n    function stitchFeature(input) {\n        var output = { type: \"Feature\", geometry: stitchGeometry(input.geometry) };\n        if (input.id != null)\n            output.id = input.id;\n        if (input.bbox != null)\n            output.bbox = input.bbox;\n        if (input.properties != null)\n            output.properties = input.properties;\n        return output;\n    }\n    function stitchGeometry(input) {\n        if (input == null)\n            return input;\n        var output, fragments, i, n;\n        switch (input.type) {\n            case \"GeometryCollection\":\n                output = { type: \"GeometryCollection\", geometries: input.geometries.map(stitchGeometry) };\n                break;\n            case \"Point\":\n                output = { type: \"Point\", coordinates: clampPoint(input.coordinates) };\n                break;\n            case \"MultiPoint\":\n            case \"LineString\":\n                output = { type: input.type, coordinates: clampPoints(input.coordinates) };\n                break;\n            case \"MultiLineString\":\n                output = { type: \"MultiLineString\", coordinates: input.coordinates.map(clampPoints) };\n                break;\n            case \"Polygon\": {\n                var polygon = [];\n                extractFragments(input.coordinates, polygon, fragments = []);\n                stitchFragments(fragments);\n                output = { type: \"Polygon\", coordinates: polygon };\n                break;\n            }\n            case \"MultiPolygon\": {\n                fragments = [], i = -1, n = input.coordinates.length;\n                var polygons = new Array(n);\n                while (++i < n)\n                    extractFragments(input.coordinates[i], polygons[i] = [], fragments);\n                stitchFragments(fragments);\n                output = { type: \"MultiPolygon\", coordinates: polygons.filter(nonempty) };\n                break;\n            }\n            default: return input;\n        }\n        if (input.bbox != null)\n            output.bbox = input.bbox;\n        return output;\n    }\n    var stitch = function (input) {\n        if (input == null)\n            return input;\n        switch (input.type) {\n            case \"Feature\": return stitchFeature(input);\n            case \"FeatureCollection\": {\n                var output = { type: \"FeatureCollection\", features: input.features.map(stitchFeature) };\n                if (input.bbox != null)\n                    output.bbox = input.bbox;\n                return output;\n            }\n            default: return stitchGeometry(input);\n        }\n    };\n    function timesRaw(lambda, phi) {\n        var t = tan(phi / 2), s = sin(quarterPi * t);\n        return [\n            lambda * (0.74482 - 0.34588 * s * s),\n            1.70711 * t\n        ];\n    }\n    timesRaw.invert = function (x, y) {\n        var t = y / 1.70711, s = sin(quarterPi * t);\n        return [\n            x / (0.74482 - 0.34588 * s * s),\n            2 * atan(t)\n        ];\n    };\n    var times = function () {\n        return d3Geo.geoProjection(timesRaw)\n            .scale(146.153);\n    };\n    // Compute the origin as the midpoint of the two reference points.\n    // Rotate one of the reference points by the origin.\n    // Apply the spherical law of sines to compute gamma rotation.\n    var twoPoint = function (raw, p0, p1) {\n        var i = d3Geo.geoInterpolate(p0, p1), o = i(0.5), a = d3Geo.geoRotation([-o[0], -o[1]])(p0), b = i.distance / 2, y = -asin(sin(a[1] * radians) / sin(b)), R = [-o[0], -o[1], -(a[0] > 0 ? pi - y : y) * degrees], p = d3Geo.geoProjection(raw(b)).rotate(R), r = d3Geo.geoRotation(R), center = p.center;\n        delete p.rotate;\n        p.center = function (_) {\n            return arguments.length ? center(r(_)) : r.invert(center());\n        };\n        return p\n            .clipAngle(90);\n    };\n    function twoPointAzimuthalRaw(d) {\n        var cosd = cos(d);\n        function forward(lambda, phi) {\n            var coordinates = d3Geo.geoGnomonicRaw(lambda, phi);\n            coordinates[0] *= cosd;\n            return coordinates;\n        }\n        forward.invert = function (x, y) {\n            return d3Geo.geoGnomonicRaw.invert(x / cosd, y);\n        };\n        return forward;\n    }\n    function twoPointAzimuthalUsa() {\n        return twoPointAzimuthal([-158, 21.5], [-77, 39])\n            .clipAngle(60)\n            .scale(400);\n    }\n    function twoPointAzimuthal(p0, p1) {\n        return twoPoint(twoPointAzimuthalRaw, p0, p1);\n    }\n    // TODO clip to ellipse\n    function twoPointEquidistantRaw(z0) {\n        if (!(z0 *= 2))\n            return d3Geo.geoAzimuthalEquidistantRaw;\n        var lambdaa = -z0 / 2, lambdab = -lambdaa, z02 = z0 * z0, tanLambda0 = tan(lambdab), S = 0.5 / sin(lambdab);\n        function forward(lambda, phi) {\n            var za = acos(cos(phi) * cos(lambda - lambdaa)), zb = acos(cos(phi) * cos(lambda - lambdab)), ys = phi < 0 ? -1 : 1;\n            za *= za, zb *= zb;\n            return [\n                (za - zb) / (2 * z0),\n                ys * sqrt(4 * z02 * zb - (z02 - za + zb) * (z02 - za + zb)) / (2 * z0)\n            ];\n        }\n        forward.invert = function (x, y) {\n            var y2 = y * y, cosza = cos(sqrt(y2 + (t = x + lambdaa) * t)), coszb = cos(sqrt(y2 + (t = x + lambdab) * t)), t, d;\n            return [\n                atan2(d = cosza - coszb, t = (cosza + coszb) * tanLambda0),\n                (y < 0 ? -1 : 1) * acos(sqrt(t * t + d * d) * S)\n            ];\n        };\n        return forward;\n    }\n    function twoPointEquidistantUsa() {\n        return twoPointEquidistant([-158, 21.5], [-77, 39])\n            .clipAngle(130)\n            .scale(122.571);\n    }\n    function twoPointEquidistant(p0, p1) {\n        return twoPoint(twoPointEquidistantRaw, p0, p1);\n    }\n    function vanDerGrintenRaw(lambda, phi) {\n        if (abs(phi) < epsilon)\n            return [lambda, 0];\n        var sinTheta = abs(phi / halfPi), theta = asin(sinTheta);\n        if (abs(lambda) < epsilon || abs(abs(phi) - halfPi) < epsilon)\n            return [0, sign(phi) * pi * tan(theta / 2)];\n        var cosTheta = cos(theta), A = abs(pi / lambda - lambda / pi) / 2, A2 = A * A, G = cosTheta / (sinTheta + cosTheta - 1), P = G * (2 / sinTheta - 1), P2 = P * P, P2_A2 = P2 + A2, G_P2 = G - P2, Q = A2 + G;\n        return [\n            sign(lambda) * pi * (A * G_P2 + sqrt(A2 * G_P2 * G_P2 - P2_A2 * (G * G - P2))) / P2_A2,\n            sign(phi) * pi * (P * Q - A * sqrt((A2 + 1) * P2_A2 - Q * Q)) / P2_A2\n        ];\n    }\n    vanDerGrintenRaw.invert = function (x, y) {\n        if (abs(y) < epsilon)\n            return [x, 0];\n        if (abs(x) < epsilon)\n            return [0, halfPi * sin(2 * atan(y / pi))];\n        var x2 = (x /= pi) * x, y2 = (y /= pi) * y, x2_y2 = x2 + y2, z = x2_y2 * x2_y2, c1 = -abs(y) * (1 + x2_y2), c2 = c1 - 2 * y2 + x2, c3 = -2 * c1 + 1 + 2 * y2 + z, d = y2 / c3 + (2 * c2 * c2 * c2 / (c3 * c3 * c3) - 9 * c1 * c2 / (c3 * c3)) / 27, a1 = (c1 - c2 * c2 / (3 * c3)) / c3, m1 = 2 * sqrt(-a1 / 3), theta1 = acos(3 * d / (a1 * m1)) / 3;\n        return [\n            pi * (x2_y2 - 1 + sqrt(1 + 2 * (x2 - y2) + z)) / (2 * x),\n            sign(y) * pi * (-m1 * cos(theta1 + pi / 3) - c2 / (3 * c3))\n        ];\n    };\n    var vanDerGrinten = function () {\n        return d3Geo.geoProjection(vanDerGrintenRaw)\n            .scale(79.4183);\n    };\n    function vanDerGrinten2Raw(lambda, phi) {\n        if (abs(phi) < epsilon)\n            return [lambda, 0];\n        var sinTheta = abs(phi / halfPi), theta = asin(sinTheta);\n        if (abs(lambda) < epsilon || abs(abs(phi) - halfPi) < epsilon)\n            return [0, sign(phi) * pi * tan(theta / 2)];\n        var cosTheta = cos(theta), A = abs(pi / lambda - lambda / pi) / 2, A2 = A * A, x1 = cosTheta * (sqrt(1 + A2) - A * cosTheta) / (1 + A2 * sinTheta * sinTheta);\n        return [\n            sign(lambda) * pi * x1,\n            sign(phi) * pi * sqrt(1 - x1 * (2 * A + x1))\n        ];\n    }\n    vanDerGrinten2Raw.invert = function (x, y) {\n        if (!x)\n            return [0, halfPi * sin(2 * atan(y / pi))];\n        var x1 = abs(x / pi), A = (1 - x1 * x1 - (y /= pi) * y) / (2 * x1), A2 = A * A, B = sqrt(A2 + 1);\n        return [\n            sign(x) * pi * (B - A),\n            sign(y) * halfPi * sin(2 * atan2(sqrt((1 - 2 * A * x1) * (A + B) - x1), sqrt(B + A + x1)))\n        ];\n    };\n    var vanDerGrinten2 = function () {\n        return d3Geo.geoProjection(vanDerGrinten2Raw)\n            .scale(79.4183);\n    };\n    function vanDerGrinten3Raw(lambda, phi) {\n        if (abs(phi) < epsilon)\n            return [lambda, 0];\n        var sinTheta = phi / halfPi, theta = asin(sinTheta);\n        if (abs(lambda) < epsilon || abs(abs(phi) - halfPi) < epsilon)\n            return [0, pi * tan(theta / 2)];\n        var A = (pi / lambda - lambda / pi) / 2, y1 = sinTheta / (1 + cos(theta));\n        return [\n            pi * (sign(lambda) * sqrt(A * A + 1 - y1 * y1) - A),\n            pi * y1\n        ];\n    }\n    vanDerGrinten3Raw.invert = function (x, y) {\n        if (!y)\n            return [x, 0];\n        var y1 = y / pi, A = (pi * pi * (1 - y1 * y1) - x * x) / (2 * pi * x);\n        return [\n            x ? pi * (sign(x) * sqrt(A * A + 1) - A) : 0,\n            halfPi * sin(2 * atan(y1))\n        ];\n    };\n    var vanDerGrinten3 = function () {\n        return d3Geo.geoProjection(vanDerGrinten3Raw)\n            .scale(79.4183);\n    };\n    function vanDerGrinten4Raw(lambda, phi) {\n        if (!phi)\n            return [lambda, 0];\n        var phi0 = abs(phi);\n        if (!lambda || phi0 === halfPi)\n            return [0, phi];\n        var B = phi0 / halfPi, B2 = B * B, C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)), C2 = C * C, BC = B * C, B_C2 = B2 + C2 + 2 * BC, B_3C = B + 3 * C, lambda0 = lambda / halfPi, lambda1 = lambda0 + 1 / lambda0, D = sign(abs(lambda) - halfPi) * sqrt(lambda1 * lambda1 - 4), D2 = D * D, F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + 12 * BC * C2 + 4 * C2 * C2), x1 = (D * (B_C2 + C2 - 1) + 2 * sqrt(F)) / (4 * B_C2 + D2);\n        return [\n            sign(lambda) * halfPi * x1,\n            sign(phi) * halfPi * sqrt(1 + D * abs(x1) - x1 * x1)\n        ];\n    }\n    vanDerGrinten4Raw.invert = function (x, y) {\n        var delta;\n        if (!x || !y)\n            return [x, y];\n        y /= pi;\n        var x1 = sign(x) * x / halfPi, D = (x1 * x1 - 1 + 4 * y * y) / abs(x1), D2 = D * D, B = 2 * y, i = 50;\n        do {\n            var B2 = B * B, C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)), C_ = (3 * B - B2 * B - 10) / (2 * B2 * B), C2 = C * C, BC = B * C, B_C = B + C, B_C2 = B_C * B_C, B_3C = B + 3 * C, F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + C2 * (12 * BC + 4 * C2)), F_ = -2 * B_C * (4 * BC * C2 + (1 - 4 * B2 + 3 * B2 * B2) * (1 + C_) + C2 * (-6 + 14 * B2 - D2 + (-8 + 8 * B2 - 2 * D2) * C_) + BC * (-8 + 12 * B2 + (-10 + 10 * B2 - D2) * C_)), sqrtF = sqrt(F), f = D * (B_C2 + C2 - 1) + 2 * sqrtF - x1 * (4 * B_C2 + D2), f_ = D * (2 * C * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D * (-1 + C2 + B_C2) + 2 * sqrtF) * (1 + C_) / (D2 + 4 * B_C2);\n            B -= delta = f / f_;\n        } while (delta > epsilon && --i > 0);\n        return [\n            sign(x) * (sqrt(D * D + 4) + D) * pi / 4,\n            halfPi * B\n        ];\n    };\n    var vanDerGrinten4 = function () {\n        return d3Geo.geoProjection(vanDerGrinten4Raw)\n            .scale(127.16);\n    };\n    var A = 4 * pi + 3 * sqrt(3);\n    var B = 2 * sqrt(2 * pi * sqrt(3) / A);\n    var wagner4Raw = mollweideBromleyRaw(B * sqrt(3) / pi, B, A / 6);\n    var wagner4 = function () {\n        return d3Geo.geoProjection(wagner4Raw)\n            .scale(176.84);\n    };\n    function wagner6Raw(lambda, phi) {\n        return [lambda * sqrt(1 - 3 * phi * phi / (pi * pi)), phi];\n    }\n    wagner6Raw.invert = function (x, y) {\n        return [x / sqrt(1 - 3 * y * y / (pi * pi)), y];\n    };\n    var wagner6 = function () {\n        return d3Geo.geoProjection(wagner6Raw)\n            .scale(152.63);\n    };\n    function wagner7Raw(lambda, phi) {\n        var s = 0.90631 * sin(phi), c0 = sqrt(1 - s * s), c1 = sqrt(2 / (1 + c0 * cos(lambda /= 3)));\n        return [\n            2.66723 * c0 * c1 * sin(lambda),\n            1.24104 * s * c1\n        ];\n    }\n    wagner7Raw.invert = function (x, y) {\n        var t1 = x / 2.66723, t2 = y / 1.24104, p = sqrt(t1 * t1 + t2 * t2), c = 2 * asin(p / 2);\n        return [\n            3 * atan2(x * tan(c), 2.66723 * p),\n            p && asin(y * sin(c) / (1.24104 * 0.90631 * p))\n        ];\n    };\n    var wagner7 = function () {\n        return d3Geo.geoProjection(wagner7Raw)\n            .scale(172.632);\n    };\n    function wiechelRaw(lambda, phi) {\n        var cosPhi = cos(phi), sinPhi = cos(lambda) * cosPhi, sin1_Phi = 1 - sinPhi, cosLambda = cos(lambda = atan2(sin(lambda) * cosPhi, -sin(phi))), sinLambda = sin(lambda);\n        cosPhi = sqrt(1 - sinPhi * sinPhi);\n        return [\n            sinLambda * cosPhi - cosLambda * sin1_Phi,\n            -cosLambda * cosPhi - sinLambda * sin1_Phi\n        ];\n    }\n    wiechelRaw.invert = function (x, y) {\n        var w = (x * x + y * y) / -2, k = sqrt(-w * (2 + w)), b = y * w + x * k, a = x * w - y * k, D = sqrt(a * a + b * b);\n        return [\n            atan2(k * b, D * (1 + w)),\n            D ? -asin(k * a / D) : 0\n        ];\n    };\n    var wiechel = function () {\n        return d3Geo.geoProjection(wiechelRaw)\n            .rotate([0, -90, 45])\n            .scale(124.75)\n            .clipAngle(180 - 1e-3);\n    };\n    function winkel3Raw(lambda, phi) {\n        var coordinates = aitoffRaw(lambda, phi);\n        return [\n            (coordinates[0] + lambda / halfPi) / 2,\n            (coordinates[1] + phi) / 2\n        ];\n    }\n    winkel3Raw.invert = function (x, y) {\n        var lambda = x, phi = y, i = 25;\n        do {\n            var cosphi = cos(phi), sinphi = sin(phi), sin_2phi = sin(2 * phi), sin2phi = sinphi * sinphi, cos2phi = cosphi * cosphi, sinlambda = sin(lambda), coslambda_2 = cos(lambda / 2), sinlambda_2 = sin(lambda / 2), sin2lambda_2 = sinlambda_2 * sinlambda_2, C = 1 - cos2phi * coslambda_2 * coslambda_2, E = C ? acos(cosphi * coslambda_2) * sqrt(F = 1 / C) : F = 0, F, fx = 0.5 * (2 * E * cosphi * sinlambda_2 + lambda / halfPi) - x, fy = 0.5 * (E * sinphi + phi) - y, dxdlambda = 0.5 * F * (cos2phi * sin2lambda_2 + E * cosphi * coslambda_2 * sin2phi) + 0.5 / halfPi, dxdphi = F * (sinlambda * sin_2phi / 4 - E * sinphi * sinlambda_2), dydlambda = 0.125 * F * (sin_2phi * sinlambda_2 - E * sinphi * cos2phi * sinlambda), dydphi = 0.5 * F * (sin2phi * coslambda_2 + E * sin2lambda_2 * cosphi) + 0.5, denominator = dxdphi * dydlambda - dydphi * dxdlambda, dlambda = (fy * dxdphi - fx * dydphi) / denominator, dphi = (fx * dydlambda - fy * dxdlambda) / denominator;\n            lambda -= dlambda, phi -= dphi;\n        } while ((abs(dlambda) > epsilon || abs(dphi) > epsilon) && --i > 0);\n        return [lambda, phi];\n    };\n    var winkel3 = function () {\n        return d3Geo.geoProjection(winkel3Raw)\n            .scale(158.837);\n    };\n    exports.geoAiry = airy;\n    exports.geoAiryRaw = airyRaw;\n    exports.geoAitoff = aitoff;\n    exports.geoAitoffRaw = aitoffRaw;\n    exports.geoArmadillo = armadillo;\n    exports.geoArmadilloRaw = armadilloRaw;\n    exports.geoAugust = august;\n    exports.geoAugustRaw = augustRaw;\n    exports.geoBaker = baker;\n    exports.geoBakerRaw = bakerRaw;\n    exports.geoBerghaus = berghaus;\n    exports.geoBerghausRaw = berghausRaw;\n    exports.geoBoggs = boggs;\n    exports.geoBoggsRaw = boggsRaw;\n    exports.geoBonne = bonne;\n    exports.geoBonneRaw = bonneRaw;\n    exports.geoBottomley = bottomley;\n    exports.geoBottomleyRaw = bottomleyRaw;\n    exports.geoBromley = bromley;\n    exports.geoBromleyRaw = bromleyRaw;\n    exports.geoChamberlin = chamberlin;\n    exports.geoChamberlinRaw = chamberlinRaw;\n    exports.geoChamberlinAfrica = chamberlinAfrica;\n    exports.geoCollignon = collignon;\n    exports.geoCollignonRaw = collignonRaw;\n    exports.geoCraig = craig;\n    exports.geoCraigRaw = craigRaw;\n    exports.geoCraster = craster;\n    exports.geoCrasterRaw = crasterRaw;\n    exports.geoCylindricalEqualArea = cylindricalEqualArea;\n    exports.geoCylindricalEqualAreaRaw = cylindricalEqualAreaRaw;\n    exports.geoCylindricalStereographic = cylindricalStereographic;\n    exports.geoCylindricalStereographicRaw = cylindricalStereographicRaw;\n    exports.geoEckert1 = eckert1;\n    exports.geoEckert1Raw = eckert1Raw;\n    exports.geoEckert2 = eckert2;\n    exports.geoEckert2Raw = eckert2Raw;\n    exports.geoEckert3 = eckert3;\n    exports.geoEckert3Raw = eckert3Raw;\n    exports.geoEckert4 = eckert4;\n    exports.geoEckert4Raw = eckert4Raw;\n    exports.geoEckert5 = eckert5;\n    exports.geoEckert5Raw = eckert5Raw;\n    exports.geoEckert6 = eckert6;\n    exports.geoEckert6Raw = eckert6Raw;\n    exports.geoEisenlohr = eisenlohr;\n    exports.geoEisenlohrRaw = eisenlohrRaw;\n    exports.geoFahey = fahey;\n    exports.geoFaheyRaw = faheyRaw;\n    exports.geoFoucaut = foucaut;\n    exports.geoFoucautRaw = foucautRaw;\n    exports.geoGilbert = gilbert;\n    exports.geoGingery = gingery;\n    exports.geoGingeryRaw = gingeryRaw;\n    exports.geoGinzburg4 = ginzburg4;\n    exports.geoGinzburg4Raw = ginzburg4Raw;\n    exports.geoGinzburg5 = ginzburg5;\n    exports.geoGinzburg5Raw = ginzburg5Raw;\n    exports.geoGinzburg6 = ginzburg6;\n    exports.geoGinzburg6Raw = ginzburg6Raw;\n    exports.geoGinzburg8 = ginzburg8;\n    exports.geoGinzburg8Raw = ginzburg8Raw;\n    exports.geoGinzburg9 = ginzburg9;\n    exports.geoGinzburg9Raw = ginzburg9Raw;\n    exports.geoGringorten = gringorten;\n    exports.geoGringortenRaw = gringortenRaw;\n    exports.geoGuyou = guyou;\n    exports.geoGuyouRaw = guyouRaw;\n    exports.geoHammer = hammer;\n    exports.geoHammerRaw = hammerRaw;\n    exports.geoHammerRetroazimuthal = hammerRetroazimuthal;\n    exports.geoHammerRetroazimuthalRaw = hammerRetroazimuthalRaw;\n    exports.geoHealpix = healpix;\n    exports.geoHealpixRaw = healpixRaw;\n    exports.geoHill = hill;\n    exports.geoHillRaw = hillRaw;\n    exports.geoHomolosine = homolosine;\n    exports.geoHomolosineRaw = homolosineRaw;\n    exports.geoInterrupt = interrupt;\n    exports.geoInterruptedBoggs = boggs$1;\n    exports.geoInterruptedHomolosine = homolosine$1;\n    exports.geoInterruptedMollweide = mollweide$1;\n    exports.geoInterruptedMollweideHemispheres = mollweideHemispheres;\n    exports.geoInterruptedSinuMollweide = sinuMollweide$1;\n    exports.geoInterruptedSinusoidal = sinusoidal$1;\n    exports.geoKavrayskiy7 = kavrayskiy7;\n    exports.geoKavrayskiy7Raw = kavrayskiy7Raw;\n    exports.geoLagrange = lagrange;\n    exports.geoLagrangeRaw = lagrangeRaw;\n    exports.geoLarrivee = larrivee;\n    exports.geoLarriveeRaw = larriveeRaw;\n    exports.geoLaskowski = laskowski;\n    exports.geoLaskowskiRaw = laskowskiRaw;\n    exports.geoLittrow = littrow;\n    exports.geoLittrowRaw = littrowRaw;\n    exports.geoLoximuthal = loximuthal;\n    exports.geoLoximuthalRaw = loximuthalRaw;\n    exports.geoMiller = miller;\n    exports.geoMillerRaw = millerRaw;\n    exports.geoModifiedStereographic = modifiedStereographic;\n    exports.geoModifiedStereographicRaw = modifiedStereographicRaw;\n    exports.geoModifiedStereographicAlaska = modifiedStereographicAlaska;\n    exports.geoModifiedStereographicGs48 = modifiedStereographicGs48;\n    exports.geoModifiedStereographicGs50 = modifiedStereographicGs50;\n    exports.geoModifiedStereographicMiller = modifiedStereographicMiller;\n    exports.geoModifiedStereographicLee = modifiedStereographicLee;\n    exports.geoMollweide = mollweide;\n    exports.geoMollweideRaw = mollweideRaw;\n    exports.geoMtFlatPolarParabolic = mtFlatPolarParabolic;\n    exports.geoMtFlatPolarParabolicRaw = mtFlatPolarParabolicRaw;\n    exports.geoMtFlatPolarQuartic = mtFlatPolarQuartic;\n    exports.geoMtFlatPolarQuarticRaw = mtFlatPolarQuarticRaw;\n    exports.geoMtFlatPolarSinusoidal = mtFlatPolarSinusoidal;\n    exports.geoMtFlatPolarSinusoidalRaw = mtFlatPolarSinusoidalRaw;\n    exports.geoNaturalEarth = naturalEarth;\n    exports.geoNaturalEarthRaw = naturalEarthRaw;\n    exports.geoNaturalEarth2 = naturalEarth2;\n    exports.geoNaturalEarth2Raw = naturalEarth2Raw;\n    exports.geoNellHammer = nellHammer;\n    exports.geoNellHammerRaw = nellHammerRaw;\n    exports.geoPatterson = patterson;\n    exports.geoPattersonRaw = pattersonRaw;\n    exports.geoPolyconic = polyconic;\n    exports.geoPolyconicRaw = polyconicRaw;\n    exports.geoPolyhedral = polyhedral;\n    exports.geoPolyhedralButterfly = butterfly;\n    exports.geoPolyhedralCollignon = collignon$1;\n    exports.geoPolyhedralWaterman = waterman;\n    exports.geoProject = index;\n    exports.geoGringortenQuincuncial = gringorten$1;\n    exports.geoPeirceQuincuncial = peirce;\n    exports.geoPierceQuincuncial = peirce;\n    exports.geoQuantize = quantize;\n    exports.geoQuincuncial = quincuncial;\n    exports.geoRectangularPolyconic = rectangularPolyconic;\n    exports.geoRectangularPolyconicRaw = rectangularPolyconicRaw;\n    exports.geoRobinson = robinson;\n    exports.geoRobinsonRaw = robinsonRaw;\n    exports.geoSatellite = satellite;\n    exports.geoSatelliteRaw = satelliteRaw;\n    exports.geoSinuMollweide = sinuMollweide;\n    exports.geoSinuMollweideRaw = sinuMollweideRaw;\n    exports.geoSinusoidal = sinusoidal;\n    exports.geoSinusoidalRaw = sinusoidalRaw;\n    exports.geoStitch = stitch;\n    exports.geoTimes = times;\n    exports.geoTimesRaw = timesRaw;\n    exports.geoTwoPointAzimuthal = twoPointAzimuthal;\n    exports.geoTwoPointAzimuthalRaw = twoPointAzimuthalRaw;\n    exports.geoTwoPointAzimuthalUsa = twoPointAzimuthalUsa;\n    exports.geoTwoPointEquidistant = twoPointEquidistant;\n    exports.geoTwoPointEquidistantRaw = twoPointEquidistantRaw;\n    exports.geoTwoPointEquidistantUsa = twoPointEquidistantUsa;\n    exports.geoVanDerGrinten = vanDerGrinten;\n    exports.geoVanDerGrintenRaw = vanDerGrintenRaw;\n    exports.geoVanDerGrinten2 = vanDerGrinten2;\n    exports.geoVanDerGrinten2Raw = vanDerGrinten2Raw;\n    exports.geoVanDerGrinten3 = vanDerGrinten3;\n    exports.geoVanDerGrinten3Raw = vanDerGrinten3Raw;\n    exports.geoVanDerGrinten4 = vanDerGrinten4;\n    exports.geoVanDerGrinten4Raw = vanDerGrinten4Raw;\n    exports.geoWagner4 = wagner4;\n    exports.geoWagner4Raw = wagner4Raw;\n    exports.geoWagner6 = wagner6;\n    exports.geoWagner6Raw = wagner6Raw;\n    exports.geoWagner7 = wagner7;\n    exports.geoWagner7Raw = wagner7Raw;\n    exports.geoWiechel = wiechel;\n    exports.geoWiechelRaw = wiechelRaw;\n    exports.geoWinkel3 = winkel3;\n    exports.geoWinkel3Raw = winkel3Raw;\n    Object.defineProperty(exports, '__esModule', { value: true });\n})));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-geo@1.11.9@d3-geo/dist/d3-geo.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_d3-geo@1.11.9@d3-geo/dist/d3-geo.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-geo/ v1.11.9 Copyright 2019 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! d3-array */ \"./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js\")) :\n        undefined;\n}(this, function (exports, d3Array) {\n    'use strict';\n    // Adds floating point numbers with twice the normal precision.\n    // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n    // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n    // 305–363 (1997).\n    // Code adapted from GeographicLib by Charles F. F. Karney,\n    // http://geographiclib.sourceforge.net/\n    function adder() {\n        return new Adder;\n    }\n    function Adder() {\n        this.reset();\n    }\n    Adder.prototype = {\n        constructor: Adder,\n        reset: function () {\n            this.s = // rounded value\n                this.t = 0; // exact error\n        },\n        add: function (y) {\n            add(temp, y, this.t);\n            add(this, temp.s, this.s);\n            if (this.s)\n                this.t += temp.t;\n            else\n                this.s = temp.t;\n        },\n        valueOf: function () {\n            return this.s;\n        }\n    };\n    var temp = new Adder;\n    function add(adder, a, b) {\n        var x = adder.s = a + b, bv = x - a, av = x - bv;\n        adder.t = (a - av) + (b - bv);\n    }\n    var epsilon = 1e-6;\n    var epsilon2 = 1e-12;\n    var pi = Math.PI;\n    var halfPi = pi / 2;\n    var quarterPi = pi / 4;\n    var tau = pi * 2;\n    var degrees = 180 / pi;\n    var radians = pi / 180;\n    var abs = Math.abs;\n    var atan = Math.atan;\n    var atan2 = Math.atan2;\n    var cos = Math.cos;\n    var ceil = Math.ceil;\n    var exp = Math.exp;\n    var log = Math.log;\n    var pow = Math.pow;\n    var sin = Math.sin;\n    var sign = Math.sign || function (x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\n    var sqrt = Math.sqrt;\n    var tan = Math.tan;\n    function acos(x) {\n        return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n    }\n    function asin(x) {\n        return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n    }\n    function haversin(x) {\n        return (x = sin(x / 2)) * x;\n    }\n    function noop() { }\n    function streamGeometry(geometry, stream) {\n        if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n            streamGeometryType[geometry.type](geometry, stream);\n        }\n    }\n    var streamObjectType = {\n        Feature: function (object, stream) {\n            streamGeometry(object.geometry, stream);\n        },\n        FeatureCollection: function (object, stream) {\n            var features = object.features, i = -1, n = features.length;\n            while (++i < n)\n                streamGeometry(features[i].geometry, stream);\n        }\n    };\n    var streamGeometryType = {\n        Sphere: function (object, stream) {\n            stream.sphere();\n        },\n        Point: function (object, stream) {\n            object = object.coordinates;\n            stream.point(object[0], object[1], object[2]);\n        },\n        MultiPoint: function (object, stream) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                object = coordinates[i], stream.point(object[0], object[1], object[2]);\n        },\n        LineString: function (object, stream) {\n            streamLine(object.coordinates, stream, 0);\n        },\n        MultiLineString: function (object, stream) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                streamLine(coordinates[i], stream, 0);\n        },\n        Polygon: function (object, stream) {\n            streamPolygon(object.coordinates, stream);\n        },\n        MultiPolygon: function (object, stream) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                streamPolygon(coordinates[i], stream);\n        },\n        GeometryCollection: function (object, stream) {\n            var geometries = object.geometries, i = -1, n = geometries.length;\n            while (++i < n)\n                streamGeometry(geometries[i], stream);\n        }\n    };\n    function streamLine(coordinates, stream, closed) {\n        var i = -1, n = coordinates.length - closed, coordinate;\n        stream.lineStart();\n        while (++i < n)\n            coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n        stream.lineEnd();\n    }\n    function streamPolygon(coordinates, stream) {\n        var i = -1, n = coordinates.length;\n        stream.polygonStart();\n        while (++i < n)\n            streamLine(coordinates[i], stream, 1);\n        stream.polygonEnd();\n    }\n    function geoStream(object, stream) {\n        if (object && streamObjectType.hasOwnProperty(object.type)) {\n            streamObjectType[object.type](object, stream);\n        }\n        else {\n            streamGeometry(object, stream);\n        }\n    }\n    var areaRingSum = adder();\n    var areaSum = adder(), lambda00, phi00, lambda0, cosPhi0, sinPhi0;\n    var areaStream = {\n        point: noop,\n        lineStart: noop,\n        lineEnd: noop,\n        polygonStart: function () {\n            areaRingSum.reset();\n            areaStream.lineStart = areaRingStart;\n            areaStream.lineEnd = areaRingEnd;\n        },\n        polygonEnd: function () {\n            var areaRing = +areaRingSum;\n            areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);\n            this.lineStart = this.lineEnd = this.point = noop;\n        },\n        sphere: function () {\n            areaSum.add(tau);\n        }\n    };\n    function areaRingStart() {\n        areaStream.point = areaPointFirst;\n    }\n    function areaRingEnd() {\n        areaPoint(lambda00, phi00);\n    }\n    function areaPointFirst(lambda, phi) {\n        areaStream.point = areaPoint;\n        lambda00 = lambda, phi00 = phi;\n        lambda *= radians, phi *= radians;\n        lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);\n    }\n    function areaPoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        phi = phi / 2 + quarterPi; // half the angular distance from south pole\n        // Spherical excess E for a spherical triangle with vertices: south pole,\n        // previous point, current point.  Uses a formula derived from Cagnoli’s\n        // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n        var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos(phi), sinPhi = sin(phi), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * cos(adLambda), v = k * sdLambda * sin(adLambda);\n        areaRingSum.add(atan2(v, u));\n        // Advance the previous points.\n        lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n    }\n    function area(object) {\n        areaSum.reset();\n        geoStream(object, areaStream);\n        return areaSum * 2;\n    }\n    function spherical(cartesian) {\n        return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n    }\n    function cartesian(spherical) {\n        var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);\n        return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n    }\n    function cartesianDot(a, b) {\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n    }\n    function cartesianCross(a, b) {\n        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n    }\n    // TODO return a\n    function cartesianAddInPlace(a, b) {\n        a[0] += b[0], a[1] += b[1], a[2] += b[2];\n    }\n    function cartesianScale(vector, k) {\n        return [vector[0] * k, vector[1] * k, vector[2] * k];\n    }\n    // TODO return d\n    function cartesianNormalizeInPlace(d) {\n        var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n        d[0] /= l, d[1] /= l, d[2] /= l;\n    }\n    var lambda0$1, phi0, lambda1, phi1, // bounds\n    lambda2, // previous lambda-coordinate\n    lambda00$1, phi00$1, // first point\n    p0, // previous 3D point\n    deltaSum = adder(), ranges, range;\n    var boundsStream = {\n        point: boundsPoint,\n        lineStart: boundsLineStart,\n        lineEnd: boundsLineEnd,\n        polygonStart: function () {\n            boundsStream.point = boundsRingPoint;\n            boundsStream.lineStart = boundsRingStart;\n            boundsStream.lineEnd = boundsRingEnd;\n            deltaSum.reset();\n            areaStream.polygonStart();\n        },\n        polygonEnd: function () {\n            areaStream.polygonEnd();\n            boundsStream.point = boundsPoint;\n            boundsStream.lineStart = boundsLineStart;\n            boundsStream.lineEnd = boundsLineEnd;\n            if (areaRingSum < 0)\n                lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n            else if (deltaSum > epsilon)\n                phi1 = 90;\n            else if (deltaSum < -epsilon)\n                phi0 = -90;\n            range[0] = lambda0$1, range[1] = lambda1;\n        },\n        sphere: function () {\n            lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n        }\n    };\n    function boundsPoint(lambda, phi) {\n        ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);\n        if (phi < phi0)\n            phi0 = phi;\n        if (phi > phi1)\n            phi1 = phi;\n    }\n    function linePoint(lambda, phi) {\n        var p = cartesian([lambda * radians, phi * radians]);\n        if (p0) {\n            var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);\n            cartesianNormalizeInPlace(inflection);\n            inflection = spherical(inflection);\n            var delta = lambda - lambda2, sign = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign, phii, antimeridian = abs(delta) > 180;\n            if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n                phii = inflection[1] * degrees;\n                if (phii > phi1)\n                    phi1 = phii;\n            }\n            else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n                phii = -inflection[1] * degrees;\n                if (phii < phi0)\n                    phi0 = phii;\n            }\n            else {\n                if (phi < phi0)\n                    phi0 = phi;\n                if (phi > phi1)\n                    phi1 = phi;\n            }\n            if (antimeridian) {\n                if (lambda < lambda2) {\n                    if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))\n                        lambda1 = lambda;\n                }\n                else {\n                    if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))\n                        lambda0$1 = lambda;\n                }\n            }\n            else {\n                if (lambda1 >= lambda0$1) {\n                    if (lambda < lambda0$1)\n                        lambda0$1 = lambda;\n                    if (lambda > lambda1)\n                        lambda1 = lambda;\n                }\n                else {\n                    if (lambda > lambda2) {\n                        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))\n                            lambda1 = lambda;\n                    }\n                    else {\n                        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))\n                            lambda0$1 = lambda;\n                    }\n                }\n            }\n        }\n        else {\n            ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);\n        }\n        if (phi < phi0)\n            phi0 = phi;\n        if (phi > phi1)\n            phi1 = phi;\n        p0 = p, lambda2 = lambda;\n    }\n    function boundsLineStart() {\n        boundsStream.point = linePoint;\n    }\n    function boundsLineEnd() {\n        range[0] = lambda0$1, range[1] = lambda1;\n        boundsStream.point = boundsPoint;\n        p0 = null;\n    }\n    function boundsRingPoint(lambda, phi) {\n        if (p0) {\n            var delta = lambda - lambda2;\n            deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n        }\n        else {\n            lambda00$1 = lambda, phi00$1 = phi;\n        }\n        areaStream.point(lambda, phi);\n        linePoint(lambda, phi);\n    }\n    function boundsRingStart() {\n        areaStream.lineStart();\n    }\n    function boundsRingEnd() {\n        boundsRingPoint(lambda00$1, phi00$1);\n        areaStream.lineEnd();\n        if (abs(deltaSum) > epsilon)\n            lambda0$1 = -(lambda1 = 180);\n        range[0] = lambda0$1, range[1] = lambda1;\n        p0 = null;\n    }\n    // Finds the left-right distance between two longitudes.\n    // This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n    // the distance between ±180° to be 360°.\n    function angle(lambda0, lambda1) {\n        return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n    }\n    function rangeCompare(a, b) {\n        return a[0] - b[0];\n    }\n    function rangeContains(range, x) {\n        return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n    }\n    function bounds(feature) {\n        var i, n, a, b, merged, deltaMax, delta;\n        phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);\n        ranges = [];\n        geoStream(feature, boundsStream);\n        // First, sort ranges by their minimum longitudes.\n        if (n = ranges.length) {\n            ranges.sort(rangeCompare);\n            // Then, merge any ranges that overlap.\n            for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n                b = ranges[i];\n                if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n                    if (angle(a[0], b[1]) > angle(a[0], a[1]))\n                        a[1] = b[1];\n                    if (angle(b[0], a[1]) > angle(a[0], a[1]))\n                        a[0] = b[0];\n                }\n                else {\n                    merged.push(a = b);\n                }\n            }\n            // Finally, find the largest gap between the merged ranges.\n            // The final bounding box will be the inverse of this gap.\n            for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n                b = merged[i];\n                if ((delta = angle(a[1], b[0])) > deltaMax)\n                    deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];\n            }\n        }\n        ranges = range = null;\n        return lambda0$1 === Infinity || phi0 === Infinity\n            ? [[NaN, NaN], [NaN, NaN]]\n            : [[lambda0$1, phi0], [lambda1, phi1]];\n    }\n    var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00$2, phi00$2, // first point\n    x0, y0, z0; // previous point\n    var centroidStream = {\n        sphere: noop,\n        point: centroidPoint,\n        lineStart: centroidLineStart,\n        lineEnd: centroidLineEnd,\n        polygonStart: function () {\n            centroidStream.lineStart = centroidRingStart;\n            centroidStream.lineEnd = centroidRingEnd;\n        },\n        polygonEnd: function () {\n            centroidStream.lineStart = centroidLineStart;\n            centroidStream.lineEnd = centroidLineEnd;\n        }\n    };\n    // Arithmetic mean of Cartesian vectors.\n    function centroidPoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var cosPhi = cos(phi);\n        centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));\n    }\n    function centroidPointCartesian(x, y, z) {\n        ++W0;\n        X0 += (x - X0) / W0;\n        Y0 += (y - Y0) / W0;\n        Z0 += (z - Z0) / W0;\n    }\n    function centroidLineStart() {\n        centroidStream.point = centroidLinePointFirst;\n    }\n    function centroidLinePointFirst(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var cosPhi = cos(phi);\n        x0 = cosPhi * cos(lambda);\n        y0 = cosPhi * sin(lambda);\n        z0 = sin(phi);\n        centroidStream.point = centroidLinePoint;\n        centroidPointCartesian(x0, y0, z0);\n    }\n    function centroidLinePoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n        W1 += w;\n        X1 += w * (x0 + (x0 = x));\n        Y1 += w * (y0 + (y0 = y));\n        Z1 += w * (z0 + (z0 = z));\n        centroidPointCartesian(x0, y0, z0);\n    }\n    function centroidLineEnd() {\n        centroidStream.point = centroidPoint;\n    }\n    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n    // J. Applied Mechanics 42, 239 (1975).\n    function centroidRingStart() {\n        centroidStream.point = centroidRingPointFirst;\n    }\n    function centroidRingEnd() {\n        centroidRingPoint(lambda00$2, phi00$2);\n        centroidStream.point = centroidPoint;\n    }\n    function centroidRingPointFirst(lambda, phi) {\n        lambda00$2 = lambda, phi00$2 = phi;\n        lambda *= radians, phi *= radians;\n        centroidStream.point = centroidRingPoint;\n        var cosPhi = cos(phi);\n        x0 = cosPhi * cos(lambda);\n        y0 = cosPhi * sin(lambda);\n        z0 = sin(phi);\n        centroidPointCartesian(x0, y0, z0);\n    }\n    function centroidRingPoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = sqrt(cx * cx + cy * cy + cz * cz), w = asin(m), // line weight = angle\n        v = m && -w / m; // area weight multiplier\n        X2 += v * cx;\n        Y2 += v * cy;\n        Z2 += v * cz;\n        W1 += w;\n        X1 += w * (x0 + (x0 = x));\n        Y1 += w * (y0 + (y0 = y));\n        Z1 += w * (z0 + (z0 = z));\n        centroidPointCartesian(x0, y0, z0);\n    }\n    function centroid(object) {\n        W0 = W1 =\n            X0 = Y0 = Z0 =\n                X1 = Y1 = Z1 =\n                    X2 = Y2 = Z2 = 0;\n        geoStream(object, centroidStream);\n        var x = X2, y = Y2, z = Z2, m = x * x + y * y + z * z;\n        // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n        if (m < epsilon2) {\n            x = X1, y = Y1, z = Z1;\n            // If the feature has zero length, fall back to arithmetic mean of point vectors.\n            if (W1 < epsilon)\n                x = X0, y = Y0, z = Z0;\n            m = x * x + y * y + z * z;\n            // If the feature still has an undefined ccentroid, then return.\n            if (m < epsilon2)\n                return [NaN, NaN];\n        }\n        return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];\n    }\n    function constant(x) {\n        return function () {\n            return x;\n        };\n    }\n    function compose(a, b) {\n        function compose(x, y) {\n            return x = a(x, y), b(x[0], x[1]);\n        }\n        if (a.invert && b.invert)\n            compose.invert = function (x, y) {\n                return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n            };\n        return compose;\n    }\n    function rotationIdentity(lambda, phi) {\n        return [abs(lambda) > pi ? lambda + Math.round(-lambda / tau) * tau : lambda, phi];\n    }\n    rotationIdentity.invert = rotationIdentity;\n    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n        return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))\n            : rotationLambda(deltaLambda))\n            : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)\n                : rotationIdentity);\n    }\n    function forwardRotationLambda(deltaLambda) {\n        return function (lambda, phi) {\n            return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n        };\n    }\n    function rotationLambda(deltaLambda) {\n        var rotation = forwardRotationLambda(deltaLambda);\n        rotation.invert = forwardRotationLambda(-deltaLambda);\n        return rotation;\n    }\n    function rotationPhiGamma(deltaPhi, deltaGamma) {\n        var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);\n        function rotation(lambda, phi) {\n            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;\n            return [\n                atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n                asin(k * cosDeltaGamma + y * sinDeltaGamma)\n            ];\n        }\n        rotation.invert = function (lambda, phi) {\n            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;\n            return [\n                atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n                asin(k * cosDeltaPhi - x * sinDeltaPhi)\n            ];\n        };\n        return rotation;\n    }\n    function rotation(rotate) {\n        rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n        function forward(coordinates) {\n            coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n            return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n        }\n        forward.invert = function (coordinates) {\n            coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n            return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n        };\n        return forward;\n    }\n    // Generates a circle centered at [0°, 0°], with a given radius and precision.\n    function circleStream(stream, radius, delta, direction, t0, t1) {\n        if (!delta)\n            return;\n        var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;\n        if (t0 == null) {\n            t0 = radius + direction * tau;\n            t1 = radius - step / 2;\n        }\n        else {\n            t0 = circleRadius(cosRadius, t0);\n            t1 = circleRadius(cosRadius, t1);\n            if (direction > 0 ? t0 < t1 : t0 > t1)\n                t0 += direction * tau;\n        }\n        for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n            point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);\n            stream.point(point[0], point[1]);\n        }\n    }\n    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\n    function circleRadius(cosRadius, point) {\n        point = cartesian(point), point[0] -= cosRadius;\n        cartesianNormalizeInPlace(point);\n        var radius = acos(-point[1]);\n        return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;\n    }\n    function circle() {\n        var center = constant([0, 0]), radius = constant(90), precision = constant(6), ring, rotate, stream = { point: point };\n        function point(x, y) {\n            ring.push(x = rotate(x, y));\n            x[0] *= degrees, x[1] *= degrees;\n        }\n        function circle() {\n            var c = center.apply(this, arguments), r = radius.apply(this, arguments) * radians, p = precision.apply(this, arguments) * radians;\n            ring = [];\n            rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;\n            circleStream(stream, r, p, 1);\n            c = { type: \"Polygon\", coordinates: [ring] };\n            ring = rotate = null;\n            return c;\n        }\n        circle.center = function (_) {\n            return arguments.length ? (center = typeof _ === \"function\" ? _ : constant([+_[0], +_[1]]), circle) : center;\n        };\n        circle.radius = function (_) {\n            return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), circle) : radius;\n        };\n        circle.precision = function (_) {\n            return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant(+_), circle) : precision;\n        };\n        return circle;\n    }\n    function clipBuffer() {\n        var lines = [], line;\n        return {\n            point: function (x, y) {\n                line.push([x, y]);\n            },\n            lineStart: function () {\n                lines.push(line = []);\n            },\n            lineEnd: noop,\n            rejoin: function () {\n                if (lines.length > 1)\n                    lines.push(lines.pop().concat(lines.shift()));\n            },\n            result: function () {\n                var result = lines;\n                lines = [];\n                line = null;\n                return result;\n            }\n        };\n    }\n    function pointEqual(a, b) {\n        return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n    }\n    function Intersection(point, points, other, entry) {\n        this.x = point;\n        this.z = points;\n        this.o = other; // another intersection\n        this.e = entry; // is an entry?\n        this.v = false; // visited\n        this.n = this.p = null; // next & previous\n    }\n    // A generalized polygon clipping algorithm: given a polygon that has been cut\n    // into its visible line segments, and rejoins the segments by interpolating\n    // along the clip edge.\n    function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {\n        var subject = [], clip = [], i, n;\n        segments.forEach(function (segment) {\n            if ((n = segment.length - 1) <= 0)\n                return;\n            var n, p0 = segment[0], p1 = segment[n], x;\n            // If the first and last points of a segment are coincident, then treat as a\n            // closed ring. TODO if all rings are closed, then the winding order of the\n            // exterior ring should be checked.\n            if (pointEqual(p0, p1)) {\n                stream.lineStart();\n                for (i = 0; i < n; ++i)\n                    stream.point((p0 = segment[i])[0], p0[1]);\n                stream.lineEnd();\n                return;\n            }\n            subject.push(x = new Intersection(p0, segment, null, true));\n            clip.push(x.o = new Intersection(p0, null, x, false));\n            subject.push(x = new Intersection(p1, segment, null, false));\n            clip.push(x.o = new Intersection(p1, null, x, true));\n        });\n        if (!subject.length)\n            return;\n        clip.sort(compareIntersection);\n        link(subject);\n        link(clip);\n        for (i = 0, n = clip.length; i < n; ++i) {\n            clip[i].e = startInside = !startInside;\n        }\n        var start = subject[0], points, point;\n        while (1) {\n            // Find first unvisited intersection.\n            var current = start, isSubject = true;\n            while (current.v)\n                if ((current = current.n) === start)\n                    return;\n            points = current.z;\n            stream.lineStart();\n            do {\n                current.v = current.o.v = true;\n                if (current.e) {\n                    if (isSubject) {\n                        for (i = 0, n = points.length; i < n; ++i)\n                            stream.point((point = points[i])[0], point[1]);\n                    }\n                    else {\n                        interpolate(current.x, current.n.x, 1, stream);\n                    }\n                    current = current.n;\n                }\n                else {\n                    if (isSubject) {\n                        points = current.p.z;\n                        for (i = points.length - 1; i >= 0; --i)\n                            stream.point((point = points[i])[0], point[1]);\n                    }\n                    else {\n                        interpolate(current.x, current.p.x, -1, stream);\n                    }\n                    current = current.p;\n                }\n                current = current.o;\n                points = current.z;\n                isSubject = !isSubject;\n            } while (!current.v);\n            stream.lineEnd();\n        }\n    }\n    function link(array) {\n        if (!(n = array.length))\n            return;\n        var n, i = 0, a = array[0], b;\n        while (++i < n) {\n            a.n = b = array[i];\n            b.p = a;\n            a = b;\n        }\n        a.n = b = array[0];\n        b.p = a;\n    }\n    var sum = adder();\n    function longitude(point) {\n        if (abs(point[0]) <= pi)\n            return point[0];\n        else\n            return sign(point[0]) * ((abs(point[0]) + pi) % tau - pi);\n    }\n    function polygonContains(polygon, point) {\n        var lambda = longitude(point), phi = point[1], sinPhi = sin(phi), normal = [sin(lambda), -cos(lambda), 0], angle = 0, winding = 0;\n        sum.reset();\n        if (sinPhi === 1)\n            phi = halfPi + epsilon;\n        else if (sinPhi === -1)\n            phi = -halfPi - epsilon;\n        for (var i = 0, n = polygon.length; i < n; ++i) {\n            if (!(m = (ring = polygon[i]).length))\n                continue;\n            var ring, m, point0 = ring[m - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);\n            for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n                var point1 = ring[j], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta = lambda1 - lambda0, sign = delta >= 0 ? 1 : -1, absDelta = sign * delta, antimeridian = absDelta > pi, k = sinPhi0 * sinPhi1;\n                sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));\n                angle += antimeridian ? delta + sign * tau : delta;\n                // Are the longitudes either side of the point’s meridian (lambda),\n                // and are the latitudes smaller than the parallel (phi)?\n                if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n                    var arc = cartesianCross(cartesian(point0), cartesian(point1));\n                    cartesianNormalizeInPlace(arc);\n                    var intersection = cartesianCross(normal, arc);\n                    cartesianNormalizeInPlace(intersection);\n                    var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n                    if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n                        winding += antimeridian ^ delta >= 0 ? 1 : -1;\n                    }\n                }\n            }\n        }\n        // First, determine whether the South pole is inside or outside:\n        //\n        // It is inside if:\n        // * the polygon winds around it in a clockwise direction.\n        // * the polygon does not (cumulatively) wind around it, but has a negative\n        //   (counter-clockwise) area.\n        //\n        // Second, count the (signed) number of times a segment crosses a lambda\n        // from the point to the South pole.  If it is zero, then the point is the\n        // same side as the South pole.\n        return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);\n    }\n    function clip(pointVisible, clipLine, interpolate, start) {\n        return function (sink) {\n            var line = clipLine(sink), ringBuffer = clipBuffer(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;\n            var clip = {\n                point: point,\n                lineStart: lineStart,\n                lineEnd: lineEnd,\n                polygonStart: function () {\n                    clip.point = pointRing;\n                    clip.lineStart = ringStart;\n                    clip.lineEnd = ringEnd;\n                    segments = [];\n                    polygon = [];\n                },\n                polygonEnd: function () {\n                    clip.point = point;\n                    clip.lineStart = lineStart;\n                    clip.lineEnd = lineEnd;\n                    segments = d3Array.merge(segments);\n                    var startInside = polygonContains(polygon, start);\n                    if (segments.length) {\n                        if (!polygonStarted)\n                            sink.polygonStart(), polygonStarted = true;\n                        clipRejoin(segments, compareIntersection, startInside, interpolate, sink);\n                    }\n                    else if (startInside) {\n                        if (!polygonStarted)\n                            sink.polygonStart(), polygonStarted = true;\n                        sink.lineStart();\n                        interpolate(null, null, 1, sink);\n                        sink.lineEnd();\n                    }\n                    if (polygonStarted)\n                        sink.polygonEnd(), polygonStarted = false;\n                    segments = polygon = null;\n                },\n                sphere: function () {\n                    sink.polygonStart();\n                    sink.lineStart();\n                    interpolate(null, null, 1, sink);\n                    sink.lineEnd();\n                    sink.polygonEnd();\n                }\n            };\n            function point(lambda, phi) {\n                if (pointVisible(lambda, phi))\n                    sink.point(lambda, phi);\n            }\n            function pointLine(lambda, phi) {\n                line.point(lambda, phi);\n            }\n            function lineStart() {\n                clip.point = pointLine;\n                line.lineStart();\n            }\n            function lineEnd() {\n                clip.point = point;\n                line.lineEnd();\n            }\n            function pointRing(lambda, phi) {\n                ring.push([lambda, phi]);\n                ringSink.point(lambda, phi);\n            }\n            function ringStart() {\n                ringSink.lineStart();\n                ring = [];\n            }\n            function ringEnd() {\n                pointRing(ring[0][0], ring[0][1]);\n                ringSink.lineEnd();\n                var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point;\n                ring.pop();\n                polygon.push(ring);\n                ring = null;\n                if (!n)\n                    return;\n                // No intersections.\n                if (clean & 1) {\n                    segment = ringSegments[0];\n                    if ((m = segment.length - 1) > 0) {\n                        if (!polygonStarted)\n                            sink.polygonStart(), polygonStarted = true;\n                        sink.lineStart();\n                        for (i = 0; i < m; ++i)\n                            sink.point((point = segment[i])[0], point[1]);\n                        sink.lineEnd();\n                    }\n                    return;\n                }\n                // Rejoin connected segments.\n                // TODO reuse ringBuffer.rejoin()?\n                if (n > 1 && clean & 2)\n                    ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n                segments.push(ringSegments.filter(validSegment));\n            }\n            return clip;\n        };\n    }\n    function validSegment(segment) {\n        return segment.length > 1;\n    }\n    // Intersections are sorted along the clip edge. For both antimeridian cutting\n    // and circle clipping, the same comparison is used.\n    function compareIntersection(a, b) {\n        return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n            - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n    }\n    var clipAntimeridian = clip(function () { return true; }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi, -halfPi]);\n    // Takes a line and cuts into visible segments. Return values: 0 - there were\n    // intersections or the line was empty; 1 - no intersections; 2 - there were\n    // intersections, and the first and last segments should be rejoined.\n    function clipAntimeridianLine(stream) {\n        var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean; // no intersections\n        return {\n            lineStart: function () {\n                stream.lineStart();\n                clean = 1;\n            },\n            point: function (lambda1, phi1) {\n                var sign1 = lambda1 > 0 ? pi : -pi, delta = abs(lambda1 - lambda0);\n                if (abs(delta - pi) < epsilon) { // line crosses a pole\n                    stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n                    stream.point(sign0, phi0);\n                    stream.lineEnd();\n                    stream.lineStart();\n                    stream.point(sign1, phi0);\n                    stream.point(lambda1, phi0);\n                    clean = 0;\n                }\n                else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian\n                    if (abs(lambda0 - sign0) < epsilon)\n                        lambda0 -= sign0 * epsilon; // handle degeneracies\n                    if (abs(lambda1 - sign1) < epsilon)\n                        lambda1 -= sign1 * epsilon;\n                    phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n                    stream.point(sign0, phi0);\n                    stream.lineEnd();\n                    stream.lineStart();\n                    stream.point(sign1, phi0);\n                    clean = 0;\n                }\n                stream.point(lambda0 = lambda1, phi0 = phi1);\n                sign0 = sign1;\n            },\n            lineEnd: function () {\n                stream.lineEnd();\n                lambda0 = phi0 = NaN;\n            },\n            clean: function () {\n                return 2 - clean; // if intersections, rejoin first and last segments\n            }\n        };\n    }\n    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n        var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);\n        return abs(sinLambda0Lambda1) > epsilon\n            ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)\n                - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))\n                / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n            : (phi0 + phi1) / 2;\n    }\n    function clipAntimeridianInterpolate(from, to, direction, stream) {\n        var phi;\n        if (from == null) {\n            phi = direction * halfPi;\n            stream.point(-pi, phi);\n            stream.point(0, phi);\n            stream.point(pi, phi);\n            stream.point(pi, 0);\n            stream.point(pi, -phi);\n            stream.point(0, -phi);\n            stream.point(-pi, -phi);\n            stream.point(-pi, 0);\n            stream.point(-pi, phi);\n        }\n        else if (abs(from[0] - to[0]) > epsilon) {\n            var lambda = from[0] < to[0] ? pi : -pi;\n            phi = direction * lambda / 2;\n            stream.point(-lambda, phi);\n            stream.point(0, phi);\n            stream.point(lambda, phi);\n        }\n        else {\n            stream.point(to[0], to[1]);\n        }\n    }\n    function clipCircle(radius) {\n        var cr = cos(radius), delta = 6 * radians, smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n        function interpolate(from, to, direction, stream) {\n            circleStream(stream, radius, delta, direction, from, to);\n        }\n        function visible(lambda, phi) {\n            return cos(lambda) * cos(phi) > cr;\n        }\n        // Takes a line and cuts into visible segments. Return values used for polygon\n        // clipping: 0 - there were intersections or the line was empty; 1 - no\n        // intersections 2 - there were intersections, and the first and last segments\n        // should be rejoined.\n        function clipLine(stream) {\n            var point0, // previous point\n            c0, // code for previous point\n            v0, // visibility of previous point\n            v00, // visibility of first point\n            clean; // no intersections\n            return {\n                lineStart: function () {\n                    v00 = v0 = false;\n                    clean = 1;\n                },\n                point: function (lambda, phi) {\n                    var point1 = [lambda, phi], point2, v = visible(lambda, phi), c = smallRadius\n                        ? v ? 0 : code(lambda, phi)\n                        : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n                    if (!point0 && (v00 = v0 = v))\n                        stream.lineStart();\n                    // Handle degeneracies.\n                    // TODO ignore if not clipping polygons.\n                    if (v !== v0) {\n                        point2 = intersect(point0, point1);\n                        if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n                            point1[0] += epsilon;\n                            point1[1] += epsilon;\n                            v = visible(point1[0], point1[1]);\n                        }\n                    }\n                    if (v !== v0) {\n                        clean = 0;\n                        if (v) {\n                            // outside going in\n                            stream.lineStart();\n                            point2 = intersect(point1, point0);\n                            stream.point(point2[0], point2[1]);\n                        }\n                        else {\n                            // inside going out\n                            point2 = intersect(point0, point1);\n                            stream.point(point2[0], point2[1]);\n                            stream.lineEnd();\n                        }\n                        point0 = point2;\n                    }\n                    else if (notHemisphere && point0 && smallRadius ^ v) {\n                        var t;\n                        // If the codes for two points are different, or are both zero,\n                        // and there this segment intersects with the small circle.\n                        if (!(c & c0) && (t = intersect(point1, point0, true))) {\n                            clean = 0;\n                            if (smallRadius) {\n                                stream.lineStart();\n                                stream.point(t[0][0], t[0][1]);\n                                stream.point(t[1][0], t[1][1]);\n                                stream.lineEnd();\n                            }\n                            else {\n                                stream.point(t[1][0], t[1][1]);\n                                stream.lineEnd();\n                                stream.lineStart();\n                                stream.point(t[0][0], t[0][1]);\n                            }\n                        }\n                    }\n                    if (v && (!point0 || !pointEqual(point0, point1))) {\n                        stream.point(point1[0], point1[1]);\n                    }\n                    point0 = point1, v0 = v, c0 = c;\n                },\n                lineEnd: function () {\n                    if (v0)\n                        stream.lineEnd();\n                    point0 = null;\n                },\n                // Rejoin first and last segments if there were intersections and the first\n                // and last points were visible.\n                clean: function () {\n                    return clean | ((v00 && v0) << 1);\n                }\n            };\n        }\n        // Intersects the great circle between a and b with the clip circle.\n        function intersect(a, b, two) {\n            var pa = cartesian(a), pb = cartesian(b);\n            // We have two planes, n1.p = d1 and n2.p = d2.\n            // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).\n            var n1 = [1, 0, 0], // normal\n            n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], // cartesianDot(n1, n2),\n            determinant = n2n2 - n1n2 * n1n2;\n            // Two polar points.\n            if (!determinant)\n                return !two && a;\n            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B = cartesianScale(n2, c2);\n            cartesianAddInPlace(A, B);\n            // Solve |p(t)|^2 = 1.\n            var u = n1xn2, w = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A, A) - 1);\n            if (t2 < 0)\n                return;\n            var t = sqrt(t2), q = cartesianScale(u, (-w - t) / uu);\n            cartesianAddInPlace(q, A);\n            q = spherical(q);\n            if (!two)\n                return q;\n            // Two intersection points.\n            var lambda0 = a[0], lambda1 = b[0], phi0 = a[1], phi1 = b[1], z;\n            if (lambda1 < lambda0)\n                z = lambda0, lambda0 = lambda1, lambda1 = z;\n            var delta = lambda1 - lambda0, polar = abs(delta - pi) < epsilon, meridian = polar || delta < epsilon;\n            if (!polar && phi1 < phi0)\n                z = phi0, phi0 = phi1, phi1 = z;\n            // Check that the first point is between a and b.\n            if (meridian\n                ? polar\n                    ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)\n                    : phi0 <= q[1] && q[1] <= phi1\n                : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n                var q1 = cartesianScale(u, (-w + t) / uu);\n                cartesianAddInPlace(q1, A);\n                return [q, spherical(q1)];\n            }\n        }\n        // Generates a 4-bit vector representing the location of a point relative to\n        // the small circle's bounding box.\n        function code(lambda, phi) {\n            var r = smallRadius ? radius : pi - radius, code = 0;\n            if (lambda < -r)\n                code |= 1; // left\n            else if (lambda > r)\n                code |= 2; // right\n            if (phi < -r)\n                code |= 4; // below\n            else if (phi > r)\n                code |= 8; // above\n            return code;\n        }\n        return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n    }\n    function clipLine(a, b, x0, y0, x1, y1) {\n        var ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;\n        r = x0 - ax;\n        if (!dx && r > 0)\n            return;\n        r /= dx;\n        if (dx < 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        else if (dx > 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        r = x1 - ax;\n        if (!dx && r < 0)\n            return;\n        r /= dx;\n        if (dx < 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        else if (dx > 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        r = y0 - ay;\n        if (!dy && r > 0)\n            return;\n        r /= dy;\n        if (dy < 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        else if (dy > 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        r = y1 - ay;\n        if (!dy && r < 0)\n            return;\n        r /= dy;\n        if (dy < 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        else if (dy > 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        if (t0 > 0)\n            a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n        if (t1 < 1)\n            b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n        return true;\n    }\n    var clipMax = 1e9, clipMin = -clipMax;\n    // TODO Use d3-polygon’s polygonContains here for the ring check?\n    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n    function clipRectangle(x0, y0, x1, y1) {\n        function visible(x, y) {\n            return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n        }\n        function interpolate(from, to, direction, stream) {\n            var a = 0, a1 = 0;\n            if (from == null\n                || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n                || comparePoint(from, to) < 0 ^ direction > 0) {\n                do\n                    stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n                while ((a = (a + direction + 4) % 4) !== a1);\n            }\n            else {\n                stream.point(to[0], to[1]);\n            }\n        }\n        function corner(p, direction) {\n            return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3\n                : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1\n                    : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0\n                        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n        }\n        function compareIntersection(a, b) {\n            return comparePoint(a.x, b.x);\n        }\n        function comparePoint(a, b) {\n            var ca = corner(a, 1), cb = corner(b, 1);\n            return ca !== cb ? ca - cb\n                : ca === 0 ? b[1] - a[1]\n                    : ca === 1 ? a[0] - b[0]\n                        : ca === 2 ? a[1] - b[1]\n                            : b[0] - a[0];\n        }\n        return function (stream) {\n            var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, // first point\n            x_, y_, v_, // previous point\n            first, clean;\n            var clipStream = {\n                point: point,\n                lineStart: lineStart,\n                lineEnd: lineEnd,\n                polygonStart: polygonStart,\n                polygonEnd: polygonEnd\n            };\n            function point(x, y) {\n                if (visible(x, y))\n                    activeStream.point(x, y);\n            }\n            function polygonInside() {\n                var winding = 0;\n                for (var i = 0, n = polygon.length; i < n; ++i) {\n                    for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n                        a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n                        if (a1 <= y1) {\n                            if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0))\n                                ++winding;\n                        }\n                        else {\n                            if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0))\n                                --winding;\n                        }\n                    }\n                }\n                return winding;\n            }\n            // Buffer geometry within a polygon and then clip it en masse.\n            function polygonStart() {\n                activeStream = bufferStream, segments = [], polygon = [], clean = true;\n            }\n            function polygonEnd() {\n                var startInside = polygonInside(), cleanInside = clean && startInside, visible = (segments = d3Array.merge(segments)).length;\n                if (cleanInside || visible) {\n                    stream.polygonStart();\n                    if (cleanInside) {\n                        stream.lineStart();\n                        interpolate(null, null, 1, stream);\n                        stream.lineEnd();\n                    }\n                    if (visible) {\n                        clipRejoin(segments, compareIntersection, startInside, interpolate, stream);\n                    }\n                    stream.polygonEnd();\n                }\n                activeStream = stream, segments = polygon = ring = null;\n            }\n            function lineStart() {\n                clipStream.point = linePoint;\n                if (polygon)\n                    polygon.push(ring = []);\n                first = true;\n                v_ = false;\n                x_ = y_ = NaN;\n            }\n            // TODO rather than special-case polygons, simply handle them separately.\n            // Ideally, coincident intersection points should be jittered to avoid\n            // clipping issues.\n            function lineEnd() {\n                if (segments) {\n                    linePoint(x__, y__);\n                    if (v__ && v_)\n                        bufferStream.rejoin();\n                    segments.push(bufferStream.result());\n                }\n                clipStream.point = point;\n                if (v_)\n                    activeStream.lineEnd();\n            }\n            function linePoint(x, y) {\n                var v = visible(x, y);\n                if (polygon)\n                    ring.push([x, y]);\n                if (first) {\n                    x__ = x, y__ = y, v__ = v;\n                    first = false;\n                    if (v) {\n                        activeStream.lineStart();\n                        activeStream.point(x, y);\n                    }\n                }\n                else {\n                    if (v && v_)\n                        activeStream.point(x, y);\n                    else {\n                        var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n                        if (clipLine(a, b, x0, y0, x1, y1)) {\n                            if (!v_) {\n                                activeStream.lineStart();\n                                activeStream.point(a[0], a[1]);\n                            }\n                            activeStream.point(b[0], b[1]);\n                            if (!v)\n                                activeStream.lineEnd();\n                            clean = false;\n                        }\n                        else if (v) {\n                            activeStream.lineStart();\n                            activeStream.point(x, y);\n                            clean = false;\n                        }\n                    }\n                }\n                x_ = x, y_ = y, v_ = v;\n            }\n            return clipStream;\n        };\n    }\n    function extent() {\n        var x0 = 0, y0 = 0, x1 = 960, y1 = 500, cache, cacheStream, clip;\n        return clip = {\n            stream: function (stream) {\n                return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);\n            },\n            extent: function (_) {\n                return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\n            }\n        };\n    }\n    var lengthSum = adder(), lambda0$2, sinPhi0$1, cosPhi0$1;\n    var lengthStream = {\n        sphere: noop,\n        point: noop,\n        lineStart: lengthLineStart,\n        lineEnd: noop,\n        polygonStart: noop,\n        polygonEnd: noop\n    };\n    function lengthLineStart() {\n        lengthStream.point = lengthPointFirst;\n        lengthStream.lineEnd = lengthLineEnd;\n    }\n    function lengthLineEnd() {\n        lengthStream.point = lengthStream.lineEnd = noop;\n    }\n    function lengthPointFirst(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);\n        lengthStream.point = lengthPoint;\n    }\n    function lengthPoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var sinPhi = sin(phi), cosPhi = cos(phi), delta = abs(lambda - lambda0$2), cosDelta = cos(delta), sinDelta = sin(delta), x = cosPhi * sinDelta, y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta, z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;\n        lengthSum.add(atan2(sqrt(x * x + y * y), z));\n        lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;\n    }\n    function length(object) {\n        lengthSum.reset();\n        geoStream(object, lengthStream);\n        return +lengthSum;\n    }\n    var coordinates = [null, null], object = { type: \"LineString\", coordinates: coordinates };\n    function distance(a, b) {\n        coordinates[0] = a;\n        coordinates[1] = b;\n        return length(object);\n    }\n    var containsObjectType = {\n        Feature: function (object, point) {\n            return containsGeometry(object.geometry, point);\n        },\n        FeatureCollection: function (object, point) {\n            var features = object.features, i = -1, n = features.length;\n            while (++i < n)\n                if (containsGeometry(features[i].geometry, point))\n                    return true;\n            return false;\n        }\n    };\n    var containsGeometryType = {\n        Sphere: function () {\n            return true;\n        },\n        Point: function (object, point) {\n            return containsPoint(object.coordinates, point);\n        },\n        MultiPoint: function (object, point) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                if (containsPoint(coordinates[i], point))\n                    return true;\n            return false;\n        },\n        LineString: function (object, point) {\n            return containsLine(object.coordinates, point);\n        },\n        MultiLineString: function (object, point) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                if (containsLine(coordinates[i], point))\n                    return true;\n            return false;\n        },\n        Polygon: function (object, point) {\n            return containsPolygon(object.coordinates, point);\n        },\n        MultiPolygon: function (object, point) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                if (containsPolygon(coordinates[i], point))\n                    return true;\n            return false;\n        },\n        GeometryCollection: function (object, point) {\n            var geometries = object.geometries, i = -1, n = geometries.length;\n            while (++i < n)\n                if (containsGeometry(geometries[i], point))\n                    return true;\n            return false;\n        }\n    };\n    function containsGeometry(geometry, point) {\n        return geometry && containsGeometryType.hasOwnProperty(geometry.type)\n            ? containsGeometryType[geometry.type](geometry, point)\n            : false;\n    }\n    function containsPoint(coordinates, point) {\n        return distance(coordinates, point) === 0;\n    }\n    function containsLine(coordinates, point) {\n        var ao, bo, ab;\n        for (var i = 0, n = coordinates.length; i < n; i++) {\n            bo = distance(coordinates[i], point);\n            if (bo === 0)\n                return true;\n            if (i > 0) {\n                ab = distance(coordinates[i], coordinates[i - 1]);\n                if (ab > 0 &&\n                    ao <= ab &&\n                    bo <= ab &&\n                    (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab)\n                    return true;\n            }\n            ao = bo;\n        }\n        return false;\n    }\n    function containsPolygon(coordinates, point) {\n        return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));\n    }\n    function ringRadians(ring) {\n        return ring = ring.map(pointRadians), ring.pop(), ring;\n    }\n    function pointRadians(point) {\n        return [point[0] * radians, point[1] * radians];\n    }\n    function contains(object, point) {\n        return (object && containsObjectType.hasOwnProperty(object.type)\n            ? containsObjectType[object.type]\n            : containsGeometry)(object, point);\n    }\n    function graticuleX(y0, y1, dy) {\n        var y = d3Array.range(y0, y1 - epsilon, dy).concat(y1);\n        return function (x) { return y.map(function (y) { return [x, y]; }); };\n    }\n    function graticuleY(x0, x1, dx) {\n        var x = d3Array.range(x0, x1 - epsilon, dx).concat(x1);\n        return function (y) { return x.map(function (x) { return [x, y]; }); };\n    }\n    function graticule() {\n        var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;\n        function graticule() {\n            return { type: \"MultiLineString\", coordinates: lines() };\n        }\n        function lines() {\n            return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X)\n                .concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))\n                .concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function (x) { return abs(x % DX) > epsilon; }).map(x))\n                .concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function (y) { return abs(y % DY) > epsilon; }).map(y));\n        }\n        graticule.lines = function () {\n            return lines().map(function (coordinates) { return { type: \"LineString\", coordinates: coordinates }; });\n        };\n        graticule.outline = function () {\n            return {\n                type: \"Polygon\",\n                coordinates: [\n                    X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))\n                ]\n            };\n        };\n        graticule.extent = function (_) {\n            if (!arguments.length)\n                return graticule.extentMinor();\n            return graticule.extentMajor(_).extentMinor(_);\n        };\n        graticule.extentMajor = function (_) {\n            if (!arguments.length)\n                return [[X0, Y0], [X1, Y1]];\n            X0 = +_[0][0], X1 = +_[1][0];\n            Y0 = +_[0][1], Y1 = +_[1][1];\n            if (X0 > X1)\n                _ = X0, X0 = X1, X1 = _;\n            if (Y0 > Y1)\n                _ = Y0, Y0 = Y1, Y1 = _;\n            return graticule.precision(precision);\n        };\n        graticule.extentMinor = function (_) {\n            if (!arguments.length)\n                return [[x0, y0], [x1, y1]];\n            x0 = +_[0][0], x1 = +_[1][0];\n            y0 = +_[0][1], y1 = +_[1][1];\n            if (x0 > x1)\n                _ = x0, x0 = x1, x1 = _;\n            if (y0 > y1)\n                _ = y0, y0 = y1, y1 = _;\n            return graticule.precision(precision);\n        };\n        graticule.step = function (_) {\n            if (!arguments.length)\n                return graticule.stepMinor();\n            return graticule.stepMajor(_).stepMinor(_);\n        };\n        graticule.stepMajor = function (_) {\n            if (!arguments.length)\n                return [DX, DY];\n            DX = +_[0], DY = +_[1];\n            return graticule;\n        };\n        graticule.stepMinor = function (_) {\n            if (!arguments.length)\n                return [dx, dy];\n            dx = +_[0], dy = +_[1];\n            return graticule;\n        };\n        graticule.precision = function (_) {\n            if (!arguments.length)\n                return precision;\n            precision = +_;\n            x = graticuleX(y0, y1, 90);\n            y = graticuleY(x0, x1, precision);\n            X = graticuleX(Y0, Y1, 90);\n            Y = graticuleY(X0, X1, precision);\n            return graticule;\n        };\n        return graticule\n            .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])\n            .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);\n    }\n    function graticule10() {\n        return graticule()();\n    }\n    function interpolate(a, b) {\n        var x0 = a[0] * radians, y0 = a[1] * radians, x1 = b[0] * radians, y1 = b[1] * radians, cy0 = cos(y0), sy0 = sin(y0), cy1 = cos(y1), sy1 = sin(y1), kx0 = cy0 * cos(x0), ky0 = cy0 * sin(x0), kx1 = cy1 * cos(x1), ky1 = cy1 * sin(x1), d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))), k = sin(d);\n        var interpolate = d ? function (t) {\n            var B = sin(t *= d) / k, A = sin(d - t) / k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;\n            return [\n                atan2(y, x) * degrees,\n                atan2(z, sqrt(x * x + y * y)) * degrees\n            ];\n        } : function () {\n            return [x0 * degrees, y0 * degrees];\n        };\n        interpolate.distance = d;\n        return interpolate;\n    }\n    function identity(x) {\n        return x;\n    }\n    var areaSum$1 = adder(), areaRingSum$1 = adder(), x00, y00, x0$1, y0$1;\n    var areaStream$1 = {\n        point: noop,\n        lineStart: noop,\n        lineEnd: noop,\n        polygonStart: function () {\n            areaStream$1.lineStart = areaRingStart$1;\n            areaStream$1.lineEnd = areaRingEnd$1;\n        },\n        polygonEnd: function () {\n            areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;\n            areaSum$1.add(abs(areaRingSum$1));\n            areaRingSum$1.reset();\n        },\n        result: function () {\n            var area = areaSum$1 / 2;\n            areaSum$1.reset();\n            return area;\n        }\n    };\n    function areaRingStart$1() {\n        areaStream$1.point = areaPointFirst$1;\n    }\n    function areaPointFirst$1(x, y) {\n        areaStream$1.point = areaPoint$1;\n        x00 = x0$1 = x, y00 = y0$1 = y;\n    }\n    function areaPoint$1(x, y) {\n        areaRingSum$1.add(y0$1 * x - x0$1 * y);\n        x0$1 = x, y0$1 = y;\n    }\n    function areaRingEnd$1() {\n        areaPoint$1(x00, y00);\n    }\n    var x0$2 = Infinity, y0$2 = x0$2, x1 = -x0$2, y1 = x1;\n    var boundsStream$1 = {\n        point: boundsPoint$1,\n        lineStart: noop,\n        lineEnd: noop,\n        polygonStart: noop,\n        polygonEnd: noop,\n        result: function () {\n            var bounds = [[x0$2, y0$2], [x1, y1]];\n            x1 = y1 = -(y0$2 = x0$2 = Infinity);\n            return bounds;\n        }\n    };\n    function boundsPoint$1(x, y) {\n        if (x < x0$2)\n            x0$2 = x;\n        if (x > x1)\n            x1 = x;\n        if (y < y0$2)\n            y0$2 = y;\n        if (y > y1)\n            y1 = y;\n    }\n    // TODO Enforce positive area for exterior, negative area for interior?\n    var X0$1 = 0, Y0$1 = 0, Z0$1 = 0, X1$1 = 0, Y1$1 = 0, Z1$1 = 0, X2$1 = 0, Y2$1 = 0, Z2$1 = 0, x00$1, y00$1, x0$3, y0$3;\n    var centroidStream$1 = {\n        point: centroidPoint$1,\n        lineStart: centroidLineStart$1,\n        lineEnd: centroidLineEnd$1,\n        polygonStart: function () {\n            centroidStream$1.lineStart = centroidRingStart$1;\n            centroidStream$1.lineEnd = centroidRingEnd$1;\n        },\n        polygonEnd: function () {\n            centroidStream$1.point = centroidPoint$1;\n            centroidStream$1.lineStart = centroidLineStart$1;\n            centroidStream$1.lineEnd = centroidLineEnd$1;\n        },\n        result: function () {\n            var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]\n                : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]\n                    : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]\n                        : [NaN, NaN];\n            X0$1 = Y0$1 = Z0$1 =\n                X1$1 = Y1$1 = Z1$1 =\n                    X2$1 = Y2$1 = Z2$1 = 0;\n            return centroid;\n        }\n    };\n    function centroidPoint$1(x, y) {\n        X0$1 += x;\n        Y0$1 += y;\n        ++Z0$1;\n    }\n    function centroidLineStart$1() {\n        centroidStream$1.point = centroidPointFirstLine;\n    }\n    function centroidPointFirstLine(x, y) {\n        centroidStream$1.point = centroidPointLine;\n        centroidPoint$1(x0$3 = x, y0$3 = y);\n    }\n    function centroidPointLine(x, y) {\n        var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);\n        X1$1 += z * (x0$3 + x) / 2;\n        Y1$1 += z * (y0$3 + y) / 2;\n        Z1$1 += z;\n        centroidPoint$1(x0$3 = x, y0$3 = y);\n    }\n    function centroidLineEnd$1() {\n        centroidStream$1.point = centroidPoint$1;\n    }\n    function centroidRingStart$1() {\n        centroidStream$1.point = centroidPointFirstRing;\n    }\n    function centroidRingEnd$1() {\n        centroidPointRing(x00$1, y00$1);\n    }\n    function centroidPointFirstRing(x, y) {\n        centroidStream$1.point = centroidPointRing;\n        centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);\n    }\n    function centroidPointRing(x, y) {\n        var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);\n        X1$1 += z * (x0$3 + x) / 2;\n        Y1$1 += z * (y0$3 + y) / 2;\n        Z1$1 += z;\n        z = y0$3 * x - x0$3 * y;\n        X2$1 += z * (x0$3 + x);\n        Y2$1 += z * (y0$3 + y);\n        Z2$1 += z * 3;\n        centroidPoint$1(x0$3 = x, y0$3 = y);\n    }\n    function PathContext(context) {\n        this._context = context;\n    }\n    PathContext.prototype = {\n        _radius: 4.5,\n        pointRadius: function (_) {\n            return this._radius = _, this;\n        },\n        polygonStart: function () {\n            this._line = 0;\n        },\n        polygonEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._line === 0)\n                this._context.closePath();\n            this._point = NaN;\n        },\n        point: function (x, y) {\n            switch (this._point) {\n                case 0: {\n                    this._context.moveTo(x, y);\n                    this._point = 1;\n                    break;\n                }\n                case 1: {\n                    this._context.lineTo(x, y);\n                    break;\n                }\n                default: {\n                    this._context.moveTo(x + this._radius, y);\n                    this._context.arc(x, y, this._radius, 0, tau);\n                    break;\n                }\n            }\n        },\n        result: noop\n    };\n    var lengthSum$1 = adder(), lengthRing, x00$2, y00$2, x0$4, y0$4;\n    var lengthStream$1 = {\n        point: noop,\n        lineStart: function () {\n            lengthStream$1.point = lengthPointFirst$1;\n        },\n        lineEnd: function () {\n            if (lengthRing)\n                lengthPoint$1(x00$2, y00$2);\n            lengthStream$1.point = noop;\n        },\n        polygonStart: function () {\n            lengthRing = true;\n        },\n        polygonEnd: function () {\n            lengthRing = null;\n        },\n        result: function () {\n            var length = +lengthSum$1;\n            lengthSum$1.reset();\n            return length;\n        }\n    };\n    function lengthPointFirst$1(x, y) {\n        lengthStream$1.point = lengthPoint$1;\n        x00$2 = x0$4 = x, y00$2 = y0$4 = y;\n    }\n    function lengthPoint$1(x, y) {\n        x0$4 -= x, y0$4 -= y;\n        lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));\n        x0$4 = x, y0$4 = y;\n    }\n    function PathString() {\n        this._string = [];\n    }\n    PathString.prototype = {\n        _radius: 4.5,\n        _circle: circle$1(4.5),\n        pointRadius: function (_) {\n            if ((_ = +_) !== this._radius)\n                this._radius = _, this._circle = null;\n            return this;\n        },\n        polygonStart: function () {\n            this._line = 0;\n        },\n        polygonEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._line === 0)\n                this._string.push(\"Z\");\n            this._point = NaN;\n        },\n        point: function (x, y) {\n            switch (this._point) {\n                case 0: {\n                    this._string.push(\"M\", x, \",\", y);\n                    this._point = 1;\n                    break;\n                }\n                case 1: {\n                    this._string.push(\"L\", x, \",\", y);\n                    break;\n                }\n                default: {\n                    if (this._circle == null)\n                        this._circle = circle$1(this._radius);\n                    this._string.push(\"M\", x, \",\", y, this._circle);\n                    break;\n                }\n            }\n        },\n        result: function () {\n            if (this._string.length) {\n                var result = this._string.join(\"\");\n                this._string = [];\n                return result;\n            }\n            else {\n                return null;\n            }\n        }\n    };\n    function circle$1(radius) {\n        return \"m0,\" + radius\n            + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius\n            + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius\n            + \"z\";\n    }\n    function index(projection, context) {\n        var pointRadius = 4.5, projectionStream, contextStream;\n        function path(object) {\n            if (object) {\n                if (typeof pointRadius === \"function\")\n                    contextStream.pointRadius(+pointRadius.apply(this, arguments));\n                geoStream(object, projectionStream(contextStream));\n            }\n            return contextStream.result();\n        }\n        path.area = function (object) {\n            geoStream(object, projectionStream(areaStream$1));\n            return areaStream$1.result();\n        };\n        path.measure = function (object) {\n            geoStream(object, projectionStream(lengthStream$1));\n            return lengthStream$1.result();\n        };\n        path.bounds = function (object) {\n            geoStream(object, projectionStream(boundsStream$1));\n            return boundsStream$1.result();\n        };\n        path.centroid = function (object) {\n            geoStream(object, projectionStream(centroidStream$1));\n            return centroidStream$1.result();\n        };\n        path.projection = function (_) {\n            return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;\n        };\n        path.context = function (_) {\n            if (!arguments.length)\n                return context;\n            contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);\n            if (typeof pointRadius !== \"function\")\n                contextStream.pointRadius(pointRadius);\n            return path;\n        };\n        path.pointRadius = function (_) {\n            if (!arguments.length)\n                return pointRadius;\n            pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n            return path;\n        };\n        return path.projection(projection).context(context);\n    }\n    function transform(methods) {\n        return {\n            stream: transformer(methods)\n        };\n    }\n    function transformer(methods) {\n        return function (stream) {\n            var s = new TransformStream;\n            for (var key in methods)\n                s[key] = methods[key];\n            s.stream = stream;\n            return s;\n        };\n    }\n    function TransformStream() { }\n    TransformStream.prototype = {\n        constructor: TransformStream,\n        point: function (x, y) { this.stream.point(x, y); },\n        sphere: function () { this.stream.sphere(); },\n        lineStart: function () { this.stream.lineStart(); },\n        lineEnd: function () { this.stream.lineEnd(); },\n        polygonStart: function () { this.stream.polygonStart(); },\n        polygonEnd: function () { this.stream.polygonEnd(); }\n    };\n    function fit(projection, fitBounds, object) {\n        var clip = projection.clipExtent && projection.clipExtent();\n        projection.scale(150).translate([0, 0]);\n        if (clip != null)\n            projection.clipExtent(null);\n        geoStream(object, projection.stream(boundsStream$1));\n        fitBounds(boundsStream$1.result());\n        if (clip != null)\n            projection.clipExtent(clip);\n        return projection;\n    }\n    function fitExtent(projection, extent, object) {\n        return fit(projection, function (b) {\n            var w = extent[1][0] - extent[0][0], h = extent[1][1] - extent[0][1], k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n            projection.scale(150 * k).translate([x, y]);\n        }, object);\n    }\n    function fitSize(projection, size, object) {\n        return fitExtent(projection, [[0, 0], size], object);\n    }\n    function fitWidth(projection, width, object) {\n        return fit(projection, function (b) {\n            var w = +width, k = w / (b[1][0] - b[0][0]), x = (w - k * (b[1][0] + b[0][0])) / 2, y = -k * b[0][1];\n            projection.scale(150 * k).translate([x, y]);\n        }, object);\n    }\n    function fitHeight(projection, height, object) {\n        return fit(projection, function (b) {\n            var h = +height, k = h / (b[1][1] - b[0][1]), x = -k * b[0][0], y = (h - k * (b[1][1] + b[0][1])) / 2;\n            projection.scale(150 * k).translate([x, y]);\n        }, object);\n    }\n    var maxDepth = 16, // maximum depth of subdivision\n    cosMinDistance = cos(30 * radians); // cos(minimum angular distance)\n    function resample(project, delta2) {\n        return +delta2 ? resample$1(project, delta2) : resampleNone(project);\n    }\n    function resampleNone(project) {\n        return transformer({\n            point: function (x, y) {\n                x = project(x, y);\n                this.stream.point(x[0], x[1]);\n            }\n        });\n    }\n    function resample$1(project, delta2) {\n        function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n            var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;\n            if (d2 > 4 * delta2 && depth--) {\n                var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = sqrt(a * a + b * b + c * c), phi2 = asin(c /= m), lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a), p = project(lambda2, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;\n                if (dz * dz / d2 > delta2 // perpendicular projected distance\n                    || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n                    || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance\n                    resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n                    stream.point(x2, y2);\n                    resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n                }\n            }\n        }\n        return function (stream) {\n            var lambda00, x00, y00, a00, b00, c00, // first point\n            lambda0, x0, y0, a0, b0, c0; // previous point\n            var resampleStream = {\n                point: point,\n                lineStart: lineStart,\n                lineEnd: lineEnd,\n                polygonStart: function () { stream.polygonStart(); resampleStream.lineStart = ringStart; },\n                polygonEnd: function () { stream.polygonEnd(); resampleStream.lineStart = lineStart; }\n            };\n            function point(x, y) {\n                x = project(x, y);\n                stream.point(x[0], x[1]);\n            }\n            function lineStart() {\n                x0 = NaN;\n                resampleStream.point = linePoint;\n                stream.lineStart();\n            }\n            function linePoint(lambda, phi) {\n                var c = cartesian([lambda, phi]), p = project(lambda, phi);\n                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n                stream.point(x0, y0);\n            }\n            function lineEnd() {\n                resampleStream.point = point;\n                stream.lineEnd();\n            }\n            function ringStart() {\n                lineStart();\n                resampleStream.point = ringPoint;\n                resampleStream.lineEnd = ringEnd;\n            }\n            function ringPoint(lambda, phi) {\n                linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n                resampleStream.point = linePoint;\n            }\n            function ringEnd() {\n                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n                resampleStream.lineEnd = lineEnd;\n                lineEnd();\n            }\n            return resampleStream;\n        };\n    }\n    var transformRadians = transformer({\n        point: function (x, y) {\n            this.stream.point(x * radians, y * radians);\n        }\n    });\n    function transformRotate(rotate) {\n        return transformer({\n            point: function (x, y) {\n                var r = rotate(x, y);\n                return this.stream.point(r[0], r[1]);\n            }\n        });\n    }\n    function scaleTranslate(k, dx, dy) {\n        function transform(x, y) {\n            return [dx + k * x, dy - k * y];\n        }\n        transform.invert = function (x, y) {\n            return [(x - dx) / k, (dy - y) / k];\n        };\n        return transform;\n    }\n    function scaleTranslateRotate(k, dx, dy, alpha) {\n        var cosAlpha = cos(alpha), sinAlpha = sin(alpha), a = cosAlpha * k, b = sinAlpha * k, ai = cosAlpha / k, bi = sinAlpha / k, ci = (sinAlpha * dy - cosAlpha * dx) / k, fi = (sinAlpha * dx + cosAlpha * dy) / k;\n        function transform(x, y) {\n            return [a * x - b * y + dx, dy - b * x - a * y];\n        }\n        transform.invert = function (x, y) {\n            return [ai * x - bi * y + ci, fi - bi * x - ai * y];\n        };\n        return transform;\n    }\n    function projection(project) {\n        return projectionMutator(function () { return project; })();\n    }\n    function projectionMutator(projectAt) {\n        var project, k = 150, // scale\n        x = 480, y = 250, // translate\n        lambda = 0, phi = 0, // center\n        deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate\n        alpha = 0, // post-rotate\n        theta = null, preclip = clipAntimeridian, // pre-clip angle\n        x0 = null, y0, x1, y1, postclip = identity, // post-clip extent\n        delta2 = 0.5, // precision\n        projectResample, projectTransform, projectRotateTransform, cache, cacheStream;\n        function projection(point) {\n            return projectRotateTransform(point[0] * radians, point[1] * radians);\n        }\n        function invert(point) {\n            point = projectRotateTransform.invert(point[0], point[1]);\n            return point && [point[0] * degrees, point[1] * degrees];\n        }\n        projection.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));\n        };\n        projection.preclip = function (_) {\n            return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;\n        };\n        projection.postclip = function (_) {\n            return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;\n        };\n        projection.clipAngle = function (_) {\n            return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;\n        };\n        projection.clipExtent = function (_) {\n            return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n        };\n        projection.scale = function (_) {\n            return arguments.length ? (k = +_, recenter()) : k;\n        };\n        projection.translate = function (_) {\n            return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n        };\n        projection.center = function (_) {\n            return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];\n        };\n        projection.rotate = function (_) {\n            return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];\n        };\n        projection.angle = function (_) {\n            return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;\n        };\n        projection.precision = function (_) {\n            return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n        };\n        projection.fitExtent = function (extent, object) {\n            return fitExtent(projection, extent, object);\n        };\n        projection.fitSize = function (size, object) {\n            return fitSize(projection, size, object);\n        };\n        projection.fitWidth = function (width, object) {\n            return fitWidth(projection, width, object);\n        };\n        projection.fitHeight = function (height, object) {\n            return fitHeight(projection, height, object);\n        };\n        function recenter() {\n            var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)), transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);\n            rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);\n            projectTransform = compose(project, transform);\n            projectRotateTransform = compose(rotate, projectTransform);\n            projectResample = resample(projectTransform, delta2);\n            return reset();\n        }\n        function reset() {\n            cache = cacheStream = null;\n            return projection;\n        }\n        return function () {\n            project = projectAt.apply(this, arguments);\n            projection.invert = project.invert && invert;\n            return recenter();\n        };\n    }\n    function conicProjection(projectAt) {\n        var phi0 = 0, phi1 = pi / 3, m = projectionMutator(projectAt), p = m(phi0, phi1);\n        p.parallels = function (_) {\n            return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];\n        };\n        return p;\n    }\n    function cylindricalEqualAreaRaw(phi0) {\n        var cosPhi0 = cos(phi0);\n        function forward(lambda, phi) {\n            return [lambda * cosPhi0, sin(phi) / cosPhi0];\n        }\n        forward.invert = function (x, y) {\n            return [x / cosPhi0, asin(y * cosPhi0)];\n        };\n        return forward;\n    }\n    function conicEqualAreaRaw(y0, y1) {\n        var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;\n        // Are the parallels symmetrical around the Equator?\n        if (abs(n) < epsilon)\n            return cylindricalEqualAreaRaw(y0);\n        var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;\n        function project(x, y) {\n            var r = sqrt(c - 2 * n * sin(y)) / n;\n            return [r * sin(x *= n), r0 - r * cos(x)];\n        }\n        project.invert = function (x, y) {\n            var r0y = r0 - y;\n            return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];\n        };\n        return project;\n    }\n    function conicEqualArea() {\n        return conicProjection(conicEqualAreaRaw)\n            .scale(155.424)\n            .center([0, 33.6442]);\n    }\n    function albers() {\n        return conicEqualArea()\n            .parallels([29.5, 45.5])\n            .scale(1070)\n            .translate([480, 250])\n            .rotate([96, 0])\n            .center([-0.6, 38.7]);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n)\n                streams[i].point(x, y); },\n            sphere: function () { var i = -1; while (++i < n)\n                streams[i].sphere(); },\n            lineStart: function () { var i = -1; while (++i < n)\n                streams[i].lineStart(); },\n            lineEnd: function () { var i = -1; while (++i < n)\n                streams[i].lineEnd(); },\n            polygonStart: function () { var i = -1; while (++i < n)\n                streams[i].polygonStart(); },\n            polygonEnd: function () { var i = -1; while (++i < n)\n                streams[i].polygonEnd(); }\n        };\n    }\n    // A composite projection for the United States, configured by default for\n    // 960×500. The projection also works quite well at 960×600 if you change the\n    // scale to 1285 and adjust the translate accordingly. The set of standard\n    // parallels for each region comes from USGS, which is published here:\n    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\n    function albersUsa() {\n        var cache, cacheStream, lower48 = albers(), lower48Point, alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n        hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n        point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        function albersUsa(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (lower48Point.point(x, y), point)\n                    || (alaskaPoint.point(x, y), point)\n                    || (hawaiiPoint.point(x, y), point);\n        }\n        albersUsa.invert = function (coordinates) {\n            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n                : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n                    : lower48).invert(coordinates);\n        };\n        albersUsa.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n        };\n        albersUsa.precision = function (_) {\n            if (!arguments.length)\n                return lower48.precision();\n            lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n            return reset();\n        };\n        albersUsa.scale = function (_) {\n            if (!arguments.length)\n                return lower48.scale();\n            lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n            return albersUsa.translate(lower48.translate());\n        };\n        albersUsa.translate = function (_) {\n            if (!arguments.length)\n                return lower48.translate();\n            var k = lower48.scale(), x = +_[0], y = +_[1];\n            lower48Point = lower48\n                .translate(_)\n                .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n                .stream(pointStream);\n            alaskaPoint = alaska\n                .translate([x - 0.307 * k, y + 0.201 * k])\n                .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])\n                .stream(pointStream);\n            hawaiiPoint = hawaii\n                .translate([x - 0.205 * k, y + 0.212 * k])\n                .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        albersUsa.fitExtent = function (extent, object) {\n            return fitExtent(albersUsa, extent, object);\n        };\n        albersUsa.fitSize = function (size, object) {\n            return fitSize(albersUsa, size, object);\n        };\n        albersUsa.fitWidth = function (width, object) {\n            return fitWidth(albersUsa, width, object);\n        };\n        albersUsa.fitHeight = function (height, object) {\n            return fitHeight(albersUsa, height, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return albersUsa;\n        }\n        return albersUsa.scale(1070);\n    }\n    function azimuthalRaw(scale) {\n        return function (x, y) {\n            var cx = cos(x), cy = cos(y), k = scale(cx * cy);\n            return [\n                k * cy * sin(x),\n                k * sin(y)\n            ];\n        };\n    }\n    function azimuthalInvert(angle) {\n        return function (x, y) {\n            var z = sqrt(x * x + y * y), c = angle(z), sc = sin(c), cc = cos(c);\n            return [\n                atan2(x * sc, z * cc),\n                asin(z && y * sc / z)\n            ];\n        };\n    }\n    var azimuthalEqualAreaRaw = azimuthalRaw(function (cxcy) {\n        return sqrt(2 / (1 + cxcy));\n    });\n    azimuthalEqualAreaRaw.invert = azimuthalInvert(function (z) {\n        return 2 * asin(z / 2);\n    });\n    function azimuthalEqualArea() {\n        return projection(azimuthalEqualAreaRaw)\n            .scale(124.75)\n            .clipAngle(180 - 1e-3);\n    }\n    var azimuthalEquidistantRaw = azimuthalRaw(function (c) {\n        return (c = acos(c)) && c / sin(c);\n    });\n    azimuthalEquidistantRaw.invert = azimuthalInvert(function (z) {\n        return z;\n    });\n    function azimuthalEquidistant() {\n        return projection(azimuthalEquidistantRaw)\n            .scale(79.4188)\n            .clipAngle(180 - 1e-3);\n    }\n    function mercatorRaw(lambda, phi) {\n        return [lambda, log(tan((halfPi + phi) / 2))];\n    }\n    mercatorRaw.invert = function (x, y) {\n        return [x, 2 * atan(exp(y)) - halfPi];\n    };\n    function mercator() {\n        return mercatorProjection(mercatorRaw)\n            .scale(961 / tau);\n    }\n    function mercatorProjection(project) {\n        var m = projection(project), center = m.center, scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, x0 = null, y0, x1, y1; // clip extent\n        m.scale = function (_) {\n            return arguments.length ? (scale(_), reclip()) : scale();\n        };\n        m.translate = function (_) {\n            return arguments.length ? (translate(_), reclip()) : translate();\n        };\n        m.center = function (_) {\n            return arguments.length ? (center(_), reclip()) : center();\n        };\n        m.clipExtent = function (_) {\n            return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n        };\n        function reclip() {\n            var k = pi * scale(), t = m(rotation(m.rotate()).invert([0, 0]));\n            return clipExtent(x0 == null\n                ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw\n                ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]\n                : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);\n        }\n        return reclip();\n    }\n    function tany(y) {\n        return tan((halfPi + y) / 2);\n    }\n    function conicConformalRaw(y0, y1) {\n        var cy0 = cos(y0), n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)), f = cy0 * pow(tany(y0), n) / n;\n        if (!n)\n            return mercatorRaw;\n        function project(x, y) {\n            if (f > 0) {\n                if (y < -halfPi + epsilon)\n                    y = -halfPi + epsilon;\n            }\n            else {\n                if (y > halfPi - epsilon)\n                    y = halfPi - epsilon;\n            }\n            var r = f / pow(tany(y), n);\n            return [r * sin(n * x), f - r * cos(n * x)];\n        }\n        project.invert = function (x, y) {\n            var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);\n            return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];\n        };\n        return project;\n    }\n    function conicConformal() {\n        return conicProjection(conicConformalRaw)\n            .scale(109.5)\n            .parallels([30, 30]);\n    }\n    function equirectangularRaw(lambda, phi) {\n        return [lambda, phi];\n    }\n    equirectangularRaw.invert = equirectangularRaw;\n    function equirectangular() {\n        return projection(equirectangularRaw)\n            .scale(152.63);\n    }\n    function conicEquidistantRaw(y0, y1) {\n        var cy0 = cos(y0), n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0), g = cy0 / n + y0;\n        if (abs(n) < epsilon)\n            return equirectangularRaw;\n        function project(x, y) {\n            var gy = g - y, nx = n * x;\n            return [gy * sin(nx), g - gy * cos(nx)];\n        }\n        project.invert = function (x, y) {\n            var gy = g - y;\n            return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];\n        };\n        return project;\n    }\n    function conicEquidistant() {\n        return conicProjection(conicEquidistantRaw)\n            .scale(131.154)\n            .center([0, 13.9389]);\n    }\n    var A1 = 1.340264, A2 = -0.081106, A3 = 0.000893, A4 = 0.003796, M = sqrt(3) / 2, iterations = 12;\n    function equalEarthRaw(lambda, phi) {\n        var l = asin(M * sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;\n        return [\n            lambda * cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),\n            l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))\n        ];\n    }\n    equalEarthRaw.invert = function (x, y) {\n        var l = y, l2 = l * l, l6 = l2 * l2 * l2;\n        for (var i = 0, delta, fy, fpy; i < iterations; ++i) {\n            fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;\n            fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);\n            l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;\n            if (abs(delta) < epsilon2)\n                break;\n        }\n        return [\n            M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),\n            asin(sin(l) / M)\n        ];\n    };\n    function equalEarth() {\n        return projection(equalEarthRaw)\n            .scale(177.158);\n    }\n    function gnomonicRaw(x, y) {\n        var cy = cos(y), k = cos(x) * cy;\n        return [cy * sin(x) / k, sin(y) / k];\n    }\n    gnomonicRaw.invert = azimuthalInvert(atan);\n    function gnomonic() {\n        return projection(gnomonicRaw)\n            .scale(144.049)\n            .clipAngle(60);\n    }\n    function scaleTranslate$1(kx, ky, tx, ty) {\n        return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({\n            point: function (x, y) {\n                this.stream.point(x * kx + tx, y * ky + ty);\n            }\n        });\n    }\n    function identity$1() {\n        var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = identity, // scale, translate and reflect\n        x0 = null, y0, x1, y1, // clip extent\n        postclip = identity, cache, cacheStream, projection;\n        function reset() {\n            cache = cacheStream = null;\n            return projection;\n        }\n        return projection = {\n            stream: function (stream) {\n                return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));\n            },\n            postclip: function (_) {\n                return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;\n            },\n            clipExtent: function (_) {\n                return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n            },\n            scale: function (_) {\n                return arguments.length ? (transform = scaleTranslate$1((k = +_) * sx, k * sy, tx, ty), reset()) : k;\n            },\n            translate: function (_) {\n                return arguments.length ? (transform = scaleTranslate$1(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];\n            },\n            reflectX: function (_) {\n                return arguments.length ? (transform = scaleTranslate$1(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;\n            },\n            reflectY: function (_) {\n                return arguments.length ? (transform = scaleTranslate$1(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;\n            },\n            fitExtent: function (extent, object) {\n                return fitExtent(projection, extent, object);\n            },\n            fitSize: function (size, object) {\n                return fitSize(projection, size, object);\n            },\n            fitWidth: function (width, object) {\n                return fitWidth(projection, width, object);\n            },\n            fitHeight: function (height, object) {\n                return fitHeight(projection, height, object);\n            }\n        };\n    }\n    function naturalEarth1Raw(lambda, phi) {\n        var phi2 = phi * phi, phi4 = phi2 * phi2;\n        return [\n            lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),\n            phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))\n        ];\n    }\n    naturalEarth1Raw.invert = function (x, y) {\n        var phi = y, i = 25, delta;\n        do {\n            var phi2 = phi * phi, phi4 = phi2 * phi2;\n            phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /\n                (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));\n        } while (abs(delta) > epsilon && --i > 0);\n        return [\n            x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),\n            phi\n        ];\n    };\n    function naturalEarth1() {\n        return projection(naturalEarth1Raw)\n            .scale(175.295);\n    }\n    function orthographicRaw(x, y) {\n        return [cos(y) * sin(x), sin(y)];\n    }\n    orthographicRaw.invert = azimuthalInvert(asin);\n    function orthographic() {\n        return projection(orthographicRaw)\n            .scale(249.5)\n            .clipAngle(90 + epsilon);\n    }\n    function stereographicRaw(x, y) {\n        var cy = cos(y), k = 1 + cos(x) * cy;\n        return [cy * sin(x) / k, sin(y) / k];\n    }\n    stereographicRaw.invert = azimuthalInvert(function (z) {\n        return 2 * atan(z);\n    });\n    function stereographic() {\n        return projection(stereographicRaw)\n            .scale(250)\n            .clipAngle(142);\n    }\n    function transverseMercatorRaw(lambda, phi) {\n        return [log(tan((halfPi + phi) / 2)), -lambda];\n    }\n    transverseMercatorRaw.invert = function (x, y) {\n        return [-y, 2 * atan(exp(x)) - halfPi];\n    };\n    function transverseMercator() {\n        var m = mercatorProjection(transverseMercatorRaw), center = m.center, rotate = m.rotate;\n        m.center = function (_) {\n            return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n        };\n        m.rotate = function (_) {\n            return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n        };\n        return rotate([0, 0, 90])\n            .scale(159.155);\n    }\n    exports.geoAlbers = albers;\n    exports.geoAlbersUsa = albersUsa;\n    exports.geoArea = area;\n    exports.geoAzimuthalEqualArea = azimuthalEqualArea;\n    exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;\n    exports.geoAzimuthalEquidistant = azimuthalEquidistant;\n    exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;\n    exports.geoBounds = bounds;\n    exports.geoCentroid = centroid;\n    exports.geoCircle = circle;\n    exports.geoClipAntimeridian = clipAntimeridian;\n    exports.geoClipCircle = clipCircle;\n    exports.geoClipExtent = extent;\n    exports.geoClipRectangle = clipRectangle;\n    exports.geoConicConformal = conicConformal;\n    exports.geoConicConformalRaw = conicConformalRaw;\n    exports.geoConicEqualArea = conicEqualArea;\n    exports.geoConicEqualAreaRaw = conicEqualAreaRaw;\n    exports.geoConicEquidistant = conicEquidistant;\n    exports.geoConicEquidistantRaw = conicEquidistantRaw;\n    exports.geoContains = contains;\n    exports.geoDistance = distance;\n    exports.geoEqualEarth = equalEarth;\n    exports.geoEqualEarthRaw = equalEarthRaw;\n    exports.geoEquirectangular = equirectangular;\n    exports.geoEquirectangularRaw = equirectangularRaw;\n    exports.geoGnomonic = gnomonic;\n    exports.geoGnomonicRaw = gnomonicRaw;\n    exports.geoGraticule = graticule;\n    exports.geoGraticule10 = graticule10;\n    exports.geoIdentity = identity$1;\n    exports.geoInterpolate = interpolate;\n    exports.geoLength = length;\n    exports.geoMercator = mercator;\n    exports.geoMercatorRaw = mercatorRaw;\n    exports.geoNaturalEarth1 = naturalEarth1;\n    exports.geoNaturalEarth1Raw = naturalEarth1Raw;\n    exports.geoOrthographic = orthographic;\n    exports.geoOrthographicRaw = orthographicRaw;\n    exports.geoPath = index;\n    exports.geoProjection = projection;\n    exports.geoProjectionMutator = projectionMutator;\n    exports.geoRotation = rotation;\n    exports.geoStereographic = stereographic;\n    exports.geoStereographicRaw = stereographicRaw;\n    exports.geoStream = geoStream;\n    exports.geoTransform = transform;\n    exports.geoTransverseMercator = transverseMercator;\n    exports.geoTransverseMercatorRaw = transverseMercatorRaw;\n    Object.defineProperty(exports, '__esModule', { value: true });\n}));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-geo/ Version 1.6.4. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! d3-array */ \"./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js\")) :\n        undefined;\n}(this, (function (exports, d3Array) {\n    'use strict';\n    // Adds floating point numbers with twice the normal precision.\n    // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n    // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n    // 305–363 (1997).\n    // Code adapted from GeographicLib by Charles F. F. Karney,\n    // http://geographiclib.sourceforge.net/\n    var adder = function () {\n        return new Adder;\n    };\n    function Adder() {\n        this.reset();\n    }\n    Adder.prototype = {\n        constructor: Adder,\n        reset: function () {\n            this.s = // rounded value\n                this.t = 0; // exact error\n        },\n        add: function (y) {\n            add(temp, y, this.t);\n            add(this, temp.s, this.s);\n            if (this.s)\n                this.t += temp.t;\n            else\n                this.s = temp.t;\n        },\n        valueOf: function () {\n            return this.s;\n        }\n    };\n    var temp = new Adder;\n    function add(adder, a, b) {\n        var x = adder.s = a + b, bv = x - a, av = x - bv;\n        adder.t = (a - av) + (b - bv);\n    }\n    var epsilon = 1e-6;\n    var epsilon2 = 1e-12;\n    var pi = Math.PI;\n    var halfPi = pi / 2;\n    var quarterPi = pi / 4;\n    var tau = pi * 2;\n    var degrees = 180 / pi;\n    var radians = pi / 180;\n    var abs = Math.abs;\n    var atan = Math.atan;\n    var atan2 = Math.atan2;\n    var cos = Math.cos;\n    var ceil = Math.ceil;\n    var exp = Math.exp;\n    var log = Math.log;\n    var pow = Math.pow;\n    var sin = Math.sin;\n    var sign = Math.sign || function (x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\n    var sqrt = Math.sqrt;\n    var tan = Math.tan;\n    function acos(x) {\n        return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n    }\n    function asin(x) {\n        return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n    }\n    function haversin(x) {\n        return (x = sin(x / 2)) * x;\n    }\n    function noop() { }\n    function streamGeometry(geometry, stream) {\n        if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n            streamGeometryType[geometry.type](geometry, stream);\n        }\n    }\n    var streamObjectType = {\n        Feature: function (object, stream) {\n            streamGeometry(object.geometry, stream);\n        },\n        FeatureCollection: function (object, stream) {\n            var features = object.features, i = -1, n = features.length;\n            while (++i < n)\n                streamGeometry(features[i].geometry, stream);\n        }\n    };\n    var streamGeometryType = {\n        Sphere: function (object, stream) {\n            stream.sphere();\n        },\n        Point: function (object, stream) {\n            object = object.coordinates;\n            stream.point(object[0], object[1], object[2]);\n        },\n        MultiPoint: function (object, stream) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                object = coordinates[i], stream.point(object[0], object[1], object[2]);\n        },\n        LineString: function (object, stream) {\n            streamLine(object.coordinates, stream, 0);\n        },\n        MultiLineString: function (object, stream) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                streamLine(coordinates[i], stream, 0);\n        },\n        Polygon: function (object, stream) {\n            streamPolygon(object.coordinates, stream);\n        },\n        MultiPolygon: function (object, stream) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                streamPolygon(coordinates[i], stream);\n        },\n        GeometryCollection: function (object, stream) {\n            var geometries = object.geometries, i = -1, n = geometries.length;\n            while (++i < n)\n                streamGeometry(geometries[i], stream);\n        }\n    };\n    function streamLine(coordinates, stream, closed) {\n        var i = -1, n = coordinates.length - closed, coordinate;\n        stream.lineStart();\n        while (++i < n)\n            coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n        stream.lineEnd();\n    }\n    function streamPolygon(coordinates, stream) {\n        var i = -1, n = coordinates.length;\n        stream.polygonStart();\n        while (++i < n)\n            streamLine(coordinates[i], stream, 1);\n        stream.polygonEnd();\n    }\n    var geoStream = function (object, stream) {\n        if (object && streamObjectType.hasOwnProperty(object.type)) {\n            streamObjectType[object.type](object, stream);\n        }\n        else {\n            streamGeometry(object, stream);\n        }\n    };\n    var areaRingSum = adder();\n    var areaSum = adder();\n    var lambda00;\n    var phi00;\n    var lambda0;\n    var cosPhi0;\n    var sinPhi0;\n    var areaStream = {\n        point: noop,\n        lineStart: noop,\n        lineEnd: noop,\n        polygonStart: function () {\n            areaRingSum.reset();\n            areaStream.lineStart = areaRingStart;\n            areaStream.lineEnd = areaRingEnd;\n        },\n        polygonEnd: function () {\n            var areaRing = +areaRingSum;\n            areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);\n            this.lineStart = this.lineEnd = this.point = noop;\n        },\n        sphere: function () {\n            areaSum.add(tau);\n        }\n    };\n    function areaRingStart() {\n        areaStream.point = areaPointFirst;\n    }\n    function areaRingEnd() {\n        areaPoint(lambda00, phi00);\n    }\n    function areaPointFirst(lambda, phi) {\n        areaStream.point = areaPoint;\n        lambda00 = lambda, phi00 = phi;\n        lambda *= radians, phi *= radians;\n        lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);\n    }\n    function areaPoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        phi = phi / 2 + quarterPi; // half the angular distance from south pole\n        // Spherical excess E for a spherical triangle with vertices: south pole,\n        // previous point, current point.  Uses a formula derived from Cagnoli’s\n        // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n        var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos(phi), sinPhi = sin(phi), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * cos(adLambda), v = k * sdLambda * sin(adLambda);\n        areaRingSum.add(atan2(v, u));\n        // Advance the previous points.\n        lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n    }\n    var area = function (object) {\n        areaSum.reset();\n        geoStream(object, areaStream);\n        return areaSum * 2;\n    };\n    function spherical(cartesian) {\n        return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n    }\n    function cartesian(spherical) {\n        var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);\n        return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n    }\n    function cartesianDot(a, b) {\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n    }\n    function cartesianCross(a, b) {\n        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n    }\n    // TODO return a\n    function cartesianAddInPlace(a, b) {\n        a[0] += b[0], a[1] += b[1], a[2] += b[2];\n    }\n    function cartesianScale(vector, k) {\n        return [vector[0] * k, vector[1] * k, vector[2] * k];\n    }\n    // TODO return d\n    function cartesianNormalizeInPlace(d) {\n        var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n        d[0] /= l, d[1] /= l, d[2] /= l;\n    }\n    var lambda0$1;\n    var phi0;\n    var lambda1;\n    var phi1;\n    var lambda2;\n    var lambda00$1;\n    var phi00$1;\n    var p0;\n    var deltaSum = adder();\n    var ranges;\n    var range$1;\n    var boundsStream = {\n        point: boundsPoint,\n        lineStart: boundsLineStart,\n        lineEnd: boundsLineEnd,\n        polygonStart: function () {\n            boundsStream.point = boundsRingPoint;\n            boundsStream.lineStart = boundsRingStart;\n            boundsStream.lineEnd = boundsRingEnd;\n            deltaSum.reset();\n            areaStream.polygonStart();\n        },\n        polygonEnd: function () {\n            areaStream.polygonEnd();\n            boundsStream.point = boundsPoint;\n            boundsStream.lineStart = boundsLineStart;\n            boundsStream.lineEnd = boundsLineEnd;\n            if (areaRingSum < 0)\n                lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n            else if (deltaSum > epsilon)\n                phi1 = 90;\n            else if (deltaSum < -epsilon)\n                phi0 = -90;\n            range$1[0] = lambda0$1, range$1[1] = lambda1;\n        }\n    };\n    function boundsPoint(lambda, phi) {\n        ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);\n        if (phi < phi0)\n            phi0 = phi;\n        if (phi > phi1)\n            phi1 = phi;\n    }\n    function linePoint(lambda, phi) {\n        var p = cartesian([lambda * radians, phi * radians]);\n        if (p0) {\n            var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);\n            cartesianNormalizeInPlace(inflection);\n            inflection = spherical(inflection);\n            var delta = lambda - lambda2, sign$$1 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign$$1, phii, antimeridian = abs(delta) > 180;\n            if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {\n                phii = inflection[1] * degrees;\n                if (phii > phi1)\n                    phi1 = phii;\n            }\n            else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {\n                phii = -inflection[1] * degrees;\n                if (phii < phi0)\n                    phi0 = phii;\n            }\n            else {\n                if (phi < phi0)\n                    phi0 = phi;\n                if (phi > phi1)\n                    phi1 = phi;\n            }\n            if (antimeridian) {\n                if (lambda < lambda2) {\n                    if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))\n                        lambda1 = lambda;\n                }\n                else {\n                    if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))\n                        lambda0$1 = lambda;\n                }\n            }\n            else {\n                if (lambda1 >= lambda0$1) {\n                    if (lambda < lambda0$1)\n                        lambda0$1 = lambda;\n                    if (lambda > lambda1)\n                        lambda1 = lambda;\n                }\n                else {\n                    if (lambda > lambda2) {\n                        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))\n                            lambda1 = lambda;\n                    }\n                    else {\n                        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))\n                            lambda0$1 = lambda;\n                    }\n                }\n            }\n        }\n        else {\n            ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);\n        }\n        if (phi < phi0)\n            phi0 = phi;\n        if (phi > phi1)\n            phi1 = phi;\n        p0 = p, lambda2 = lambda;\n    }\n    function boundsLineStart() {\n        boundsStream.point = linePoint;\n    }\n    function boundsLineEnd() {\n        range$1[0] = lambda0$1, range$1[1] = lambda1;\n        boundsStream.point = boundsPoint;\n        p0 = null;\n    }\n    function boundsRingPoint(lambda, phi) {\n        if (p0) {\n            var delta = lambda - lambda2;\n            deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n        }\n        else {\n            lambda00$1 = lambda, phi00$1 = phi;\n        }\n        areaStream.point(lambda, phi);\n        linePoint(lambda, phi);\n    }\n    function boundsRingStart() {\n        areaStream.lineStart();\n    }\n    function boundsRingEnd() {\n        boundsRingPoint(lambda00$1, phi00$1);\n        areaStream.lineEnd();\n        if (abs(deltaSum) > epsilon)\n            lambda0$1 = -(lambda1 = 180);\n        range$1[0] = lambda0$1, range$1[1] = lambda1;\n        p0 = null;\n    }\n    // Finds the left-right distance between two longitudes.\n    // This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n    // the distance between ±180° to be 360°.\n    function angle(lambda0, lambda1) {\n        return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n    }\n    function rangeCompare(a, b) {\n        return a[0] - b[0];\n    }\n    function rangeContains(range$$1, x) {\n        return range$$1[0] <= range$$1[1] ? range$$1[0] <= x && x <= range$$1[1] : x < range$$1[0] || range$$1[1] < x;\n    }\n    var bounds = function (feature) {\n        var i, n, a, b, merged, deltaMax, delta;\n        phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);\n        ranges = [];\n        geoStream(feature, boundsStream);\n        // First, sort ranges by their minimum longitudes.\n        if (n = ranges.length) {\n            ranges.sort(rangeCompare);\n            // Then, merge any ranges that overlap.\n            for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n                b = ranges[i];\n                if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n                    if (angle(a[0], b[1]) > angle(a[0], a[1]))\n                        a[1] = b[1];\n                    if (angle(b[0], a[1]) > angle(a[0], a[1]))\n                        a[0] = b[0];\n                }\n                else {\n                    merged.push(a = b);\n                }\n            }\n            // Finally, find the largest gap between the merged ranges.\n            // The final bounding box will be the inverse of this gap.\n            for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n                b = merged[i];\n                if ((delta = angle(a[1], b[0])) > deltaMax)\n                    deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];\n            }\n        }\n        ranges = range$1 = null;\n        return lambda0$1 === Infinity || phi0 === Infinity\n            ? [[NaN, NaN], [NaN, NaN]]\n            : [[lambda0$1, phi0], [lambda1, phi1]];\n    };\n    var W0;\n    var W1;\n    var X0;\n    var Y0;\n    var Z0;\n    var X1;\n    var Y1;\n    var Z1;\n    var X2;\n    var Y2;\n    var Z2;\n    var lambda00$2;\n    var phi00$2;\n    var x0;\n    var y0;\n    var z0; // previous point\n    var centroidStream = {\n        sphere: noop,\n        point: centroidPoint,\n        lineStart: centroidLineStart,\n        lineEnd: centroidLineEnd,\n        polygonStart: function () {\n            centroidStream.lineStart = centroidRingStart;\n            centroidStream.lineEnd = centroidRingEnd;\n        },\n        polygonEnd: function () {\n            centroidStream.lineStart = centroidLineStart;\n            centroidStream.lineEnd = centroidLineEnd;\n        }\n    };\n    // Arithmetic mean of Cartesian vectors.\n    function centroidPoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var cosPhi = cos(phi);\n        centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));\n    }\n    function centroidPointCartesian(x, y, z) {\n        ++W0;\n        X0 += (x - X0) / W0;\n        Y0 += (y - Y0) / W0;\n        Z0 += (z - Z0) / W0;\n    }\n    function centroidLineStart() {\n        centroidStream.point = centroidLinePointFirst;\n    }\n    function centroidLinePointFirst(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var cosPhi = cos(phi);\n        x0 = cosPhi * cos(lambda);\n        y0 = cosPhi * sin(lambda);\n        z0 = sin(phi);\n        centroidStream.point = centroidLinePoint;\n        centroidPointCartesian(x0, y0, z0);\n    }\n    function centroidLinePoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n        W1 += w;\n        X1 += w * (x0 + (x0 = x));\n        Y1 += w * (y0 + (y0 = y));\n        Z1 += w * (z0 + (z0 = z));\n        centroidPointCartesian(x0, y0, z0);\n    }\n    function centroidLineEnd() {\n        centroidStream.point = centroidPoint;\n    }\n    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n    // J. Applied Mechanics 42, 239 (1975).\n    function centroidRingStart() {\n        centroidStream.point = centroidRingPointFirst;\n    }\n    function centroidRingEnd() {\n        centroidRingPoint(lambda00$2, phi00$2);\n        centroidStream.point = centroidPoint;\n    }\n    function centroidRingPointFirst(lambda, phi) {\n        lambda00$2 = lambda, phi00$2 = phi;\n        lambda *= radians, phi *= radians;\n        centroidStream.point = centroidRingPoint;\n        var cosPhi = cos(phi);\n        x0 = cosPhi * cos(lambda);\n        y0 = cosPhi * sin(lambda);\n        z0 = sin(phi);\n        centroidPointCartesian(x0, y0, z0);\n    }\n    function centroidRingPoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = sqrt(cx * cx + cy * cy + cz * cz), w = asin(m), // line weight = angle\n        v = m && -w / m; // area weight multiplier\n        X2 += v * cx;\n        Y2 += v * cy;\n        Z2 += v * cz;\n        W1 += w;\n        X1 += w * (x0 + (x0 = x));\n        Y1 += w * (y0 + (y0 = y));\n        Z1 += w * (z0 + (z0 = z));\n        centroidPointCartesian(x0, y0, z0);\n    }\n    var centroid = function (object) {\n        W0 = W1 =\n            X0 = Y0 = Z0 =\n                X1 = Y1 = Z1 =\n                    X2 = Y2 = Z2 = 0;\n        geoStream(object, centroidStream);\n        var x = X2, y = Y2, z = Z2, m = x * x + y * y + z * z;\n        // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n        if (m < epsilon2) {\n            x = X1, y = Y1, z = Z1;\n            // If the feature has zero length, fall back to arithmetic mean of point vectors.\n            if (W1 < epsilon)\n                x = X0, y = Y0, z = Z0;\n            m = x * x + y * y + z * z;\n            // If the feature still has an undefined ccentroid, then return.\n            if (m < epsilon2)\n                return [NaN, NaN];\n        }\n        return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];\n    };\n    var constant = function (x) {\n        return function () {\n            return x;\n        };\n    };\n    var compose = function (a, b) {\n        function compose(x, y) {\n            return x = a(x, y), b(x[0], x[1]);\n        }\n        if (a.invert && b.invert)\n            compose.invert = function (x, y) {\n                return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n            };\n        return compose;\n    };\n    function rotationIdentity(lambda, phi) {\n        return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n    }\n    rotationIdentity.invert = rotationIdentity;\n    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n        return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))\n            : rotationLambda(deltaLambda))\n            : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)\n                : rotationIdentity);\n    }\n    function forwardRotationLambda(deltaLambda) {\n        return function (lambda, phi) {\n            return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n        };\n    }\n    function rotationLambda(deltaLambda) {\n        var rotation = forwardRotationLambda(deltaLambda);\n        rotation.invert = forwardRotationLambda(-deltaLambda);\n        return rotation;\n    }\n    function rotationPhiGamma(deltaPhi, deltaGamma) {\n        var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);\n        function rotation(lambda, phi) {\n            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;\n            return [\n                atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n                asin(k * cosDeltaGamma + y * sinDeltaGamma)\n            ];\n        }\n        rotation.invert = function (lambda, phi) {\n            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;\n            return [\n                atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n                asin(k * cosDeltaPhi - x * sinDeltaPhi)\n            ];\n        };\n        return rotation;\n    }\n    var rotation = function (rotate) {\n        rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n        function forward(coordinates) {\n            coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n            return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n        }\n        forward.invert = function (coordinates) {\n            coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n            return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n        };\n        return forward;\n    };\n    // Generates a circle centered at [0°, 0°], with a given radius and precision.\n    function circleStream(stream, radius, delta, direction, t0, t1) {\n        if (!delta)\n            return;\n        var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;\n        if (t0 == null) {\n            t0 = radius + direction * tau;\n            t1 = radius - step / 2;\n        }\n        else {\n            t0 = circleRadius(cosRadius, t0);\n            t1 = circleRadius(cosRadius, t1);\n            if (direction > 0 ? t0 < t1 : t0 > t1)\n                t0 += direction * tau;\n        }\n        for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n            point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);\n            stream.point(point[0], point[1]);\n        }\n    }\n    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\n    function circleRadius(cosRadius, point) {\n        point = cartesian(point), point[0] -= cosRadius;\n        cartesianNormalizeInPlace(point);\n        var radius = acos(-point[1]);\n        return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;\n    }\n    var circle = function () {\n        var center = constant([0, 0]), radius = constant(90), precision = constant(6), ring, rotate, stream = { point: point };\n        function point(x, y) {\n            ring.push(x = rotate(x, y));\n            x[0] *= degrees, x[1] *= degrees;\n        }\n        function circle() {\n            var c = center.apply(this, arguments), r = radius.apply(this, arguments) * radians, p = precision.apply(this, arguments) * radians;\n            ring = [];\n            rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;\n            circleStream(stream, r, p, 1);\n            c = { type: \"Polygon\", coordinates: [ring] };\n            ring = rotate = null;\n            return c;\n        }\n        circle.center = function (_) {\n            return arguments.length ? (center = typeof _ === \"function\" ? _ : constant([+_[0], +_[1]]), circle) : center;\n        };\n        circle.radius = function (_) {\n            return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), circle) : radius;\n        };\n        circle.precision = function (_) {\n            return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant(+_), circle) : precision;\n        };\n        return circle;\n    };\n    var clipBuffer = function () {\n        var lines = [], line;\n        return {\n            point: function (x, y) {\n                line.push([x, y]);\n            },\n            lineStart: function () {\n                lines.push(line = []);\n            },\n            lineEnd: noop,\n            rejoin: function () {\n                if (lines.length > 1)\n                    lines.push(lines.pop().concat(lines.shift()));\n            },\n            result: function () {\n                var result = lines;\n                lines = [];\n                line = null;\n                return result;\n            }\n        };\n    };\n    var clipLine = function (a, b, x0, y0, x1, y1) {\n        var ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;\n        r = x0 - ax;\n        if (!dx && r > 0)\n            return;\n        r /= dx;\n        if (dx < 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        else if (dx > 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        r = x1 - ax;\n        if (!dx && r < 0)\n            return;\n        r /= dx;\n        if (dx < 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        else if (dx > 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        r = y0 - ay;\n        if (!dy && r > 0)\n            return;\n        r /= dy;\n        if (dy < 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        else if (dy > 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        r = y1 - ay;\n        if (!dy && r < 0)\n            return;\n        r /= dy;\n        if (dy < 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        else if (dy > 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        if (t0 > 0)\n            a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n        if (t1 < 1)\n            b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n        return true;\n    };\n    var pointEqual = function (a, b) {\n        return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n    };\n    function Intersection(point, points, other, entry) {\n        this.x = point;\n        this.z = points;\n        this.o = other; // another intersection\n        this.e = entry; // is an entry?\n        this.v = false; // visited\n        this.n = this.p = null; // next & previous\n    }\n    // A generalized polygon clipping algorithm: given a polygon that has been cut\n    // into its visible line segments, and rejoins the segments by interpolating\n    // along the clip edge.\n    var clipPolygon = function (segments, compareIntersection, startInside, interpolate, stream) {\n        var subject = [], clip = [], i, n;\n        segments.forEach(function (segment) {\n            if ((n = segment.length - 1) <= 0)\n                return;\n            var n, p0 = segment[0], p1 = segment[n], x;\n            // If the first and last points of a segment are coincident, then treat as a\n            // closed ring. TODO if all rings are closed, then the winding order of the\n            // exterior ring should be checked.\n            if (pointEqual(p0, p1)) {\n                stream.lineStart();\n                for (i = 0; i < n; ++i)\n                    stream.point((p0 = segment[i])[0], p0[1]);\n                stream.lineEnd();\n                return;\n            }\n            subject.push(x = new Intersection(p0, segment, null, true));\n            clip.push(x.o = new Intersection(p0, null, x, false));\n            subject.push(x = new Intersection(p1, segment, null, false));\n            clip.push(x.o = new Intersection(p1, null, x, true));\n        });\n        if (!subject.length)\n            return;\n        clip.sort(compareIntersection);\n        link(subject);\n        link(clip);\n        for (i = 0, n = clip.length; i < n; ++i) {\n            clip[i].e = startInside = !startInside;\n        }\n        var start = subject[0], points, point;\n        while (1) {\n            // Find first unvisited intersection.\n            var current = start, isSubject = true;\n            while (current.v)\n                if ((current = current.n) === start)\n                    return;\n            points = current.z;\n            stream.lineStart();\n            do {\n                current.v = current.o.v = true;\n                if (current.e) {\n                    if (isSubject) {\n                        for (i = 0, n = points.length; i < n; ++i)\n                            stream.point((point = points[i])[0], point[1]);\n                    }\n                    else {\n                        interpolate(current.x, current.n.x, 1, stream);\n                    }\n                    current = current.n;\n                }\n                else {\n                    if (isSubject) {\n                        points = current.p.z;\n                        for (i = points.length - 1; i >= 0; --i)\n                            stream.point((point = points[i])[0], point[1]);\n                    }\n                    else {\n                        interpolate(current.x, current.p.x, -1, stream);\n                    }\n                    current = current.p;\n                }\n                current = current.o;\n                points = current.z;\n                isSubject = !isSubject;\n            } while (!current.v);\n            stream.lineEnd();\n        }\n    };\n    function link(array) {\n        if (!(n = array.length))\n            return;\n        var n, i = 0, a = array[0], b;\n        while (++i < n) {\n            a.n = b = array[i];\n            b.p = a;\n            a = b;\n        }\n        a.n = b = array[0];\n        b.p = a;\n    }\n    var clipMax = 1e9;\n    var clipMin = -clipMax;\n    // TODO Use d3-polygon’s polygonContains here for the ring check?\n    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n    function clipExtent(x0, y0, x1, y1) {\n        function visible(x, y) {\n            return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n        }\n        function interpolate(from, to, direction, stream) {\n            var a = 0, a1 = 0;\n            if (from == null\n                || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n                || comparePoint(from, to) < 0 ^ direction > 0) {\n                do\n                    stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n                while ((a = (a + direction + 4) % 4) !== a1);\n            }\n            else {\n                stream.point(to[0], to[1]);\n            }\n        }\n        function corner(p, direction) {\n            return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3\n                : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1\n                    : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0\n                        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n        }\n        function compareIntersection(a, b) {\n            return comparePoint(a.x, b.x);\n        }\n        function comparePoint(a, b) {\n            var ca = corner(a, 1), cb = corner(b, 1);\n            return ca !== cb ? ca - cb\n                : ca === 0 ? b[1] - a[1]\n                    : ca === 1 ? a[0] - b[0]\n                        : ca === 2 ? a[1] - b[1]\n                            : b[0] - a[0];\n        }\n        return function (stream) {\n            var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, // first point\n            x_, y_, v_, // previous point\n            first, clean;\n            var clipStream = {\n                point: point,\n                lineStart: lineStart,\n                lineEnd: lineEnd,\n                polygonStart: polygonStart,\n                polygonEnd: polygonEnd\n            };\n            function point(x, y) {\n                if (visible(x, y))\n                    activeStream.point(x, y);\n            }\n            function polygonInside() {\n                var winding = 0;\n                for (var i = 0, n = polygon.length; i < n; ++i) {\n                    for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n                        a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n                        if (a1 <= y1) {\n                            if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0))\n                                ++winding;\n                        }\n                        else {\n                            if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0))\n                                --winding;\n                        }\n                    }\n                }\n                return winding;\n            }\n            // Buffer geometry within a polygon and then clip it en masse.\n            function polygonStart() {\n                activeStream = bufferStream, segments = [], polygon = [], clean = true;\n            }\n            function polygonEnd() {\n                var startInside = polygonInside(), cleanInside = clean && startInside, visible = (segments = d3Array.merge(segments)).length;\n                if (cleanInside || visible) {\n                    stream.polygonStart();\n                    if (cleanInside) {\n                        stream.lineStart();\n                        interpolate(null, null, 1, stream);\n                        stream.lineEnd();\n                    }\n                    if (visible) {\n                        clipPolygon(segments, compareIntersection, startInside, interpolate, stream);\n                    }\n                    stream.polygonEnd();\n                }\n                activeStream = stream, segments = polygon = ring = null;\n            }\n            function lineStart() {\n                clipStream.point = linePoint;\n                if (polygon)\n                    polygon.push(ring = []);\n                first = true;\n                v_ = false;\n                x_ = y_ = NaN;\n            }\n            // TODO rather than special-case polygons, simply handle them separately.\n            // Ideally, coincident intersection points should be jittered to avoid\n            // clipping issues.\n            function lineEnd() {\n                if (segments) {\n                    linePoint(x__, y__);\n                    if (v__ && v_)\n                        bufferStream.rejoin();\n                    segments.push(bufferStream.result());\n                }\n                clipStream.point = point;\n                if (v_)\n                    activeStream.lineEnd();\n            }\n            function linePoint(x, y) {\n                var v = visible(x, y);\n                if (polygon)\n                    ring.push([x, y]);\n                if (first) {\n                    x__ = x, y__ = y, v__ = v;\n                    first = false;\n                    if (v) {\n                        activeStream.lineStart();\n                        activeStream.point(x, y);\n                    }\n                }\n                else {\n                    if (v && v_)\n                        activeStream.point(x, y);\n                    else {\n                        var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n                        if (clipLine(a, b, x0, y0, x1, y1)) {\n                            if (!v_) {\n                                activeStream.lineStart();\n                                activeStream.point(a[0], a[1]);\n                            }\n                            activeStream.point(b[0], b[1]);\n                            if (!v)\n                                activeStream.lineEnd();\n                            clean = false;\n                        }\n                        else if (v) {\n                            activeStream.lineStart();\n                            activeStream.point(x, y);\n                            clean = false;\n                        }\n                    }\n                }\n                x_ = x, y_ = y, v_ = v;\n            }\n            return clipStream;\n        };\n    }\n    var extent = function () {\n        var x0 = 0, y0 = 0, x1 = 960, y1 = 500, cache, cacheStream, clip;\n        return clip = {\n            stream: function (stream) {\n                return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);\n            },\n            extent: function (_) {\n                return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\n            }\n        };\n    };\n    var sum = adder();\n    var polygonContains = function (polygon, point) {\n        var lambda = point[0], phi = point[1], normal = [sin(lambda), -cos(lambda), 0], angle = 0, winding = 0;\n        sum.reset();\n        for (var i = 0, n = polygon.length; i < n; ++i) {\n            if (!(m = (ring = polygon[i]).length))\n                continue;\n            var ring, m, point0 = ring[m - 1], lambda0 = point0[0], phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);\n            for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n                var point1 = ring[j], lambda1 = point1[0], phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta = lambda1 - lambda0, sign$$1 = delta >= 0 ? 1 : -1, absDelta = sign$$1 * delta, antimeridian = absDelta > pi, k = sinPhi0 * sinPhi1;\n                sum.add(atan2(k * sign$$1 * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));\n                angle += antimeridian ? delta + sign$$1 * tau : delta;\n                // Are the longitudes either side of the point’s meridian (lambda),\n                // and are the latitudes smaller than the parallel (phi)?\n                if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n                    var arc = cartesianCross(cartesian(point0), cartesian(point1));\n                    cartesianNormalizeInPlace(arc);\n                    var intersection = cartesianCross(normal, arc);\n                    cartesianNormalizeInPlace(intersection);\n                    var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n                    if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n                        winding += antimeridian ^ delta >= 0 ? 1 : -1;\n                    }\n                }\n            }\n        }\n        // First, determine whether the South pole is inside or outside:\n        //\n        // It is inside if:\n        // * the polygon winds around it in a clockwise direction.\n        // * the polygon does not (cumulatively) wind around it, but has a negative\n        //   (counter-clockwise) area.\n        //\n        // Second, count the (signed) number of times a segment crosses a lambda\n        // from the point to the South pole.  If it is zero, then the point is the\n        // same side as the South pole.\n        return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);\n    };\n    var lengthSum = adder();\n    var lambda0$2;\n    var sinPhi0$1;\n    var cosPhi0$1;\n    var lengthStream = {\n        sphere: noop,\n        point: noop,\n        lineStart: lengthLineStart,\n        lineEnd: noop,\n        polygonStart: noop,\n        polygonEnd: noop\n    };\n    function lengthLineStart() {\n        lengthStream.point = lengthPointFirst;\n        lengthStream.lineEnd = lengthLineEnd;\n    }\n    function lengthLineEnd() {\n        lengthStream.point = lengthStream.lineEnd = noop;\n    }\n    function lengthPointFirst(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);\n        lengthStream.point = lengthPoint;\n    }\n    function lengthPoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var sinPhi = sin(phi), cosPhi = cos(phi), delta = abs(lambda - lambda0$2), cosDelta = cos(delta), sinDelta = sin(delta), x = cosPhi * sinDelta, y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta, z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;\n        lengthSum.add(atan2(sqrt(x * x + y * y), z));\n        lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;\n    }\n    var length = function (object) {\n        lengthSum.reset();\n        geoStream(object, lengthStream);\n        return +lengthSum;\n    };\n    var coordinates = [null, null];\n    var object = { type: \"LineString\", coordinates: coordinates };\n    var distance = function (a, b) {\n        coordinates[0] = a;\n        coordinates[1] = b;\n        return length(object);\n    };\n    var containsObjectType = {\n        Feature: function (object, point) {\n            return containsGeometry(object.geometry, point);\n        },\n        FeatureCollection: function (object, point) {\n            var features = object.features, i = -1, n = features.length;\n            while (++i < n)\n                if (containsGeometry(features[i].geometry, point))\n                    return true;\n            return false;\n        }\n    };\n    var containsGeometryType = {\n        Sphere: function () {\n            return true;\n        },\n        Point: function (object, point) {\n            return containsPoint(object.coordinates, point);\n        },\n        MultiPoint: function (object, point) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                if (containsPoint(coordinates[i], point))\n                    return true;\n            return false;\n        },\n        LineString: function (object, point) {\n            return containsLine(object.coordinates, point);\n        },\n        MultiLineString: function (object, point) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                if (containsLine(coordinates[i], point))\n                    return true;\n            return false;\n        },\n        Polygon: function (object, point) {\n            return containsPolygon(object.coordinates, point);\n        },\n        MultiPolygon: function (object, point) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                if (containsPolygon(coordinates[i], point))\n                    return true;\n            return false;\n        },\n        GeometryCollection: function (object, point) {\n            var geometries = object.geometries, i = -1, n = geometries.length;\n            while (++i < n)\n                if (containsGeometry(geometries[i], point))\n                    return true;\n            return false;\n        }\n    };\n    function containsGeometry(geometry, point) {\n        return geometry && containsGeometryType.hasOwnProperty(geometry.type)\n            ? containsGeometryType[geometry.type](geometry, point)\n            : false;\n    }\n    function containsPoint(coordinates, point) {\n        return distance(coordinates, point) === 0;\n    }\n    function containsLine(coordinates, point) {\n        var ab = distance(coordinates[0], coordinates[1]), ao = distance(coordinates[0], point), ob = distance(point, coordinates[1]);\n        return ao + ob <= ab + epsilon;\n    }\n    function containsPolygon(coordinates, point) {\n        return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));\n    }\n    function ringRadians(ring) {\n        return ring = ring.map(pointRadians), ring.pop(), ring;\n    }\n    function pointRadians(point) {\n        return [point[0] * radians, point[1] * radians];\n    }\n    var contains = function (object, point) {\n        return (object && containsObjectType.hasOwnProperty(object.type)\n            ? containsObjectType[object.type]\n            : containsGeometry)(object, point);\n    };\n    function graticuleX(y0, y1, dy) {\n        var y = d3Array.range(y0, y1 - epsilon, dy).concat(y1);\n        return function (x) { return y.map(function (y) { return [x, y]; }); };\n    }\n    function graticuleY(x0, x1, dx) {\n        var x = d3Array.range(x0, x1 - epsilon, dx).concat(x1);\n        return function (y) { return x.map(function (x) { return [x, y]; }); };\n    }\n    function graticule() {\n        var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;\n        function graticule() {\n            return { type: \"MultiLineString\", coordinates: lines() };\n        }\n        function lines() {\n            return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X)\n                .concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))\n                .concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function (x) { return abs(x % DX) > epsilon; }).map(x))\n                .concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function (y) { return abs(y % DY) > epsilon; }).map(y));\n        }\n        graticule.lines = function () {\n            return lines().map(function (coordinates) { return { type: \"LineString\", coordinates: coordinates }; });\n        };\n        graticule.outline = function () {\n            return {\n                type: \"Polygon\",\n                coordinates: [\n                    X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))\n                ]\n            };\n        };\n        graticule.extent = function (_) {\n            if (!arguments.length)\n                return graticule.extentMinor();\n            return graticule.extentMajor(_).extentMinor(_);\n        };\n        graticule.extentMajor = function (_) {\n            if (!arguments.length)\n                return [[X0, Y0], [X1, Y1]];\n            X0 = +_[0][0], X1 = +_[1][0];\n            Y0 = +_[0][1], Y1 = +_[1][1];\n            if (X0 > X1)\n                _ = X0, X0 = X1, X1 = _;\n            if (Y0 > Y1)\n                _ = Y0, Y0 = Y1, Y1 = _;\n            return graticule.precision(precision);\n        };\n        graticule.extentMinor = function (_) {\n            if (!arguments.length)\n                return [[x0, y0], [x1, y1]];\n            x0 = +_[0][0], x1 = +_[1][0];\n            y0 = +_[0][1], y1 = +_[1][1];\n            if (x0 > x1)\n                _ = x0, x0 = x1, x1 = _;\n            if (y0 > y1)\n                _ = y0, y0 = y1, y1 = _;\n            return graticule.precision(precision);\n        };\n        graticule.step = function (_) {\n            if (!arguments.length)\n                return graticule.stepMinor();\n            return graticule.stepMajor(_).stepMinor(_);\n        };\n        graticule.stepMajor = function (_) {\n            if (!arguments.length)\n                return [DX, DY];\n            DX = +_[0], DY = +_[1];\n            return graticule;\n        };\n        graticule.stepMinor = function (_) {\n            if (!arguments.length)\n                return [dx, dy];\n            dx = +_[0], dy = +_[1];\n            return graticule;\n        };\n        graticule.precision = function (_) {\n            if (!arguments.length)\n                return precision;\n            precision = +_;\n            x = graticuleX(y0, y1, 90);\n            y = graticuleY(x0, x1, precision);\n            X = graticuleX(Y0, Y1, 90);\n            Y = graticuleY(X0, X1, precision);\n            return graticule;\n        };\n        return graticule\n            .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])\n            .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);\n    }\n    function graticule10() {\n        return graticule()();\n    }\n    var interpolate = function (a, b) {\n        var x0 = a[0] * radians, y0 = a[1] * radians, x1 = b[0] * radians, y1 = b[1] * radians, cy0 = cos(y0), sy0 = sin(y0), cy1 = cos(y1), sy1 = sin(y1), kx0 = cy0 * cos(x0), ky0 = cy0 * sin(x0), kx1 = cy1 * cos(x1), ky1 = cy1 * sin(x1), d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))), k = sin(d);\n        var interpolate = d ? function (t) {\n            var B = sin(t *= d) / k, A = sin(d - t) / k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;\n            return [\n                atan2(y, x) * degrees,\n                atan2(z, sqrt(x * x + y * y)) * degrees\n            ];\n        } : function () {\n            return [x0 * degrees, y0 * degrees];\n        };\n        interpolate.distance = d;\n        return interpolate;\n    };\n    var identity = function (x) {\n        return x;\n    };\n    var areaSum$1 = adder();\n    var areaRingSum$1 = adder();\n    var x00;\n    var y00;\n    var x0$1;\n    var y0$1;\n    var areaStream$1 = {\n        point: noop,\n        lineStart: noop,\n        lineEnd: noop,\n        polygonStart: function () {\n            areaStream$1.lineStart = areaRingStart$1;\n            areaStream$1.lineEnd = areaRingEnd$1;\n        },\n        polygonEnd: function () {\n            areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;\n            areaSum$1.add(abs(areaRingSum$1));\n            areaRingSum$1.reset();\n        },\n        result: function () {\n            var area = areaSum$1 / 2;\n            areaSum$1.reset();\n            return area;\n        }\n    };\n    function areaRingStart$1() {\n        areaStream$1.point = areaPointFirst$1;\n    }\n    function areaPointFirst$1(x, y) {\n        areaStream$1.point = areaPoint$1;\n        x00 = x0$1 = x, y00 = y0$1 = y;\n    }\n    function areaPoint$1(x, y) {\n        areaRingSum$1.add(y0$1 * x - x0$1 * y);\n        x0$1 = x, y0$1 = y;\n    }\n    function areaRingEnd$1() {\n        areaPoint$1(x00, y00);\n    }\n    var x0$2 = Infinity;\n    var y0$2 = x0$2;\n    var x1 = -x0$2;\n    var y1 = x1;\n    var boundsStream$1 = {\n        point: boundsPoint$1,\n        lineStart: noop,\n        lineEnd: noop,\n        polygonStart: noop,\n        polygonEnd: noop,\n        result: function () {\n            var bounds = [[x0$2, y0$2], [x1, y1]];\n            x1 = y1 = -(y0$2 = x0$2 = Infinity);\n            return bounds;\n        }\n    };\n    function boundsPoint$1(x, y) {\n        if (x < x0$2)\n            x0$2 = x;\n        if (x > x1)\n            x1 = x;\n        if (y < y0$2)\n            y0$2 = y;\n        if (y > y1)\n            y1 = y;\n    }\n    // TODO Enforce positive area for exterior, negative area for interior?\n    var X0$1 = 0;\n    var Y0$1 = 0;\n    var Z0$1 = 0;\n    var X1$1 = 0;\n    var Y1$1 = 0;\n    var Z1$1 = 0;\n    var X2$1 = 0;\n    var Y2$1 = 0;\n    var Z2$1 = 0;\n    var x00$1;\n    var y00$1;\n    var x0$3;\n    var y0$3;\n    var centroidStream$1 = {\n        point: centroidPoint$1,\n        lineStart: centroidLineStart$1,\n        lineEnd: centroidLineEnd$1,\n        polygonStart: function () {\n            centroidStream$1.lineStart = centroidRingStart$1;\n            centroidStream$1.lineEnd = centroidRingEnd$1;\n        },\n        polygonEnd: function () {\n            centroidStream$1.point = centroidPoint$1;\n            centroidStream$1.lineStart = centroidLineStart$1;\n            centroidStream$1.lineEnd = centroidLineEnd$1;\n        },\n        result: function () {\n            var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]\n                : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]\n                    : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]\n                        : [NaN, NaN];\n            X0$1 = Y0$1 = Z0$1 =\n                X1$1 = Y1$1 = Z1$1 =\n                    X2$1 = Y2$1 = Z2$1 = 0;\n            return centroid;\n        }\n    };\n    function centroidPoint$1(x, y) {\n        X0$1 += x;\n        Y0$1 += y;\n        ++Z0$1;\n    }\n    function centroidLineStart$1() {\n        centroidStream$1.point = centroidPointFirstLine;\n    }\n    function centroidPointFirstLine(x, y) {\n        centroidStream$1.point = centroidPointLine;\n        centroidPoint$1(x0$3 = x, y0$3 = y);\n    }\n    function centroidPointLine(x, y) {\n        var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);\n        X1$1 += z * (x0$3 + x) / 2;\n        Y1$1 += z * (y0$3 + y) / 2;\n        Z1$1 += z;\n        centroidPoint$1(x0$3 = x, y0$3 = y);\n    }\n    function centroidLineEnd$1() {\n        centroidStream$1.point = centroidPoint$1;\n    }\n    function centroidRingStart$1() {\n        centroidStream$1.point = centroidPointFirstRing;\n    }\n    function centroidRingEnd$1() {\n        centroidPointRing(x00$1, y00$1);\n    }\n    function centroidPointFirstRing(x, y) {\n        centroidStream$1.point = centroidPointRing;\n        centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);\n    }\n    function centroidPointRing(x, y) {\n        var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);\n        X1$1 += z * (x0$3 + x) / 2;\n        Y1$1 += z * (y0$3 + y) / 2;\n        Z1$1 += z;\n        z = y0$3 * x - x0$3 * y;\n        X2$1 += z * (x0$3 + x);\n        Y2$1 += z * (y0$3 + y);\n        Z2$1 += z * 3;\n        centroidPoint$1(x0$3 = x, y0$3 = y);\n    }\n    function PathContext(context) {\n        this._context = context;\n    }\n    PathContext.prototype = {\n        _radius: 4.5,\n        pointRadius: function (_) {\n            return this._radius = _, this;\n        },\n        polygonStart: function () {\n            this._line = 0;\n        },\n        polygonEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._line === 0)\n                this._context.closePath();\n            this._point = NaN;\n        },\n        point: function (x, y) {\n            switch (this._point) {\n                case 0: {\n                    this._context.moveTo(x, y);\n                    this._point = 1;\n                    break;\n                }\n                case 1: {\n                    this._context.lineTo(x, y);\n                    break;\n                }\n                default: {\n                    this._context.moveTo(x + this._radius, y);\n                    this._context.arc(x, y, this._radius, 0, tau);\n                    break;\n                }\n            }\n        },\n        result: noop\n    };\n    var lengthSum$1 = adder();\n    var lengthRing;\n    var x00$2;\n    var y00$2;\n    var x0$4;\n    var y0$4;\n    var lengthStream$1 = {\n        point: noop,\n        lineStart: function () {\n            lengthStream$1.point = lengthPointFirst$1;\n        },\n        lineEnd: function () {\n            if (lengthRing)\n                lengthPoint$1(x00$2, y00$2);\n            lengthStream$1.point = noop;\n        },\n        polygonStart: function () {\n            lengthRing = true;\n        },\n        polygonEnd: function () {\n            lengthRing = null;\n        },\n        result: function () {\n            var length = +lengthSum$1;\n            lengthSum$1.reset();\n            return length;\n        }\n    };\n    function lengthPointFirst$1(x, y) {\n        lengthStream$1.point = lengthPoint$1;\n        x00$2 = x0$4 = x, y00$2 = y0$4 = y;\n    }\n    function lengthPoint$1(x, y) {\n        x0$4 -= x, y0$4 -= y;\n        lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));\n        x0$4 = x, y0$4 = y;\n    }\n    function PathString() {\n        this._string = [];\n    }\n    PathString.prototype = {\n        _radius: 4.5,\n        _circle: circle$1(4.5),\n        pointRadius: function (_) {\n            if ((_ = +_) !== this._radius)\n                this._radius = _, this._circle = null;\n            return this;\n        },\n        polygonStart: function () {\n            this._line = 0;\n        },\n        polygonEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._line === 0)\n                this._string.push(\"Z\");\n            this._point = NaN;\n        },\n        point: function (x, y) {\n            switch (this._point) {\n                case 0: {\n                    this._string.push(\"M\", x, \",\", y);\n                    this._point = 1;\n                    break;\n                }\n                case 1: {\n                    this._string.push(\"L\", x, \",\", y);\n                    break;\n                }\n                default: {\n                    if (this._circle == null)\n                        this._circle = circle$1(this._radius);\n                    this._string.push(\"M\", x, \",\", y, this._circle);\n                    break;\n                }\n            }\n        },\n        result: function () {\n            if (this._string.length) {\n                var result = this._string.join(\"\");\n                this._string = [];\n                return result;\n            }\n            else {\n                return null;\n            }\n        }\n    };\n    function circle$1(radius) {\n        return \"m0,\" + radius\n            + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius\n            + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius\n            + \"z\";\n    }\n    var index = function (projection, context) {\n        var pointRadius = 4.5, projectionStream, contextStream;\n        function path(object) {\n            if (object) {\n                if (typeof pointRadius === \"function\")\n                    contextStream.pointRadius(+pointRadius.apply(this, arguments));\n                geoStream(object, projectionStream(contextStream));\n            }\n            return contextStream.result();\n        }\n        path.area = function (object) {\n            geoStream(object, projectionStream(areaStream$1));\n            return areaStream$1.result();\n        };\n        path.measure = function (object) {\n            geoStream(object, projectionStream(lengthStream$1));\n            return lengthStream$1.result();\n        };\n        path.bounds = function (object) {\n            geoStream(object, projectionStream(boundsStream$1));\n            return boundsStream$1.result();\n        };\n        path.centroid = function (object) {\n            geoStream(object, projectionStream(centroidStream$1));\n            return centroidStream$1.result();\n        };\n        path.projection = function (_) {\n            return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;\n        };\n        path.context = function (_) {\n            if (!arguments.length)\n                return context;\n            contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);\n            if (typeof pointRadius !== \"function\")\n                contextStream.pointRadius(pointRadius);\n            return path;\n        };\n        path.pointRadius = function (_) {\n            if (!arguments.length)\n                return pointRadius;\n            pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n            return path;\n        };\n        return path.projection(projection).context(context);\n    };\n    var clip = function (pointVisible, clipLine, interpolate, start) {\n        return function (rotate, sink) {\n            var line = clipLine(sink), rotatedStart = rotate.invert(start[0], start[1]), ringBuffer = clipBuffer(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;\n            var clip = {\n                point: point,\n                lineStart: lineStart,\n                lineEnd: lineEnd,\n                polygonStart: function () {\n                    clip.point = pointRing;\n                    clip.lineStart = ringStart;\n                    clip.lineEnd = ringEnd;\n                    segments = [];\n                    polygon = [];\n                },\n                polygonEnd: function () {\n                    clip.point = point;\n                    clip.lineStart = lineStart;\n                    clip.lineEnd = lineEnd;\n                    segments = d3Array.merge(segments);\n                    var startInside = polygonContains(polygon, rotatedStart);\n                    if (segments.length) {\n                        if (!polygonStarted)\n                            sink.polygonStart(), polygonStarted = true;\n                        clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\n                    }\n                    else if (startInside) {\n                        if (!polygonStarted)\n                            sink.polygonStart(), polygonStarted = true;\n                        sink.lineStart();\n                        interpolate(null, null, 1, sink);\n                        sink.lineEnd();\n                    }\n                    if (polygonStarted)\n                        sink.polygonEnd(), polygonStarted = false;\n                    segments = polygon = null;\n                },\n                sphere: function () {\n                    sink.polygonStart();\n                    sink.lineStart();\n                    interpolate(null, null, 1, sink);\n                    sink.lineEnd();\n                    sink.polygonEnd();\n                }\n            };\n            function point(lambda, phi) {\n                var point = rotate(lambda, phi);\n                if (pointVisible(lambda = point[0], phi = point[1]))\n                    sink.point(lambda, phi);\n            }\n            function pointLine(lambda, phi) {\n                var point = rotate(lambda, phi);\n                line.point(point[0], point[1]);\n            }\n            function lineStart() {\n                clip.point = pointLine;\n                line.lineStart();\n            }\n            function lineEnd() {\n                clip.point = point;\n                line.lineEnd();\n            }\n            function pointRing(lambda, phi) {\n                ring.push([lambda, phi]);\n                var point = rotate(lambda, phi);\n                ringSink.point(point[0], point[1]);\n            }\n            function ringStart() {\n                ringSink.lineStart();\n                ring = [];\n            }\n            function ringEnd() {\n                pointRing(ring[0][0], ring[0][1]);\n                ringSink.lineEnd();\n                var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point;\n                ring.pop();\n                polygon.push(ring);\n                ring = null;\n                if (!n)\n                    return;\n                // No intersections.\n                if (clean & 1) {\n                    segment = ringSegments[0];\n                    if ((m = segment.length - 1) > 0) {\n                        if (!polygonStarted)\n                            sink.polygonStart(), polygonStarted = true;\n                        sink.lineStart();\n                        for (i = 0; i < m; ++i)\n                            sink.point((point = segment[i])[0], point[1]);\n                        sink.lineEnd();\n                    }\n                    return;\n                }\n                // Rejoin connected segments.\n                // TODO reuse ringBuffer.rejoin()?\n                if (n > 1 && clean & 2)\n                    ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n                segments.push(ringSegments.filter(validSegment));\n            }\n            return clip;\n        };\n    };\n    function validSegment(segment) {\n        return segment.length > 1;\n    }\n    // Intersections are sorted along the clip edge. For both antimeridian cutting\n    // and circle clipping, the same comparison is used.\n    function compareIntersection(a, b) {\n        return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n            - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n    }\n    var clipAntimeridian = clip(function () { return true; }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi, -halfPi]);\n    // Takes a line and cuts into visible segments. Return values: 0 - there were\n    // intersections or the line was empty; 1 - no intersections; 2 - there were\n    // intersections, and the first and last segments should be rejoined.\n    function clipAntimeridianLine(stream) {\n        var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean; // no intersections\n        return {\n            lineStart: function () {\n                stream.lineStart();\n                clean = 1;\n            },\n            point: function (lambda1, phi1) {\n                var sign1 = lambda1 > 0 ? pi : -pi, delta = abs(lambda1 - lambda0);\n                if (abs(delta - pi) < epsilon) { // line crosses a pole\n                    stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n                    stream.point(sign0, phi0);\n                    stream.lineEnd();\n                    stream.lineStart();\n                    stream.point(sign1, phi0);\n                    stream.point(lambda1, phi0);\n                    clean = 0;\n                }\n                else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian\n                    if (abs(lambda0 - sign0) < epsilon)\n                        lambda0 -= sign0 * epsilon; // handle degeneracies\n                    if (abs(lambda1 - sign1) < epsilon)\n                        lambda1 -= sign1 * epsilon;\n                    phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n                    stream.point(sign0, phi0);\n                    stream.lineEnd();\n                    stream.lineStart();\n                    stream.point(sign1, phi0);\n                    clean = 0;\n                }\n                stream.point(lambda0 = lambda1, phi0 = phi1);\n                sign0 = sign1;\n            },\n            lineEnd: function () {\n                stream.lineEnd();\n                lambda0 = phi0 = NaN;\n            },\n            clean: function () {\n                return 2 - clean; // if intersections, rejoin first and last segments\n            }\n        };\n    }\n    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n        var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);\n        return abs(sinLambda0Lambda1) > epsilon\n            ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)\n                - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))\n                / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n            : (phi0 + phi1) / 2;\n    }\n    function clipAntimeridianInterpolate(from, to, direction, stream) {\n        var phi;\n        if (from == null) {\n            phi = direction * halfPi;\n            stream.point(-pi, phi);\n            stream.point(0, phi);\n            stream.point(pi, phi);\n            stream.point(pi, 0);\n            stream.point(pi, -phi);\n            stream.point(0, -phi);\n            stream.point(-pi, -phi);\n            stream.point(-pi, 0);\n            stream.point(-pi, phi);\n        }\n        else if (abs(from[0] - to[0]) > epsilon) {\n            var lambda = from[0] < to[0] ? pi : -pi;\n            phi = direction * lambda / 2;\n            stream.point(-lambda, phi);\n            stream.point(0, phi);\n            stream.point(lambda, phi);\n        }\n        else {\n            stream.point(to[0], to[1]);\n        }\n    }\n    var clipCircle = function (radius, delta) {\n        var cr = cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n        function interpolate(from, to, direction, stream) {\n            circleStream(stream, radius, delta, direction, from, to);\n        }\n        function visible(lambda, phi) {\n            return cos(lambda) * cos(phi) > cr;\n        }\n        // Takes a line and cuts into visible segments. Return values used for polygon\n        // clipping: 0 - there were intersections or the line was empty; 1 - no\n        // intersections 2 - there were intersections, and the first and last segments\n        // should be rejoined.\n        function clipLine(stream) {\n            var point0, // previous point\n            c0, // code for previous point\n            v0, // visibility of previous point\n            v00, // visibility of first point\n            clean; // no intersections\n            return {\n                lineStart: function () {\n                    v00 = v0 = false;\n                    clean = 1;\n                },\n                point: function (lambda, phi) {\n                    var point1 = [lambda, phi], point2, v = visible(lambda, phi), c = smallRadius\n                        ? v ? 0 : code(lambda, phi)\n                        : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n                    if (!point0 && (v00 = v0 = v))\n                        stream.lineStart();\n                    // Handle degeneracies.\n                    // TODO ignore if not clipping polygons.\n                    if (v !== v0) {\n                        point2 = intersect(point0, point1);\n                        if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n                            point1[0] += epsilon;\n                            point1[1] += epsilon;\n                            v = visible(point1[0], point1[1]);\n                        }\n                    }\n                    if (v !== v0) {\n                        clean = 0;\n                        if (v) {\n                            // outside going in\n                            stream.lineStart();\n                            point2 = intersect(point1, point0);\n                            stream.point(point2[0], point2[1]);\n                        }\n                        else {\n                            // inside going out\n                            point2 = intersect(point0, point1);\n                            stream.point(point2[0], point2[1]);\n                            stream.lineEnd();\n                        }\n                        point0 = point2;\n                    }\n                    else if (notHemisphere && point0 && smallRadius ^ v) {\n                        var t;\n                        // If the codes for two points are different, or are both zero,\n                        // and there this segment intersects with the small circle.\n                        if (!(c & c0) && (t = intersect(point1, point0, true))) {\n                            clean = 0;\n                            if (smallRadius) {\n                                stream.lineStart();\n                                stream.point(t[0][0], t[0][1]);\n                                stream.point(t[1][0], t[1][1]);\n                                stream.lineEnd();\n                            }\n                            else {\n                                stream.point(t[1][0], t[1][1]);\n                                stream.lineEnd();\n                                stream.lineStart();\n                                stream.point(t[0][0], t[0][1]);\n                            }\n                        }\n                    }\n                    if (v && (!point0 || !pointEqual(point0, point1))) {\n                        stream.point(point1[0], point1[1]);\n                    }\n                    point0 = point1, v0 = v, c0 = c;\n                },\n                lineEnd: function () {\n                    if (v0)\n                        stream.lineEnd();\n                    point0 = null;\n                },\n                // Rejoin first and last segments if there were intersections and the first\n                // and last points were visible.\n                clean: function () {\n                    return clean | ((v00 && v0) << 1);\n                }\n            };\n        }\n        // Intersects the great circle between a and b with the clip circle.\n        function intersect(a, b, two) {\n            var pa = cartesian(a), pb = cartesian(b);\n            // We have two planes, n1.p = d1 and n2.p = d2.\n            // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).\n            var n1 = [1, 0, 0], // normal\n            n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], // cartesianDot(n1, n2),\n            determinant = n2n2 - n1n2 * n1n2;\n            // Two polar points.\n            if (!determinant)\n                return !two && a;\n            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B = cartesianScale(n2, c2);\n            cartesianAddInPlace(A, B);\n            // Solve |p(t)|^2 = 1.\n            var u = n1xn2, w = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A, A) - 1);\n            if (t2 < 0)\n                return;\n            var t = sqrt(t2), q = cartesianScale(u, (-w - t) / uu);\n            cartesianAddInPlace(q, A);\n            q = spherical(q);\n            if (!two)\n                return q;\n            // Two intersection points.\n            var lambda0 = a[0], lambda1 = b[0], phi0 = a[1], phi1 = b[1], z;\n            if (lambda1 < lambda0)\n                z = lambda0, lambda0 = lambda1, lambda1 = z;\n            var delta = lambda1 - lambda0, polar = abs(delta - pi) < epsilon, meridian = polar || delta < epsilon;\n            if (!polar && phi1 < phi0)\n                z = phi0, phi0 = phi1, phi1 = z;\n            // Check that the first point is between a and b.\n            if (meridian\n                ? polar\n                    ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)\n                    : phi0 <= q[1] && q[1] <= phi1\n                : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n                var q1 = cartesianScale(u, (-w + t) / uu);\n                cartesianAddInPlace(q1, A);\n                return [q, spherical(q1)];\n            }\n        }\n        // Generates a 4-bit vector representing the location of a point relative to\n        // the small circle's bounding box.\n        function code(lambda, phi) {\n            var r = smallRadius ? radius : pi - radius, code = 0;\n            if (lambda < -r)\n                code |= 1; // left\n            else if (lambda > r)\n                code |= 2; // right\n            if (phi < -r)\n                code |= 4; // below\n            else if (phi > r)\n                code |= 8; // above\n            return code;\n        }\n        return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n    };\n    var transform = function (methods) {\n        return {\n            stream: transformer(methods)\n        };\n    };\n    function transformer(methods) {\n        return function (stream) {\n            var s = new TransformStream;\n            for (var key in methods)\n                s[key] = methods[key];\n            s.stream = stream;\n            return s;\n        };\n    }\n    function TransformStream() { }\n    TransformStream.prototype = {\n        constructor: TransformStream,\n        point: function (x, y) { this.stream.point(x, y); },\n        sphere: function () { this.stream.sphere(); },\n        lineStart: function () { this.stream.lineStart(); },\n        lineEnd: function () { this.stream.lineEnd(); },\n        polygonStart: function () { this.stream.polygonStart(); },\n        polygonEnd: function () { this.stream.polygonEnd(); }\n    };\n    function fitExtent(projection, extent, object) {\n        var w = extent[1][0] - extent[0][0], h = extent[1][1] - extent[0][1], clip = projection.clipExtent && projection.clipExtent();\n        projection\n            .scale(150)\n            .translate([0, 0]);\n        if (clip != null)\n            projection.clipExtent(null);\n        geoStream(object, projection.stream(boundsStream$1));\n        var b = boundsStream$1.result(), k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n        if (clip != null)\n            projection.clipExtent(clip);\n        return projection\n            .scale(k * 150)\n            .translate([x, y]);\n    }\n    function fitSize(projection, size, object) {\n        return fitExtent(projection, [[0, 0], size], object);\n    }\n    var maxDepth = 16;\n    var cosMinDistance = cos(30 * radians); // cos(minimum angular distance)\n    var resample = function (project, delta2) {\n        return +delta2 ? resample$1(project, delta2) : resampleNone(project);\n    };\n    function resampleNone(project) {\n        return transformer({\n            point: function (x, y) {\n                x = project(x, y);\n                this.stream.point(x[0], x[1]);\n            }\n        });\n    }\n    function resample$1(project, delta2) {\n        function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n            var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;\n            if (d2 > 4 * delta2 && depth--) {\n                var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = sqrt(a * a + b * b + c * c), phi2 = asin(c /= m), lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a), p = project(lambda2, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;\n                if (dz * dz / d2 > delta2 // perpendicular projected distance\n                    || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n                    || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance\n                    resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n                    stream.point(x2, y2);\n                    resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n                }\n            }\n        }\n        return function (stream) {\n            var lambda00, x00, y00, a00, b00, c00, // first point\n            lambda0, x0, y0, a0, b0, c0; // previous point\n            var resampleStream = {\n                point: point,\n                lineStart: lineStart,\n                lineEnd: lineEnd,\n                polygonStart: function () { stream.polygonStart(); resampleStream.lineStart = ringStart; },\n                polygonEnd: function () { stream.polygonEnd(); resampleStream.lineStart = lineStart; }\n            };\n            function point(x, y) {\n                x = project(x, y);\n                stream.point(x[0], x[1]);\n            }\n            function lineStart() {\n                x0 = NaN;\n                resampleStream.point = linePoint;\n                stream.lineStart();\n            }\n            function linePoint(lambda, phi) {\n                var c = cartesian([lambda, phi]), p = project(lambda, phi);\n                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n                stream.point(x0, y0);\n            }\n            function lineEnd() {\n                resampleStream.point = point;\n                stream.lineEnd();\n            }\n            function ringStart() {\n                lineStart();\n                resampleStream.point = ringPoint;\n                resampleStream.lineEnd = ringEnd;\n            }\n            function ringPoint(lambda, phi) {\n                linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n                resampleStream.point = linePoint;\n            }\n            function ringEnd() {\n                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n                resampleStream.lineEnd = lineEnd;\n                lineEnd();\n            }\n            return resampleStream;\n        };\n    }\n    var transformRadians = transformer({\n        point: function (x, y) {\n            this.stream.point(x * radians, y * radians);\n        }\n    });\n    function projection(project) {\n        return projectionMutator(function () { return project; })();\n    }\n    function projectionMutator(projectAt) {\n        var project, k = 150, // scale\n        x = 480, y = 250, // translate\n        dx, dy, lambda = 0, phi = 0, // center\n        deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate\n        theta = null, preclip = clipAntimeridian, // clip angle\n        x0 = null, y0, x1, y1, postclip = identity, // clip extent\n        delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision\n        cache, cacheStream;\n        function projection(point) {\n            point = projectRotate(point[0] * radians, point[1] * radians);\n            return [point[0] * k + dx, dy - point[1] * k];\n        }\n        function invert(point) {\n            point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);\n            return point && [point[0] * degrees, point[1] * degrees];\n        }\n        function projectTransform(x, y) {\n            return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];\n        }\n        projection.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));\n        };\n        projection.clipAngle = function (_) {\n            return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;\n        };\n        projection.clipExtent = function (_) {\n            return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n        };\n        projection.scale = function (_) {\n            return arguments.length ? (k = +_, recenter()) : k;\n        };\n        projection.translate = function (_) {\n            return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n        };\n        projection.center = function (_) {\n            return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];\n        };\n        projection.rotate = function (_) {\n            return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];\n        };\n        projection.precision = function (_) {\n            return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n        };\n        projection.fitExtent = function (extent, object) {\n            return fitExtent(projection, extent, object);\n        };\n        projection.fitSize = function (size, object) {\n            return fitSize(projection, size, object);\n        };\n        function recenter() {\n            projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);\n            var center = project(lambda, phi);\n            dx = x - center[0] * k;\n            dy = y + center[1] * k;\n            return reset();\n        }\n        function reset() {\n            cache = cacheStream = null;\n            return projection;\n        }\n        return function () {\n            project = projectAt.apply(this, arguments);\n            projection.invert = project.invert && invert;\n            return recenter();\n        };\n    }\n    function conicProjection(projectAt) {\n        var phi0 = 0, phi1 = pi / 3, m = projectionMutator(projectAt), p = m(phi0, phi1);\n        p.parallels = function (_) {\n            return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];\n        };\n        return p;\n    }\n    function cylindricalEqualAreaRaw(phi0) {\n        var cosPhi0 = cos(phi0);\n        function forward(lambda, phi) {\n            return [lambda * cosPhi0, sin(phi) / cosPhi0];\n        }\n        forward.invert = function (x, y) {\n            return [x / cosPhi0, asin(y * cosPhi0)];\n        };\n        return forward;\n    }\n    function conicEqualAreaRaw(y0, y1) {\n        var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;\n        // Are the parallels symmetrical around the Equator?\n        if (abs(n) < epsilon)\n            return cylindricalEqualAreaRaw(y0);\n        var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;\n        function project(x, y) {\n            var r = sqrt(c - 2 * n * sin(y)) / n;\n            return [r * sin(x *= n), r0 - r * cos(x)];\n        }\n        project.invert = function (x, y) {\n            var r0y = r0 - y;\n            return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];\n        };\n        return project;\n    }\n    var conicEqualArea = function () {\n        return conicProjection(conicEqualAreaRaw)\n            .scale(155.424)\n            .center([0, 33.6442]);\n    };\n    var albers = function () {\n        return conicEqualArea()\n            .parallels([29.5, 45.5])\n            .scale(1070)\n            .translate([480, 250])\n            .rotate([96, 0])\n            .center([-0.6, 38.7]);\n    };\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n)\n                streams[i].point(x, y); },\n            sphere: function () { var i = -1; while (++i < n)\n                streams[i].sphere(); },\n            lineStart: function () { var i = -1; while (++i < n)\n                streams[i].lineStart(); },\n            lineEnd: function () { var i = -1; while (++i < n)\n                streams[i].lineEnd(); },\n            polygonStart: function () { var i = -1; while (++i < n)\n                streams[i].polygonStart(); },\n            polygonEnd: function () { var i = -1; while (++i < n)\n                streams[i].polygonEnd(); }\n        };\n    }\n    // A composite projection for the United States, configured by default for\n    // 960×500. The projection also works quite well at 960×600 if you change the\n    // scale to 1285 and adjust the translate accordingly. The set of standard\n    // parallels for each region comes from USGS, which is published here:\n    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\n    var albersUsa = function () {\n        var cache, cacheStream, lower48 = albers(), lower48Point, alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n        hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n        point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        function albersUsa(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (lower48Point.point(x, y), point)\n                    || (alaskaPoint.point(x, y), point)\n                    || (hawaiiPoint.point(x, y), point);\n        }\n        albersUsa.invert = function (coordinates) {\n            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n                : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n                    : lower48).invert(coordinates);\n        };\n        albersUsa.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n        };\n        albersUsa.precision = function (_) {\n            if (!arguments.length)\n                return lower48.precision();\n            lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n            return reset();\n        };\n        albersUsa.scale = function (_) {\n            if (!arguments.length)\n                return lower48.scale();\n            lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n            return albersUsa.translate(lower48.translate());\n        };\n        albersUsa.translate = function (_) {\n            if (!arguments.length)\n                return lower48.translate();\n            var k = lower48.scale(), x = +_[0], y = +_[1];\n            lower48Point = lower48\n                .translate(_)\n                .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n                .stream(pointStream);\n            alaskaPoint = alaska\n                .translate([x - 0.307 * k, y + 0.201 * k])\n                .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])\n                .stream(pointStream);\n            hawaiiPoint = hawaii\n                .translate([x - 0.205 * k, y + 0.212 * k])\n                .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        albersUsa.fitExtent = function (extent, object) {\n            return fitExtent(albersUsa, extent, object);\n        };\n        albersUsa.fitSize = function (size, object) {\n            return fitSize(albersUsa, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return albersUsa;\n        }\n        return albersUsa.scale(1070);\n    };\n    function azimuthalRaw(scale) {\n        return function (x, y) {\n            var cx = cos(x), cy = cos(y), k = scale(cx * cy);\n            return [\n                k * cy * sin(x),\n                k * sin(y)\n            ];\n        };\n    }\n    function azimuthalInvert(angle) {\n        return function (x, y) {\n            var z = sqrt(x * x + y * y), c = angle(z), sc = sin(c), cc = cos(c);\n            return [\n                atan2(x * sc, z * cc),\n                asin(z && y * sc / z)\n            ];\n        };\n    }\n    var azimuthalEqualAreaRaw = azimuthalRaw(function (cxcy) {\n        return sqrt(2 / (1 + cxcy));\n    });\n    azimuthalEqualAreaRaw.invert = azimuthalInvert(function (z) {\n        return 2 * asin(z / 2);\n    });\n    var azimuthalEqualArea = function () {\n        return projection(azimuthalEqualAreaRaw)\n            .scale(124.75)\n            .clipAngle(180 - 1e-3);\n    };\n    var azimuthalEquidistantRaw = azimuthalRaw(function (c) {\n        return (c = acos(c)) && c / sin(c);\n    });\n    azimuthalEquidistantRaw.invert = azimuthalInvert(function (z) {\n        return z;\n    });\n    var azimuthalEquidistant = function () {\n        return projection(azimuthalEquidistantRaw)\n            .scale(79.4188)\n            .clipAngle(180 - 1e-3);\n    };\n    function mercatorRaw(lambda, phi) {\n        return [lambda, log(tan((halfPi + phi) / 2))];\n    }\n    mercatorRaw.invert = function (x, y) {\n        return [x, 2 * atan(exp(y)) - halfPi];\n    };\n    var mercator = function () {\n        return mercatorProjection(mercatorRaw)\n            .scale(961 / tau);\n    };\n    function mercatorProjection(project) {\n        var m = projection(project), center = m.center, scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, x0 = null, y0, x1, y1; // clip extent\n        m.scale = function (_) {\n            return arguments.length ? (scale(_), reclip()) : scale();\n        };\n        m.translate = function (_) {\n            return arguments.length ? (translate(_), reclip()) : translate();\n        };\n        m.center = function (_) {\n            return arguments.length ? (center(_), reclip()) : center();\n        };\n        m.clipExtent = function (_) {\n            return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n        };\n        function reclip() {\n            var k = pi * scale(), t = m(rotation(m.rotate()).invert([0, 0]));\n            return clipExtent(x0 == null\n                ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw\n                ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]\n                : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);\n        }\n        return reclip();\n    }\n    function tany(y) {\n        return tan((halfPi + y) / 2);\n    }\n    function conicConformalRaw(y0, y1) {\n        var cy0 = cos(y0), n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)), f = cy0 * pow(tany(y0), n) / n;\n        if (!n)\n            return mercatorRaw;\n        function project(x, y) {\n            if (f > 0) {\n                if (y < -halfPi + epsilon)\n                    y = -halfPi + epsilon;\n            }\n            else {\n                if (y > halfPi - epsilon)\n                    y = halfPi - epsilon;\n            }\n            var r = f / pow(tany(y), n);\n            return [r * sin(n * x), f - r * cos(n * x)];\n        }\n        project.invert = function (x, y) {\n            var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);\n            return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];\n        };\n        return project;\n    }\n    var conicConformal = function () {\n        return conicProjection(conicConformalRaw)\n            .scale(109.5)\n            .parallels([30, 30]);\n    };\n    function equirectangularRaw(lambda, phi) {\n        return [lambda, phi];\n    }\n    equirectangularRaw.invert = equirectangularRaw;\n    var equirectangular = function () {\n        return projection(equirectangularRaw)\n            .scale(152.63);\n    };\n    function conicEquidistantRaw(y0, y1) {\n        var cy0 = cos(y0), n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0), g = cy0 / n + y0;\n        if (abs(n) < epsilon)\n            return equirectangularRaw;\n        function project(x, y) {\n            var gy = g - y, nx = n * x;\n            return [gy * sin(nx), g - gy * cos(nx)];\n        }\n        project.invert = function (x, y) {\n            var gy = g - y;\n            return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];\n        };\n        return project;\n    }\n    var conicEquidistant = function () {\n        return conicProjection(conicEquidistantRaw)\n            .scale(131.154)\n            .center([0, 13.9389]);\n    };\n    function gnomonicRaw(x, y) {\n        var cy = cos(y), k = cos(x) * cy;\n        return [cy * sin(x) / k, sin(y) / k];\n    }\n    gnomonicRaw.invert = azimuthalInvert(atan);\n    var gnomonic = function () {\n        return projection(gnomonicRaw)\n            .scale(144.049)\n            .clipAngle(60);\n    };\n    function scaleTranslate(kx, ky, tx, ty) {\n        return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({\n            point: function (x, y) {\n                this.stream.point(x * kx + tx, y * ky + ty);\n            }\n        });\n    }\n    var identity$1 = function () {\n        var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = identity, // scale, translate and reflect\n        x0 = null, y0, x1, y1, clip = identity, // clip extent\n        cache, cacheStream, projection;\n        function reset() {\n            cache = cacheStream = null;\n            return projection;\n        }\n        return projection = {\n            stream: function (stream) {\n                return cache && cacheStream === stream ? cache : cache = transform(clip(cacheStream = stream));\n            },\n            clipExtent: function (_) {\n                return arguments.length ? (clip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n            },\n            scale: function (_) {\n                return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;\n            },\n            translate: function (_) {\n                return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];\n            },\n            reflectX: function (_) {\n                return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;\n            },\n            reflectY: function (_) {\n                return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;\n            },\n            fitExtent: function (extent, object) {\n                return fitExtent(projection, extent, object);\n            },\n            fitSize: function (size, object) {\n                return fitSize(projection, size, object);\n            }\n        };\n    };\n    function orthographicRaw(x, y) {\n        return [cos(y) * sin(x), sin(y)];\n    }\n    orthographicRaw.invert = azimuthalInvert(asin);\n    var orthographic = function () {\n        return projection(orthographicRaw)\n            .scale(249.5)\n            .clipAngle(90 + epsilon);\n    };\n    function stereographicRaw(x, y) {\n        var cy = cos(y), k = 1 + cos(x) * cy;\n        return [cy * sin(x) / k, sin(y) / k];\n    }\n    stereographicRaw.invert = azimuthalInvert(function (z) {\n        return 2 * atan(z);\n    });\n    var stereographic = function () {\n        return projection(stereographicRaw)\n            .scale(250)\n            .clipAngle(142);\n    };\n    function transverseMercatorRaw(lambda, phi) {\n        return [log(tan((halfPi + phi) / 2)), -lambda];\n    }\n    transverseMercatorRaw.invert = function (x, y) {\n        return [-y, 2 * atan(exp(x)) - halfPi];\n    };\n    var transverseMercator = function () {\n        var m = mercatorProjection(transverseMercatorRaw), center = m.center, rotate = m.rotate;\n        m.center = function (_) {\n            return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n        };\n        m.rotate = function (_) {\n            return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n        };\n        return rotate([0, 0, 90])\n            .scale(159.155);\n    };\n    exports.geoArea = area;\n    exports.geoBounds = bounds;\n    exports.geoCentroid = centroid;\n    exports.geoCircle = circle;\n    exports.geoClipExtent = extent;\n    exports.geoContains = contains;\n    exports.geoDistance = distance;\n    exports.geoGraticule = graticule;\n    exports.geoGraticule10 = graticule10;\n    exports.geoInterpolate = interpolate;\n    exports.geoLength = length;\n    exports.geoPath = index;\n    exports.geoAlbers = albers;\n    exports.geoAlbersUsa = albersUsa;\n    exports.geoAzimuthalEqualArea = azimuthalEqualArea;\n    exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;\n    exports.geoAzimuthalEquidistant = azimuthalEquidistant;\n    exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;\n    exports.geoConicConformal = conicConformal;\n    exports.geoConicConformalRaw = conicConformalRaw;\n    exports.geoConicEqualArea = conicEqualArea;\n    exports.geoConicEqualAreaRaw = conicEqualAreaRaw;\n    exports.geoConicEquidistant = conicEquidistant;\n    exports.geoConicEquidistantRaw = conicEquidistantRaw;\n    exports.geoEquirectangular = equirectangular;\n    exports.geoEquirectangularRaw = equirectangularRaw;\n    exports.geoGnomonic = gnomonic;\n    exports.geoGnomonicRaw = gnomonicRaw;\n    exports.geoIdentity = identity$1;\n    exports.geoProjection = projection;\n    exports.geoProjectionMutator = projectionMutator;\n    exports.geoMercator = mercator;\n    exports.geoMercatorRaw = mercatorRaw;\n    exports.geoOrthographic = orthographic;\n    exports.geoOrthographicRaw = orthographicRaw;\n    exports.geoStereographic = stereographic;\n    exports.geoStereographicRaw = stereographicRaw;\n    exports.geoTransverseMercator = transverseMercator;\n    exports.geoTransverseMercatorRaw = transverseMercatorRaw;\n    exports.geoRotation = rotation;\n    exports.geoStream = geoStream;\n    exports.geoTransform = transform;\n    Object.defineProperty(exports, '__esModule', { value: true });\n})));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-hexjson@1.1.0@d3-hexjson/build/d3-hexjson.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_d3-hexjson@1.1.0@d3-hexjson/build/d3-hexjson.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! d3-array */ \"./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js\")) :\n        undefined;\n}(this, function (exports, d3Array) {\n    'use strict';\n    // Main render method\n    function renderHexJSON(hexjson, width, height) {\n        // Get the layout\n        var layout = hexjson.layout;\n        // Get the hex objects as an array\n        var hexes = [];\n        var hexRadius = 0;\n        Object.keys(hexjson.hexes).forEach(function (key) {\n            hexjson.hexes[key].key = key;\n            hexes.push(hexjson.hexes[key]);\n        });\n        // Calculate the number of rows and columns\n        var qmax = d3Array.max(hexes, function (d) { return +d.q; }), qmin = d3Array.min(hexes, function (d) { return +d.q; }), rmax = d3Array.max(hexes, function (d) { return +d.r; }), rmin = d3Array.min(hexes, function (d) { return +d.r; });\n        var qnum = qmax - qmin + 1, rnum = rmax - rmin + 1;\n        // Calculate maximum radius the hexagons can have to fit the svg\n        if (layout === \"odd-r\" || layout === \"even-r\") {\n            hexRadius = d3Array.min([(width) / ((qnum + 0.5) * Math.sqrt(3)),\n                height / ((rnum + 1 / 3) * 1.5)]);\n        }\n        else {\n            hexRadius = d3Array.min([(height) / ((rnum + 0.5) * Math.sqrt(3)),\n                width / ((qnum + 1 / 3) * 1.5)]);\n        }\n        // Calculate the hexagon width\n        var hexWidth = hexRadius * Math.sqrt(3);\n        // Get the vertices and points for this layout\n        var vertices = getVertices(layout, hexWidth, hexRadius);\n        var points = getPoints(vertices);\n        // Calculate the values needed to render each hex and add to hexes\n        hexes.forEach(function (hex) {\n            // Calculate the absolute co-ordinates of each hex\n            hex.qc = hex.q - qmin;\n            hex.rc = rmax - hex.r;\n            // Calculate the x and y position of each hex for this svg\n            hex.x = getX(hex, layout, hexWidth, hexRadius);\n            hex.y = getY(hex, layout, hexWidth, hexRadius);\n            // Add the vertex positions and points relative to x and y\n            hex.vertices = vertices;\n            hex.points = points;\n        });\n        return hexes;\n    }\n    // Get the x position for a hex\n    function getX(hex, layout, hexWidth, hexRadius) {\n        var x = 0, xOffset = 0;\n        switch (layout) {\n            case \"odd-r\":\n                xOffset = (hex.rc % 2 === 1) ? hexWidth : (hexWidth / 2);\n                x = (hex.qc * hexWidth) + xOffset;\n                break;\n            case \"even-r\":\n                xOffset = (hex.rc % 2 === 0) ? hexWidth : (hexWidth / 2);\n                x = (hex.qc * hexWidth) + xOffset;\n                break;\n            case \"odd-q\":\n            case \"even-q\":\n                x = (hex.qc * hexRadius * 1.5) + hexRadius;\n                break;\n        }\n        return x;\n    }\n    // Get the y position for a hex\n    function getY(hex, layout, hexWidth, hexRadius) {\n        var y = 0, yOffset = 0;\n        switch (layout) {\n            case \"odd-r\":\n            case \"even-r\":\n                y = (hex.rc * hexRadius * 1.5) + hexRadius;\n                break;\n            case \"odd-q\":\n                yOffset = (hex.qc % 2 === 1) ? hexWidth : (hexWidth / 2);\n                y = (hex.rc * hexWidth) + yOffset;\n                break;\n            case \"even-q\":\n                yOffset = (hex.qc % 2 === 0) ? hexWidth : (hexWidth / 2);\n                y = (hex.rc * hexWidth) + yOffset;\n                break;\n        }\n        return y;\n    }\n    // Get the positions of the vertices for the hex:\n    // - Row layouts are ordered from the topmost vertex clockwise\n    // - Column layouts are ordered from the leftmost vertex clockwise\n    function getVertices(layout, hexWidth, hexRadius) {\n        var vertices = [];\n        switch (layout) {\n            case \"odd-r\":\n            case \"even-r\":\n                vertices.push({ x: 0, y: (0 - hexRadius) });\n                vertices.push({ x: (0 + hexWidth * 0.5), y: (0 - 0.5 * hexRadius) });\n                vertices.push({ x: (0 + hexWidth * 0.5), y: (0 + 0.5 * hexRadius) });\n                vertices.push({ x: 0, y: (0 + hexRadius) });\n                vertices.push({ x: (0 - hexWidth * 0.5), y: (0 + 0.5 * hexRadius) });\n                vertices.push({ x: (0 - hexWidth * 0.5), y: (0 - 0.5 * hexRadius) });\n                break;\n            case \"odd-q\":\n            case \"even-q\":\n                vertices.push({ x: (0 - hexRadius), y: 0 });\n                vertices.push({ x: (0 - 0.5 * hexRadius), y: (0 - hexWidth * 0.5) });\n                vertices.push({ x: (0 + 0.5 * hexRadius), y: (0 - hexWidth * 0.5) });\n                vertices.push({ x: (0 + hexRadius), y: 0 });\n                vertices.push({ x: (0 + 0.5 * hexRadius), y: (0 + hexWidth * 0.5) });\n                vertices.push({ x: (0 - 0.5 * hexRadius), y: (0 + hexWidth * 0.5) });\n                break;\n        }\n        return vertices;\n    }\n    // Get the points attribute for a polygon with these vertices\n    function getPoints(vertices) {\n        var points = \"\";\n        vertices.forEach(function (v) { points += v.x + \",\" + v.y + \" \"; });\n        return points.substring(0, points.length - 1);\n    }\n    // Creates a hexjson grid with the layout and dimensions of the given hexjson\n    function getGridForHexJSON(hexjson) {\n        // Create a new HexJSON object for the grid\n        var grid = {};\n        grid.layout = hexjson.layout;\n        grid.hexes = {};\n        // Get the hex objects from the hexjson as an array\n        var hexes = [];\n        Object.keys(hexjson.hexes).forEach(function (key) {\n            hexes.push(hexjson.hexes[key]);\n        });\n        // Calculate the number of rows and columns in the grid\n        var qmax = d3Array.max(hexes, function (d) { return +d.q; }), qmin = d3Array.min(hexes, function (d) { return +d.q; }), rmax = d3Array.max(hexes, function (d) { return +d.r; }), rmin = d3Array.min(hexes, function (d) { return +d.r; });\n        // Create the hexjson grid\n        var i, j, fkey;\n        for (i = qmin; i <= qmax; i++) {\n            for (j = rmin; j <= rmax; j++) {\n                fkey = \"Q\" + i + \"R\" + j;\n                grid.hexes[fkey] = { q: i, r: j };\n            }\n        }\n        return grid;\n    }\n    // Creates a list of dots along the boundaries between\n    // hexes which have different values of \"field\"\n    function getBoundaryDotsForHexJSON(hexjson, width, height, field) {\n        // Get the hex objects from the hexjson as an array\n        var hexes = [];\n        var layout = hexjson.layout;\n        Object.keys(hexjson.hexes).forEach(function (key) {\n            hexes.push(hexjson.hexes[key]);\n        });\n        // Calculate the number of rows and columns\n        var qmax = d3Array.max(hexes, function (d) { return +d.q; }), qmin = d3Array.min(hexes, function (d) { return +d.q; }), rmax = d3Array.max(hexes, function (d) { return +d.r; }), rmin = d3Array.min(hexes, function (d) { return +d.r; });\n        var qnum = qmax - qmin + 1, rnum = rmax - rmin + 1;\n        var hexRadius;\n        // Calculate maximum radius the hexagons can have to fit the svg\n        if (layout === \"odd-r\" || layout === \"even-r\") {\n            hexRadius = d3Array.min([(width) / ((qnum + 0.5) * Math.sqrt(3)),\n                height / ((rnum + 1 / 3) * 1.5)]);\n        }\n        else {\n            hexRadius = d3Array.min([(height) / ((rnum + 0.5) * Math.sqrt(3)),\n                width / ((qnum + 1 / 3) * 1.5)]);\n        }\n        // Calculate the hexagon width\n        var hexWidth = hexRadius * Math.sqrt(3);\n        // Create an array into which we will put points along the\n        // boundaries between differing hexes.\n        // Each edge has five points, equally spaced.\n        var lines = [];\n        var hexRadiusSquared = hexRadius * hexRadius * 4;\n        var maxHex = hexes.length;\n        if (maxHex > 1) {\n            hexes.forEach(function (hex) {\n                hex.qc = hex.q - qmin;\n                hex.rc = rmax - hex.r;\n                // Calculate the x and y position of each hex for this svg\n                hex.x = getX(hex, layout, hexWidth, hexRadius);\n                hex.y = getY(hex, layout, hexWidth, hexRadius);\n            });\n            for (var i = 0; i < maxHex - 1; i++) {\n                for (var j = i + 1; j < maxHex; j++) {\n                    var hex = hexes[i];\n                    var otherHex = hexes[j];\n                    if (hex[field] !== otherHex[field]) {\n                        if (Math.abs(hex.q - otherHex.q) <= 1 &&\n                            Math.abs(hex.r - otherHex.r) <= 1) {\n                            if (((hex.x - otherHex.x) * (hex.x - otherHex.x)) +\n                                ((hex.y - otherHex.y) * (hex.y - otherHex.y)) < hexRadiusSquared) {\n                                // They're neighbours\n                                var midpoint = {};\n                                midpoint.x = otherHex.x + (hex.x - otherHex.x) / 2;\n                                midpoint.y = otherHex.y + (hex.y - otherHex.y) / 2;\n                                var perp = {};\n                                var denom = Math.sqrt(3) * 4;\n                                perp.dx = (hex.y - otherHex.y) / denom;\n                                perp.dy = -(hex.x - otherHex.x) / denom;\n                                lines.push({ x: midpoint.x - 2 * perp.dx, y: midpoint.y - 2 * perp.dy });\n                                lines.push({ x: midpoint.x - perp.dx, y: midpoint.y - perp.dy });\n                                lines.push({ x: midpoint.x, y: midpoint.y });\n                                lines.push({ x: midpoint.x + perp.dx, y: midpoint.y + perp.dy });\n                                lines.push({ x: midpoint.x + 2 * perp.dx, y: midpoint.y + 2 * perp.dy });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return lines;\n    }\n    // Creates a list of line segments along the boundaries\n    // between hexes which have different values of \"field\"\n    function getBoundarySegmentsForHexJSON(hexjson, width, height, field) {\n        // Get the hex objects from the hexjson as an array\n        var hexes = [];\n        var layout = hexjson.layout;\n        Object.keys(hexjson.hexes).forEach(function (key) {\n            hexes.push(hexjson.hexes[key]);\n        });\n        // Calculate the number of rows and columns\n        var qmax = d3Array.max(hexes, function (d) { return +d.q; }), qmin = d3Array.min(hexes, function (d) { return +d.q; }), rmax = d3Array.max(hexes, function (d) { return +d.r; }), rmin = d3Array.min(hexes, function (d) { return +d.r; });\n        var qnum = qmax - qmin + 1, rnum = rmax - rmin + 1;\n        var hexRadius;\n        // Calculate maximum radius the hexagons can have to fit the svg\n        if (layout === \"odd-r\" || layout === \"even-r\") {\n            hexRadius = d3Array.min([(width) / ((qnum + 0.5) * Math.sqrt(3)),\n                height / ((rnum + 1 / 3) * 1.5)]);\n        }\n        else {\n            hexRadius = d3Array.min([(height) / ((rnum + 0.5) * Math.sqrt(3)),\n                width / ((qnum + 1 / 3) * 1.5)]);\n        }\n        // Calculate the hexagon width\n        var hexWidth = hexRadius * Math.sqrt(3);\n        // Create an array into which we will put points along the\n        // boundaries between differing hexes.\n        // Each segment will be of the form\n        // {x: <start point X>, y: <start point Y>, cx: <difference X>, cy: <difference Y> }\n        // intended to be used with the simple line drawing functionality of d3\n        //\n        var segments = [];\n        var hexRadiusSquared = hexRadius * hexRadius * 4;\n        var maxHex = hexes.length;\n        if (maxHex > 1) {\n            hexes.forEach(function (hex) {\n                hex.qc = hex.q - qmin;\n                hex.rc = rmax - hex.r;\n                // Calculate the x and y position of each hex for this svg\n                hex.x = getX(hex, layout, hexWidth, hexRadius);\n                hex.y = getY(hex, layout, hexWidth, hexRadius);\n            });\n            for (var i = 0; i < maxHex - 1; i++) {\n                for (var j = i + 1; j < maxHex; j++) {\n                    var hex = hexes[i];\n                    var otherHex = hexes[j];\n                    if (hex[field] !== otherHex[field]) {\n                        if (Math.abs(hex.q - otherHex.q) <= 1 &&\n                            Math.abs(hex.r - otherHex.r) <= 1) {\n                            if (((hex.x - otherHex.x) * (hex.x - otherHex.x)) +\n                                ((hex.y - otherHex.y) * (hex.y - otherHex.y)) < hexRadiusSquared) {\n                                // They're neighbours\n                                var midpoint = {};\n                                midpoint.x = otherHex.x + (hex.x - otherHex.x) / 2;\n                                midpoint.y = otherHex.y + (hex.y - otherHex.y) / 2;\n                                var perp = {};\n                                var direction = +1;\n                                if (hex[field] < otherHex[field]) {\n                                    direction = -1;\n                                } // otherwise, direction will be +1\n                                var denom = Math.sqrt(3) * 2 * direction;\n                                perp.dx = (hex.y - otherHex.y) / denom;\n                                perp.dy = -(hex.x - otherHex.x) / denom;\n                                segments.push({\n                                    x1: midpoint.x - perp.dx,\n                                    y1: midpoint.y - perp.dy,\n                                    x2: midpoint.x + perp.dx,\n                                    y2: midpoint.y + perp.dy\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return segments;\n    }\n    exports.renderHexJSON = renderHexJSON;\n    exports.getGridForHexJSON = getGridForHexJSON;\n    exports.getBoundaryDotsForHexJSON = getBoundaryDotsForHexJSON;\n    exports.getBoundarySegmentsForHexJSON = getBoundarySegmentsForHexJSON;\n    Object.defineProperty(exports, '__esModule', { value: true });\n}));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js\":\n/*!****************************************************************************!*\\\n  !*** ./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js ***!\n  \\****************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-hierarchy/ v1.1.9 Copyright 2019 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports) :\n        undefined;\n}(this, function (exports) {\n    'use strict';\n    function defaultSeparation(a, b) {\n        return a.parent === b.parent ? 1 : 2;\n    }\n    function meanX(children) {\n        return children.reduce(meanXReduce, 0) / children.length;\n    }\n    function meanXReduce(x, c) {\n        return x + c.x;\n    }\n    function maxY(children) {\n        return 1 + children.reduce(maxYReduce, 0);\n    }\n    function maxYReduce(y, c) {\n        return Math.max(y, c.y);\n    }\n    function leafLeft(node) {\n        var children;\n        while (children = node.children)\n            node = children[0];\n        return node;\n    }\n    function leafRight(node) {\n        var children;\n        while (children = node.children)\n            node = children[children.length - 1];\n        return node;\n    }\n    function cluster() {\n        var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;\n        function cluster(root) {\n            var previousNode, x = 0;\n            // First walk, computing the initial x & y values.\n            root.eachAfter(function (node) {\n                var children = node.children;\n                if (children) {\n                    node.x = meanX(children);\n                    node.y = maxY(children);\n                }\n                else {\n                    node.x = previousNode ? x += separation(node, previousNode) : 0;\n                    node.y = 0;\n                    previousNode = node;\n                }\n            });\n            var left = leafLeft(root), right = leafRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;\n            // Second walk, normalizing x & y to the desired size.\n            return root.eachAfter(nodeSize ? function (node) {\n                node.x = (node.x - root.x) * dx;\n                node.y = (root.y - node.y) * dy;\n            } : function (node) {\n                node.x = (node.x - x0) / (x1 - x0) * dx;\n                node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;\n            });\n        }\n        cluster.separation = function (x) {\n            return arguments.length ? (separation = x, cluster) : separation;\n        };\n        cluster.size = function (x) {\n            return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);\n        };\n        cluster.nodeSize = function (x) {\n            return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);\n        };\n        return cluster;\n    }\n    function count(node) {\n        var sum = 0, children = node.children, i = children && children.length;\n        if (!i)\n            sum = 1;\n        else\n            while (--i >= 0)\n                sum += children[i].value;\n        node.value = sum;\n    }\n    function node_count() {\n        return this.eachAfter(count);\n    }\n    function node_each(callback) {\n        var node = this, current, next = [node], children, i, n;\n        do {\n            current = next.reverse(), next = [];\n            while (node = current.pop()) {\n                callback(node), children = node.children;\n                if (children)\n                    for (i = 0, n = children.length; i < n; ++i) {\n                        next.push(children[i]);\n                    }\n            }\n        } while (next.length);\n        return this;\n    }\n    function node_eachBefore(callback) {\n        var node = this, nodes = [node], children, i;\n        while (node = nodes.pop()) {\n            callback(node), children = node.children;\n            if (children)\n                for (i = children.length - 1; i >= 0; --i) {\n                    nodes.push(children[i]);\n                }\n        }\n        return this;\n    }\n    function node_eachAfter(callback) {\n        var node = this, nodes = [node], next = [], children, i, n;\n        while (node = nodes.pop()) {\n            next.push(node), children = node.children;\n            if (children)\n                for (i = 0, n = children.length; i < n; ++i) {\n                    nodes.push(children[i]);\n                }\n        }\n        while (node = next.pop()) {\n            callback(node);\n        }\n        return this;\n    }\n    function node_sum(value) {\n        return this.eachAfter(function (node) {\n            var sum = +value(node.data) || 0, children = node.children, i = children && children.length;\n            while (--i >= 0)\n                sum += children[i].value;\n            node.value = sum;\n        });\n    }\n    function node_sort(compare) {\n        return this.eachBefore(function (node) {\n            if (node.children) {\n                node.children.sort(compare);\n            }\n        });\n    }\n    function node_path(end) {\n        var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];\n        while (start !== ancestor) {\n            start = start.parent;\n            nodes.push(start);\n        }\n        var k = nodes.length;\n        while (end !== ancestor) {\n            nodes.splice(k, 0, end);\n            end = end.parent;\n        }\n        return nodes;\n    }\n    function leastCommonAncestor(a, b) {\n        if (a === b)\n            return a;\n        var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;\n        a = aNodes.pop();\n        b = bNodes.pop();\n        while (a === b) {\n            c = a;\n            a = aNodes.pop();\n            b = bNodes.pop();\n        }\n        return c;\n    }\n    function node_ancestors() {\n        var node = this, nodes = [node];\n        while (node = node.parent) {\n            nodes.push(node);\n        }\n        return nodes;\n    }\n    function node_descendants() {\n        var nodes = [];\n        this.each(function (node) {\n            nodes.push(node);\n        });\n        return nodes;\n    }\n    function node_leaves() {\n        var leaves = [];\n        this.eachBefore(function (node) {\n            if (!node.children) {\n                leaves.push(node);\n            }\n        });\n        return leaves;\n    }\n    function node_links() {\n        var root = this, links = [];\n        root.each(function (node) {\n            if (node !== root) { // Don’t include the root’s parent, if any.\n                links.push({ source: node.parent, target: node });\n            }\n        });\n        return links;\n    }\n    function hierarchy(data, children) {\n        var root = new Node(data), valued = +data.value && (root.value = data.value), node, nodes = [root], child, childs, i, n;\n        if (children == null)\n            children = defaultChildren;\n        while (node = nodes.pop()) {\n            if (valued)\n                node.value = +node.data.value;\n            if ((childs = children(node.data)) && (n = childs.length)) {\n                node.children = new Array(n);\n                for (i = n - 1; i >= 0; --i) {\n                    nodes.push(child = node.children[i] = new Node(childs[i]));\n                    child.parent = node;\n                    child.depth = node.depth + 1;\n                }\n            }\n        }\n        return root.eachBefore(computeHeight);\n    }\n    function node_copy() {\n        return hierarchy(this).eachBefore(copyData);\n    }\n    function defaultChildren(d) {\n        return d.children;\n    }\n    function copyData(node) {\n        node.data = node.data.data;\n    }\n    function computeHeight(node) {\n        var height = 0;\n        do\n            node.height = height;\n        while ((node = node.parent) && (node.height < ++height));\n    }\n    function Node(data) {\n        this.data = data;\n        this.depth =\n            this.height = 0;\n        this.parent = null;\n    }\n    Node.prototype = hierarchy.prototype = {\n        constructor: Node,\n        count: node_count,\n        each: node_each,\n        eachAfter: node_eachAfter,\n        eachBefore: node_eachBefore,\n        sum: node_sum,\n        sort: node_sort,\n        path: node_path,\n        ancestors: node_ancestors,\n        descendants: node_descendants,\n        leaves: node_leaves,\n        links: node_links,\n        copy: node_copy\n    };\n    var slice = Array.prototype.slice;\n    function shuffle(array) {\n        var m = array.length, t, i;\n        while (m) {\n            i = Math.random() * m-- | 0;\n            t = array[m];\n            array[m] = array[i];\n            array[i] = t;\n        }\n        return array;\n    }\n    function enclose(circles) {\n        var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;\n        while (i < n) {\n            p = circles[i];\n            if (e && enclosesWeak(e, p))\n                ++i;\n            else\n                e = encloseBasis(B = extendBasis(B, p)), i = 0;\n        }\n        return e;\n    }\n    function extendBasis(B, p) {\n        var i, j;\n        if (enclosesWeakAll(p, B))\n            return [p];\n        // If we get here then B must have at least one element.\n        for (i = 0; i < B.length; ++i) {\n            if (enclosesNot(p, B[i])\n                && enclosesWeakAll(encloseBasis2(B[i], p), B)) {\n                return [B[i], p];\n            }\n        }\n        // If we get here then B must have at least two elements.\n        for (i = 0; i < B.length - 1; ++i) {\n            for (j = i + 1; j < B.length; ++j) {\n                if (enclosesNot(encloseBasis2(B[i], B[j]), p)\n                    && enclosesNot(encloseBasis2(B[i], p), B[j])\n                    && enclosesNot(encloseBasis2(B[j], p), B[i])\n                    && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {\n                    return [B[i], B[j], p];\n                }\n            }\n        }\n        // If we get here then something is very wrong.\n        throw new Error;\n    }\n    function enclosesNot(a, b) {\n        var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;\n        return dr < 0 || dr * dr < dx * dx + dy * dy;\n    }\n    function enclosesWeak(a, b) {\n        var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;\n        return dr > 0 && dr * dr > dx * dx + dy * dy;\n    }\n    function enclosesWeakAll(a, B) {\n        for (var i = 0; i < B.length; ++i) {\n            if (!enclosesWeak(a, B[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function encloseBasis(B) {\n        switch (B.length) {\n            case 1: return encloseBasis1(B[0]);\n            case 2: return encloseBasis2(B[0], B[1]);\n            case 3: return encloseBasis3(B[0], B[1], B[2]);\n        }\n    }\n    function encloseBasis1(a) {\n        return {\n            x: a.x,\n            y: a.y,\n            r: a.r\n        };\n    }\n    function encloseBasis2(a, b) {\n        var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);\n        return {\n            x: (x1 + x2 + x21 / l * r21) / 2,\n            y: (y1 + y2 + y21 / l * r21) / 2,\n            r: (l + r1 + r2) / 2\n        };\n    }\n    function encloseBasis3(a, b, c) {\n        var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x3 = c.x, y3 = c.y, r3 = c.r, a2 = x1 - x2, a3 = x1 - x3, b2 = y1 - y2, b3 = y1 - y3, c2 = r2 - r1, c3 = r3 - r1, d1 = x1 * x1 + y1 * y1 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b2 - a2 * b3, xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1, xb = (b3 * c2 - b2 * c3) / ab, ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1, yb = (a2 * c3 - a3 * c2) / ab, A = xb * xb + yb * yb - 1, B = 2 * (r1 + xa * xb + ya * yb), C = xa * xa + ya * ya - r1 * r1, r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);\n        return {\n            x: x1 + xa + xb * r,\n            y: y1 + ya + yb * r,\n            r: r\n        };\n    }\n    function place(b, a, c) {\n        var dx = b.x - a.x, x, a2, dy = b.y - a.y, y, b2, d2 = dx * dx + dy * dy;\n        if (d2) {\n            a2 = a.r + c.r, a2 *= a2;\n            b2 = b.r + c.r, b2 *= b2;\n            if (a2 > b2) {\n                x = (d2 + b2 - a2) / (2 * d2);\n                y = Math.sqrt(Math.max(0, b2 / d2 - x * x));\n                c.x = b.x - x * dx - y * dy;\n                c.y = b.y - x * dy + y * dx;\n            }\n            else {\n                x = (d2 + a2 - b2) / (2 * d2);\n                y = Math.sqrt(Math.max(0, a2 / d2 - x * x));\n                c.x = a.x + x * dx - y * dy;\n                c.y = a.y + x * dy + y * dx;\n            }\n        }\n        else {\n            c.x = a.x + c.r;\n            c.y = a.y;\n        }\n    }\n    function intersects(a, b) {\n        var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;\n        return dr > 0 && dr * dr > dx * dx + dy * dy;\n    }\n    function score(node) {\n        var a = node._, b = node.next._, ab = a.r + b.r, dx = (a.x * b.r + b.x * a.r) / ab, dy = (a.y * b.r + b.y * a.r) / ab;\n        return dx * dx + dy * dy;\n    }\n    function Node$1(circle) {\n        this._ = circle;\n        this.next = null;\n        this.previous = null;\n    }\n    function packEnclose(circles) {\n        if (!(n = circles.length))\n            return 0;\n        var a, b, c, n, aa, ca, i, j, k, sj, sk;\n        // Place the first circle.\n        a = circles[0], a.x = 0, a.y = 0;\n        if (!(n > 1))\n            return a.r;\n        // Place the second circle.\n        b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;\n        if (!(n > 2))\n            return a.r + b.r;\n        // Place the third circle.\n        place(b, a, c = circles[2]);\n        // Initialize the front-chain using the first three circles a, b and c.\n        a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);\n        a.next = c.previous = b;\n        b.next = a.previous = c;\n        c.next = b.previous = a;\n        // Attempt to place each remaining circle…\n        pack: for (i = 3; i < n; ++i) {\n            place(a._, b._, c = circles[i]), c = new Node$1(c);\n            // Find the closest intersecting circle on the front-chain, if any.\n            // “Closeness” is determined by linear distance along the front-chain.\n            // “Ahead” or “behind” is likewise determined by linear distance.\n            j = b.next, k = a.previous, sj = b._.r, sk = a._.r;\n            do {\n                if (sj <= sk) {\n                    if (intersects(j._, c._)) {\n                        b = j, a.next = b, b.previous = a, --i;\n                        continue pack;\n                    }\n                    sj += j._.r, j = j.next;\n                }\n                else {\n                    if (intersects(k._, c._)) {\n                        a = k, a.next = b, b.previous = a, --i;\n                        continue pack;\n                    }\n                    sk += k._.r, k = k.previous;\n                }\n            } while (j !== k.next);\n            // Success! Insert the new circle c between a and b.\n            c.previous = a, c.next = b, a.next = b.previous = b = c;\n            // Compute the new closest circle pair to the centroid.\n            aa = score(a);\n            while ((c = c.next) !== b) {\n                if ((ca = score(c)) < aa) {\n                    a = c, aa = ca;\n                }\n            }\n            b = a.next;\n        }\n        // Compute the enclosing circle of the front chain.\n        a = [b._], c = b;\n        while ((c = c.next) !== b)\n            a.push(c._);\n        c = enclose(a);\n        // Translate the circles to put the enclosing circle around the origin.\n        for (i = 0; i < n; ++i)\n            a = circles[i], a.x -= c.x, a.y -= c.y;\n        return c.r;\n    }\n    function siblings(circles) {\n        packEnclose(circles);\n        return circles;\n    }\n    function optional(f) {\n        return f == null ? null : required(f);\n    }\n    function required(f) {\n        if (typeof f !== \"function\")\n            throw new Error;\n        return f;\n    }\n    function constantZero() {\n        return 0;\n    }\n    function constant(x) {\n        return function () {\n            return x;\n        };\n    }\n    function defaultRadius(d) {\n        return Math.sqrt(d.value);\n    }\n    function index() {\n        var radius = null, dx = 1, dy = 1, padding = constantZero;\n        function pack(root) {\n            root.x = dx / 2, root.y = dy / 2;\n            if (radius) {\n                root.eachBefore(radiusLeaf(radius))\n                    .eachAfter(packChildren(padding, 0.5))\n                    .eachBefore(translateChild(1));\n            }\n            else {\n                root.eachBefore(radiusLeaf(defaultRadius))\n                    .eachAfter(packChildren(constantZero, 1))\n                    .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))\n                    .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));\n            }\n            return root;\n        }\n        pack.radius = function (x) {\n            return arguments.length ? (radius = optional(x), pack) : radius;\n        };\n        pack.size = function (x) {\n            return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];\n        };\n        pack.padding = function (x) {\n            return arguments.length ? (padding = typeof x === \"function\" ? x : constant(+x), pack) : padding;\n        };\n        return pack;\n    }\n    function radiusLeaf(radius) {\n        return function (node) {\n            if (!node.children) {\n                node.r = Math.max(0, +radius(node) || 0);\n            }\n        };\n    }\n    function packChildren(padding, k) {\n        return function (node) {\n            if (children = node.children) {\n                var children, i, n = children.length, r = padding(node) * k || 0, e;\n                if (r)\n                    for (i = 0; i < n; ++i)\n                        children[i].r += r;\n                e = packEnclose(children);\n                if (r)\n                    for (i = 0; i < n; ++i)\n                        children[i].r -= r;\n                node.r = e + r;\n            }\n        };\n    }\n    function translateChild(k) {\n        return function (node) {\n            var parent = node.parent;\n            node.r *= k;\n            if (parent) {\n                node.x = parent.x + k * node.x;\n                node.y = parent.y + k * node.y;\n            }\n        };\n    }\n    function roundNode(node) {\n        node.x0 = Math.round(node.x0);\n        node.y0 = Math.round(node.y0);\n        node.x1 = Math.round(node.x1);\n        node.y1 = Math.round(node.y1);\n    }\n    function treemapDice(parent, x0, y0, x1, y1) {\n        var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;\n        while (++i < n) {\n            node = nodes[i], node.y0 = y0, node.y1 = y1;\n            node.x0 = x0, node.x1 = x0 += node.value * k;\n        }\n    }\n    function partition() {\n        var dx = 1, dy = 1, padding = 0, round = false;\n        function partition(root) {\n            var n = root.height + 1;\n            root.x0 =\n                root.y0 = padding;\n            root.x1 = dx;\n            root.y1 = dy / n;\n            root.eachBefore(positionNode(dy, n));\n            if (round)\n                root.eachBefore(roundNode);\n            return root;\n        }\n        function positionNode(dy, n) {\n            return function (node) {\n                if (node.children) {\n                    treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);\n                }\n                var x0 = node.x0, y0 = node.y0, x1 = node.x1 - padding, y1 = node.y1 - padding;\n                if (x1 < x0)\n                    x0 = x1 = (x0 + x1) / 2;\n                if (y1 < y0)\n                    y0 = y1 = (y0 + y1) / 2;\n                node.x0 = x0;\n                node.y0 = y0;\n                node.x1 = x1;\n                node.y1 = y1;\n            };\n        }\n        partition.round = function (x) {\n            return arguments.length ? (round = !!x, partition) : round;\n        };\n        partition.size = function (x) {\n            return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];\n        };\n        partition.padding = function (x) {\n            return arguments.length ? (padding = +x, partition) : padding;\n        };\n        return partition;\n    }\n    var keyPrefix = \"$\", // Protect against keys like “__proto__”.\n    preroot = { depth: -1 }, ambiguous = {};\n    function defaultId(d) {\n        return d.id;\n    }\n    function defaultParentId(d) {\n        return d.parentId;\n    }\n    function stratify() {\n        var id = defaultId, parentId = defaultParentId;\n        function stratify(data) {\n            var d, i, n = data.length, root, parent, node, nodes = new Array(n), nodeId, nodeKey, nodeByKey = {};\n            for (i = 0; i < n; ++i) {\n                d = data[i], node = nodes[i] = new Node(d);\n                if ((nodeId = id(d, i, data)) != null && (nodeId += \"\")) {\n                    nodeKey = keyPrefix + (node.id = nodeId);\n                    nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;\n                }\n            }\n            for (i = 0; i < n; ++i) {\n                node = nodes[i], nodeId = parentId(data[i], i, data);\n                if (nodeId == null || !(nodeId += \"\")) {\n                    if (root)\n                        throw new Error(\"multiple roots\");\n                    root = node;\n                }\n                else {\n                    parent = nodeByKey[keyPrefix + nodeId];\n                    if (!parent)\n                        throw new Error(\"missing: \" + nodeId);\n                    if (parent === ambiguous)\n                        throw new Error(\"ambiguous: \" + nodeId);\n                    if (parent.children)\n                        parent.children.push(node);\n                    else\n                        parent.children = [node];\n                    node.parent = parent;\n                }\n            }\n            if (!root)\n                throw new Error(\"no root\");\n            root.parent = preroot;\n            root.eachBefore(function (node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);\n            root.parent = null;\n            if (n > 0)\n                throw new Error(\"cycle\");\n            return root;\n        }\n        stratify.id = function (x) {\n            return arguments.length ? (id = required(x), stratify) : id;\n        };\n        stratify.parentId = function (x) {\n            return arguments.length ? (parentId = required(x), stratify) : parentId;\n        };\n        return stratify;\n    }\n    function defaultSeparation$1(a, b) {\n        return a.parent === b.parent ? 1 : 2;\n    }\n    // function radialSeparation(a, b) {\n    //   return (a.parent === b.parent ? 1 : 2) / a.depth;\n    // }\n    // This function is used to traverse the left contour of a subtree (or\n    // subforest). It returns the successor of v on this contour. This successor is\n    // either given by the leftmost child of v or by the thread of v. The function\n    // returns null if and only if v is on the highest level of its subtree.\n    function nextLeft(v) {\n        var children = v.children;\n        return children ? children[0] : v.t;\n    }\n    // This function works analogously to nextLeft.\n    function nextRight(v) {\n        var children = v.children;\n        return children ? children[children.length - 1] : v.t;\n    }\n    // Shifts the current subtree rooted at w+. This is done by increasing\n    // prelim(w+) and mod(w+) by shift.\n    function moveSubtree(wm, wp, shift) {\n        var change = shift / (wp.i - wm.i);\n        wp.c -= change;\n        wp.s += shift;\n        wm.c += change;\n        wp.z += shift;\n        wp.m += shift;\n    }\n    // All other shifts, applied to the smaller subtrees between w- and w+, are\n    // performed by this function. To prepare the shifts, we have to adjust\n    // change(w+), shift(w+), and change(w-).\n    function executeShifts(v) {\n        var shift = 0, change = 0, children = v.children, i = children.length, w;\n        while (--i >= 0) {\n            w = children[i];\n            w.z += shift;\n            w.m += shift;\n            shift += w.s + (change += w.c);\n        }\n    }\n    // If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,\n    // returns the specified (default) ancestor.\n    function nextAncestor(vim, v, ancestor) {\n        return vim.a.parent === v.parent ? vim.a : ancestor;\n    }\n    function TreeNode(node, i) {\n        this._ = node;\n        this.parent = null;\n        this.children = null;\n        this.A = null; // default ancestor\n        this.a = this; // ancestor\n        this.z = 0; // prelim\n        this.m = 0; // mod\n        this.c = 0; // change\n        this.s = 0; // shift\n        this.t = null; // thread\n        this.i = i; // number\n    }\n    TreeNode.prototype = Object.create(Node.prototype);\n    function treeRoot(root) {\n        var tree = new TreeNode(root, 0), node, nodes = [tree], child, children, i, n;\n        while (node = nodes.pop()) {\n            if (children = node._.children) {\n                node.children = new Array(n = children.length);\n                for (i = n - 1; i >= 0; --i) {\n                    nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n                    child.parent = node;\n                }\n            }\n        }\n        (tree.parent = new TreeNode(null, 0)).children = [tree];\n        return tree;\n    }\n    // Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\n    function tree() {\n        var separation = defaultSeparation$1, dx = 1, dy = 1, nodeSize = null;\n        function tree(root) {\n            var t = treeRoot(root);\n            // Compute the layout using Buchheim et al.’s algorithm.\n            t.eachAfter(firstWalk), t.parent.m = -t.z;\n            t.eachBefore(secondWalk);\n            // If a fixed node size is specified, scale x and y.\n            if (nodeSize)\n                root.eachBefore(sizeNode);\n            // If a fixed tree size is specified, scale x and y based on the extent.\n            // Compute the left-most, right-most, and depth-most nodes for extents.\n            else {\n                var left = root, right = root, bottom = root;\n                root.eachBefore(function (node) {\n                    if (node.x < left.x)\n                        left = node;\n                    if (node.x > right.x)\n                        right = node;\n                    if (node.depth > bottom.depth)\n                        bottom = node;\n                });\n                var s = left === right ? 1 : separation(left, right) / 2, tx = s - left.x, kx = dx / (right.x + s + tx), ky = dy / (bottom.depth || 1);\n                root.eachBefore(function (node) {\n                    node.x = (node.x + tx) * kx;\n                    node.y = node.depth * ky;\n                });\n            }\n            return root;\n        }\n        // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n        // applied recursively to the children of v, as well as the function\n        // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n        // node v is placed to the midpoint of its outermost children.\n        function firstWalk(v) {\n            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;\n            if (children) {\n                executeShifts(v);\n                var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n                if (w) {\n                    v.z = w.z + separation(v._, w._);\n                    v.m = v.z - midpoint;\n                }\n                else {\n                    v.z = midpoint;\n                }\n            }\n            else if (w) {\n                v.z = w.z + separation(v._, w._);\n            }\n            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n        }\n        // Computes all real x-coordinates by summing up the modifiers recursively.\n        function secondWalk(v) {\n            v._.x = v.z + v.parent.m;\n            v.m += v.parent.m;\n        }\n        // The core of the algorithm. Here, a new subtree is combined with the\n        // previous subtrees. Threads are used to traverse the inside and outside\n        // contours of the left and right subtree up to the highest common level. The\n        // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n        // superscript o means outside and i means inside, the subscript - means left\n        // subtree and + means right subtree. For summing up the modifiers along the\n        // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n        // nodes of the inside contours conflict, we compute the left one of the\n        // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n        // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n        // Finally, we add a new thread (if necessary).\n        function apportion(v, w, ancestor) {\n            if (w) {\n                var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;\n                while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n                    vom = nextLeft(vom);\n                    vop = nextRight(vop);\n                    vop.a = v;\n                    shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n                    if (shift > 0) {\n                        moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n                        sip += shift;\n                        sop += shift;\n                    }\n                    sim += vim.m;\n                    sip += vip.m;\n                    som += vom.m;\n                    sop += vop.m;\n                }\n                if (vim && !nextRight(vop)) {\n                    vop.t = vim;\n                    vop.m += sim - sop;\n                }\n                if (vip && !nextLeft(vom)) {\n                    vom.t = vip;\n                    vom.m += sip - som;\n                    ancestor = v;\n                }\n            }\n            return ancestor;\n        }\n        function sizeNode(node) {\n            node.x *= dx;\n            node.y = node.depth * dy;\n        }\n        tree.separation = function (x) {\n            return arguments.length ? (separation = x, tree) : separation;\n        };\n        tree.size = function (x) {\n            return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\n        };\n        tree.nodeSize = function (x) {\n            return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\n        };\n        return tree;\n    }\n    function treemapSlice(parent, x0, y0, x1, y1) {\n        var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y1 - y0) / parent.value;\n        while (++i < n) {\n            node = nodes[i], node.x0 = x0, node.x1 = x1;\n            node.y0 = y0, node.y1 = y0 += node.value * k;\n        }\n    }\n    var phi = (1 + Math.sqrt(5)) / 2;\n    function squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n        var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;\n        while (i0 < n) {\n            dx = x1 - x0, dy = y1 - y0;\n            // Find the next non-empty node.\n            do\n                sumValue = nodes[i1++].value;\n            while (!sumValue && i1 < n);\n            minValue = maxValue = sumValue;\n            alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n            beta = sumValue * sumValue * alpha;\n            minRatio = Math.max(maxValue / beta, beta / minValue);\n            // Keep adding nodes while the aspect ratio maintains or improves.\n            for (; i1 < n; ++i1) {\n                sumValue += nodeValue = nodes[i1].value;\n                if (nodeValue < minValue)\n                    minValue = nodeValue;\n                if (nodeValue > maxValue)\n                    maxValue = nodeValue;\n                beta = sumValue * sumValue * alpha;\n                newRatio = Math.max(maxValue / beta, beta / minValue);\n                if (newRatio > minRatio) {\n                    sumValue -= nodeValue;\n                    break;\n                }\n                minRatio = newRatio;\n            }\n            // Position and record the row orientation.\n            rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });\n            if (row.dice)\n                treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n            else\n                treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n            value -= sumValue, i0 = i1;\n        }\n        return rows;\n    }\n    var squarify = (function custom(ratio) {\n        function squarify(parent, x0, y0, x1, y1) {\n            squarifyRatio(ratio, parent, x0, y0, x1, y1);\n        }\n        squarify.ratio = function (x) {\n            return custom((x = +x) > 1 ? x : 1);\n        };\n        return squarify;\n    })(phi);\n    function index$1() {\n        var tile = squarify, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;\n        function treemap(root) {\n            root.x0 =\n                root.y0 = 0;\n            root.x1 = dx;\n            root.y1 = dy;\n            root.eachBefore(positionNode);\n            paddingStack = [0];\n            if (round)\n                root.eachBefore(roundNode);\n            return root;\n        }\n        function positionNode(node) {\n            var p = paddingStack[node.depth], x0 = node.x0 + p, y0 = node.y0 + p, x1 = node.x1 - p, y1 = node.y1 - p;\n            if (x1 < x0)\n                x0 = x1 = (x0 + x1) / 2;\n            if (y1 < y0)\n                y0 = y1 = (y0 + y1) / 2;\n            node.x0 = x0;\n            node.y0 = y0;\n            node.x1 = x1;\n            node.y1 = y1;\n            if (node.children) {\n                p = paddingStack[node.depth + 1] = paddingInner(node) / 2;\n                x0 += paddingLeft(node) - p;\n                y0 += paddingTop(node) - p;\n                x1 -= paddingRight(node) - p;\n                y1 -= paddingBottom(node) - p;\n                if (x1 < x0)\n                    x0 = x1 = (x0 + x1) / 2;\n                if (y1 < y0)\n                    y0 = y1 = (y0 + y1) / 2;\n                tile(node, x0, y0, x1, y1);\n            }\n        }\n        treemap.round = function (x) {\n            return arguments.length ? (round = !!x, treemap) : round;\n        };\n        treemap.size = function (x) {\n            return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];\n        };\n        treemap.tile = function (x) {\n            return arguments.length ? (tile = required(x), treemap) : tile;\n        };\n        treemap.padding = function (x) {\n            return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();\n        };\n        treemap.paddingInner = function (x) {\n            return arguments.length ? (paddingInner = typeof x === \"function\" ? x : constant(+x), treemap) : paddingInner;\n        };\n        treemap.paddingOuter = function (x) {\n            return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();\n        };\n        treemap.paddingTop = function (x) {\n            return arguments.length ? (paddingTop = typeof x === \"function\" ? x : constant(+x), treemap) : paddingTop;\n        };\n        treemap.paddingRight = function (x) {\n            return arguments.length ? (paddingRight = typeof x === \"function\" ? x : constant(+x), treemap) : paddingRight;\n        };\n        treemap.paddingBottom = function (x) {\n            return arguments.length ? (paddingBottom = typeof x === \"function\" ? x : constant(+x), treemap) : paddingBottom;\n        };\n        treemap.paddingLeft = function (x) {\n            return arguments.length ? (paddingLeft = typeof x === \"function\" ? x : constant(+x), treemap) : paddingLeft;\n        };\n        return treemap;\n    }\n    function binary(parent, x0, y0, x1, y1) {\n        var nodes = parent.children, i, n = nodes.length, sum, sums = new Array(n + 1);\n        for (sums[0] = sum = i = 0; i < n; ++i) {\n            sums[i + 1] = sum += nodes[i].value;\n        }\n        partition(0, n, parent.value, x0, y0, x1, y1);\n        function partition(i, j, value, x0, y0, x1, y1) {\n            if (i >= j - 1) {\n                var node = nodes[i];\n                node.x0 = x0, node.y0 = y0;\n                node.x1 = x1, node.y1 = y1;\n                return;\n            }\n            var valueOffset = sums[i], valueTarget = (value / 2) + valueOffset, k = i + 1, hi = j - 1;\n            while (k < hi) {\n                var mid = k + hi >>> 1;\n                if (sums[mid] < valueTarget)\n                    k = mid + 1;\n                else\n                    hi = mid;\n            }\n            if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k)\n                --k;\n            var valueLeft = sums[k] - valueOffset, valueRight = value - valueLeft;\n            if ((x1 - x0) > (y1 - y0)) {\n                var xk = (x0 * valueRight + x1 * valueLeft) / value;\n                partition(i, k, valueLeft, x0, y0, xk, y1);\n                partition(k, j, valueRight, xk, y0, x1, y1);\n            }\n            else {\n                var yk = (y0 * valueRight + y1 * valueLeft) / value;\n                partition(i, k, valueLeft, x0, y0, x1, yk);\n                partition(k, j, valueRight, x0, yk, x1, y1);\n            }\n        }\n    }\n    function sliceDice(parent, x0, y0, x1, y1) {\n        (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);\n    }\n    var resquarify = (function custom(ratio) {\n        function resquarify(parent, x0, y0, x1, y1) {\n            if ((rows = parent._squarify) && (rows.ratio === ratio)) {\n                var rows, row, nodes, i, j = -1, n, m = rows.length, value = parent.value;\n                while (++j < m) {\n                    row = rows[j], nodes = row.children;\n                    for (i = row.value = 0, n = nodes.length; i < n; ++i)\n                        row.value += nodes[i].value;\n                    if (row.dice)\n                        treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);\n                    else\n                        treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);\n                    value -= row.value;\n                }\n            }\n            else {\n                parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);\n                rows.ratio = ratio;\n            }\n        }\n        resquarify.ratio = function (x) {\n            return custom((x = +x) > 1 ? x : 1);\n        };\n        return resquarify;\n    })(phi);\n    exports.cluster = cluster;\n    exports.hierarchy = hierarchy;\n    exports.pack = index;\n    exports.packEnclose = enclose;\n    exports.packSiblings = siblings;\n    exports.partition = partition;\n    exports.stratify = stratify;\n    exports.tree = tree;\n    exports.treemap = index$1;\n    exports.treemapBinary = binary;\n    exports.treemapDice = treemapDice;\n    exports.treemapResquarify = resquarify;\n    exports.treemapSlice = treemapSlice;\n    exports.treemapSliceDice = sliceDice;\n    exports.treemapSquarify = squarify;\n    Object.defineProperty(exports, '__esModule', { value: true });\n}));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-path@1.0.9@d3-path/dist/d3-path.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_d3-path@1.0.9@d3-path/dist/d3-path.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-path/ v1.0.9 Copyright 2019 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports) :\n        undefined;\n}(this, function (exports) {\n    'use strict';\n    var pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;\n    function Path() {\n        this._x0 = this._y0 = // start of current subpath\n            this._x1 = this._y1 = null; // end of current subpath\n        this._ = \"\";\n    }\n    function path() {\n        return new Path;\n    }\n    Path.prototype = path.prototype = {\n        constructor: Path,\n        moveTo: function (x, y) {\n            this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y);\n        },\n        closePath: function () {\n            if (this._x1 !== null) {\n                this._x1 = this._x0, this._y1 = this._y0;\n                this._ += \"Z\";\n            }\n        },\n        lineTo: function (x, y) {\n            this._ += \"L\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n        },\n        quadraticCurveTo: function (x1, y1, x, y) {\n            this._ += \"Q\" + (+x1) + \",\" + (+y1) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n        },\n        bezierCurveTo: function (x1, y1, x2, y2, x, y) {\n            this._ += \"C\" + (+x1) + \",\" + (+y1) + \",\" + (+x2) + \",\" + (+y2) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n        },\n        arcTo: function (x1, y1, x2, y2, r) {\n            x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n            var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;\n            // Is the radius negative? Error.\n            if (r < 0)\n                throw new Error(\"negative radius: \" + r);\n            // Is this path empty? Move to (x1,y1).\n            if (this._x1 === null) {\n                this._ += \"M\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n            }\n            // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n            else if (!(l01_2 > epsilon))\n                ;\n            // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n            // Equivalently, is (x1,y1) coincident with (x2,y2)?\n            // Or, is the radius zero? Line to (x1,y1).\n            else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n                this._ += \"L\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n            }\n            // Otherwise, draw an arc!\n            else {\n                var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;\n                // If the start tangent is not coincident with (x0,y0), line to.\n                if (Math.abs(t01 - 1) > epsilon) {\n                    this._ += \"L\" + (x1 + t01 * x01) + \",\" + (y1 + t01 * y01);\n                }\n                this._ += \"A\" + r + \",\" + r + \",0,0,\" + (+(y01 * x20 > x01 * y20)) + \",\" + (this._x1 = x1 + t21 * x21) + \",\" + (this._y1 = y1 + t21 * y21);\n            }\n        },\n        arc: function (x, y, r, a0, a1, ccw) {\n            x = +x, y = +y, r = +r, ccw = !!ccw;\n            var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x + dx, y0 = y + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;\n            // Is the radius negative? Error.\n            if (r < 0)\n                throw new Error(\"negative radius: \" + r);\n            // Is this path empty? Move to (x0,y0).\n            if (this._x1 === null) {\n                this._ += \"M\" + x0 + \",\" + y0;\n            }\n            // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n            else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n                this._ += \"L\" + x0 + \",\" + y0;\n            }\n            // Is this arc empty? We’re done.\n            if (!r)\n                return;\n            // Does the angle go the wrong way? Flip the direction.\n            if (da < 0)\n                da = da % tau + tau;\n            // Is this a complete circle? Draw two arcs to complete the circle.\n            if (da > tauEpsilon) {\n                this._ += \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (x - dx) + \",\" + (y - dy) + \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (this._x1 = x0) + \",\" + (this._y1 = y0);\n            }\n            // Is this arc non-empty? Draw an arc!\n            else if (da > epsilon) {\n                this._ += \"A\" + r + \",\" + r + \",0,\" + (+(da >= pi)) + \",\" + cw + \",\" + (this._x1 = x + r * Math.cos(a1)) + \",\" + (this._y1 = y + r * Math.sin(a1));\n            }\n        },\n        rect: function (x, y, w, h) {\n            this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y) + \"h\" + (+w) + \"v\" + (+h) + \"h\" + (-w) + \"Z\";\n        },\n        toString: function () {\n            return this._;\n        }\n    };\n    exports.path = path;\n    Object.defineProperty(exports, '__esModule', { value: true });\n}));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-sankey@0.9.1@d3-sankey/dist/d3-sankey.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_d3-sankey@0.9.1@d3-sankey/dist/d3-sankey.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\n// https://github.com/d3/d3-sankey v0.9.1 Copyright 2019 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! d3-array */ \"./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js\"), __webpack_require__(/*! d3-collection */ \"./node_modules/_d3-collection@1.0.7@d3-collection/dist/d3-collection.js\"), __webpack_require__(/*! d3-shape */ \"./node_modules/_d3-shape@1.3.7@d3-shape/dist/d3-shape.js\")) :\n        undefined;\n}(this, function (exports, d3Array, d3Collection, d3Shape) {\n    'use strict';\n    function targetDepth(d) {\n        return d.target.depth;\n    }\n    function left(node) {\n        return node.depth;\n    }\n    function right(node, n) {\n        return n - 1 - node.height;\n    }\n    function justify(node, n) {\n        return node.sourceLinks.length ? node.depth : n - 1;\n    }\n    function center(node) {\n        return node.targetLinks.length ? node.depth\n            : node.sourceLinks.length ? d3Array.min(node.sourceLinks, targetDepth) - 1\n                : 0;\n    }\n    function constant(x) {\n        return function () {\n            return x;\n        };\n    }\n    function ascendingSourceBreadth(a, b) {\n        return ascendingBreadth(a.source, b.source) || a.index - b.index;\n    }\n    function ascendingTargetBreadth(a, b) {\n        return ascendingBreadth(a.target, b.target) || a.index - b.index;\n    }\n    function ascendingBreadth(a, b) {\n        return a.y0 - b.y0;\n    }\n    function value(d) {\n        return d.value;\n    }\n    function defaultId(d) {\n        return d.index;\n    }\n    function defaultNodes(graph) {\n        return graph.nodes;\n    }\n    function defaultLinks(graph) {\n        return graph.links;\n    }\n    function find(nodeById, id) {\n        var node = nodeById.get(id);\n        if (!node)\n            throw new Error(\"missing: \" + id);\n        return node;\n    }\n    function Sankey() {\n        var x0 = 0, y0 = 0, x1 = 1, y1 = 1, // extent\n        dx = 24, // nodeWidth\n        py = 8, // nodePadding\n        id = defaultId, align = justify, sort, nodes = defaultNodes, links = defaultLinks, iterations = 6;\n        function sankey() {\n            var graph = { nodes: nodes.apply(null, arguments), links: links.apply(null, arguments) };\n            computeNodeLinks(graph);\n            computeNodeValues(graph);\n            computeNodeDepths(graph);\n            computeNodeBreadths(graph);\n            computeLinkBreadths(graph);\n            return graph;\n        }\n        sankey.update = function (graph) {\n            computeLinkBreadths(graph);\n            return graph;\n        };\n        sankey.nodeId = function (_) {\n            return arguments.length ? (id = typeof _ === \"function\" ? _ : constant(_), sankey) : id;\n        };\n        sankey.nodeAlign = function (_) {\n            return arguments.length ? (align = typeof _ === \"function\" ? _ : constant(_), sankey) : align;\n        };\n        sankey.nodeSort = function (_) {\n            return arguments.length ? (sort = _, sankey) : sort;\n        };\n        sankey.nodeWidth = function (_) {\n            return arguments.length ? (dx = +_, sankey) : dx;\n        };\n        sankey.nodePadding = function (_) {\n            return arguments.length ? (py = +_, sankey) : py;\n        };\n        sankey.nodes = function (_) {\n            return arguments.length ? (nodes = typeof _ === \"function\" ? _ : constant(_), sankey) : nodes;\n        };\n        sankey.links = function (_) {\n            return arguments.length ? (links = typeof _ === \"function\" ? _ : constant(_), sankey) : links;\n        };\n        sankey.size = function (_) {\n            return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];\n        };\n        sankey.extent = function (_) {\n            return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];\n        };\n        sankey.iterations = function (_) {\n            return arguments.length ? (iterations = +_, sankey) : iterations;\n        };\n        // Populate the sourceLinks and targetLinks for each node.\n        // Also, if the source and target are not objects, assume they are indices.\n        function computeNodeLinks(graph) {\n            graph.nodes.forEach(function (node, i) {\n                node.index = i;\n                node.sourceLinks = [];\n                node.targetLinks = [];\n            });\n            var nodeById = d3Collection.map(graph.nodes, id);\n            graph.links.forEach(function (link, i) {\n                link.index = i;\n                var source = link.source, target = link.target;\n                if (typeof source !== \"object\")\n                    source = link.source = find(nodeById, source);\n                if (typeof target !== \"object\")\n                    target = link.target = find(nodeById, target);\n                source.sourceLinks.push(link);\n                target.targetLinks.push(link);\n            });\n        }\n        // Compute the value (size) of each node by summing the associated links.\n        function computeNodeValues(graph) {\n            graph.nodes.forEach(function (node) {\n                node.value = Math.max(d3Array.sum(node.sourceLinks, value), d3Array.sum(node.targetLinks, value));\n            });\n        }\n        // Iteratively assign the depth (x-position) for each node.\n        // Nodes are assigned the maximum depth of incoming neighbors plus one;\n        // nodes with no incoming links are assigned depth zero, while\n        // nodes with no outgoing links are assigned the maximum depth.\n        function computeNodeDepths(graph) {\n            var nodes, next, x, n = graph.nodes.length;\n            for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {\n                if (x > n)\n                    throw new Error(\"circular link\");\n                nodes.forEach(function (node) {\n                    node.depth = x;\n                    node.sourceLinks.forEach(function (link) {\n                        if (next.indexOf(link.target) < 0) {\n                            next.push(link.target);\n                        }\n                    });\n                });\n            }\n            for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {\n                if (x > n)\n                    throw new Error(\"circular link\");\n                nodes.forEach(function (node) {\n                    node.height = x;\n                    node.targetLinks.forEach(function (link) {\n                        if (next.indexOf(link.source) < 0) {\n                            next.push(link.source);\n                        }\n                    });\n                });\n            }\n            var kx = (x1 - x0 - dx) / (x - 1);\n            graph.nodes.forEach(function (node) {\n                node.x1 = (node.x0 = x0 + Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x)))) * kx) + dx;\n            });\n        }\n        function computeNodeBreadths(graph) {\n            var columns = d3Collection.nest()\n                .key(function (d) { return d.x0; })\n                .sortKeys(d3Array.ascending)\n                .entries(graph.nodes)\n                .map(function (d) { return d.values; });\n            //\n            initializeNodeBreadth();\n            resolveCollisions();\n            for (var alpha = 0.9, n = iterations; n > 0; --n, alpha *= 0.9) {\n                relaxRightToLeft(alpha);\n                resolveCollisions();\n                relaxLeftToRight(alpha);\n                resolveCollisions();\n            }\n            function initializeNodeBreadth() {\n                var ky = d3Array.min(columns, function (nodes) {\n                    return (y1 - y0 - (nodes.length - 1) * py) / d3Array.sum(nodes, value);\n                });\n                columns.forEach(function (nodes) {\n                    if (sort != null)\n                        nodes.sort(sort);\n                    nodes.forEach(function (node, i) {\n                        node.y1 = (node.y0 = i) + node.value * ky;\n                    });\n                });\n                graph.links.forEach(function (link) {\n                    link.width = link.value * ky;\n                });\n            }\n            function relaxLeftToRight(alpha) {\n                columns.forEach(function (nodes) {\n                    nodes.forEach(function (node) {\n                        var e_1, _a, e_2, _b;\n                        var y = node.y0;\n                        try {\n                            for (var _c = tslib_1.__values(node.sourceLinks.sort(ascendingTargetBreadth)), _d = _c.next(); !_d.done; _d = _c.next()) {\n                                var _e = _d.value, target = _e.target, width = _e.width, value_1 = _e.value;\n                                if (value_1 > 0) {\n                                    var dy = 0;\n                                    try {\n                                        for (var _f = (e_2 = void 0, tslib_1.__values(target.targetLinks)), _g = _f.next(); !_g.done; _g = _f.next()) {\n                                            var _h = _g.value, source = _h.source, width_1 = _h.width;\n                                            if (source === node)\n                                                break;\n                                            dy += width_1 + py / 2;\n                                        }\n                                    }\n                                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                                    finally {\n                                        try {\n                                            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n                                        }\n                                        finally { if (e_2) throw e_2.error; }\n                                    }\n                                    dy = (y - dy - target.y0) * alpha * (value_1 / Math.min(node.value, target.value));\n                                    target.y0 += dy;\n                                    target.y1 += dy;\n                                }\n                                y += width + py / 2;\n                            }\n                        }\n                        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                        finally {\n                            try {\n                                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                            }\n                            finally { if (e_1) throw e_1.error; }\n                        }\n                    });\n                });\n            }\n            function relaxRightToLeft(alpha) {\n                columns.slice().reverse().forEach(function (nodes) {\n                    nodes.forEach(function (node) {\n                        var e_3, _a, e_4, _b;\n                        var y = node.y0;\n                        try {\n                            for (var _c = tslib_1.__values(node.targetLinks.sort(ascendingSourceBreadth)), _d = _c.next(); !_d.done; _d = _c.next()) {\n                                var _e = _d.value, source = _e.source, width = _e.width, value_2 = _e.value;\n                                if (value_2 > 0) {\n                                    var dy = 0;\n                                    try {\n                                        for (var _f = (e_4 = void 0, tslib_1.__values(source.sourceLinks)), _g = _f.next(); !_g.done; _g = _f.next()) {\n                                            var _h = _g.value, target = _h.target, width_2 = _h.width;\n                                            if (target === node)\n                                                break;\n                                            dy += width_2 + py / 2;\n                                        }\n                                    }\n                                    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                                    finally {\n                                        try {\n                                            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n                                        }\n                                        finally { if (e_4) throw e_4.error; }\n                                    }\n                                    dy = (y - dy - source.y0) * alpha * (value_2 / Math.min(node.value, source.value));\n                                    source.y0 += dy;\n                                    source.y1 += dy;\n                                }\n                                y += width + py / 2;\n                            }\n                        }\n                        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                        finally {\n                            try {\n                                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                            }\n                            finally { if (e_3) throw e_3.error; }\n                        }\n                    });\n                });\n            }\n            function resolveCollisions() {\n                columns.forEach(function (nodes) {\n                    var node, dy, y = y0, n = nodes.length, i;\n                    // Push any overlapping nodes down.\n                    if (sort === undefined)\n                        nodes.sort(ascendingBreadth);\n                    for (i = 0; i < n; ++i) {\n                        node = nodes[i];\n                        dy = y - node.y0;\n                        if (dy > 0)\n                            node.y0 += dy, node.y1 += dy;\n                        y = node.y1 + py;\n                    }\n                    // If the bottommost node goes outside the bounds, push it back up.\n                    dy = y - py - y1;\n                    if (dy > 0) {\n                        y = (node.y0 -= dy), node.y1 -= dy;\n                        // Push any overlapping nodes back up.\n                        for (i = n - 2; i >= 0; --i) {\n                            node = nodes[i];\n                            dy = node.y1 + py - y;\n                            if (dy > 0)\n                                node.y0 -= dy, node.y1 -= dy;\n                            y = node.y0;\n                        }\n                    }\n                });\n            }\n        }\n        function computeLinkBreadths(graph) {\n            graph.nodes.forEach(function (node) {\n                node.sourceLinks.sort(ascendingTargetBreadth);\n                node.targetLinks.sort(ascendingSourceBreadth);\n            });\n            graph.nodes.forEach(function (node) {\n                var y0 = node.y0, y1 = y0;\n                node.sourceLinks.forEach(function (link) {\n                    link.y0 = y0 + link.width / 2, y0 += link.width;\n                });\n                node.targetLinks.forEach(function (link) {\n                    link.y1 = y1 + link.width / 2, y1 += link.width;\n                });\n            });\n        }\n        return sankey;\n    }\n    function horizontalSource(d) {\n        return [d.source.x1, d.y0];\n    }\n    function horizontalTarget(d) {\n        return [d.target.x0, d.y1];\n    }\n    function sankeyLinkHorizontal() {\n        return d3Shape.linkHorizontal()\n            .source(horizontalSource)\n            .target(horizontalTarget);\n    }\n    exports.sankey = Sankey;\n    exports.sankeyCenter = center;\n    exports.sankeyLeft = left;\n    exports.sankeyRight = right;\n    exports.sankeyJustify = justify;\n    exports.sankeyLinkHorizontal = sankeyLinkHorizontal;\n    Object.defineProperty(exports, '__esModule', { value: true });\n}));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-shape@1.3.7@d3-shape/dist/d3-shape.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_d3-shape@1.3.7@d3-shape/dist/d3-shape.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-shape/ v1.3.7 Copyright 2019 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! d3-path */ \"./node_modules/_d3-path@1.0.9@d3-path/dist/d3-path.js\")) :\n        undefined;\n}(this, function (exports, d3Path) {\n    'use strict';\n    function constant(x) {\n        return function constant() {\n            return x;\n        };\n    }\n    var abs = Math.abs;\n    var atan2 = Math.atan2;\n    var cos = Math.cos;\n    var max = Math.max;\n    var min = Math.min;\n    var sin = Math.sin;\n    var sqrt = Math.sqrt;\n    var epsilon = 1e-12;\n    var pi = Math.PI;\n    var halfPi = pi / 2;\n    var tau = 2 * pi;\n    function acos(x) {\n        return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n    }\n    function asin(x) {\n        return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);\n    }\n    function arcInnerRadius(d) {\n        return d.innerRadius;\n    }\n    function arcOuterRadius(d) {\n        return d.outerRadius;\n    }\n    function arcStartAngle(d) {\n        return d.startAngle;\n    }\n    function arcEndAngle(d) {\n        return d.endAngle;\n    }\n    function arcPadAngle(d) {\n        return d && d.padAngle; // Note: optional!\n    }\n    function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n        var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;\n        if (t * t < epsilon)\n            return;\n        t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;\n        return [x0 + t * x10, y0 + t * y10];\n    }\n    // Compute perpendicular offset line of length rc.\n    // http://mathworld.wolfram.com/Circle-LineIntersection.html\n    function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {\n        var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;\n        // Pick the closer of the two intersection points.\n        // TODO Is there a faster way to determine which intersection to use?\n        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)\n            cx0 = cx1, cy0 = cy1;\n        return {\n            cx: cx0,\n            cy: cy0,\n            x01: -ox,\n            y01: -oy,\n            x11: cx0 * (r1 / r - 1),\n            y11: cy0 * (r1 / r - 1)\n        };\n    }\n    function arc() {\n        var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;\n        function arc() {\n            var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw = a1 > a0;\n            if (!context)\n                context = buffer = d3Path.path();\n            // Ensure that the outer radius is always larger than the inner radius.\n            if (r1 < r0)\n                r = r1, r1 = r0, r0 = r;\n            // Is it a point?\n            if (!(r1 > epsilon))\n                context.moveTo(0, 0);\n            // Or is it a circle or annulus?\n            else if (da > tau - epsilon) {\n                context.moveTo(r1 * cos(a0), r1 * sin(a0));\n                context.arc(0, 0, r1, a0, a1, !cw);\n                if (r0 > epsilon) {\n                    context.moveTo(r0 * cos(a1), r0 * sin(a1));\n                    context.arc(0, 0, r0, a1, a0, cw);\n                }\n            }\n            // Or is it a circular or annular sector?\n            else {\n                var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;\n                // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.\n                if (rp > epsilon) {\n                    var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));\n                    if ((da0 -= p0 * 2) > epsilon)\n                        p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;\n                    else\n                        da0 = 0, a00 = a10 = (a0 + a1) / 2;\n                    if ((da1 -= p1 * 2) > epsilon)\n                        p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;\n                    else\n                        da1 = 0, a01 = a11 = (a0 + a1) / 2;\n                }\n                var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);\n                // Apply rounded corners?\n                if (rc > epsilon) {\n                    var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;\n                    // Restrict the corner radius according to the sector angle.\n                    if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {\n                        var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n                        rc0 = min(rc, (r0 - lc) / (kc - 1));\n                        rc1 = min(rc, (r1 - lc) / (kc + 1));\n                    }\n                }\n                // Is the sector collapsed to a line?\n                if (!(da1 > epsilon))\n                    context.moveTo(x01, y01);\n                // Does the sector’s outer ring have rounded corners?\n                else if (rc1 > epsilon) {\n                    t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);\n                    t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n                    context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);\n                    // Have the corners merged?\n                    if (rc1 < rc)\n                        context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);\n                    // Otherwise, draw the two corners and the ring.\n                    else {\n                        context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n                        context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);\n                        context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n                    }\n                }\n                // Or is the outer ring just a circular arc?\n                else\n                    context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);\n                // Is there no inner ring, and it’s a circular sector?\n                // Or perhaps it’s an annular sector collapsed due to padding?\n                if (!(r0 > epsilon) || !(da0 > epsilon))\n                    context.lineTo(x10, y10);\n                // Does the sector’s inner ring (or point) have rounded corners?\n                else if (rc0 > epsilon) {\n                    t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n                    t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);\n                    context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);\n                    // Have the corners merged?\n                    if (rc0 < rc)\n                        context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);\n                    // Otherwise, draw the two corners and the ring.\n                    else {\n                        context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n                        context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);\n                        context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n                    }\n                }\n                // Or is the inner ring just a circular arc?\n                else\n                    context.arc(0, 0, r0, a10, a00, cw);\n            }\n            context.closePath();\n            if (buffer)\n                return context = null, buffer + \"\" || null;\n        }\n        arc.centroid = function () {\n            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;\n            return [cos(a) * r, sin(a) * r];\n        };\n        arc.innerRadius = function (_) {\n            return arguments.length ? (innerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : innerRadius;\n        };\n        arc.outerRadius = function (_) {\n            return arguments.length ? (outerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : outerRadius;\n        };\n        arc.cornerRadius = function (_) {\n            return arguments.length ? (cornerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : cornerRadius;\n        };\n        arc.padRadius = function (_) {\n            return arguments.length ? (padRadius = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), arc) : padRadius;\n        };\n        arc.startAngle = function (_) {\n            return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : startAngle;\n        };\n        arc.endAngle = function (_) {\n            return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : endAngle;\n        };\n        arc.padAngle = function (_) {\n            return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : padAngle;\n        };\n        arc.context = function (_) {\n            return arguments.length ? ((context = _ == null ? null : _), arc) : context;\n        };\n        return arc;\n    }\n    function Linear(context) {\n        this._context = context;\n    }\n    Linear.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._line || (this._line !== 0 && this._point === 1))\n                this._context.closePath();\n            this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);\n                    break;\n                case 1: this._point = 2; // proceed\n                default:\n                    this._context.lineTo(x, y);\n                    break;\n            }\n        }\n    };\n    function curveLinear(context) {\n        return new Linear(context);\n    }\n    function x(p) {\n        return p[0];\n    }\n    function y(p) {\n        return p[1];\n    }\n    function line() {\n        var x$1 = x, y$1 = y, defined = constant(true), context = null, curve = curveLinear, output = null;\n        function line(data) {\n            var i, n = data.length, d, defined0 = false, buffer;\n            if (context == null)\n                output = curve(buffer = d3Path.path());\n            for (i = 0; i <= n; ++i) {\n                if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n                    if (defined0 = !defined0)\n                        output.lineStart();\n                    else\n                        output.lineEnd();\n                }\n                if (defined0)\n                    output.point(+x$1(d, i, data), +y$1(d, i, data));\n            }\n            if (buffer)\n                return output = null, buffer + \"\" || null;\n        }\n        line.x = function (_) {\n            return arguments.length ? (x$1 = typeof _ === \"function\" ? _ : constant(+_), line) : x$1;\n        };\n        line.y = function (_) {\n            return arguments.length ? (y$1 = typeof _ === \"function\" ? _ : constant(+_), line) : y$1;\n        };\n        line.defined = function (_) {\n            return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant(!!_), line) : defined;\n        };\n        line.curve = function (_) {\n            return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;\n        };\n        line.context = function (_) {\n            return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;\n        };\n        return line;\n    }\n    function area() {\n        var x0 = x, x1 = null, y0 = constant(0), y1 = y, defined = constant(true), context = null, curve = curveLinear, output = null;\n        function area(data) {\n            var i, j, k, n = data.length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);\n            if (context == null)\n                output = curve(buffer = d3Path.path());\n            for (i = 0; i <= n; ++i) {\n                if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n                    if (defined0 = !defined0) {\n                        j = i;\n                        output.areaStart();\n                        output.lineStart();\n                    }\n                    else {\n                        output.lineEnd();\n                        output.lineStart();\n                        for (k = i - 1; k >= j; --k) {\n                            output.point(x0z[k], y0z[k]);\n                        }\n                        output.lineEnd();\n                        output.areaEnd();\n                    }\n                }\n                if (defined0) {\n                    x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);\n                    output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);\n                }\n            }\n            if (buffer)\n                return output = null, buffer + \"\" || null;\n        }\n        function arealine() {\n            return line().defined(defined).curve(curve).context(context);\n        }\n        area.x = function (_) {\n            return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant(+_), x1 = null, area) : x0;\n        };\n        area.x0 = function (_) {\n            return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant(+_), area) : x0;\n        };\n        area.x1 = function (_) {\n            return arguments.length ? (x1 = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), area) : x1;\n        };\n        area.y = function (_) {\n            return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant(+_), y1 = null, area) : y0;\n        };\n        area.y0 = function (_) {\n            return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant(+_), area) : y0;\n        };\n        area.y1 = function (_) {\n            return arguments.length ? (y1 = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), area) : y1;\n        };\n        area.lineX0 =\n            area.lineY0 = function () {\n                return arealine().x(x0).y(y0);\n            };\n        area.lineY1 = function () {\n            return arealine().x(x0).y(y1);\n        };\n        area.lineX1 = function () {\n            return arealine().x(x1).y(y0);\n        };\n        area.defined = function (_) {\n            return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant(!!_), area) : defined;\n        };\n        area.curve = function (_) {\n            return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;\n        };\n        area.context = function (_) {\n            return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;\n        };\n        return area;\n    }\n    function descending(a, b) {\n        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n    }\n    function identity(d) {\n        return d;\n    }\n    function pie() {\n        var value = identity, sortValues = descending, sort = null, startAngle = constant(0), endAngle = constant(tau), padAngle = constant(0);\n        function pie(data) {\n            var i, n = data.length, j, k, sum = 0, index = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;\n            for (i = 0; i < n; ++i) {\n                if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {\n                    sum += v;\n                }\n            }\n            // Optionally sort the arcs by previously-computed values or by data.\n            if (sortValues != null)\n                index.sort(function (i, j) { return sortValues(arcs[i], arcs[j]); });\n            else if (sort != null)\n                index.sort(function (i, j) { return sort(data[i], data[j]); });\n            // Compute the arcs! They are stored in the original data's order.\n            for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {\n                j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {\n                    data: data[j],\n                    index: i,\n                    value: v,\n                    startAngle: a0,\n                    endAngle: a1,\n                    padAngle: p\n                };\n            }\n            return arcs;\n        }\n        pie.value = function (_) {\n            return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(+_), pie) : value;\n        };\n        pie.sortValues = function (_) {\n            return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;\n        };\n        pie.sort = function (_) {\n            return arguments.length ? (sort = _, sortValues = null, pie) : sort;\n        };\n        pie.startAngle = function (_) {\n            return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : startAngle;\n        };\n        pie.endAngle = function (_) {\n            return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : endAngle;\n        };\n        pie.padAngle = function (_) {\n            return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : padAngle;\n        };\n        return pie;\n    }\n    var curveRadialLinear = curveRadial(curveLinear);\n    function Radial(curve) {\n        this._curve = curve;\n    }\n    Radial.prototype = {\n        areaStart: function () {\n            this._curve.areaStart();\n        },\n        areaEnd: function () {\n            this._curve.areaEnd();\n        },\n        lineStart: function () {\n            this._curve.lineStart();\n        },\n        lineEnd: function () {\n            this._curve.lineEnd();\n        },\n        point: function (a, r) {\n            this._curve.point(r * Math.sin(a), r * -Math.cos(a));\n        }\n    };\n    function curveRadial(curve) {\n        function radial(context) {\n            return new Radial(curve(context));\n        }\n        radial._curve = curve;\n        return radial;\n    }\n    function lineRadial(l) {\n        var c = l.curve;\n        l.angle = l.x, delete l.x;\n        l.radius = l.y, delete l.y;\n        l.curve = function (_) {\n            return arguments.length ? c(curveRadial(_)) : c()._curve;\n        };\n        return l;\n    }\n    function lineRadial$1() {\n        return lineRadial(line().curve(curveRadialLinear));\n    }\n    function areaRadial() {\n        var a = area().curve(curveRadialLinear), c = a.curve, x0 = a.lineX0, x1 = a.lineX1, y0 = a.lineY0, y1 = a.lineY1;\n        a.angle = a.x, delete a.x;\n        a.startAngle = a.x0, delete a.x0;\n        a.endAngle = a.x1, delete a.x1;\n        a.radius = a.y, delete a.y;\n        a.innerRadius = a.y0, delete a.y0;\n        a.outerRadius = a.y1, delete a.y1;\n        a.lineStartAngle = function () { return lineRadial(x0()); }, delete a.lineX0;\n        a.lineEndAngle = function () { return lineRadial(x1()); }, delete a.lineX1;\n        a.lineInnerRadius = function () { return lineRadial(y0()); }, delete a.lineY0;\n        a.lineOuterRadius = function () { return lineRadial(y1()); }, delete a.lineY1;\n        a.curve = function (_) {\n            return arguments.length ? c(curveRadial(_)) : c()._curve;\n        };\n        return a;\n    }\n    function pointRadial(x, y) {\n        return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];\n    }\n    var slice = Array.prototype.slice;\n    function linkSource(d) {\n        return d.source;\n    }\n    function linkTarget(d) {\n        return d.target;\n    }\n    function link(curve) {\n        var source = linkSource, target = linkTarget, x$1 = x, y$1 = y, context = null;\n        function link() {\n            var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);\n            if (!context)\n                context = buffer = d3Path.path();\n            curve(context, +x$1.apply(this, (argv[0] = s, argv)), +y$1.apply(this, argv), +x$1.apply(this, (argv[0] = t, argv)), +y$1.apply(this, argv));\n            if (buffer)\n                return context = null, buffer + \"\" || null;\n        }\n        link.source = function (_) {\n            return arguments.length ? (source = _, link) : source;\n        };\n        link.target = function (_) {\n            return arguments.length ? (target = _, link) : target;\n        };\n        link.x = function (_) {\n            return arguments.length ? (x$1 = typeof _ === \"function\" ? _ : constant(+_), link) : x$1;\n        };\n        link.y = function (_) {\n            return arguments.length ? (y$1 = typeof _ === \"function\" ? _ : constant(+_), link) : y$1;\n        };\n        link.context = function (_) {\n            return arguments.length ? ((context = _ == null ? null : _), link) : context;\n        };\n        return link;\n    }\n    function curveHorizontal(context, x0, y0, x1, y1) {\n        context.moveTo(x0, y0);\n        context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);\n    }\n    function curveVertical(context, x0, y0, x1, y1) {\n        context.moveTo(x0, y0);\n        context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);\n    }\n    function curveRadial$1(context, x0, y0, x1, y1) {\n        var p0 = pointRadial(x0, y0), p1 = pointRadial(x0, y0 = (y0 + y1) / 2), p2 = pointRadial(x1, y0), p3 = pointRadial(x1, y1);\n        context.moveTo(p0[0], p0[1]);\n        context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);\n    }\n    function linkHorizontal() {\n        return link(curveHorizontal);\n    }\n    function linkVertical() {\n        return link(curveVertical);\n    }\n    function linkRadial() {\n        var l = link(curveRadial$1);\n        l.angle = l.x, delete l.x;\n        l.radius = l.y, delete l.y;\n        return l;\n    }\n    var circle = {\n        draw: function (context, size) {\n            var r = Math.sqrt(size / pi);\n            context.moveTo(r, 0);\n            context.arc(0, 0, r, 0, tau);\n        }\n    };\n    var cross = {\n        draw: function (context, size) {\n            var r = Math.sqrt(size / 5) / 2;\n            context.moveTo(-3 * r, -r);\n            context.lineTo(-r, -r);\n            context.lineTo(-r, -3 * r);\n            context.lineTo(r, -3 * r);\n            context.lineTo(r, -r);\n            context.lineTo(3 * r, -r);\n            context.lineTo(3 * r, r);\n            context.lineTo(r, r);\n            context.lineTo(r, 3 * r);\n            context.lineTo(-r, 3 * r);\n            context.lineTo(-r, r);\n            context.lineTo(-3 * r, r);\n            context.closePath();\n        }\n    };\n    var tan30 = Math.sqrt(1 / 3), tan30_2 = tan30 * 2;\n    var diamond = {\n        draw: function (context, size) {\n            var y = Math.sqrt(size / tan30_2), x = y * tan30;\n            context.moveTo(0, -y);\n            context.lineTo(x, 0);\n            context.lineTo(0, y);\n            context.lineTo(-x, 0);\n            context.closePath();\n        }\n    };\n    var ka = 0.89081309152928522810, kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10), kx = Math.sin(tau / 10) * kr, ky = -Math.cos(tau / 10) * kr;\n    var star = {\n        draw: function (context, size) {\n            var r = Math.sqrt(size * ka), x = kx * r, y = ky * r;\n            context.moveTo(0, -r);\n            context.lineTo(x, y);\n            for (var i = 1; i < 5; ++i) {\n                var a = tau * i / 5, c = Math.cos(a), s = Math.sin(a);\n                context.lineTo(s * r, -c * r);\n                context.lineTo(c * x - s * y, s * x + c * y);\n            }\n            context.closePath();\n        }\n    };\n    var square = {\n        draw: function (context, size) {\n            var w = Math.sqrt(size), x = -w / 2;\n            context.rect(x, x, w, w);\n        }\n    };\n    var sqrt3 = Math.sqrt(3);\n    var triangle = {\n        draw: function (context, size) {\n            var y = -Math.sqrt(size / (sqrt3 * 3));\n            context.moveTo(0, y * 2);\n            context.lineTo(-sqrt3 * y, -y);\n            context.lineTo(sqrt3 * y, -y);\n            context.closePath();\n        }\n    };\n    var c = -0.5, s = Math.sqrt(3) / 2, k = 1 / Math.sqrt(12), a = (k / 2 + 1) * 3;\n    var wye = {\n        draw: function (context, size) {\n            var r = Math.sqrt(size / a), x0 = r / 2, y0 = r * k, x1 = x0, y1 = r * k + r, x2 = -x1, y2 = y1;\n            context.moveTo(x0, y0);\n            context.lineTo(x1, y1);\n            context.lineTo(x2, y2);\n            context.lineTo(c * x0 - s * y0, s * x0 + c * y0);\n            context.lineTo(c * x1 - s * y1, s * x1 + c * y1);\n            context.lineTo(c * x2 - s * y2, s * x2 + c * y2);\n            context.lineTo(c * x0 + s * y0, c * y0 - s * x0);\n            context.lineTo(c * x1 + s * y1, c * y1 - s * x1);\n            context.lineTo(c * x2 + s * y2, c * y2 - s * x2);\n            context.closePath();\n        }\n    };\n    var symbols = [\n        circle,\n        cross,\n        diamond,\n        square,\n        star,\n        triangle,\n        wye\n    ];\n    function symbol() {\n        var type = constant(circle), size = constant(64), context = null;\n        function symbol() {\n            var buffer;\n            if (!context)\n                context = buffer = d3Path.path();\n            type.apply(this, arguments).draw(context, +size.apply(this, arguments));\n            if (buffer)\n                return context = null, buffer + \"\" || null;\n        }\n        symbol.type = function (_) {\n            return arguments.length ? (type = typeof _ === \"function\" ? _ : constant(_), symbol) : type;\n        };\n        symbol.size = function (_) {\n            return arguments.length ? (size = typeof _ === \"function\" ? _ : constant(+_), symbol) : size;\n        };\n        symbol.context = function (_) {\n            return arguments.length ? (context = _ == null ? null : _, symbol) : context;\n        };\n        return symbol;\n    }\n    function noop() { }\n    function point(that, x, y) {\n        that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x) / 6, (that._y0 + 4 * that._y1 + y) / 6);\n    }\n    function Basis(context) {\n        this._context = context;\n    }\n    Basis.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x0 = this._x1 =\n                this._y0 = this._y1 = NaN;\n            this._point = 0;\n        },\n        lineEnd: function () {\n            switch (this._point) {\n                case 3: point(this, this._x1, this._y1); // proceed\n                case 2:\n                    this._context.lineTo(this._x1, this._y1);\n                    break;\n            }\n            if (this._line || (this._line !== 0 && this._point === 1))\n                this._context.closePath();\n            this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);\n                    break;\n                case 1:\n                    this._point = 2;\n                    break;\n                case 2:\n                    this._point = 3;\n                    this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed\n                default:\n                    point(this, x, y);\n                    break;\n            }\n            this._x0 = this._x1, this._x1 = x;\n            this._y0 = this._y1, this._y1 = y;\n        }\n    };\n    function basis(context) {\n        return new Basis(context);\n    }\n    function BasisClosed(context) {\n        this._context = context;\n    }\n    BasisClosed.prototype = {\n        areaStart: noop,\n        areaEnd: noop,\n        lineStart: function () {\n            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =\n                this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;\n            this._point = 0;\n        },\n        lineEnd: function () {\n            switch (this._point) {\n                case 1: {\n                    this._context.moveTo(this._x2, this._y2);\n                    this._context.closePath();\n                    break;\n                }\n                case 2: {\n                    this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);\n                    this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);\n                    this._context.closePath();\n                    break;\n                }\n                case 3: {\n                    this.point(this._x2, this._y2);\n                    this.point(this._x3, this._y3);\n                    this.point(this._x4, this._y4);\n                    break;\n                }\n            }\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._x2 = x, this._y2 = y;\n                    break;\n                case 1:\n                    this._point = 2;\n                    this._x3 = x, this._y3 = y;\n                    break;\n                case 2:\n                    this._point = 3;\n                    this._x4 = x, this._y4 = y;\n                    this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6);\n                    break;\n                default:\n                    point(this, x, y);\n                    break;\n            }\n            this._x0 = this._x1, this._x1 = x;\n            this._y0 = this._y1, this._y1 = y;\n        }\n    };\n    function basisClosed(context) {\n        return new BasisClosed(context);\n    }\n    function BasisOpen(context) {\n        this._context = context;\n    }\n    BasisOpen.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x0 = this._x1 =\n                this._y0 = this._y1 = NaN;\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._line || (this._line !== 0 && this._point === 3))\n                this._context.closePath();\n            this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    break;\n                case 1:\n                    this._point = 2;\n                    break;\n                case 2:\n                    this._point = 3;\n                    var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6;\n                    this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);\n                    break;\n                case 3: this._point = 4; // proceed\n                default:\n                    point(this, x, y);\n                    break;\n            }\n            this._x0 = this._x1, this._x1 = x;\n            this._y0 = this._y1, this._y1 = y;\n        }\n    };\n    function basisOpen(context) {\n        return new BasisOpen(context);\n    }\n    function Bundle(context, beta) {\n        this._basis = new Basis(context);\n        this._beta = beta;\n    }\n    Bundle.prototype = {\n        lineStart: function () {\n            this._x = [];\n            this._y = [];\n            this._basis.lineStart();\n        },\n        lineEnd: function () {\n            var x = this._x, y = this._y, j = x.length - 1;\n            if (j > 0) {\n                var x0 = x[0], y0 = y[0], dx = x[j] - x0, dy = y[j] - y0, i = -1, t;\n                while (++i <= j) {\n                    t = i / j;\n                    this._basis.point(this._beta * x[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y[i] + (1 - this._beta) * (y0 + t * dy));\n                }\n            }\n            this._x = this._y = null;\n            this._basis.lineEnd();\n        },\n        point: function (x, y) {\n            this._x.push(+x);\n            this._y.push(+y);\n        }\n    };\n    var bundle = (function custom(beta) {\n        function bundle(context) {\n            return beta === 1 ? new Basis(context) : new Bundle(context, beta);\n        }\n        bundle.beta = function (beta) {\n            return custom(+beta);\n        };\n        return bundle;\n    })(0.85);\n    function point$1(that, x, y) {\n        that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2);\n    }\n    function Cardinal(context, tension) {\n        this._context = context;\n        this._k = (1 - tension) / 6;\n    }\n    Cardinal.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x0 = this._x1 = this._x2 =\n                this._y0 = this._y1 = this._y2 = NaN;\n            this._point = 0;\n        },\n        lineEnd: function () {\n            switch (this._point) {\n                case 2:\n                    this._context.lineTo(this._x2, this._y2);\n                    break;\n                case 3:\n                    point$1(this, this._x1, this._y1);\n                    break;\n            }\n            if (this._line || (this._line !== 0 && this._point === 1))\n                this._context.closePath();\n            this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);\n                    break;\n                case 1:\n                    this._point = 2;\n                    this._x1 = x, this._y1 = y;\n                    break;\n                case 2: this._point = 3; // proceed\n                default:\n                    point$1(this, x, y);\n                    break;\n            }\n            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n        }\n    };\n    var cardinal = (function custom(tension) {\n        function cardinal(context) {\n            return new Cardinal(context, tension);\n        }\n        cardinal.tension = function (tension) {\n            return custom(+tension);\n        };\n        return cardinal;\n    })(0);\n    function CardinalClosed(context, tension) {\n        this._context = context;\n        this._k = (1 - tension) / 6;\n    }\n    CardinalClosed.prototype = {\n        areaStart: noop,\n        areaEnd: noop,\n        lineStart: function () {\n            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n                this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n            this._point = 0;\n        },\n        lineEnd: function () {\n            switch (this._point) {\n                case 1: {\n                    this._context.moveTo(this._x3, this._y3);\n                    this._context.closePath();\n                    break;\n                }\n                case 2: {\n                    this._context.lineTo(this._x3, this._y3);\n                    this._context.closePath();\n                    break;\n                }\n                case 3: {\n                    this.point(this._x3, this._y3);\n                    this.point(this._x4, this._y4);\n                    this.point(this._x5, this._y5);\n                    break;\n                }\n            }\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._x3 = x, this._y3 = y;\n                    break;\n                case 1:\n                    this._point = 2;\n                    this._context.moveTo(this._x4 = x, this._y4 = y);\n                    break;\n                case 2:\n                    this._point = 3;\n                    this._x5 = x, this._y5 = y;\n                    break;\n                default:\n                    point$1(this, x, y);\n                    break;\n            }\n            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n        }\n    };\n    var cardinalClosed = (function custom(tension) {\n        function cardinal(context) {\n            return new CardinalClosed(context, tension);\n        }\n        cardinal.tension = function (tension) {\n            return custom(+tension);\n        };\n        return cardinal;\n    })(0);\n    function CardinalOpen(context, tension) {\n        this._context = context;\n        this._k = (1 - tension) / 6;\n    }\n    CardinalOpen.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x0 = this._x1 = this._x2 =\n                this._y0 = this._y1 = this._y2 = NaN;\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._line || (this._line !== 0 && this._point === 3))\n                this._context.closePath();\n            this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    break;\n                case 1:\n                    this._point = 2;\n                    break;\n                case 2:\n                    this._point = 3;\n                    this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);\n                    break;\n                case 3: this._point = 4; // proceed\n                default:\n                    point$1(this, x, y);\n                    break;\n            }\n            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n        }\n    };\n    var cardinalOpen = (function custom(tension) {\n        function cardinal(context) {\n            return new CardinalOpen(context, tension);\n        }\n        cardinal.tension = function (tension) {\n            return custom(+tension);\n        };\n        return cardinal;\n    })(0);\n    function point$2(that, x, y) {\n        var x1 = that._x1, y1 = that._y1, x2 = that._x2, y2 = that._y2;\n        if (that._l01_a > epsilon) {\n            var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);\n            x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;\n            y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;\n        }\n        if (that._l23_a > epsilon) {\n            var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);\n            x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;\n            y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;\n        }\n        that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);\n    }\n    function CatmullRom(context, alpha) {\n        this._context = context;\n        this._alpha = alpha;\n    }\n    CatmullRom.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x0 = this._x1 = this._x2 =\n                this._y0 = this._y1 = this._y2 = NaN;\n            this._l01_a = this._l12_a = this._l23_a =\n                this._l01_2a = this._l12_2a = this._l23_2a =\n                    this._point = 0;\n        },\n        lineEnd: function () {\n            switch (this._point) {\n                case 2:\n                    this._context.lineTo(this._x2, this._y2);\n                    break;\n                case 3:\n                    this.point(this._x2, this._y2);\n                    break;\n            }\n            if (this._line || (this._line !== 0 && this._point === 1))\n                this._context.closePath();\n            this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            if (this._point) {\n                var x23 = this._x2 - x, y23 = this._y2 - y;\n                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n            }\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);\n                    break;\n                case 1:\n                    this._point = 2;\n                    break;\n                case 2: this._point = 3; // proceed\n                default:\n                    point$2(this, x, y);\n                    break;\n            }\n            this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n            this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n        }\n    };\n    var catmullRom = (function custom(alpha) {\n        function catmullRom(context) {\n            return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);\n        }\n        catmullRom.alpha = function (alpha) {\n            return custom(+alpha);\n        };\n        return catmullRom;\n    })(0.5);\n    function CatmullRomClosed(context, alpha) {\n        this._context = context;\n        this._alpha = alpha;\n    }\n    CatmullRomClosed.prototype = {\n        areaStart: noop,\n        areaEnd: noop,\n        lineStart: function () {\n            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n                this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n            this._l01_a = this._l12_a = this._l23_a =\n                this._l01_2a = this._l12_2a = this._l23_2a =\n                    this._point = 0;\n        },\n        lineEnd: function () {\n            switch (this._point) {\n                case 1: {\n                    this._context.moveTo(this._x3, this._y3);\n                    this._context.closePath();\n                    break;\n                }\n                case 2: {\n                    this._context.lineTo(this._x3, this._y3);\n                    this._context.closePath();\n                    break;\n                }\n                case 3: {\n                    this.point(this._x3, this._y3);\n                    this.point(this._x4, this._y4);\n                    this.point(this._x5, this._y5);\n                    break;\n                }\n            }\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            if (this._point) {\n                var x23 = this._x2 - x, y23 = this._y2 - y;\n                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n            }\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._x3 = x, this._y3 = y;\n                    break;\n                case 1:\n                    this._point = 2;\n                    this._context.moveTo(this._x4 = x, this._y4 = y);\n                    break;\n                case 2:\n                    this._point = 3;\n                    this._x5 = x, this._y5 = y;\n                    break;\n                default:\n                    point$2(this, x, y);\n                    break;\n            }\n            this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n            this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n        }\n    };\n    var catmullRomClosed = (function custom(alpha) {\n        function catmullRom(context) {\n            return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);\n        }\n        catmullRom.alpha = function (alpha) {\n            return custom(+alpha);\n        };\n        return catmullRom;\n    })(0.5);\n    function CatmullRomOpen(context, alpha) {\n        this._context = context;\n        this._alpha = alpha;\n    }\n    CatmullRomOpen.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x0 = this._x1 = this._x2 =\n                this._y0 = this._y1 = this._y2 = NaN;\n            this._l01_a = this._l12_a = this._l23_a =\n                this._l01_2a = this._l12_2a = this._l23_2a =\n                    this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._line || (this._line !== 0 && this._point === 3))\n                this._context.closePath();\n            this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            if (this._point) {\n                var x23 = this._x2 - x, y23 = this._y2 - y;\n                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n            }\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    break;\n                case 1:\n                    this._point = 2;\n                    break;\n                case 2:\n                    this._point = 3;\n                    this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);\n                    break;\n                case 3: this._point = 4; // proceed\n                default:\n                    point$2(this, x, y);\n                    break;\n            }\n            this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n            this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n        }\n    };\n    var catmullRomOpen = (function custom(alpha) {\n        function catmullRom(context) {\n            return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);\n        }\n        catmullRom.alpha = function (alpha) {\n            return custom(+alpha);\n        };\n        return catmullRom;\n    })(0.5);\n    function LinearClosed(context) {\n        this._context = context;\n    }\n    LinearClosed.prototype = {\n        areaStart: noop,\n        areaEnd: noop,\n        lineStart: function () {\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._point)\n                this._context.closePath();\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            if (this._point)\n                this._context.lineTo(x, y);\n            else\n                this._point = 1, this._context.moveTo(x, y);\n        }\n    };\n    function linearClosed(context) {\n        return new LinearClosed(context);\n    }\n    function sign(x) {\n        return x < 0 ? -1 : 1;\n    }\n    // Calculate the slopes of the tangents (Hermite-type interpolation) based on\n    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic\n    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.\n    // NOV(II), P. 443, 1990.\n    function slope3(that, x2, y2) {\n        var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);\n        return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n    }\n    // Calculate a one-sided slope.\n    function slope2(that, t) {\n        var h = that._x1 - that._x0;\n        return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;\n    }\n    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n    // \"you can express cubic Hermite interpolation in terms of cubic Bézier curves\n    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1\".\n    function point$3(that, t0, t1) {\n        var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;\n        that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);\n    }\n    function MonotoneX(context) {\n        this._context = context;\n    }\n    MonotoneX.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x0 = this._x1 =\n                this._y0 = this._y1 =\n                    this._t0 = NaN;\n            this._point = 0;\n        },\n        lineEnd: function () {\n            switch (this._point) {\n                case 2:\n                    this._context.lineTo(this._x1, this._y1);\n                    break;\n                case 3:\n                    point$3(this, this._t0, slope2(this, this._t0));\n                    break;\n            }\n            if (this._line || (this._line !== 0 && this._point === 1))\n                this._context.closePath();\n            this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            var t1 = NaN;\n            x = +x, y = +y;\n            if (x === this._x1 && y === this._y1)\n                return; // Ignore coincident points.\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);\n                    break;\n                case 1:\n                    this._point = 2;\n                    break;\n                case 2:\n                    this._point = 3;\n                    point$3(this, slope2(this, t1 = slope3(this, x, y)), t1);\n                    break;\n                default:\n                    point$3(this, this._t0, t1 = slope3(this, x, y));\n                    break;\n            }\n            this._x0 = this._x1, this._x1 = x;\n            this._y0 = this._y1, this._y1 = y;\n            this._t0 = t1;\n        }\n    };\n    function MonotoneY(context) {\n        this._context = new ReflectContext(context);\n    }\n    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function (x, y) {\n        MonotoneX.prototype.point.call(this, y, x);\n    };\n    function ReflectContext(context) {\n        this._context = context;\n    }\n    ReflectContext.prototype = {\n        moveTo: function (x, y) { this._context.moveTo(y, x); },\n        closePath: function () { this._context.closePath(); },\n        lineTo: function (x, y) { this._context.lineTo(y, x); },\n        bezierCurveTo: function (x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }\n    };\n    function monotoneX(context) {\n        return new MonotoneX(context);\n    }\n    function monotoneY(context) {\n        return new MonotoneY(context);\n    }\n    function Natural(context) {\n        this._context = context;\n    }\n    Natural.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x = [];\n            this._y = [];\n        },\n        lineEnd: function () {\n            var x = this._x, y = this._y, n = x.length;\n            if (n) {\n                this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);\n                if (n === 2) {\n                    this._context.lineTo(x[1], y[1]);\n                }\n                else {\n                    var px = controlPoints(x), py = controlPoints(y);\n                    for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {\n                        this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);\n                    }\n                }\n            }\n            if (this._line || (this._line !== 0 && n === 1))\n                this._context.closePath();\n            this._line = 1 - this._line;\n            this._x = this._y = null;\n        },\n        point: function (x, y) {\n            this._x.push(+x);\n            this._y.push(+y);\n        }\n    };\n    // See https://www.particleincell.com/2012/bezier-splines/ for derivation.\n    function controlPoints(x) {\n        var i, n = x.length - 1, m, a = new Array(n), b = new Array(n), r = new Array(n);\n        a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];\n        for (i = 1; i < n - 1; ++i)\n            a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];\n        a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];\n        for (i = 1; i < n; ++i)\n            m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];\n        a[n - 1] = r[n - 1] / b[n - 1];\n        for (i = n - 2; i >= 0; --i)\n            a[i] = (r[i] - a[i + 1]) / b[i];\n        b[n - 1] = (x[n] + a[n - 1]) / 2;\n        for (i = 0; i < n - 1; ++i)\n            b[i] = 2 * x[i + 1] - a[i + 1];\n        return [a, b];\n    }\n    function natural(context) {\n        return new Natural(context);\n    }\n    function Step(context, t) {\n        this._context = context;\n        this._t = t;\n    }\n    Step.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x = this._y = NaN;\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (0 < this._t && this._t < 1 && this._point === 2)\n                this._context.lineTo(this._x, this._y);\n            if (this._line || (this._line !== 0 && this._point === 1))\n                this._context.closePath();\n            if (this._line >= 0)\n                this._t = 1 - this._t, this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);\n                    break;\n                case 1: this._point = 2; // proceed\n                default: {\n                    if (this._t <= 0) {\n                        this._context.lineTo(this._x, y);\n                        this._context.lineTo(x, y);\n                    }\n                    else {\n                        var x1 = this._x * (1 - this._t) + x * this._t;\n                        this._context.lineTo(x1, this._y);\n                        this._context.lineTo(x1, y);\n                    }\n                    break;\n                }\n            }\n            this._x = x, this._y = y;\n        }\n    };\n    function step(context) {\n        return new Step(context, 0.5);\n    }\n    function stepBefore(context) {\n        return new Step(context, 0);\n    }\n    function stepAfter(context) {\n        return new Step(context, 1);\n    }\n    function none(series, order) {\n        if (!((n = series.length) > 1))\n            return;\n        for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {\n            s0 = s1, s1 = series[order[i]];\n            for (j = 0; j < m; ++j) {\n                s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];\n            }\n        }\n    }\n    function none$1(series) {\n        var n = series.length, o = new Array(n);\n        while (--n >= 0)\n            o[n] = n;\n        return o;\n    }\n    function stackValue(d, key) {\n        return d[key];\n    }\n    function stack() {\n        var keys = constant([]), order = none$1, offset = none, value = stackValue;\n        function stack(data) {\n            var kz = keys.apply(this, arguments), i, m = data.length, n = kz.length, sz = new Array(n), oz;\n            for (i = 0; i < n; ++i) {\n                for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {\n                    si[j] = sij = [0, +value(data[j], ki, j, data)];\n                    sij.data = data[j];\n                }\n                si.key = ki;\n            }\n            for (i = 0, oz = order(sz); i < n; ++i) {\n                sz[oz[i]].index = i;\n            }\n            offset(sz, oz);\n            return sz;\n        }\n        stack.keys = function (_) {\n            return arguments.length ? (keys = typeof _ === \"function\" ? _ : constant(slice.call(_)), stack) : keys;\n        };\n        stack.value = function (_) {\n            return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(+_), stack) : value;\n        };\n        stack.order = function (_) {\n            return arguments.length ? (order = _ == null ? none$1 : typeof _ === \"function\" ? _ : constant(slice.call(_)), stack) : order;\n        };\n        stack.offset = function (_) {\n            return arguments.length ? (offset = _ == null ? none : _, stack) : offset;\n        };\n        return stack;\n    }\n    function expand(series, order) {\n        if (!((n = series.length) > 0))\n            return;\n        for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {\n            for (y = i = 0; i < n; ++i)\n                y += series[i][j][1] || 0;\n            if (y)\n                for (i = 0; i < n; ++i)\n                    series[i][j][1] /= y;\n        }\n        none(series, order);\n    }\n    function diverging(series, order) {\n        if (!((n = series.length) > 0))\n            return;\n        for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {\n            for (yp = yn = 0, i = 0; i < n; ++i) {\n                if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {\n                    d[0] = yp, d[1] = yp += dy;\n                }\n                else if (dy < 0) {\n                    d[1] = yn, d[0] = yn += dy;\n                }\n                else {\n                    d[0] = 0, d[1] = dy;\n                }\n            }\n        }\n    }\n    function silhouette(series, order) {\n        if (!((n = series.length) > 0))\n            return;\n        for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {\n            for (var i = 0, y = 0; i < n; ++i)\n                y += series[i][j][1] || 0;\n            s0[j][1] += s0[j][0] = -y / 2;\n        }\n        none(series, order);\n    }\n    function wiggle(series, order) {\n        if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0))\n            return;\n        for (var y = 0, j = 1, s0, m, n; j < m; ++j) {\n            for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {\n                var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;\n                for (var k = 0; k < i; ++k) {\n                    var sk = series[order[k]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;\n                    s3 += skj0 - skj1;\n                }\n                s1 += sij0, s2 += s3 * sij0;\n            }\n            s0[j - 1][1] += s0[j - 1][0] = y;\n            if (s1)\n                y -= s2 / s1;\n        }\n        s0[j - 1][1] += s0[j - 1][0] = y;\n        none(series, order);\n    }\n    function appearance(series) {\n        var peaks = series.map(peak);\n        return none$1(series).sort(function (a, b) { return peaks[a] - peaks[b]; });\n    }\n    function peak(series) {\n        var i = -1, j = 0, n = series.length, vi, vj = -Infinity;\n        while (++i < n)\n            if ((vi = +series[i][1]) > vj)\n                vj = vi, j = i;\n        return j;\n    }\n    function ascending(series) {\n        var sums = series.map(sum);\n        return none$1(series).sort(function (a, b) { return sums[a] - sums[b]; });\n    }\n    function sum(series) {\n        var s = 0, i = -1, n = series.length, v;\n        while (++i < n)\n            if (v = +series[i][1])\n                s += v;\n        return s;\n    }\n    function descending$1(series) {\n        return ascending(series).reverse();\n    }\n    function insideOut(series) {\n        var n = series.length, i, j, sums = series.map(sum), order = appearance(series), top = 0, bottom = 0, tops = [], bottoms = [];\n        for (i = 0; i < n; ++i) {\n            j = order[i];\n            if (top < bottom) {\n                top += sums[j];\n                tops.push(j);\n            }\n            else {\n                bottom += sums[j];\n                bottoms.push(j);\n            }\n        }\n        return bottoms.reverse().concat(tops);\n    }\n    function reverse(series) {\n        return none$1(series).reverse();\n    }\n    exports.arc = arc;\n    exports.area = area;\n    exports.areaRadial = areaRadial;\n    exports.curveBasis = basis;\n    exports.curveBasisClosed = basisClosed;\n    exports.curveBasisOpen = basisOpen;\n    exports.curveBundle = bundle;\n    exports.curveCardinal = cardinal;\n    exports.curveCardinalClosed = cardinalClosed;\n    exports.curveCardinalOpen = cardinalOpen;\n    exports.curveCatmullRom = catmullRom;\n    exports.curveCatmullRomClosed = catmullRomClosed;\n    exports.curveCatmullRomOpen = catmullRomOpen;\n    exports.curveLinear = curveLinear;\n    exports.curveLinearClosed = linearClosed;\n    exports.curveMonotoneX = monotoneX;\n    exports.curveMonotoneY = monotoneY;\n    exports.curveNatural = natural;\n    exports.curveStep = step;\n    exports.curveStepAfter = stepAfter;\n    exports.curveStepBefore = stepBefore;\n    exports.line = line;\n    exports.lineRadial = lineRadial$1;\n    exports.linkHorizontal = linkHorizontal;\n    exports.linkRadial = linkRadial;\n    exports.linkVertical = linkVertical;\n    exports.pie = pie;\n    exports.pointRadial = pointRadial;\n    exports.radialArea = areaRadial;\n    exports.radialLine = lineRadial$1;\n    exports.stack = stack;\n    exports.stackOffsetDiverging = diverging;\n    exports.stackOffsetExpand = expand;\n    exports.stackOffsetNone = none;\n    exports.stackOffsetSilhouette = silhouette;\n    exports.stackOffsetWiggle = wiggle;\n    exports.stackOrderAppearance = appearance;\n    exports.stackOrderAscending = ascending;\n    exports.stackOrderDescending = descending$1;\n    exports.stackOrderInsideOut = insideOut;\n    exports.stackOrderNone = none$1;\n    exports.stackOrderReverse = reverse;\n    exports.symbol = symbol;\n    exports.symbolCircle = circle;\n    exports.symbolCross = cross;\n    exports.symbolDiamond = diamond;\n    exports.symbolSquare = square;\n    exports.symbolStar = star;\n    exports.symbolTriangle = triangle;\n    exports.symbolWye = wye;\n    exports.symbols = symbols;\n    Object.defineProperty(exports, '__esModule', { value: true });\n}));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-voronoi@1.1.4@d3-voronoi/dist/d3-voronoi.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_d3-voronoi@1.1.4@d3-voronoi/dist/d3-voronoi.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-voronoi/ v1.1.4 Copyright 2018 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports) :\n        undefined;\n}(this, (function (exports) {\n    'use strict';\n    function constant(x) {\n        return function () {\n            return x;\n        };\n    }\n    function x(d) {\n        return d[0];\n    }\n    function y(d) {\n        return d[1];\n    }\n    function RedBlackTree() {\n        this._ = null; // root node\n    }\n    function RedBlackNode(node) {\n        node.U = // parent node\n            node.C = // color - true for red, false for black\n                node.L = // left node\n                    node.R = // right node\n                        node.P = // previous node\n                            node.N = null; // next node\n    }\n    RedBlackTree.prototype = {\n        constructor: RedBlackTree,\n        insert: function (after, node) {\n            var parent, grandpa, uncle;\n            if (after) {\n                node.P = after;\n                node.N = after.N;\n                if (after.N)\n                    after.N.P = node;\n                after.N = node;\n                if (after.R) {\n                    after = after.R;\n                    while (after.L)\n                        after = after.L;\n                    after.L = node;\n                }\n                else {\n                    after.R = node;\n                }\n                parent = after;\n            }\n            else if (this._) {\n                after = RedBlackFirst(this._);\n                node.P = null;\n                node.N = after;\n                after.P = after.L = node;\n                parent = after;\n            }\n            else {\n                node.P = node.N = null;\n                this._ = node;\n                parent = null;\n            }\n            node.L = node.R = null;\n            node.U = parent;\n            node.C = true;\n            after = node;\n            while (parent && parent.C) {\n                grandpa = parent.U;\n                if (parent === grandpa.L) {\n                    uncle = grandpa.R;\n                    if (uncle && uncle.C) {\n                        parent.C = uncle.C = false;\n                        grandpa.C = true;\n                        after = grandpa;\n                    }\n                    else {\n                        if (after === parent.R) {\n                            RedBlackRotateLeft(this, parent);\n                            after = parent;\n                            parent = after.U;\n                        }\n                        parent.C = false;\n                        grandpa.C = true;\n                        RedBlackRotateRight(this, grandpa);\n                    }\n                }\n                else {\n                    uncle = grandpa.L;\n                    if (uncle && uncle.C) {\n                        parent.C = uncle.C = false;\n                        grandpa.C = true;\n                        after = grandpa;\n                    }\n                    else {\n                        if (after === parent.L) {\n                            RedBlackRotateRight(this, parent);\n                            after = parent;\n                            parent = after.U;\n                        }\n                        parent.C = false;\n                        grandpa.C = true;\n                        RedBlackRotateLeft(this, grandpa);\n                    }\n                }\n                parent = after.U;\n            }\n            this._.C = false;\n        },\n        remove: function (node) {\n            if (node.N)\n                node.N.P = node.P;\n            if (node.P)\n                node.P.N = node.N;\n            node.N = node.P = null;\n            var parent = node.U, sibling, left = node.L, right = node.R, next, red;\n            if (!left)\n                next = right;\n            else if (!right)\n                next = left;\n            else\n                next = RedBlackFirst(right);\n            if (parent) {\n                if (parent.L === node)\n                    parent.L = next;\n                else\n                    parent.R = next;\n            }\n            else {\n                this._ = next;\n            }\n            if (left && right) {\n                red = next.C;\n                next.C = node.C;\n                next.L = left;\n                left.U = next;\n                if (next !== right) {\n                    parent = next.U;\n                    next.U = node.U;\n                    node = next.R;\n                    parent.L = node;\n                    next.R = right;\n                    right.U = next;\n                }\n                else {\n                    next.U = parent;\n                    parent = next;\n                    node = next.R;\n                }\n            }\n            else {\n                red = node.C;\n                node = next;\n            }\n            if (node)\n                node.U = parent;\n            if (red)\n                return;\n            if (node && node.C) {\n                node.C = false;\n                return;\n            }\n            do {\n                if (node === this._)\n                    break;\n                if (node === parent.L) {\n                    sibling = parent.R;\n                    if (sibling.C) {\n                        sibling.C = false;\n                        parent.C = true;\n                        RedBlackRotateLeft(this, parent);\n                        sibling = parent.R;\n                    }\n                    if ((sibling.L && sibling.L.C)\n                        || (sibling.R && sibling.R.C)) {\n                        if (!sibling.R || !sibling.R.C) {\n                            sibling.L.C = false;\n                            sibling.C = true;\n                            RedBlackRotateRight(this, sibling);\n                            sibling = parent.R;\n                        }\n                        sibling.C = parent.C;\n                        parent.C = sibling.R.C = false;\n                        RedBlackRotateLeft(this, parent);\n                        node = this._;\n                        break;\n                    }\n                }\n                else {\n                    sibling = parent.L;\n                    if (sibling.C) {\n                        sibling.C = false;\n                        parent.C = true;\n                        RedBlackRotateRight(this, parent);\n                        sibling = parent.L;\n                    }\n                    if ((sibling.L && sibling.L.C)\n                        || (sibling.R && sibling.R.C)) {\n                        if (!sibling.L || !sibling.L.C) {\n                            sibling.R.C = false;\n                            sibling.C = true;\n                            RedBlackRotateLeft(this, sibling);\n                            sibling = parent.L;\n                        }\n                        sibling.C = parent.C;\n                        parent.C = sibling.L.C = false;\n                        RedBlackRotateRight(this, parent);\n                        node = this._;\n                        break;\n                    }\n                }\n                sibling.C = true;\n                node = parent;\n                parent = parent.U;\n            } while (!node.C);\n            if (node)\n                node.C = false;\n        }\n    };\n    function RedBlackRotateLeft(tree, node) {\n        var p = node, q = node.R, parent = p.U;\n        if (parent) {\n            if (parent.L === p)\n                parent.L = q;\n            else\n                parent.R = q;\n        }\n        else {\n            tree._ = q;\n        }\n        q.U = parent;\n        p.U = q;\n        p.R = q.L;\n        if (p.R)\n            p.R.U = p;\n        q.L = p;\n    }\n    function RedBlackRotateRight(tree, node) {\n        var p = node, q = node.L, parent = p.U;\n        if (parent) {\n            if (parent.L === p)\n                parent.L = q;\n            else\n                parent.R = q;\n        }\n        else {\n            tree._ = q;\n        }\n        q.U = parent;\n        p.U = q;\n        p.L = q.R;\n        if (p.L)\n            p.L.U = p;\n        q.R = p;\n    }\n    function RedBlackFirst(node) {\n        while (node.L)\n            node = node.L;\n        return node;\n    }\n    function createEdge(left, right, v0, v1) {\n        var edge = [null, null], index = edges.push(edge) - 1;\n        edge.left = left;\n        edge.right = right;\n        if (v0)\n            setEdgeEnd(edge, left, right, v0);\n        if (v1)\n            setEdgeEnd(edge, right, left, v1);\n        cells[left.index].halfedges.push(index);\n        cells[right.index].halfedges.push(index);\n        return edge;\n    }\n    function createBorderEdge(left, v0, v1) {\n        var edge = [v0, v1];\n        edge.left = left;\n        return edge;\n    }\n    function setEdgeEnd(edge, left, right, vertex) {\n        if (!edge[0] && !edge[1]) {\n            edge[0] = vertex;\n            edge.left = left;\n            edge.right = right;\n        }\n        else if (edge.left === right) {\n            edge[1] = vertex;\n        }\n        else {\n            edge[0] = vertex;\n        }\n    }\n    // Liang–Barsky line clipping.\n    function clipEdge(edge, x0, y0, x1, y1) {\n        var a = edge[0], b = edge[1], ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;\n        r = x0 - ax;\n        if (!dx && r > 0)\n            return;\n        r /= dx;\n        if (dx < 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        else if (dx > 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        r = x1 - ax;\n        if (!dx && r < 0)\n            return;\n        r /= dx;\n        if (dx < 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        else if (dx > 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        r = y0 - ay;\n        if (!dy && r > 0)\n            return;\n        r /= dy;\n        if (dy < 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        else if (dy > 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        r = y1 - ay;\n        if (!dy && r < 0)\n            return;\n        r /= dy;\n        if (dy < 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        else if (dy > 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        if (!(t0 > 0) && !(t1 < 1))\n            return true; // TODO Better check?\n        if (t0 > 0)\n            edge[0] = [ax + t0 * dx, ay + t0 * dy];\n        if (t1 < 1)\n            edge[1] = [ax + t1 * dx, ay + t1 * dy];\n        return true;\n    }\n    function connectEdge(edge, x0, y0, x1, y1) {\n        var v1 = edge[1];\n        if (v1)\n            return true;\n        var v0 = edge[0], left = edge.left, right = edge.right, lx = left[0], ly = left[1], rx = right[0], ry = right[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;\n        if (ry === ly) {\n            if (fx < x0 || fx >= x1)\n                return;\n            if (lx > rx) {\n                if (!v0)\n                    v0 = [fx, y0];\n                else if (v0[1] >= y1)\n                    return;\n                v1 = [fx, y1];\n            }\n            else {\n                if (!v0)\n                    v0 = [fx, y1];\n                else if (v0[1] < y0)\n                    return;\n                v1 = [fx, y0];\n            }\n        }\n        else {\n            fm = (lx - rx) / (ry - ly);\n            fb = fy - fm * fx;\n            if (fm < -1 || fm > 1) {\n                if (lx > rx) {\n                    if (!v0)\n                        v0 = [(y0 - fb) / fm, y0];\n                    else if (v0[1] >= y1)\n                        return;\n                    v1 = [(y1 - fb) / fm, y1];\n                }\n                else {\n                    if (!v0)\n                        v0 = [(y1 - fb) / fm, y1];\n                    else if (v0[1] < y0)\n                        return;\n                    v1 = [(y0 - fb) / fm, y0];\n                }\n            }\n            else {\n                if (ly < ry) {\n                    if (!v0)\n                        v0 = [x0, fm * x0 + fb];\n                    else if (v0[0] >= x1)\n                        return;\n                    v1 = [x1, fm * x1 + fb];\n                }\n                else {\n                    if (!v0)\n                        v0 = [x1, fm * x1 + fb];\n                    else if (v0[0] < x0)\n                        return;\n                    v1 = [x0, fm * x0 + fb];\n                }\n            }\n        }\n        edge[0] = v0;\n        edge[1] = v1;\n        return true;\n    }\n    function clipEdges(x0, y0, x1, y1) {\n        var i = edges.length, edge;\n        while (i--) {\n            if (!connectEdge(edge = edges[i], x0, y0, x1, y1)\n                || !clipEdge(edge, x0, y0, x1, y1)\n                || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon\n                    || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {\n                delete edges[i];\n            }\n        }\n    }\n    function createCell(site) {\n        return cells[site.index] = {\n            site: site,\n            halfedges: []\n        };\n    }\n    function cellHalfedgeAngle(cell, edge) {\n        var site = cell.site, va = edge.left, vb = edge.right;\n        if (site === vb)\n            vb = va, va = site;\n        if (vb)\n            return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\n        if (site === va)\n            va = edge[1], vb = edge[0];\n        else\n            va = edge[0], vb = edge[1];\n        return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\n    }\n    function cellHalfedgeStart(cell, edge) {\n        return edge[+(edge.left !== cell.site)];\n    }\n    function cellHalfedgeEnd(cell, edge) {\n        return edge[+(edge.left === cell.site)];\n    }\n    function sortCellHalfedges() {\n        for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\n            if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\n                var index = new Array(m), array = new Array(m);\n                for (j = 0; j < m; ++j)\n                    index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);\n                index.sort(function (i, j) { return array[j] - array[i]; });\n                for (j = 0; j < m; ++j)\n                    array[j] = halfedges[index[j]];\n                for (j = 0; j < m; ++j)\n                    halfedges[j] = array[j];\n            }\n        }\n    }\n    function clipCells(x0, y0, x1, y1) {\n        var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;\n        for (iCell = 0; iCell < nCells; ++iCell) {\n            if (cell = cells[iCell]) {\n                site = cell.site;\n                halfedges = cell.halfedges;\n                iHalfedge = halfedges.length;\n                // Remove any dangling clipped edges.\n                while (iHalfedge--) {\n                    if (!edges[halfedges[iHalfedge]]) {\n                        halfedges.splice(iHalfedge, 1);\n                    }\n                }\n                // Insert any border edges as necessary.\n                iHalfedge = 0, nHalfedges = halfedges.length;\n                while (iHalfedge < nHalfedges) {\n                    end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\n                    start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\n                    if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {\n                        halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end, Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]\n                            : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]\n                                : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]\n                                    : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]\n                                        : null)) - 1);\n                        ++nHalfedges;\n                    }\n                }\n                if (nHalfedges)\n                    cover = false;\n            }\n        }\n        // If there weren’t any edges, have the closest site cover the extent.\n        // It doesn’t matter which corner of the extent we measure!\n        if (cover) {\n            var dx, dy, d2, dc = Infinity;\n            for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\n                if (cell = cells[iCell]) {\n                    site = cell.site;\n                    dx = site[0] - x0;\n                    dy = site[1] - y0;\n                    d2 = dx * dx + dy * dy;\n                    if (d2 < dc)\n                        dc = d2, cover = cell;\n                }\n            }\n            if (cover) {\n                var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];\n                cover.halfedges.push(edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1, edges.push(createBorderEdge(site, v01, v11)) - 1, edges.push(createBorderEdge(site, v11, v10)) - 1, edges.push(createBorderEdge(site, v10, v00)) - 1);\n            }\n        }\n        // Lastly delete any cells with no edges; these were entirely clipped.\n        for (iCell = 0; iCell < nCells; ++iCell) {\n            if (cell = cells[iCell]) {\n                if (!cell.halfedges.length) {\n                    delete cells[iCell];\n                }\n            }\n        }\n    }\n    var circlePool = [];\n    var firstCircle;\n    function Circle() {\n        RedBlackNode(this);\n        this.x =\n            this.y =\n                this.arc =\n                    this.site =\n                        this.cy = null;\n    }\n    function attachCircle(arc) {\n        var lArc = arc.P, rArc = arc.N;\n        if (!lArc || !rArc)\n            return;\n        var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;\n        if (lSite === rSite)\n            return;\n        var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;\n        var d = 2 * (ax * cy - ay * cx);\n        if (d >= -epsilon2)\n            return;\n        var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d;\n        var circle = circlePool.pop() || new Circle;\n        circle.arc = arc;\n        circle.site = cSite;\n        circle.x = x + bx;\n        circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom\n        arc.circle = circle;\n        var before = null, node = circles._;\n        while (node) {\n            if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {\n                if (node.L)\n                    node = node.L;\n                else {\n                    before = node.P;\n                    break;\n                }\n            }\n            else {\n                if (node.R)\n                    node = node.R;\n                else {\n                    before = node;\n                    break;\n                }\n            }\n        }\n        circles.insert(before, circle);\n        if (!before)\n            firstCircle = circle;\n    }\n    function detachCircle(arc) {\n        var circle = arc.circle;\n        if (circle) {\n            if (!circle.P)\n                firstCircle = circle.N;\n            circles.remove(circle);\n            circlePool.push(circle);\n            RedBlackNode(circle);\n            arc.circle = null;\n        }\n    }\n    var beachPool = [];\n    function Beach() {\n        RedBlackNode(this);\n        this.edge =\n            this.site =\n                this.circle = null;\n    }\n    function createBeach(site) {\n        var beach = beachPool.pop() || new Beach;\n        beach.site = site;\n        return beach;\n    }\n    function detachBeach(beach) {\n        detachCircle(beach);\n        beaches.remove(beach);\n        beachPool.push(beach);\n        RedBlackNode(beach);\n    }\n    function removeBeach(beach) {\n        var circle = beach.circle, x = circle.x, y = circle.cy, vertex = [x, y], previous = beach.P, next = beach.N, disappearing = [beach];\n        detachBeach(beach);\n        var lArc = previous;\n        while (lArc.circle\n            && Math.abs(x - lArc.circle.x) < epsilon\n            && Math.abs(y - lArc.circle.cy) < epsilon) {\n            previous = lArc.P;\n            disappearing.unshift(lArc);\n            detachBeach(lArc);\n            lArc = previous;\n        }\n        disappearing.unshift(lArc);\n        detachCircle(lArc);\n        var rArc = next;\n        while (rArc.circle\n            && Math.abs(x - rArc.circle.x) < epsilon\n            && Math.abs(y - rArc.circle.cy) < epsilon) {\n            next = rArc.N;\n            disappearing.push(rArc);\n            detachBeach(rArc);\n            rArc = next;\n        }\n        disappearing.push(rArc);\n        detachCircle(rArc);\n        var nArcs = disappearing.length, iArc;\n        for (iArc = 1; iArc < nArcs; ++iArc) {\n            rArc = disappearing[iArc];\n            lArc = disappearing[iArc - 1];\n            setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n        }\n        lArc = disappearing[0];\n        rArc = disappearing[nArcs - 1];\n        rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);\n        attachCircle(lArc);\n        attachCircle(rArc);\n    }\n    function addBeach(site) {\n        var x = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = beaches._;\n        while (node) {\n            dxl = leftBreakPoint(node, directrix) - x;\n            if (dxl > epsilon)\n                node = node.L;\n            else {\n                dxr = x - rightBreakPoint(node, directrix);\n                if (dxr > epsilon) {\n                    if (!node.R) {\n                        lArc = node;\n                        break;\n                    }\n                    node = node.R;\n                }\n                else {\n                    if (dxl > -epsilon) {\n                        lArc = node.P;\n                        rArc = node;\n                    }\n                    else if (dxr > -epsilon) {\n                        lArc = node;\n                        rArc = node.N;\n                    }\n                    else {\n                        lArc = rArc = node;\n                    }\n                    break;\n                }\n            }\n        }\n        createCell(site);\n        var newArc = createBeach(site);\n        beaches.insert(lArc, newArc);\n        if (!lArc && !rArc)\n            return;\n        if (lArc === rArc) {\n            detachCircle(lArc);\n            rArc = createBeach(lArc.site);\n            beaches.insert(newArc, rArc);\n            newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);\n            attachCircle(lArc);\n            attachCircle(rArc);\n            return;\n        }\n        if (!rArc) { // && lArc\n            newArc.edge = createEdge(lArc.site, newArc.site);\n            return;\n        }\n        // else lArc !== rArc\n        detachCircle(lArc);\n        detachCircle(rArc);\n        var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];\n        setEdgeEnd(rArc.edge, lSite, rSite, vertex);\n        newArc.edge = createEdge(lSite, site, null, vertex);\n        rArc.edge = createEdge(site, rSite, null, vertex);\n        attachCircle(lArc);\n        attachCircle(rArc);\n    }\n    function leftBreakPoint(arc, directrix) {\n        var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;\n        if (!pby2)\n            return rfocx;\n        var lArc = arc.P;\n        if (!lArc)\n            return -Infinity;\n        site = lArc.site;\n        var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;\n        if (!plby2)\n            return lfocx;\n        var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;\n        if (aby2)\n            return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n        return (rfocx + lfocx) / 2;\n    }\n    function rightBreakPoint(arc, directrix) {\n        var rArc = arc.N;\n        if (rArc)\n            return leftBreakPoint(rArc, directrix);\n        var site = arc.site;\n        return site[1] === directrix ? site[0] : Infinity;\n    }\n    var epsilon = 1e-6;\n    var epsilon2 = 1e-12;\n    var beaches;\n    var cells;\n    var circles;\n    var edges;\n    function triangleArea(a, b, c) {\n        return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);\n    }\n    function lexicographic(a, b) {\n        return b[1] - a[1]\n            || b[0] - a[0];\n    }\n    function Diagram(sites, extent) {\n        var site = sites.sort(lexicographic).pop(), x, y, circle;\n        edges = [];\n        cells = new Array(sites.length);\n        beaches = new RedBlackTree;\n        circles = new RedBlackTree;\n        while (true) {\n            circle = firstCircle;\n            if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {\n                if (site[0] !== x || site[1] !== y) {\n                    addBeach(site);\n                    x = site[0], y = site[1];\n                }\n                site = sites.pop();\n            }\n            else if (circle) {\n                removeBeach(circle.arc);\n            }\n            else {\n                break;\n            }\n        }\n        sortCellHalfedges();\n        if (extent) {\n            var x0 = +extent[0][0], y0 = +extent[0][1], x1 = +extent[1][0], y1 = +extent[1][1];\n            clipEdges(x0, y0, x1, y1);\n            clipCells(x0, y0, x1, y1);\n        }\n        this.edges = edges;\n        this.cells = cells;\n        beaches =\n            circles =\n                edges =\n                    cells = null;\n    }\n    Diagram.prototype = {\n        constructor: Diagram,\n        polygons: function () {\n            var edges = this.edges;\n            return this.cells.map(function (cell) {\n                var polygon = cell.halfedges.map(function (i) { return cellHalfedgeStart(cell, edges[i]); });\n                polygon.data = cell.site.data;\n                return polygon;\n            });\n        },\n        triangles: function () {\n            var triangles = [], edges = this.edges;\n            this.cells.forEach(function (cell, i) {\n                if (!(m = (halfedges = cell.halfedges).length))\n                    return;\n                var site = cell.site, halfedges, j = -1, m, s0, e1 = edges[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;\n                while (++j < m) {\n                    s0 = s1;\n                    e1 = edges[halfedges[j]];\n                    s1 = e1.left === site ? e1.right : e1.left;\n                    if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {\n                        triangles.push([site.data, s0.data, s1.data]);\n                    }\n                }\n            });\n            return triangles;\n        },\n        links: function () {\n            return this.edges.filter(function (edge) {\n                return edge.right;\n            }).map(function (edge) {\n                return {\n                    source: edge.left.data,\n                    target: edge.right.data\n                };\n            });\n        },\n        find: function (x, y, radius) {\n            var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;\n            // Use the previously-found cell, or start with an arbitrary one.\n            while (!(cell = that.cells[i1]))\n                if (++i1 >= n)\n                    return null;\n            var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;\n            // Traverse the half-edges to find a closer cell, if any.\n            do {\n                cell = that.cells[i0 = i1], i1 = null;\n                cell.halfedges.forEach(function (e) {\n                    var edge = that.edges[e], v = edge.left;\n                    if ((v === cell.site || !v) && !(v = edge.right))\n                        return;\n                    var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;\n                    if (v2 < d2)\n                        d2 = v2, i1 = v.index;\n                });\n            } while (i1 !== null);\n            that._found = i0;\n            return radius == null || d2 <= radius * radius ? cell.site : null;\n        }\n    };\n    function voronoi() {\n        var x$$1 = x, y$$1 = y, extent = null;\n        function voronoi(data) {\n            return new Diagram(data.map(function (d, i) {\n                var s = [Math.round(x$$1(d, i, data) / epsilon) * epsilon, Math.round(y$$1(d, i, data) / epsilon) * epsilon];\n                s.index = i;\n                s.data = d;\n                return s;\n            }), extent);\n        }\n        voronoi.polygons = function (data) {\n            return voronoi(data).polygons();\n        };\n        voronoi.links = function (data) {\n            return voronoi(data).links();\n        };\n        voronoi.triangles = function (data) {\n            return voronoi(data).triangles();\n        };\n        voronoi.x = function (_) {\n            return arguments.length ? (x$$1 = typeof _ === \"function\" ? _ : constant(+_), voronoi) : x$$1;\n        };\n        voronoi.y = function (_) {\n            return arguments.length ? (y$$1 = typeof _ === \"function\" ? _ : constant(+_), voronoi) : y$$1;\n        };\n        voronoi.extent = function (_) {\n            return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];\n        };\n        voronoi.size = function (_) {\n            return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];\n        };\n        return voronoi;\n    }\n    exports.voronoi = voronoi;\n    Object.defineProperty(exports, '__esModule', { value: true });\n})));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/index.js\":\n/*!**************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/index.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\nCopyright (c) 2012-2014 Chris Pettitt\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nmodule.exports = {\n  graphlib: __webpack_require__(/*! ./lib/graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\"),\n\n  layout: __webpack_require__(/*! ./lib/layout */ \"./node_modules/_dagre@0.8.5@dagre/lib/layout.js\"),\n  debug: __webpack_require__(/*! ./lib/debug */ \"./node_modules/_dagre@0.8.5@dagre/lib/debug.js\"),\n  util: {\n    time: __webpack_require__(/*! ./lib/util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\").time,\n    notime: __webpack_require__(/*! ./lib/util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\").notime\n  },\n  version: __webpack_require__(/*! ./lib/version */ \"./node_modules/_dagre@0.8.5@dagre/lib/version.js\")\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/acyclic.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/acyclic.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar greedyFAS = __webpack_require__(/*! ./greedy-fas */ \"./node_modules/_dagre@0.8.5@dagre/lib/greedy-fas.js\");\n\nmodule.exports = {\n  run: run,\n  undo: undo\n};\n\nfunction run(g) {\n  var fas = (g.graph().acyclicer === \"greedy\"\n    ? greedyFAS(g, weightFn(g))\n    : dfsFAS(g));\n  _.forEach(fas, function(e) {\n    var label = g.edge(e);\n    g.removeEdge(e);\n    label.forwardName = e.name;\n    label.reversed = true;\n    g.setEdge(e.w, e.v, label, _.uniqueId(\"rev\"));\n  });\n\n  function weightFn(g) {\n    return function(e) {\n      return g.edge(e).weight;\n    };\n  }\n}\n\nfunction dfsFAS(g) {\n  var fas = [];\n  var stack = {};\n  var visited = {};\n\n  function dfs(v) {\n    if (_.has(visited, v)) {\n      return;\n    }\n    visited[v] = true;\n    stack[v] = true;\n    _.forEach(g.outEdges(v), function(e) {\n      if (_.has(stack, e.w)) {\n        fas.push(e);\n      } else {\n        dfs(e.w);\n      }\n    });\n    delete stack[v];\n  }\n\n  _.forEach(g.nodes(), dfs);\n  return fas;\n}\n\nfunction undo(g) {\n  _.forEach(g.edges(), function(e) {\n    var label = g.edge(e);\n    if (label.reversed) {\n      g.removeEdge(e);\n\n      var forwardName = label.forwardName;\n      delete label.reversed;\n      delete label.forwardName;\n      g.setEdge(e.w, e.v, label, forwardName);\n    }\n  });\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/add-border-segments.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/add-border-segments.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\n\nmodule.exports = addBorderSegments;\n\nfunction addBorderSegments(g) {\n  function dfs(v) {\n    var children = g.children(v);\n    var node = g.node(v);\n    if (children.length) {\n      _.forEach(children, dfs);\n    }\n\n    if (_.has(node, \"minRank\")) {\n      node.borderLeft = [];\n      node.borderRight = [];\n      for (var rank = node.minRank, maxRank = node.maxRank + 1;\n        rank < maxRank;\n        ++rank) {\n        addBorderNode(g, \"borderLeft\", \"_bl\", v, node, rank);\n        addBorderNode(g, \"borderRight\", \"_br\", v, node, rank);\n      }\n    }\n  }\n\n  _.forEach(g.children(), dfs);\n}\n\nfunction addBorderNode(g, prop, prefix, sg, sgNode, rank) {\n  var label = { width: 0, height: 0, rank: rank, borderType: prop };\n  var prev = sgNode[prop][rank - 1];\n  var curr = util.addDummyNode(g, \"border\", label, prefix);\n  sgNode[prop][rank] = curr;\n  g.setParent(curr, sg);\n  if (prev) {\n    g.setEdge(prev, curr, { weight: 1 });\n  }\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/coordinate-system.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/coordinate-system.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\n\nmodule.exports = {\n  adjust: adjust,\n  undo: undo\n};\n\nfunction adjust(g) {\n  var rankDir = g.graph().rankdir.toLowerCase();\n  if (rankDir === \"lr\" || rankDir === \"rl\") {\n    swapWidthHeight(g);\n  }\n}\n\nfunction undo(g) {\n  var rankDir = g.graph().rankdir.toLowerCase();\n  if (rankDir === \"bt\" || rankDir === \"rl\") {\n    reverseY(g);\n  }\n\n  if (rankDir === \"lr\" || rankDir === \"rl\") {\n    swapXY(g);\n    swapWidthHeight(g);\n  }\n}\n\nfunction swapWidthHeight(g) {\n  _.forEach(g.nodes(), function(v) { swapWidthHeightOne(g.node(v)); });\n  _.forEach(g.edges(), function(e) { swapWidthHeightOne(g.edge(e)); });\n}\n\nfunction swapWidthHeightOne(attrs) {\n  var w = attrs.width;\n  attrs.width = attrs.height;\n  attrs.height = w;\n}\n\nfunction reverseY(g) {\n  _.forEach(g.nodes(), function(v) { reverseYOne(g.node(v)); });\n\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    _.forEach(edge.points, reverseYOne);\n    if (_.has(edge, \"y\")) {\n      reverseYOne(edge);\n    }\n  });\n}\n\nfunction reverseYOne(attrs) {\n  attrs.y = -attrs.y;\n}\n\nfunction swapXY(g) {\n  _.forEach(g.nodes(), function(v) { swapXYOne(g.node(v)); });\n\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    _.forEach(edge.points, swapXYOne);\n    if (_.has(edge, \"x\")) {\n      swapXYOne(edge);\n    }\n  });\n}\n\nfunction swapXYOne(attrs) {\n  var x = attrs.x;\n  attrs.x = attrs.y;\n  attrs.y = x;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/data/list.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/data/list.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/*\n * Simple doubly linked list implementation derived from Cormen, et al.,\n * \"Introduction to Algorithms\".\n */\n\nmodule.exports = List;\n\nfunction List() {\n  var sentinel = {};\n  sentinel._next = sentinel._prev = sentinel;\n  this._sentinel = sentinel;\n}\n\nList.prototype.dequeue = function() {\n  var sentinel = this._sentinel;\n  var entry = sentinel._prev;\n  if (entry !== sentinel) {\n    unlink(entry);\n    return entry;\n  }\n};\n\nList.prototype.enqueue = function(entry) {\n  var sentinel = this._sentinel;\n  if (entry._prev && entry._next) {\n    unlink(entry);\n  }\n  entry._next = sentinel._next;\n  sentinel._next._prev = entry;\n  sentinel._next = entry;\n  entry._prev = sentinel;\n};\n\nList.prototype.toString = function() {\n  var strs = [];\n  var sentinel = this._sentinel;\n  var curr = sentinel._prev;\n  while (curr !== sentinel) {\n    strs.push(JSON.stringify(curr, filterOutLinks));\n    curr = curr._prev;\n  }\n  return \"[\" + strs.join(\", \") + \"]\";\n};\n\nfunction unlink(entry) {\n  entry._prev._next = entry._next;\n  entry._next._prev = entry._prev;\n  delete entry._next;\n  delete entry._prev;\n}\n\nfunction filterOutLinks(k, v) {\n  if (k !== \"_next\" && k !== \"_prev\") {\n    return v;\n  }\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/debug.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/debug.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\nvar Graph = __webpack_require__(/*! ./graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").Graph;\n\nmodule.exports = {\n  debugOrdering: debugOrdering\n};\n\n/* istanbul ignore next */\nfunction debugOrdering(g) {\n  var layerMatrix = util.buildLayerMatrix(g);\n\n  var h = new Graph({ compound: true, multigraph: true }).setGraph({});\n\n  _.forEach(g.nodes(), function(v) {\n    h.setNode(v, { label: v });\n    h.setParent(v, \"layer\" + g.node(v).rank);\n  });\n\n  _.forEach(g.edges(), function(e) {\n    h.setEdge(e.v, e.w, {}, e.name);\n  });\n\n  _.forEach(layerMatrix, function(layer, i) {\n    var layerV = \"layer\" + i;\n    h.setNode(layerV, { rank: \"same\" });\n    _.reduce(layer, function(u, v) {\n      h.setEdge(u, v, { style: \"invis\" });\n      return v;\n    });\n  });\n\n  return h;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* global window */\n\nvar graphlib;\n\nif (true) {\n  try {\n    graphlib = __webpack_require__(/*! graphlib */ \"./node_modules/_graphlib@2.1.8@graphlib/index.js\");\n  } catch (e) {\n    // continue regardless of error\n  }\n}\n\nif (!graphlib) {\n  graphlib = window.graphlib;\n}\n\nmodule.exports = graphlib;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/greedy-fas.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/greedy-fas.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar Graph = __webpack_require__(/*! ./graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").Graph;\nvar List = __webpack_require__(/*! ./data/list */ \"./node_modules/_dagre@0.8.5@dagre/lib/data/list.js\");\n\n/*\n * A greedy heuristic for finding a feedback arc set for a graph. A feedback\n * arc set is a set of edges that can be removed to make a graph acyclic.\n * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, \"A fast and\n * effective heuristic for the feedback arc set problem.\" This implementation\n * adjusts that from the paper to allow for weighted edges.\n */\nmodule.exports = greedyFAS;\n\nvar DEFAULT_WEIGHT_FN = _.constant(1);\n\nfunction greedyFAS(g, weightFn) {\n  if (g.nodeCount() <= 1) {\n    return [];\n  }\n  var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);\n  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);\n\n  // Expand multi-edges\n  return _.flatten(_.map(results, function(e) {\n    return g.outEdges(e.v, e.w);\n  }), true);\n}\n\nfunction doGreedyFAS(g, buckets, zeroIdx) {\n  var results = [];\n  var sources = buckets[buckets.length - 1];\n  var sinks = buckets[0];\n\n  var entry;\n  while (g.nodeCount()) {\n    while ((entry = sinks.dequeue()))   { removeNode(g, buckets, zeroIdx, entry); }\n    while ((entry = sources.dequeue())) { removeNode(g, buckets, zeroIdx, entry); }\n    if (g.nodeCount()) {\n      for (var i = buckets.length - 2; i > 0; --i) {\n        entry = buckets[i].dequeue();\n        if (entry) {\n          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));\n          break;\n        }\n      }\n    }\n  }\n\n  return results;\n}\n\nfunction removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {\n  var results = collectPredecessors ? [] : undefined;\n\n  _.forEach(g.inEdges(entry.v), function(edge) {\n    var weight = g.edge(edge);\n    var uEntry = g.node(edge.v);\n\n    if (collectPredecessors) {\n      results.push({ v: edge.v, w: edge.w });\n    }\n\n    uEntry.out -= weight;\n    assignBucket(buckets, zeroIdx, uEntry);\n  });\n\n  _.forEach(g.outEdges(entry.v), function(edge) {\n    var weight = g.edge(edge);\n    var w = edge.w;\n    var wEntry = g.node(w);\n    wEntry[\"in\"] -= weight;\n    assignBucket(buckets, zeroIdx, wEntry);\n  });\n\n  g.removeNode(entry.v);\n\n  return results;\n}\n\nfunction buildState(g, weightFn) {\n  var fasGraph = new Graph();\n  var maxIn = 0;\n  var maxOut = 0;\n\n  _.forEach(g.nodes(), function(v) {\n    fasGraph.setNode(v, { v: v, \"in\": 0, out: 0 });\n  });\n\n  // Aggregate weights on nodes, but also sum the weights across multi-edges\n  // into a single edge for the fasGraph.\n  _.forEach(g.edges(), function(e) {\n    var prevWeight = fasGraph.edge(e.v, e.w) || 0;\n    var weight = weightFn(e);\n    var edgeWeight = prevWeight + weight;\n    fasGraph.setEdge(e.v, e.w, edgeWeight);\n    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);\n    maxIn  = Math.max(maxIn,  fasGraph.node(e.w)[\"in\"]  += weight);\n  });\n\n  var buckets = _.range(maxOut + maxIn + 3).map(function() { return new List(); });\n  var zeroIdx = maxIn + 1;\n\n  _.forEach(fasGraph.nodes(), function(v) {\n    assignBucket(buckets, zeroIdx, fasGraph.node(v));\n  });\n\n  return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx };\n}\n\nfunction assignBucket(buckets, zeroIdx, entry) {\n  if (!entry.out) {\n    buckets[0].enqueue(entry);\n  } else if (!entry[\"in\"]) {\n    buckets[buckets.length - 1].enqueue(entry);\n  } else {\n    buckets[entry.out - entry[\"in\"] + zeroIdx].enqueue(entry);\n  }\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/layout.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/layout.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar acyclic = __webpack_require__(/*! ./acyclic */ \"./node_modules/_dagre@0.8.5@dagre/lib/acyclic.js\");\nvar normalize = __webpack_require__(/*! ./normalize */ \"./node_modules/_dagre@0.8.5@dagre/lib/normalize.js\");\nvar rank = __webpack_require__(/*! ./rank */ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/index.js\");\nvar normalizeRanks = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\").normalizeRanks;\nvar parentDummyChains = __webpack_require__(/*! ./parent-dummy-chains */ \"./node_modules/_dagre@0.8.5@dagre/lib/parent-dummy-chains.js\");\nvar removeEmptyRanks = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\").removeEmptyRanks;\nvar nestingGraph = __webpack_require__(/*! ./nesting-graph */ \"./node_modules/_dagre@0.8.5@dagre/lib/nesting-graph.js\");\nvar addBorderSegments = __webpack_require__(/*! ./add-border-segments */ \"./node_modules/_dagre@0.8.5@dagre/lib/add-border-segments.js\");\nvar coordinateSystem = __webpack_require__(/*! ./coordinate-system */ \"./node_modules/_dagre@0.8.5@dagre/lib/coordinate-system.js\");\nvar order = __webpack_require__(/*! ./order */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/index.js\");\nvar position = __webpack_require__(/*! ./position */ \"./node_modules/_dagre@0.8.5@dagre/lib/position/index.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\nvar Graph = __webpack_require__(/*! ./graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").Graph;\n\nmodule.exports = layout;\n\nfunction layout(g, opts) {\n  var time = opts && opts.debugTiming ? util.time : util.notime;\n  time(\"layout\", function() {\n    var layoutGraph = \n      time(\"  buildLayoutGraph\", function() { return buildLayoutGraph(g); });\n    time(\"  runLayout\",        function() { runLayout(layoutGraph, time); });\n    time(\"  updateInputGraph\", function() { updateInputGraph(g, layoutGraph); });\n  });\n}\n\nfunction runLayout(g, time) {\n  time(\"    makeSpaceForEdgeLabels\", function() { makeSpaceForEdgeLabels(g); });\n  time(\"    removeSelfEdges\",        function() { removeSelfEdges(g); });\n  time(\"    acyclic\",                function() { acyclic.run(g); });\n  time(\"    nestingGraph.run\",       function() { nestingGraph.run(g); });\n  time(\"    rank\",                   function() { rank(util.asNonCompoundGraph(g)); });\n  time(\"    injectEdgeLabelProxies\", function() { injectEdgeLabelProxies(g); });\n  time(\"    removeEmptyRanks\",       function() { removeEmptyRanks(g); });\n  time(\"    nestingGraph.cleanup\",   function() { nestingGraph.cleanup(g); });\n  time(\"    normalizeRanks\",         function() { normalizeRanks(g); });\n  time(\"    assignRankMinMax\",       function() { assignRankMinMax(g); });\n  time(\"    removeEdgeLabelProxies\", function() { removeEdgeLabelProxies(g); });\n  time(\"    normalize.run\",          function() { normalize.run(g); });\n  time(\"    parentDummyChains\",      function() { parentDummyChains(g); });\n  time(\"    addBorderSegments\",      function() { addBorderSegments(g); });\n  time(\"    order\",                  function() { order(g); });\n  time(\"    insertSelfEdges\",        function() { insertSelfEdges(g); });\n  time(\"    adjustCoordinateSystem\", function() { coordinateSystem.adjust(g); });\n  time(\"    position\",               function() { position(g); });\n  time(\"    positionSelfEdges\",      function() { positionSelfEdges(g); });\n  time(\"    removeBorderNodes\",      function() { removeBorderNodes(g); });\n  time(\"    normalize.undo\",         function() { normalize.undo(g); });\n  time(\"    fixupEdgeLabelCoords\",   function() { fixupEdgeLabelCoords(g); });\n  time(\"    undoCoordinateSystem\",   function() { coordinateSystem.undo(g); });\n  time(\"    translateGraph\",         function() { translateGraph(g); });\n  time(\"    assignNodeIntersects\",   function() { assignNodeIntersects(g); });\n  time(\"    reversePoints\",          function() { reversePointsForReversedEdges(g); });\n  time(\"    acyclic.undo\",           function() { acyclic.undo(g); });\n}\n\n/*\n * Copies final layout information from the layout graph back to the input\n * graph. This process only copies whitelisted attributes from the layout graph\n * to the input graph, so it serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction updateInputGraph(inputGraph, layoutGraph) {\n  _.forEach(inputGraph.nodes(), function(v) {\n    var inputLabel = inputGraph.node(v);\n    var layoutLabel = layoutGraph.node(v);\n\n    if (inputLabel) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n\n      if (layoutGraph.children(v).length) {\n        inputLabel.width = layoutLabel.width;\n        inputLabel.height = layoutLabel.height;\n      }\n    }\n  });\n\n  _.forEach(inputGraph.edges(), function(e) {\n    var inputLabel = inputGraph.edge(e);\n    var layoutLabel = layoutGraph.edge(e);\n\n    inputLabel.points = layoutLabel.points;\n    if (_.has(layoutLabel, \"x\")) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n    }\n  });\n\n  inputGraph.graph().width = layoutGraph.graph().width;\n  inputGraph.graph().height = layoutGraph.graph().height;\n}\n\nvar graphNumAttrs = [\"nodesep\", \"edgesep\", \"ranksep\", \"marginx\", \"marginy\"];\nvar graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: \"tb\" };\nvar graphAttrs = [\"acyclicer\", \"ranker\", \"rankdir\", \"align\"];\nvar nodeNumAttrs = [\"width\", \"height\"];\nvar nodeDefaults = { width: 0, height: 0 };\nvar edgeNumAttrs = [\"minlen\", \"weight\", \"width\", \"height\", \"labeloffset\"];\nvar edgeDefaults = {\n  minlen: 1, weight: 1, width: 0, height: 0,\n  labeloffset: 10, labelpos: \"r\"\n};\nvar edgeAttrs = [\"labelpos\"];\n\n/*\n * Constructs a new graph from the input graph, which can be used for layout.\n * This process copies only whitelisted attributes from the input graph to the\n * layout graph. Thus this function serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction buildLayoutGraph(inputGraph) {\n  var g = new Graph({ multigraph: true, compound: true });\n  var graph = canonicalize(inputGraph.graph());\n\n  g.setGraph(_.merge({},\n    graphDefaults,\n    selectNumberAttrs(graph, graphNumAttrs),\n    _.pick(graph, graphAttrs)));\n\n  _.forEach(inputGraph.nodes(), function(v) {\n    var node = canonicalize(inputGraph.node(v));\n    g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));\n    g.setParent(v, inputGraph.parent(v));\n  });\n\n  _.forEach(inputGraph.edges(), function(e) {\n    var edge = canonicalize(inputGraph.edge(e));\n    g.setEdge(e, _.merge({},\n      edgeDefaults,\n      selectNumberAttrs(edge, edgeNumAttrs),\n      _.pick(edge, edgeAttrs)));\n  });\n\n  return g;\n}\n\n/*\n * This idea comes from the Gansner paper: to account for edge labels in our\n * layout we split each rank in half by doubling minlen and halving ranksep.\n * Then we can place labels at these mid-points between nodes.\n *\n * We also add some minimal padding to the width to push the label for the edge\n * away from the edge itself a bit.\n */\nfunction makeSpaceForEdgeLabels(g) {\n  var graph = g.graph();\n  graph.ranksep /= 2;\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    edge.minlen *= 2;\n    if (edge.labelpos.toLowerCase() !== \"c\") {\n      if (graph.rankdir === \"TB\" || graph.rankdir === \"BT\") {\n        edge.width += edge.labeloffset;\n      } else {\n        edge.height += edge.labeloffset;\n      }\n    }\n  });\n}\n\n/*\n * Creates temporary dummy nodes that capture the rank in which each edge's\n * label is going to, if it has one of non-zero width and height. We do this\n * so that we can safely remove empty ranks while preserving balance for the\n * label's position.\n */\nfunction injectEdgeLabelProxies(g) {\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    if (edge.width && edge.height) {\n      var v = g.node(e.v);\n      var w = g.node(e.w);\n      var label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e };\n      util.addDummyNode(g, \"edge-proxy\", label, \"_ep\");\n    }\n  });\n}\n\nfunction assignRankMinMax(g) {\n  var maxRank = 0;\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    if (node.borderTop) {\n      node.minRank = g.node(node.borderTop).rank;\n      node.maxRank = g.node(node.borderBottom).rank;\n      maxRank = _.max(maxRank, node.maxRank);\n    }\n  });\n  g.graph().maxRank = maxRank;\n}\n\nfunction removeEdgeLabelProxies(g) {\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    if (node.dummy === \"edge-proxy\") {\n      g.edge(node.e).labelRank = node.rank;\n      g.removeNode(v);\n    }\n  });\n}\n\nfunction translateGraph(g) {\n  var minX = Number.POSITIVE_INFINITY;\n  var maxX = 0;\n  var minY = Number.POSITIVE_INFINITY;\n  var maxY = 0;\n  var graphLabel = g.graph();\n  var marginX = graphLabel.marginx || 0;\n  var marginY = graphLabel.marginy || 0;\n\n  function getExtremes(attrs) {\n    var x = attrs.x;\n    var y = attrs.y;\n    var w = attrs.width;\n    var h = attrs.height;\n    minX = Math.min(minX, x - w / 2);\n    maxX = Math.max(maxX, x + w / 2);\n    minY = Math.min(minY, y - h / 2);\n    maxY = Math.max(maxY, y + h / 2);\n  }\n\n  _.forEach(g.nodes(), function(v) { getExtremes(g.node(v)); });\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    if (_.has(edge, \"x\")) {\n      getExtremes(edge);\n    }\n  });\n\n  minX -= marginX;\n  minY -= marginY;\n\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    node.x -= minX;\n    node.y -= minY;\n  });\n\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    _.forEach(edge.points, function(p) {\n      p.x -= minX;\n      p.y -= minY;\n    });\n    if (_.has(edge, \"x\")) { edge.x -= minX; }\n    if (_.has(edge, \"y\")) { edge.y -= minY; }\n  });\n\n  graphLabel.width = maxX - minX + marginX;\n  graphLabel.height = maxY - minY + marginY;\n}\n\nfunction assignNodeIntersects(g) {\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    var nodeV = g.node(e.v);\n    var nodeW = g.node(e.w);\n    var p1, p2;\n    if (!edge.points) {\n      edge.points = [];\n      p1 = nodeW;\n      p2 = nodeV;\n    } else {\n      p1 = edge.points[0];\n      p2 = edge.points[edge.points.length - 1];\n    }\n    edge.points.unshift(util.intersectRect(nodeV, p1));\n    edge.points.push(util.intersectRect(nodeW, p2));\n  });\n}\n\nfunction fixupEdgeLabelCoords(g) {\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    if (_.has(edge, \"x\")) {\n      if (edge.labelpos === \"l\" || edge.labelpos === \"r\") {\n        edge.width -= edge.labeloffset;\n      }\n      switch (edge.labelpos) {\n      case \"l\": edge.x -= edge.width / 2 + edge.labeloffset; break;\n      case \"r\": edge.x += edge.width / 2 + edge.labeloffset; break;\n      }\n    }\n  });\n}\n\nfunction reversePointsForReversedEdges(g) {\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    if (edge.reversed) {\n      edge.points.reverse();\n    }\n  });\n}\n\nfunction removeBorderNodes(g) {\n  _.forEach(g.nodes(), function(v) {\n    if (g.children(v).length) {\n      var node = g.node(v);\n      var t = g.node(node.borderTop);\n      var b = g.node(node.borderBottom);\n      var l = g.node(_.last(node.borderLeft));\n      var r = g.node(_.last(node.borderRight));\n\n      node.width = Math.abs(r.x - l.x);\n      node.height = Math.abs(b.y - t.y);\n      node.x = l.x + node.width / 2;\n      node.y = t.y + node.height / 2;\n    }\n  });\n\n  _.forEach(g.nodes(), function(v) {\n    if (g.node(v).dummy === \"border\") {\n      g.removeNode(v);\n    }\n  });\n}\n\nfunction removeSelfEdges(g) {\n  _.forEach(g.edges(), function(e) {\n    if (e.v === e.w) {\n      var node = g.node(e.v);\n      if (!node.selfEdges) {\n        node.selfEdges = [];\n      }\n      node.selfEdges.push({ e: e, label: g.edge(e) });\n      g.removeEdge(e);\n    }\n  });\n}\n\nfunction insertSelfEdges(g) {\n  var layers = util.buildLayerMatrix(g);\n  _.forEach(layers, function(layer) {\n    var orderShift = 0;\n    _.forEach(layer, function(v, i) {\n      var node = g.node(v);\n      node.order = i + orderShift;\n      _.forEach(node.selfEdges, function(selfEdge) {\n        util.addDummyNode(g, \"selfedge\", {\n          width: selfEdge.label.width,\n          height: selfEdge.label.height,\n          rank: node.rank,\n          order: i + (++orderShift),\n          e: selfEdge.e,\n          label: selfEdge.label\n        }, \"_se\");\n      });\n      delete node.selfEdges;\n    });\n  });\n}\n\nfunction positionSelfEdges(g) {\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    if (node.dummy === \"selfedge\") {\n      var selfNode = g.node(node.e.v);\n      var x = selfNode.x + selfNode.width / 2;\n      var y = selfNode.y;\n      var dx = node.x - x;\n      var dy = selfNode.height / 2;\n      g.setEdge(node.e, node.label);\n      g.removeNode(v);\n      node.label.points = [\n        { x: x + 2 * dx / 3, y: y - dy },\n        { x: x + 5 * dx / 6, y: y - dy },\n        { x: x +     dx    , y: y },\n        { x: x + 5 * dx / 6, y: y + dy },\n        { x: x + 2 * dx / 3, y: y + dy }\n      ];\n      node.label.x = node.x;\n      node.label.y = node.y;\n    }\n  });\n}\n\nfunction selectNumberAttrs(obj, attrs) {\n  return _.mapValues(_.pick(obj, attrs), Number);\n}\n\nfunction canonicalize(attrs) {\n  var newAttrs = {};\n  _.forEach(attrs, function(v, k) {\n    newAttrs[k.toLowerCase()] = v;\n  });\n  return newAttrs;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/lodash.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* global window */\n\nvar lodash;\n\nif (true) {\n  try {\n    lodash = {\n      cloneDeep: __webpack_require__(/*! lodash/cloneDeep */ \"./node_modules/_lodash@4.17.15@lodash/cloneDeep.js\"),\n      constant: __webpack_require__(/*! lodash/constant */ \"./node_modules/_lodash@4.17.15@lodash/constant.js\"),\n      defaults: __webpack_require__(/*! lodash/defaults */ \"./node_modules/_lodash@4.17.15@lodash/defaults.js\"),\n      each: __webpack_require__(/*! lodash/each */ \"./node_modules/_lodash@4.17.15@lodash/each.js\"),\n      filter: __webpack_require__(/*! lodash/filter */ \"./node_modules/_lodash@4.17.15@lodash/filter.js\"),\n      find: __webpack_require__(/*! lodash/find */ \"./node_modules/_lodash@4.17.15@lodash/find.js\"),\n      flatten: __webpack_require__(/*! lodash/flatten */ \"./node_modules/_lodash@4.17.15@lodash/flatten.js\"),\n      forEach: __webpack_require__(/*! lodash/forEach */ \"./node_modules/_lodash@4.17.15@lodash/forEach.js\"),\n      forIn: __webpack_require__(/*! lodash/forIn */ \"./node_modules/_lodash@4.17.15@lodash/forIn.js\"),\n      has:  __webpack_require__(/*! lodash/has */ \"./node_modules/_lodash@4.17.15@lodash/has.js\"),\n      isUndefined: __webpack_require__(/*! lodash/isUndefined */ \"./node_modules/_lodash@4.17.15@lodash/isUndefined.js\"),\n      last: __webpack_require__(/*! lodash/last */ \"./node_modules/_lodash@4.17.15@lodash/last.js\"),\n      map: __webpack_require__(/*! lodash/map */ \"./node_modules/_lodash@4.17.15@lodash/map.js\"),\n      mapValues: __webpack_require__(/*! lodash/mapValues */ \"./node_modules/_lodash@4.17.15@lodash/mapValues.js\"),\n      max: __webpack_require__(/*! lodash/max */ \"./node_modules/_lodash@4.17.15@lodash/max.js\"),\n      merge: __webpack_require__(/*! lodash/merge */ \"./node_modules/_lodash@4.17.15@lodash/merge.js\"),\n      min: __webpack_require__(/*! lodash/min */ \"./node_modules/_lodash@4.17.15@lodash/min.js\"),\n      minBy: __webpack_require__(/*! lodash/minBy */ \"./node_modules/_lodash@4.17.15@lodash/minBy.js\"),\n      now: __webpack_require__(/*! lodash/now */ \"./node_modules/_lodash@4.17.15@lodash/now.js\"),\n      pick: __webpack_require__(/*! lodash/pick */ \"./node_modules/_lodash@4.17.15@lodash/pick.js\"),\n      range: __webpack_require__(/*! lodash/range */ \"./node_modules/_lodash@4.17.15@lodash/range.js\"),\n      reduce: __webpack_require__(/*! lodash/reduce */ \"./node_modules/_lodash@4.17.15@lodash/reduce.js\"),\n      sortBy: __webpack_require__(/*! lodash/sortBy */ \"./node_modules/_lodash@4.17.15@lodash/sortBy.js\"),\n      uniqueId: __webpack_require__(/*! lodash/uniqueId */ \"./node_modules/_lodash@4.17.15@lodash/uniqueId.js\"),\n      values: __webpack_require__(/*! lodash/values */ \"./node_modules/_lodash@4.17.15@lodash/values.js\"),\n      zipObject: __webpack_require__(/*! lodash/zipObject */ \"./node_modules/_lodash@4.17.15@lodash/zipObject.js\"),\n    };\n  } catch (e) {\n    // continue regardless of error\n  }\n}\n\nif (!lodash) {\n  lodash = window._;\n}\n\nmodule.exports = lodash;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/nesting-graph.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/nesting-graph.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\n\nmodule.exports = {\n  run: run,\n  cleanup: cleanup\n};\n\n/*\n * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,\n * adds appropriate edges to ensure that all cluster nodes are placed between\n * these boundries, and ensures that the graph is connected.\n *\n * In addition we ensure, through the use of the minlen property, that nodes\n * and subgraph border nodes to not end up on the same rank.\n *\n * Preconditions:\n *\n *    1. Input graph is a DAG\n *    2. Nodes in the input graph has a minlen attribute\n *\n * Postconditions:\n *\n *    1. Input graph is connected.\n *    2. Dummy nodes are added for the tops and bottoms of subgraphs.\n *    3. The minlen attribute for nodes is adjusted to ensure nodes do not\n *       get placed on the same rank as subgraph border nodes.\n *\n * The nesting graph idea comes from Sander, \"Layout of Compound Directed\n * Graphs.\"\n */\nfunction run(g) {\n  var root = util.addDummyNode(g, \"root\", {}, \"_root\");\n  var depths = treeDepths(g);\n  var height = _.max(_.values(depths)) - 1; // Note: depths is an Object not an array\n  var nodeSep = 2 * height + 1;\n\n  g.graph().nestingRoot = root;\n\n  // Multiply minlen by nodeSep to align nodes on non-border ranks.\n  _.forEach(g.edges(), function(e) { g.edge(e).minlen *= nodeSep; });\n\n  // Calculate a weight that is sufficient to keep subgraphs vertically compact\n  var weight = sumWeights(g) + 1;\n\n  // Create border nodes and link them up\n  _.forEach(g.children(), function(child) {\n    dfs(g, root, nodeSep, weight, height, depths, child);\n  });\n\n  // Save the multiplier for node layers for later removal of empty border\n  // layers.\n  g.graph().nodeRankFactor = nodeSep;\n}\n\nfunction dfs(g, root, nodeSep, weight, height, depths, v) {\n  var children = g.children(v);\n  if (!children.length) {\n    if (v !== root) {\n      g.setEdge(root, v, { weight: 0, minlen: nodeSep });\n    }\n    return;\n  }\n\n  var top = util.addBorderNode(g, \"_bt\");\n  var bottom = util.addBorderNode(g, \"_bb\");\n  var label = g.node(v);\n\n  g.setParent(top, v);\n  label.borderTop = top;\n  g.setParent(bottom, v);\n  label.borderBottom = bottom;\n\n  _.forEach(children, function(child) {\n    dfs(g, root, nodeSep, weight, height, depths, child);\n\n    var childNode = g.node(child);\n    var childTop = childNode.borderTop ? childNode.borderTop : child;\n    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;\n    var thisWeight = childNode.borderTop ? weight : 2 * weight;\n    var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;\n\n    g.setEdge(top, childTop, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true\n    });\n\n    g.setEdge(childBottom, bottom, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true\n    });\n  });\n\n  if (!g.parent(v)) {\n    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });\n  }\n}\n\nfunction treeDepths(g) {\n  var depths = {};\n  function dfs(v, depth) {\n    var children = g.children(v);\n    if (children && children.length) {\n      _.forEach(children, function(child) {\n        dfs(child, depth + 1);\n      });\n    }\n    depths[v] = depth;\n  }\n  _.forEach(g.children(), function(v) { dfs(v, 1); });\n  return depths;\n}\n\nfunction sumWeights(g) {\n  return _.reduce(g.edges(), function(acc, e) {\n    return acc + g.edge(e).weight;\n  }, 0);\n}\n\nfunction cleanup(g) {\n  var graphLabel = g.graph();\n  g.removeNode(graphLabel.nestingRoot);\n  delete graphLabel.nestingRoot;\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    if (edge.nestingEdge) {\n      g.removeEdge(e);\n    }\n  });\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/normalize.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/normalize.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\n\nmodule.exports = {\n  run: run,\n  undo: undo\n};\n\n/*\n * Breaks any long edges in the graph into short segments that span 1 layer\n * each. This operation is undoable with the denormalize function.\n *\n * Pre-conditions:\n *\n *    1. The input graph is a DAG.\n *    2. Each node in the graph has a \"rank\" property.\n *\n * Post-condition:\n *\n *    1. All edges in the graph have a length of 1.\n *    2. Dummy nodes are added where edges have been split into segments.\n *    3. The graph is augmented with a \"dummyChains\" attribute which contains\n *       the first dummy in each chain of dummy nodes produced.\n */\nfunction run(g) {\n  g.graph().dummyChains = [];\n  _.forEach(g.edges(), function(edge) { normalizeEdge(g, edge); });\n}\n\nfunction normalizeEdge(g, e) {\n  var v = e.v;\n  var vRank = g.node(v).rank;\n  var w = e.w;\n  var wRank = g.node(w).rank;\n  var name = e.name;\n  var edgeLabel = g.edge(e);\n  var labelRank = edgeLabel.labelRank;\n\n  if (wRank === vRank + 1) return;\n\n  g.removeEdge(e);\n\n  var dummy, attrs, i;\n  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {\n    edgeLabel.points = [];\n    attrs = {\n      width: 0, height: 0,\n      edgeLabel: edgeLabel, edgeObj: e,\n      rank: vRank\n    };\n    dummy = util.addDummyNode(g, \"edge\", attrs, \"_d\");\n    if (vRank === labelRank) {\n      attrs.width = edgeLabel.width;\n      attrs.height = edgeLabel.height;\n      attrs.dummy = \"edge-label\";\n      attrs.labelpos = edgeLabel.labelpos;\n    }\n    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);\n    if (i === 0) {\n      g.graph().dummyChains.push(dummy);\n    }\n    v = dummy;\n  }\n\n  g.setEdge(v, w, { weight: edgeLabel.weight }, name);\n}\n\nfunction undo(g) {\n  _.forEach(g.graph().dummyChains, function(v) {\n    var node = g.node(v);\n    var origLabel = node.edgeLabel;\n    var w;\n    g.setEdge(node.edgeObj, origLabel);\n    while (node.dummy) {\n      w = g.successors(v)[0];\n      g.removeNode(v);\n      origLabel.points.push({ x: node.x, y: node.y });\n      if (node.dummy === \"edge-label\") {\n        origLabel.x = node.x;\n        origLabel.y = node.y;\n        origLabel.width = node.width;\n        origLabel.height = node.height;\n      }\n      v = w;\n      node = g.node(v);\n    }\n  });\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/add-subgraph-constraints.js\":\n/*!*******************************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/add-subgraph-constraints.js ***!\n  \\*******************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\n\nmodule.exports = addSubgraphConstraints;\n\nfunction addSubgraphConstraints(g, cg, vs) {\n  var prev = {},\n    rootPrev;\n\n  _.forEach(vs, function(v) {\n    var child = g.parent(v),\n      parent,\n      prevChild;\n    while (child) {\n      parent = g.parent(child);\n      if (parent) {\n        prevChild = prev[parent];\n        prev[parent] = child;\n      } else {\n        prevChild = rootPrev;\n        rootPrev = child;\n      }\n      if (prevChild && prevChild !== child) {\n        cg.setEdge(prevChild, child);\n        return;\n      }\n      child = parent;\n    }\n  });\n\n  /*\n  function dfs(v) {\n    var children = v ? g.children(v) : g.children();\n    if (children.length) {\n      var min = Number.POSITIVE_INFINITY,\n          subgraphs = [];\n      _.each(children, function(child) {\n        var childMin = dfs(child);\n        if (g.children(child).length) {\n          subgraphs.push({ v: child, order: childMin });\n        }\n        min = Math.min(min, childMin);\n      });\n      _.reduce(_.sortBy(subgraphs, \"order\"), function(prev, curr) {\n        cg.setEdge(prev.v, curr.v);\n        return curr;\n      });\n      return min;\n    }\n    return g.node(v).order;\n  }\n  dfs(undefined);\n  */\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/barycenter.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/barycenter.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\n\nmodule.exports = barycenter;\n\nfunction barycenter(g, movable) {\n  return _.map(movable, function(v) {\n    var inV = g.inEdges(v);\n    if (!inV.length) {\n      return { v: v };\n    } else {\n      var result = _.reduce(inV, function(acc, e) {\n        var edge = g.edge(e),\n          nodeU = g.node(e.v);\n        return {\n          sum: acc.sum + (edge.weight * nodeU.order),\n          weight: acc.weight + edge.weight\n        };\n      }, { sum: 0, weight: 0 });\n\n      return {\n        v: v,\n        barycenter: result.sum / result.weight,\n        weight: result.weight\n      };\n    }\n  });\n}\n\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/build-layer-graph.js\":\n/*!************************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/build-layer-graph.js ***!\n  \\************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar Graph = __webpack_require__(/*! ../graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").Graph;\n\nmodule.exports = buildLayerGraph;\n\n/*\n * Constructs a graph that can be used to sort a layer of nodes. The graph will\n * contain all base and subgraph nodes from the request layer in their original\n * hierarchy and any edges that are incident on these nodes and are of the type\n * requested by the \"relationship\" parameter.\n *\n * Nodes from the requested rank that do not have parents are assigned a root\n * node in the output graph, which is set in the root graph attribute. This\n * makes it easy to walk the hierarchy of movable nodes during ordering.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG\n *    2. Base nodes in the input graph have a rank attribute\n *    3. Subgraph nodes in the input graph has minRank and maxRank attributes\n *    4. Edges have an assigned weight\n *\n * Post-conditions:\n *\n *    1. Output graph has all nodes in the movable rank with preserved\n *       hierarchy.\n *    2. Root nodes in the movable layer are made children of the node\n *       indicated by the root attribute of the graph.\n *    3. Non-movable nodes incident on movable nodes, selected by the\n *       relationship parameter, are included in the graph (without hierarchy).\n *    4. Edges incident on movable nodes, selected by the relationship\n *       parameter, are added to the output graph.\n *    5. The weights for copied edges are aggregated as need, since the output\n *       graph is not a multi-graph.\n */\nfunction buildLayerGraph(g, rank, relationship) {\n  var root = createRootNode(g),\n    result = new Graph({ compound: true }).setGraph({ root: root })\n      .setDefaultNodeLabel(function(v) { return g.node(v); });\n\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v),\n      parent = g.parent(v);\n\n    if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {\n      result.setNode(v);\n      result.setParent(v, parent || root);\n\n      // This assumes we have only short edges!\n      _.forEach(g[relationship](v), function(e) {\n        var u = e.v === v ? e.w : e.v,\n          edge = result.edge(u, v),\n          weight = !_.isUndefined(edge) ? edge.weight : 0;\n        result.setEdge(u, v, { weight: g.edge(e).weight + weight });\n      });\n\n      if (_.has(node, \"minRank\")) {\n        result.setNode(v, {\n          borderLeft: node.borderLeft[rank],\n          borderRight: node.borderRight[rank]\n        });\n      }\n    }\n  });\n\n  return result;\n}\n\nfunction createRootNode(g) {\n  var v;\n  while (g.hasNode((v = _.uniqueId(\"_root\"))));\n  return v;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/cross-count.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/cross-count.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\n\nmodule.exports = crossCount;\n\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nfunction crossCount(g, layering) {\n  var cc = 0;\n  for (var i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i-1], layering[i]);\n  }\n  return cc;\n}\n\nfunction twoLayerCrossCount(g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  var southPos = _.zipObject(southLayer,\n    _.map(southLayer, function (v, i) { return i; }));\n  var southEntries = _.flatten(_.map(northLayer, function(v) {\n    return _.sortBy(_.map(g.outEdges(v), function(e) {\n      return { pos: southPos[e.w], weight: g.edge(e).weight };\n    }), \"pos\");\n  }), true);\n\n  // Build the accumulator tree\n  var firstIndex = 1;\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n  var treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  var tree = _.map(new Array(treeSize), function() { return 0; });\n\n  // Calculate the weighted crossings\n  var cc = 0;\n  _.forEach(southEntries.forEach(function(entry) {\n    var index = entry.pos + firstIndex;\n    tree[index] += entry.weight;\n    var weightSum = 0;\n    while (index > 0) {\n      if (index % 2) {\n        weightSum += tree[index + 1];\n      }\n      index = (index - 1) >> 1;\n      tree[index] += entry.weight;\n    }\n    cc += entry.weight * weightSum;\n  }));\n\n  return cc;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/index.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/index.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar initOrder = __webpack_require__(/*! ./init-order */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/init-order.js\");\nvar crossCount = __webpack_require__(/*! ./cross-count */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/cross-count.js\");\nvar sortSubgraph = __webpack_require__(/*! ./sort-subgraph */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/sort-subgraph.js\");\nvar buildLayerGraph = __webpack_require__(/*! ./build-layer-graph */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/build-layer-graph.js\");\nvar addSubgraphConstraints = __webpack_require__(/*! ./add-subgraph-constraints */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/add-subgraph-constraints.js\");\nvar Graph = __webpack_require__(/*! ../graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").Graph;\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\n\nmodule.exports = order;\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order(g) {\n  var maxRank = util.maxRank(g),\n    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), \"inEdges\"),\n    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), \"outEdges\");\n\n  var layering = initOrder(g);\n  assignOrder(g, layering);\n\n  var bestCC = Number.POSITIVE_INFINITY,\n    best;\n\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n\n    layering = util.buildLayerMatrix(g);\n    var cc = crossCount(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = _.cloneDeep(layering);\n      bestCC = cc;\n    }\n  }\n\n  assignOrder(g, best);\n}\n\nfunction buildLayerGraphs(g, ranks, relationship) {\n  return _.map(ranks, function(rank) {\n    return buildLayerGraph(g, rank, relationship);\n  });\n}\n\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n  var cg = new Graph();\n  _.forEach(layerGraphs, function(lg) {\n    var root = lg.graph().root;\n    var sorted = sortSubgraph(lg, root, cg, biasRight);\n    _.forEach(sorted.vs, function(v, i) {\n      lg.node(v).order = i;\n    });\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n}\n\nfunction assignOrder(g, layering) {\n  _.forEach(layering, function(layer) {\n    _.forEach(layer, function(v, i) {\n      g.node(v).order = i;\n    });\n  });\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/init-order.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/init-order.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\n\nmodule.exports = initOrder;\n\n/*\n * Assigns an initial order value for each node by performing a DFS search\n * starting from nodes in the first rank. Nodes are assigned an order in their\n * rank as they are first visited.\n *\n * This approach comes from Gansner, et al., \"A Technique for Drawing Directed\n * Graphs.\"\n *\n * Returns a layering matrix with an array per layer and each layer sorted by\n * the order of its nodes.\n */\nfunction initOrder(g) {\n  var visited = {};\n  var simpleNodes = _.filter(g.nodes(), function(v) {\n    return !g.children(v).length;\n  });\n  var maxRank = _.max(_.map(simpleNodes, function(v) { return g.node(v).rank; }));\n  var layers = _.map(_.range(maxRank + 1), function() { return []; });\n\n  function dfs(v) {\n    if (_.has(visited, v)) return;\n    visited[v] = true;\n    var node = g.node(v);\n    layers[node.rank].push(v);\n    _.forEach(g.successors(v), dfs);\n  }\n\n  var orderedVs = _.sortBy(simpleNodes, function(v) { return g.node(v).rank; });\n  _.forEach(orderedVs, dfs);\n\n  return layers;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/resolve-conflicts.js\":\n/*!************************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/resolve-conflicts.js ***!\n  \\************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\n\nmodule.exports = resolveConflicts;\n\n/*\n * Given a list of entries of the form {v, barycenter, weight} and a\n * constraint graph this function will resolve any conflicts between the\n * constraint graph and the barycenters for the entries. If the barycenters for\n * an entry would violate a constraint in the constraint graph then we coalesce\n * the nodes in the conflict into a new node that respects the contraint and\n * aggregates barycenter and weight information.\n *\n * This implementation is based on the description in Forster, \"A Fast and\n * Simple Hueristic for Constrained Two-Level Crossing Reduction,\" thought it\n * differs in some specific details.\n *\n * Pre-conditions:\n *\n *    1. Each entry has the form {v, barycenter, weight}, or if the node has\n *       no barycenter, then {v}.\n *\n * Returns:\n *\n *    A new list of entries of the form {vs, i, barycenter, weight}. The list\n *    `vs` may either be a singleton or it may be an aggregation of nodes\n *    ordered such that they do not violate constraints from the constraint\n *    graph. The property `i` is the lowest original index of any of the\n *    elements in `vs`.\n */\nfunction resolveConflicts(entries, cg) {\n  var mappedEntries = {};\n  _.forEach(entries, function(entry, i) {\n    var tmp = mappedEntries[entry.v] = {\n      indegree: 0,\n      \"in\": [],\n      out: [],\n      vs: [entry.v],\n      i: i\n    };\n    if (!_.isUndefined(entry.barycenter)) {\n      tmp.barycenter = entry.barycenter;\n      tmp.weight = entry.weight;\n    }\n  });\n\n  _.forEach(cg.edges(), function(e) {\n    var entryV = mappedEntries[e.v];\n    var entryW = mappedEntries[e.w];\n    if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {\n      entryW.indegree++;\n      entryV.out.push(mappedEntries[e.w]);\n    }\n  });\n\n  var sourceSet = _.filter(mappedEntries, function(entry) {\n    return !entry.indegree;\n  });\n\n  return doResolveConflicts(sourceSet);\n}\n\nfunction doResolveConflicts(sourceSet) {\n  var entries = [];\n\n  function handleIn(vEntry) {\n    return function(uEntry) {\n      if (uEntry.merged) {\n        return;\n      }\n      if (_.isUndefined(uEntry.barycenter) ||\n          _.isUndefined(vEntry.barycenter) ||\n          uEntry.barycenter >= vEntry.barycenter) {\n        mergeEntries(vEntry, uEntry);\n      }\n    };\n  }\n\n  function handleOut(vEntry) {\n    return function(wEntry) {\n      wEntry[\"in\"].push(vEntry);\n      if (--wEntry.indegree === 0) {\n        sourceSet.push(wEntry);\n      }\n    };\n  }\n\n  while (sourceSet.length) {\n    var entry = sourceSet.pop();\n    entries.push(entry);\n    _.forEach(entry[\"in\"].reverse(), handleIn(entry));\n    _.forEach(entry.out, handleOut(entry));\n  }\n\n  return _.map(_.filter(entries, function(entry) { return !entry.merged; }),\n    function(entry) {\n      return _.pick(entry, [\"vs\", \"i\", \"barycenter\", \"weight\"]);\n    });\n\n}\n\nfunction mergeEntries(target, source) {\n  var sum = 0;\n  var weight = 0;\n\n  if (target.weight) {\n    sum += target.barycenter * target.weight;\n    weight += target.weight;\n  }\n\n  if (source.weight) {\n    sum += source.barycenter * source.weight;\n    weight += source.weight;\n  }\n\n  target.vs = source.vs.concat(target.vs);\n  target.barycenter = sum / weight;\n  target.weight = weight;\n  target.i = Math.min(source.i, target.i);\n  source.merged = true;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/sort-subgraph.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/sort-subgraph.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar barycenter = __webpack_require__(/*! ./barycenter */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/barycenter.js\");\nvar resolveConflicts = __webpack_require__(/*! ./resolve-conflicts */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/resolve-conflicts.js\");\nvar sort = __webpack_require__(/*! ./sort */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/sort.js\");\n\nmodule.exports = sortSubgraph;\n\nfunction sortSubgraph(g, v, cg, biasRight) {\n  var movable = g.children(v);\n  var node = g.node(v);\n  var bl = node ? node.borderLeft : undefined;\n  var br = node ? node.borderRight: undefined;\n  var subgraphs = {};\n\n  if (bl) {\n    movable = _.filter(movable, function(w) {\n      return w !== bl && w !== br;\n    });\n  }\n\n  var barycenters = barycenter(g, movable);\n  _.forEach(barycenters, function(entry) {\n    if (g.children(entry.v).length) {\n      var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);\n      subgraphs[entry.v] = subgraphResult;\n      if (_.has(subgraphResult, \"barycenter\")) {\n        mergeBarycenters(entry, subgraphResult);\n      }\n    }\n  });\n\n  var entries = resolveConflicts(barycenters, cg);\n  expandSubgraphs(entries, subgraphs);\n\n  var result = sort(entries, biasRight);\n\n  if (bl) {\n    result.vs = _.flatten([bl, result.vs, br], true);\n    if (g.predecessors(bl).length) {\n      var blPred = g.node(g.predecessors(bl)[0]),\n        brPred = g.node(g.predecessors(br)[0]);\n      if (!_.has(result, \"barycenter\")) {\n        result.barycenter = 0;\n        result.weight = 0;\n      }\n      result.barycenter = (result.barycenter * result.weight +\n                           blPred.order + brPred.order) / (result.weight + 2);\n      result.weight += 2;\n    }\n  }\n\n  return result;\n}\n\nfunction expandSubgraphs(entries, subgraphs) {\n  _.forEach(entries, function(entry) {\n    entry.vs = _.flatten(entry.vs.map(function(v) {\n      if (subgraphs[v]) {\n        return subgraphs[v].vs;\n      }\n      return v;\n    }), true);\n  });\n}\n\nfunction mergeBarycenters(target, other) {\n  if (!_.isUndefined(target.barycenter)) {\n    target.barycenter = (target.barycenter * target.weight +\n                         other.barycenter * other.weight) /\n                        (target.weight + other.weight);\n    target.weight += other.weight;\n  } else {\n    target.barycenter = other.barycenter;\n    target.weight = other.weight;\n  }\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/sort.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/sort.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\n\nmodule.exports = sort;\n\nfunction sort(entries, biasRight) {\n  var parts = util.partition(entries, function(entry) {\n    return _.has(entry, \"barycenter\");\n  });\n  var sortable = parts.lhs,\n    unsortable = _.sortBy(parts.rhs, function(entry) { return -entry.i; }),\n    vs = [],\n    sum = 0,\n    weight = 0,\n    vsIndex = 0;\n\n  sortable.sort(compareWithBias(!!biasRight));\n\n  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n\n  _.forEach(sortable, function (entry) {\n    vsIndex += entry.vs.length;\n    vs.push(entry.vs);\n    sum += entry.barycenter * entry.weight;\n    weight += entry.weight;\n    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n  });\n\n  var result = { vs: _.flatten(vs, true) };\n  if (weight) {\n    result.barycenter = sum / weight;\n    result.weight = weight;\n  }\n  return result;\n}\n\nfunction consumeUnsortable(vs, unsortable, index) {\n  var last;\n  while (unsortable.length && (last = _.last(unsortable)).i <= index) {\n    unsortable.pop();\n    vs.push(last.vs);\n    index++;\n  }\n  return index;\n}\n\nfunction compareWithBias(bias) {\n  return function(entryV, entryW) {\n    if (entryV.barycenter < entryW.barycenter) {\n      return -1;\n    } else if (entryV.barycenter > entryW.barycenter) {\n      return 1;\n    }\n\n    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;\n  };\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/parent-dummy-chains.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/parent-dummy-chains.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\n\nmodule.exports = parentDummyChains;\n\nfunction parentDummyChains(g) {\n  var postorderNums = postorder(g);\n\n  _.forEach(g.graph().dummyChains, function(v) {\n    var node = g.node(v);\n    var edgeObj = node.edgeObj;\n    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);\n    var path = pathData.path;\n    var lca = pathData.lca;\n    var pathIdx = 0;\n    var pathV = path[pathIdx];\n    var ascending = true;\n\n    while (v !== edgeObj.w) {\n      node = g.node(v);\n\n      if (ascending) {\n        while ((pathV = path[pathIdx]) !== lca &&\n               g.node(pathV).maxRank < node.rank) {\n          pathIdx++;\n        }\n\n        if (pathV === lca) {\n          ascending = false;\n        }\n      }\n\n      if (!ascending) {\n        while (pathIdx < path.length - 1 &&\n               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {\n          pathIdx++;\n        }\n        pathV = path[pathIdx];\n      }\n\n      g.setParent(v, pathV);\n      v = g.successors(v)[0];\n    }\n  });\n}\n\n// Find a path from v to w through the lowest common ancestor (LCA). Return the\n// full path and the LCA.\nfunction findPath(g, postorderNums, v, w) {\n  var vPath = [];\n  var wPath = [];\n  var low = Math.min(postorderNums[v].low, postorderNums[w].low);\n  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);\n  var parent;\n  var lca;\n\n  // Traverse up from v to find the LCA\n  parent = v;\n  do {\n    parent = g.parent(parent);\n    vPath.push(parent);\n  } while (parent &&\n           (postorderNums[parent].low > low || lim > postorderNums[parent].lim));\n  lca = parent;\n\n  // Traverse from w to LCA\n  parent = w;\n  while ((parent = g.parent(parent)) !== lca) {\n    wPath.push(parent);\n  }\n\n  return { path: vPath.concat(wPath.reverse()), lca: lca };\n}\n\nfunction postorder(g) {\n  var result = {};\n  var lim = 0;\n\n  function dfs(v) {\n    var low = lim;\n    _.forEach(g.children(v), dfs);\n    result[v] = { low: low, lim: lim++ };\n  }\n  _.forEach(g.children(), dfs);\n\n  return result;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/position/bk.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/position/bk.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar Graph = __webpack_require__(/*! ../graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").Graph;\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\n\n/*\n * This module provides coordinate assignment based on Brandes and Köpf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n\nmodule.exports = {\n  positionX: positionX,\n  findType1Conflicts: findType1Conflicts,\n  findType2Conflicts: findType2Conflicts,\n  addConflict: addConflict,\n  hasConflict: hasConflict,\n  verticalAlignment: verticalAlignment,\n  horizontalCompaction: horizontalCompaction,\n  alignCoordinates: alignCoordinates,\n  findSmallestWidthAlignment: findSmallestWidthAlignment,\n  balance: balance\n};\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\nfunction findType1Conflicts(g, layering) {\n  var conflicts = {};\n\n  function visitLayer(prevLayer, layer) {\n    var\n      // last visited node in the previous layer that is incident on an inner\n      // segment.\n      k0 = 0,\n      // Tracks the last node in this layer scanned for crossings with a type-1\n      // segment.\n      scanPos = 0,\n      prevLayerLength = prevLayer.length,\n      lastNode = _.last(layer);\n\n    _.forEach(layer, function(v, i) {\n      var w = findOtherInnerSegmentNode(g, v),\n        k1 = w ? g.node(w).order : prevLayerLength;\n\n      if (w || v === lastNode) {\n        _.forEach(layer.slice(scanPos, i +1), function(scanNode) {\n          _.forEach(g.predecessors(scanNode), function(u) {\n            var uLabel = g.node(u),\n              uPos = uLabel.order;\n            if ((uPos < k0 || k1 < uPos) &&\n                !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode);\n            }\n          });\n        });\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n\n    return layer;\n  }\n\n  _.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findType2Conflicts(g, layering) {\n  var conflicts = {};\n\n  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    var v;\n    _.forEach(_.range(southPos, southEnd), function(i) {\n      v = south[i];\n      if (g.node(v).dummy) {\n        _.forEach(g.predecessors(v), function(u) {\n          var uNode = g.node(u);\n          if (uNode.dummy &&\n              (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v);\n          }\n        });\n      }\n    });\n  }\n\n\n  function visitLayer(north, south) {\n    var prevNorthPos = -1,\n      nextNorthPos,\n      southPos = 0;\n\n    _.forEach(south, function(v, southLookahead) {\n      if (g.node(v).dummy === \"border\") {\n        var predecessors = g.predecessors(v);\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n\n    return south;\n  }\n\n  _.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findOtherInnerSegmentNode(g, v) {\n  if (g.node(v).dummy) {\n    return _.find(g.predecessors(v), function(u) {\n      return g.node(u).dummy;\n    });\n  }\n}\n\nfunction addConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n\n  var conflictsV = conflicts[v];\n  if (!conflictsV) {\n    conflicts[v] = conflictsV = {};\n  }\n  conflictsV[w] = true;\n}\n\nfunction hasConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  return _.has(conflicts[v], w);\n}\n\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nfunction verticalAlignment(g, layering, conflicts, neighborFn) {\n  var root = {},\n    align = {},\n    pos = {};\n\n  // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n  _.forEach(layering, function(layer) {\n    _.forEach(layer, function(v, order) {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n\n  _.forEach(layering, function(layer) {\n    var prevIdx = -1;\n    _.forEach(layer, function(v) {\n      var ws = neighborFn(v);\n      if (ws.length) {\n        ws = _.sortBy(ws, function(w) { return pos[w]; });\n        var mp = (ws.length - 1) / 2;\n        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          var w = ws[i];\n          if (align[v] === v &&\n              prevIdx < pos[w] &&\n              !hasConflict(conflicts, v, w)) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n\n  return { root: root, align: align };\n}\n\nfunction horizontalCompaction(g, layering, root, align, reverseSep) {\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  var xs = {},\n    blockG = buildBlockGraph(g, layering, root, reverseSep),\n    borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\n\n  function iterate(setXsFunc, nextNodesFunc) {\n    var stack = blockG.nodes();\n    var elem = stack.pop();\n    var visited = {};\n    while (elem) {\n      if (visited[elem]) {\n        setXsFunc(elem);\n      } else {\n        visited[elem] = true;\n        stack.push(elem);\n        stack = stack.concat(nextNodesFunc(elem));\n      }\n\n      elem = stack.pop();\n    }\n  }\n\n  // First pass, assign smallest coordinates\n  function pass1(elem) {\n    xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {\n      return Math.max(acc, xs[e.v] + blockG.edge(e));\n    }, 0);\n  }\n\n  // Second pass, assign greatest coordinates\n  function pass2(elem) {\n    var min = blockG.outEdges(elem).reduce(function(acc, e) {\n      return Math.min(acc, xs[e.w] - blockG.edge(e));\n    }, Number.POSITIVE_INFINITY);\n\n    var node = g.node(elem);\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n      xs[elem] = Math.max(xs[elem], min);\n    }\n  }\n\n  iterate(pass1, blockG.predecessors.bind(blockG));\n  iterate(pass2, blockG.successors.bind(blockG));\n\n  // Assign x coordinates to all nodes\n  _.forEach(align, function(v) {\n    xs[v] = xs[root[v]];\n  });\n\n  return xs;\n}\n\n\nfunction buildBlockGraph(g, layering, root, reverseSep) {\n  var blockGraph = new Graph(),\n    graphLabel = g.graph(),\n    sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n\n  _.forEach(layering, function(layer) {\n    var u;\n    _.forEach(layer, function(v) {\n      var vRoot = root[v];\n      blockGraph.setNode(vRoot);\n      if (u) {\n        var uRoot = root[u],\n          prevMax = blockGraph.edge(uRoot, vRoot);\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n      }\n      u = v;\n    });\n  });\n\n  return blockGraph;\n}\n\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nfunction findSmallestWidthAlignment(g, xss) {\n  return _.minBy(_.values(xss), function (xs) {\n    var max = Number.NEGATIVE_INFINITY;\n    var min = Number.POSITIVE_INFINITY;\n\n    _.forIn(xs, function (x, v) {\n      var halfWidth = width(g, v) / 2;\n\n      max = Math.max(x + halfWidth, max);\n      min = Math.min(x - halfWidth, min);\n    });\n\n    return max - min;\n  });\n}\n\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nfunction alignCoordinates(xss, alignTo) {\n  var alignToVals = _.values(alignTo),\n    alignToMin = _.min(alignToVals),\n    alignToMax = _.max(alignToVals);\n\n  _.forEach([\"u\", \"d\"], function(vert) {\n    _.forEach([\"l\", \"r\"], function(horiz) {\n      var alignment = vert + horiz,\n        xs = xss[alignment],\n        delta;\n      if (xs === alignTo) return;\n\n      var xsVals = _.values(xs);\n      delta = horiz === \"l\" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);\n\n      if (delta) {\n        xss[alignment] = _.mapValues(xs, function(x) { return x + delta; });\n      }\n    });\n  });\n}\n\nfunction balance(xss, align) {\n  return _.mapValues(xss.ul, function(ignore, v) {\n    if (align) {\n      return xss[align.toLowerCase()][v];\n    } else {\n      var xs = _.sortBy(_.map(xss, v));\n      return (xs[1] + xs[2]) / 2;\n    }\n  });\n}\n\nfunction positionX(g) {\n  var layering = util.buildLayerMatrix(g);\n  var conflicts = _.merge(\n    findType1Conflicts(g, layering),\n    findType2Conflicts(g, layering));\n\n  var xss = {};\n  var adjustedLayering;\n  _.forEach([\"u\", \"d\"], function(vert) {\n    adjustedLayering = vert === \"u\" ? layering : _.values(layering).reverse();\n    _.forEach([\"l\", \"r\"], function(horiz) {\n      if (horiz === \"r\") {\n        adjustedLayering = _.map(adjustedLayering, function(inner) {\n          return _.values(inner).reverse();\n        });\n      }\n\n      var neighborFn = (vert === \"u\" ? g.predecessors : g.successors).bind(g);\n      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);\n      var xs = horizontalCompaction(g, adjustedLayering,\n        align.root, align.align, horiz === \"r\");\n      if (horiz === \"r\") {\n        xs = _.mapValues(xs, function(x) { return -x; });\n      }\n      xss[vert + horiz] = xs;\n    });\n  });\n\n  var smallestWidth = findSmallestWidthAlignment(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return balance(xss, g.graph().align);\n}\n\nfunction sep(nodeSep, edgeSep, reverseSep) {\n  return function(g, v, w) {\n    var vLabel = g.node(v);\n    var wLabel = g.node(w);\n    var sum = 0;\n    var delta;\n\n    sum += vLabel.width / 2;\n    if (_.has(vLabel, \"labelpos\")) {\n      switch (vLabel.labelpos.toLowerCase()) {\n      case \"l\": delta = -vLabel.width / 2; break;\n      case \"r\": delta = vLabel.width / 2; break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n\n    sum += wLabel.width / 2;\n    if (_.has(wLabel, \"labelpos\")) {\n      switch (wLabel.labelpos.toLowerCase()) {\n      case \"l\": delta = wLabel.width / 2; break;\n      case \"r\": delta = -wLabel.width / 2; break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    return sum;\n  };\n}\n\nfunction width(g, v) {\n  return g.node(v).width;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/position/index.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/position/index.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\nvar positionX = __webpack_require__(/*! ./bk */ \"./node_modules/_dagre@0.8.5@dagre/lib/position/bk.js\").positionX;\n\nmodule.exports = position;\n\nfunction position(g) {\n  g = util.asNonCompoundGraph(g);\n\n  positionY(g);\n  _.forEach(positionX(g), function(x, v) {\n    g.node(v).x = x;\n  });\n}\n\nfunction positionY(g) {\n  var layering = util.buildLayerMatrix(g);\n  var rankSep = g.graph().ranksep;\n  var prevY = 0;\n  _.forEach(layering, function(layer) {\n    var maxHeight = _.max(_.map(layer, function(v) { return g.node(v).height; }));\n    _.forEach(layer, function(v) {\n      g.node(v).y = prevY + maxHeight / 2;\n    });\n    prevY += maxHeight + rankSep;\n  });\n}\n\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/feasible-tree.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/rank/feasible-tree.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar Graph = __webpack_require__(/*! ../graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").Graph;\nvar slack = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js\").slack;\n\nmodule.exports = feasibleTree;\n\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nfunction feasibleTree(g) {\n  var t = new Graph({ directed: false });\n\n  // Choose arbitrary node from which to start our tree\n  var start = g.nodes()[0];\n  var size = g.nodeCount();\n  t.setNode(start, {});\n\n  var edge, delta;\n  while (tightTree(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);\n    shiftRanks(t, g, delta);\n  }\n\n  return t;\n}\n\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nfunction tightTree(t, g) {\n  function dfs(v) {\n    _.forEach(g.nodeEdges(v), function(e) {\n      var edgeV = e.v,\n        w = (v === edgeV) ? e.w : edgeV;\n      if (!t.hasNode(w) && !slack(g, e)) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  }\n\n  _.forEach(t.nodes(), dfs);\n  return t.nodeCount();\n}\n\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\nfunction findMinSlackEdge(t, g) {\n  return _.minBy(g.edges(), function(e) {\n    if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n      return slack(g, e);\n    }\n  });\n}\n\nfunction shiftRanks(t, g, delta) {\n  _.forEach(t.nodes(), function(v) {\n    g.node(v).rank += delta;\n  });\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/index.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/rank/index.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar rankUtil = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js\");\nvar longestPath = rankUtil.longestPath;\nvar feasibleTree = __webpack_require__(/*! ./feasible-tree */ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/feasible-tree.js\");\nvar networkSimplex = __webpack_require__(/*! ./network-simplex */ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/network-simplex.js\");\n\nmodule.exports = rank;\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nfunction rank(g) {\n  switch(g.graph().ranker) {\n  case \"network-simplex\": networkSimplexRanker(g); break;\n  case \"tight-tree\": tightTreeRanker(g); break;\n  case \"longest-path\": longestPathRanker(g); break;\n  default: networkSimplexRanker(g);\n  }\n}\n\n// A fast and simple ranker, but results are far from optimal.\nvar longestPathRanker = longestPath;\n\nfunction tightTreeRanker(g) {\n  longestPath(g);\n  feasibleTree(g);\n}\n\nfunction networkSimplexRanker(g) {\n  networkSimplex(g);\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/network-simplex.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/rank/network-simplex.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar feasibleTree = __webpack_require__(/*! ./feasible-tree */ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/feasible-tree.js\");\nvar slack = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js\").slack;\nvar initRank = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js\").longestPath;\nvar preorder = __webpack_require__(/*! ../graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").alg.preorder;\nvar postorder = __webpack_require__(/*! ../graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").alg.postorder;\nvar simplify = __webpack_require__(/*! ../util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\").simplify;\n\nmodule.exports = networkSimplex;\n\n// Expose some internals for testing purposes\nnetworkSimplex.initLowLimValues = initLowLimValues;\nnetworkSimplex.initCutValues = initCutValues;\nnetworkSimplex.calcCutValue = calcCutValue;\nnetworkSimplex.leaveEdge = leaveEdge;\nnetworkSimplex.enterEdge = enterEdge;\nnetworkSimplex.exchangeEdges = exchangeEdges;\n\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nfunction networkSimplex(g) {\n  g = simplify(g);\n  initRank(g);\n  var t = feasibleTree(g);\n  initLowLimValues(t);\n  initCutValues(t, g);\n\n  var e, f;\n  while ((e = leaveEdge(t))) {\n    f = enterEdge(t, g, e);\n    exchangeEdges(t, g, e, f);\n  }\n}\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nfunction initCutValues(t, g) {\n  var vs = postorder(t, t.nodes());\n  vs = vs.slice(0, vs.length - 1);\n  _.forEach(vs, function(v) {\n    assignCutValue(t, g, v);\n  });\n}\n\nfunction assignCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);\n}\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nfunction calcCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  // True if the child is on the tail end of the edge in the directed graph\n  var childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  var graphEdge = g.edge(child, parent);\n  // The accumulated cut value for the edge between this node and its parent\n  var cutValue = 0;\n\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edge(parent, child);\n  }\n\n  cutValue = graphEdge.weight;\n\n  _.forEach(g.nodeEdges(child), function(e) {\n    var isOutEdge = e.v === child,\n      other = isOutEdge ? e.w : e.v;\n\n    if (other !== parent) {\n      var pointsToHead = isOutEdge === childIsTail,\n        otherWeight = g.edge(e).weight;\n\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n      if (isTreeEdge(t, child, other)) {\n        var otherCutValue = t.edge(child, other).cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n\n  return cutValue;\n}\n\nfunction initLowLimValues(tree, root) {\n  if (arguments.length < 2) {\n    root = tree.nodes()[0];\n  }\n  dfsAssignLowLim(tree, {}, 1, root);\n}\n\nfunction dfsAssignLowLim(tree, visited, nextLim, v, parent) {\n  var low = nextLim;\n  var label = tree.node(v);\n\n  visited[v] = true;\n  _.forEach(tree.neighbors(v), function(w) {\n    if (!_.has(visited, w)) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);\n    }\n  });\n\n  label.low = low;\n  label.lim = nextLim++;\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n\n  return nextLim;\n}\n\nfunction leaveEdge(tree) {\n  return _.find(tree.edges(), function(e) {\n    return tree.edge(e).cutvalue < 0;\n  });\n}\n\nfunction enterEdge(t, g, edge) {\n  var v = edge.v;\n  var w = edge.w;\n\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n\n  var vLabel = t.node(v);\n  var wLabel = t.node(w);\n  var tailLabel = vLabel;\n  var flip = false;\n\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n\n  var candidates = _.filter(g.edges(), function(edge) {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&\n           flip !== isDescendant(t, t.node(edge.w), tailLabel);\n  });\n\n  return _.minBy(candidates, function(edge) { return slack(g, edge); });\n}\n\nfunction exchangeEdges(t, g, e, f) {\n  var v = e.v;\n  var w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  initLowLimValues(t);\n  initCutValues(t, g);\n  updateRanks(t, g);\n}\n\nfunction updateRanks(t, g) {\n  var root = _.find(t.nodes(), function(v) { return !g.node(v).parent; });\n  var vs = preorder(t, root);\n  vs = vs.slice(1);\n  _.forEach(vs, function(v) {\n    var parent = t.node(v).parent,\n      edge = g.edge(v, parent),\n      flipped = false;\n\n    if (!edge) {\n      edge = g.edge(parent, v);\n      flipped = true;\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n  });\n}\n\n/*\n * Returns true if the edge is in the tree.\n */\nfunction isTreeEdge(tree, u, v) {\n  return tree.hasEdge(u, v);\n}\n\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nfunction isDescendant(tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\n\nmodule.exports = {\n  longestPath: longestPath,\n  slack: slack\n};\n\n/*\n * Initializes ranks for the input graph using the longest path algorithm. This\n * algorithm scales well and is fast in practice, it yields rather poor\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\n * ranks wide and leaving edges longer than necessary. However, due to its\n * speed, this algorithm is good for getting an initial ranking that can be fed\n * into other algorithms.\n *\n * This algorithm does not normalize layers because it will be used by other\n * algorithms in most cases. If using this algorithm directly, be sure to\n * run normalize at the end.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG.\n *    2. Input graph node labels can be assigned properties.\n *\n * Post-conditions:\n *\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\n */\nfunction longestPath(g) {\n  var visited = {};\n\n  function dfs(v) {\n    var label = g.node(v);\n    if (_.has(visited, v)) {\n      return label.rank;\n    }\n    visited[v] = true;\n\n    var rank = _.min(_.map(g.outEdges(v), function(e) {\n      return dfs(e.w) - g.edge(e).minlen;\n    }));\n\n    if (rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3\n        rank === undefined || // return value of _.map([]) for Lodash 4\n        rank === null) { // return value of _.map([null])\n      rank = 0;\n    }\n\n    return (label.rank = rank);\n  }\n\n  _.forEach(g.sources(), dfs);\n}\n\n/*\n * Returns the amount of slack for the given edge. The slack is defined as the\n * difference between the length of the edge and its minimum length.\n */\nfunction slack(g, e) {\n  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/util.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* eslint \"no-console\": off */\n\n\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar Graph = __webpack_require__(/*! ./graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").Graph;\n\nmodule.exports = {\n  addDummyNode: addDummyNode,\n  simplify: simplify,\n  asNonCompoundGraph: asNonCompoundGraph,\n  successorWeights: successorWeights,\n  predecessorWeights: predecessorWeights,\n  intersectRect: intersectRect,\n  buildLayerMatrix: buildLayerMatrix,\n  normalizeRanks: normalizeRanks,\n  removeEmptyRanks: removeEmptyRanks,\n  addBorderNode: addBorderNode,\n  maxRank: maxRank,\n  partition: partition,\n  time: time,\n  notime: notime\n};\n\n/*\n * Adds a dummy node to the graph and return v.\n */\nfunction addDummyNode(g, type, attrs, name) {\n  var v;\n  do {\n    v = _.uniqueId(name);\n  } while (g.hasNode(v));\n\n  attrs.dummy = type;\n  g.setNode(v, attrs);\n  return v;\n}\n\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\nfunction simplify(g) {\n  var simplified = new Graph().setGraph(g.graph());\n  _.forEach(g.nodes(), function(v) { simplified.setNode(v, g.node(v)); });\n  _.forEach(g.edges(), function(e) {\n    var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };\n    var label = g.edge(e);\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight + label.weight,\n      minlen: Math.max(simpleLabel.minlen, label.minlen)\n    });\n  });\n  return simplified;\n}\n\nfunction asNonCompoundGraph(g) {\n  var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());\n  _.forEach(g.nodes(), function(v) {\n    if (!g.children(v).length) {\n      simplified.setNode(v, g.node(v));\n    }\n  });\n  _.forEach(g.edges(), function(e) {\n    simplified.setEdge(e, g.edge(e));\n  });\n  return simplified;\n}\n\nfunction successorWeights(g) {\n  var weightMap = _.map(g.nodes(), function(v) {\n    var sucs = {};\n    _.forEach(g.outEdges(v), function(e) {\n      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;\n    });\n    return sucs;\n  });\n  return _.zipObject(g.nodes(), weightMap);\n}\n\nfunction predecessorWeights(g) {\n  var weightMap = _.map(g.nodes(), function(v) {\n    var preds = {};\n    _.forEach(g.inEdges(v), function(e) {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;\n    });\n    return preds;\n  });\n  return _.zipObject(g.nodes(), weightMap);\n}\n\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\nfunction intersectRect(rect, point) {\n  var x = rect.x;\n  var y = rect.y;\n\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  var dx = point.x - x;\n  var dy = point.y - y;\n  var w = rect.width / 2;\n  var h = rect.height / 2;\n\n  if (!dx && !dy) {\n    throw new Error(\"Not possible to find intersection inside of the rectangle\");\n  }\n\n  var sx, sy;\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = h * dx / dy;\n    sy = h;\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = w * dy / dx;\n  }\n\n  return { x: x + sx, y: y + sy };\n}\n\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * function will produce a matrix with the ids of each node.\n */\nfunction buildLayerMatrix(g) {\n  var layering = _.map(_.range(maxRank(g) + 1), function() { return []; });\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    var rank = node.rank;\n    if (!_.isUndefined(rank)) {\n      layering[rank][node.order] = v;\n    }\n  });\n  return layering;\n}\n\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\nfunction normalizeRanks(g) {\n  var min = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    if (_.has(node, \"rank\")) {\n      node.rank -= min;\n    }\n  });\n}\n\nfunction removeEmptyRanks(g) {\n  // Ranks may not start at 0, so we need to offset them\n  var offset = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));\n\n  var layers = [];\n  _.forEach(g.nodes(), function(v) {\n    var rank = g.node(v).rank - offset;\n    if (!layers[rank]) {\n      layers[rank] = [];\n    }\n    layers[rank].push(v);\n  });\n\n  var delta = 0;\n  var nodeRankFactor = g.graph().nodeRankFactor;\n  _.forEach(layers, function(vs, i) {\n    if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {\n      --delta;\n    } else if (delta) {\n      _.forEach(vs, function(v) { g.node(v).rank += delta; });\n    }\n  });\n}\n\nfunction addBorderNode(g, prefix, rank, order) {\n  var node = {\n    width: 0,\n    height: 0\n  };\n  if (arguments.length >= 4) {\n    node.rank = rank;\n    node.order = order;\n  }\n  return addDummyNode(g, \"border\", node, prefix);\n}\n\nfunction maxRank(g) {\n  return _.max(_.map(g.nodes(), function(v) {\n    var rank = g.node(v).rank;\n    if (!_.isUndefined(rank)) {\n      return rank;\n    }\n  }));\n}\n\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * function returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\nfunction partition(collection, fn) {\n  var result = { lhs: [], rhs: [] };\n  _.forEach(collection, function(value) {\n    if (fn(value)) {\n      result.lhs.push(value);\n    } else {\n      result.rhs.push(value);\n    }\n  });\n  return result;\n}\n\n/*\n * Returns a new function that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\nfunction time(name, fn) {\n  var start = _.now();\n  try {\n    return fn();\n  } finally {\n    console.log(name + \" time: \" + (_.now() - start) + \"ms\");\n  }\n}\n\nfunction notime(name, fn) {\n  return fn();\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/version.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/version.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"0.8.5\";\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/index.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/index.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Copyright (c) 2014, Chris Pettitt\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its contributors\n * may be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar lib = __webpack_require__(/*! ./lib */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/index.js\");\n\nmodule.exports = {\n  Graph: lib.Graph,\n  json: __webpack_require__(/*! ./lib/json */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/json.js\"),\n  alg: __webpack_require__(/*! ./lib/alg */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/index.js\"),\n  version: lib.version\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/components.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/components.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\n\nmodule.exports = components;\n\nfunction components(g) {\n  var visited = {};\n  var cmpts = [];\n  var cmpt;\n\n  function dfs(v) {\n    if (_.has(visited, v)) return;\n    visited[v] = true;\n    cmpt.push(v);\n    _.each(g.successors(v), dfs);\n    _.each(g.predecessors(v), dfs);\n  }\n\n  _.each(g.nodes(), function(v) {\n    cmpt = [];\n    dfs(v);\n    if (cmpt.length) {\n      cmpts.push(cmpt);\n    }\n  });\n\n  return cmpts;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dfs.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dfs.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\n\nmodule.exports = dfs;\n\n/*\n * A helper that preforms a pre- or post-order traversal on the input graph\n * and returns the nodes in the order they were visited. If the graph is\n * undirected then this algorithm will navigate using neighbors. If the graph\n * is directed then this algorithm will navigate using successors.\n *\n * Order must be one of \"pre\" or \"post\".\n */\nfunction dfs(g, vs, order) {\n  if (!_.isArray(vs)) {\n    vs = [vs];\n  }\n\n  var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);\n\n  var acc = [];\n  var visited = {};\n  _.each(vs, function(v) {\n    if (!g.hasNode(v)) {\n      throw new Error(\"Graph does not have node: \" + v);\n    }\n\n    doDfs(g, v, order === \"post\", visited, navigation, acc);\n  });\n  return acc;\n}\n\nfunction doDfs(g, v, postorder, visited, navigation, acc) {\n  if (!_.has(visited, v)) {\n    visited[v] = true;\n\n    if (!postorder) { acc.push(v); }\n    _.each(navigation(v), function(w) {\n      doDfs(g, w, postorder, visited, navigation, acc);\n    });\n    if (postorder) { acc.push(v); }\n  }\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra-all.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra-all.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dijkstra = __webpack_require__(/*! ./dijkstra */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra.js\");\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\n\nmodule.exports = dijkstraAll;\n\nfunction dijkstraAll(g, weightFunc, edgeFunc) {\n  return _.transform(g.nodes(), function(acc, v) {\n    acc[v] = dijkstra(g, v, weightFunc, edgeFunc);\n  }, {});\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\nvar PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/data/priority-queue.js\");\n\nmodule.exports = dijkstra;\n\nvar DEFAULT_WEIGHT_FUNC = _.constant(1);\n\nfunction dijkstra(g, source, weightFn, edgeFn) {\n  return runDijkstra(g, String(source),\n    weightFn || DEFAULT_WEIGHT_FUNC,\n    edgeFn || function(v) { return g.outEdges(v); });\n}\n\nfunction runDijkstra(g, source, weightFn, edgeFn) {\n  var results = {};\n  var pq = new PriorityQueue();\n  var v, vEntry;\n\n  var updateNeighbors = function(edge) {\n    var w = edge.v !== v ? edge.v : edge.w;\n    var wEntry = results[w];\n    var weight = weightFn(edge);\n    var distance = vEntry.distance + weight;\n\n    if (weight < 0) {\n      throw new Error(\"dijkstra does not allow negative edge weights. \" +\n                      \"Bad edge: \" + edge + \" Weight: \" + weight);\n    }\n\n    if (distance < wEntry.distance) {\n      wEntry.distance = distance;\n      wEntry.predecessor = v;\n      pq.decrease(w, distance);\n    }\n  };\n\n  g.nodes().forEach(function(v) {\n    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;\n    results[v] = { distance: distance };\n    pq.add(v, distance);\n  });\n\n  while (pq.size() > 0) {\n    v = pq.removeMin();\n    vEntry = results[v];\n    if (vEntry.distance === Number.POSITIVE_INFINITY) {\n      break;\n    }\n\n    edgeFn(v).forEach(updateNeighbors);\n  }\n\n  return results;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/find-cycles.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/find-cycles.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\nvar tarjan = __webpack_require__(/*! ./tarjan */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/tarjan.js\");\n\nmodule.exports = findCycles;\n\nfunction findCycles(g) {\n  return _.filter(tarjan(g), function(cmpt) {\n    return cmpt.length > 1 || (cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]));\n  });\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/floyd-warshall.js\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/floyd-warshall.js ***!\n  \\*************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\n\nmodule.exports = floydWarshall;\n\nvar DEFAULT_WEIGHT_FUNC = _.constant(1);\n\nfunction floydWarshall(g, weightFn, edgeFn) {\n  return runFloydWarshall(g,\n    weightFn || DEFAULT_WEIGHT_FUNC,\n    edgeFn || function(v) { return g.outEdges(v); });\n}\n\nfunction runFloydWarshall(g, weightFn, edgeFn) {\n  var results = {};\n  var nodes = g.nodes();\n\n  nodes.forEach(function(v) {\n    results[v] = {};\n    results[v][v] = { distance: 0 };\n    nodes.forEach(function(w) {\n      if (v !== w) {\n        results[v][w] = { distance: Number.POSITIVE_INFINITY };\n      }\n    });\n    edgeFn(v).forEach(function(edge) {\n      var w = edge.v === v ? edge.w : edge.v;\n      var d = weightFn(edge);\n      results[v][w] = { distance: d, predecessor: v };\n    });\n  });\n\n  nodes.forEach(function(k) {\n    var rowK = results[k];\n    nodes.forEach(function(i) {\n      var rowI = results[i];\n      nodes.forEach(function(j) {\n        var ik = rowI[k];\n        var kj = rowK[j];\n        var ij = rowI[j];\n        var altDistance = ik.distance + kj.distance;\n        if (altDistance < ij.distance) {\n          ij.distance = altDistance;\n          ij.predecessor = kj.predecessor;\n        }\n      });\n    });\n  });\n\n  return results;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/index.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/index.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  components: __webpack_require__(/*! ./components */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/components.js\"),\n  dijkstra: __webpack_require__(/*! ./dijkstra */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra.js\"),\n  dijkstraAll: __webpack_require__(/*! ./dijkstra-all */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra-all.js\"),\n  findCycles: __webpack_require__(/*! ./find-cycles */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/find-cycles.js\"),\n  floydWarshall: __webpack_require__(/*! ./floyd-warshall */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/floyd-warshall.js\"),\n  isAcyclic: __webpack_require__(/*! ./is-acyclic */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/is-acyclic.js\"),\n  postorder: __webpack_require__(/*! ./postorder */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/postorder.js\"),\n  preorder: __webpack_require__(/*! ./preorder */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/preorder.js\"),\n  prim: __webpack_require__(/*! ./prim */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/prim.js\"),\n  tarjan: __webpack_require__(/*! ./tarjan */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/tarjan.js\"),\n  topsort: __webpack_require__(/*! ./topsort */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/topsort.js\")\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/is-acyclic.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/is-acyclic.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar topsort = __webpack_require__(/*! ./topsort */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/topsort.js\");\n\nmodule.exports = isAcyclic;\n\nfunction isAcyclic(g) {\n  try {\n    topsort(g);\n  } catch (e) {\n    if (e instanceof topsort.CycleException) {\n      return false;\n    }\n    throw e;\n  }\n  return true;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/postorder.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/postorder.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dfs = __webpack_require__(/*! ./dfs */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dfs.js\");\n\nmodule.exports = postorder;\n\nfunction postorder(g, vs) {\n  return dfs(g, vs, \"post\");\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/preorder.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/preorder.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dfs = __webpack_require__(/*! ./dfs */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dfs.js\");\n\nmodule.exports = preorder;\n\nfunction preorder(g, vs) {\n  return dfs(g, vs, \"pre\");\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/prim.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/prim.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\nvar Graph = __webpack_require__(/*! ../graph */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/graph.js\");\nvar PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/data/priority-queue.js\");\n\nmodule.exports = prim;\n\nfunction prim(g, weightFunc) {\n  var result = new Graph();\n  var parents = {};\n  var pq = new PriorityQueue();\n  var v;\n\n  function updateNeighbors(edge) {\n    var w = edge.v === v ? edge.w : edge.v;\n    var pri = pq.priority(w);\n    if (pri !== undefined) {\n      var edgeWeight = weightFunc(edge);\n      if (edgeWeight < pri) {\n        parents[w] = v;\n        pq.decrease(w, edgeWeight);\n      }\n    }\n  }\n\n  if (g.nodeCount() === 0) {\n    return result;\n  }\n\n  _.each(g.nodes(), function(v) {\n    pq.add(v, Number.POSITIVE_INFINITY);\n    result.setNode(v);\n  });\n\n  // Start from an arbitrary node\n  pq.decrease(g.nodes()[0], 0);\n\n  var init = false;\n  while (pq.size() > 0) {\n    v = pq.removeMin();\n    if (_.has(parents, v)) {\n      result.setEdge(v, parents[v]);\n    } else if (init) {\n      throw new Error(\"Input graph is not connected: \" + g);\n    } else {\n      init = true;\n    }\n\n    g.nodeEdges(v).forEach(updateNeighbors);\n  }\n\n  return result;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/tarjan.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/tarjan.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\n\nmodule.exports = tarjan;\n\nfunction tarjan(g) {\n  var index = 0;\n  var stack = [];\n  var visited = {}; // node id -> { onStack, lowlink, index }\n  var results = [];\n\n  function dfs(v) {\n    var entry = visited[v] = {\n      onStack: true,\n      lowlink: index,\n      index: index++\n    };\n    stack.push(v);\n\n    g.successors(v).forEach(function(w) {\n      if (!_.has(visited, w)) {\n        dfs(w);\n        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);\n      } else if (visited[w].onStack) {\n        entry.lowlink = Math.min(entry.lowlink, visited[w].index);\n      }\n    });\n\n    if (entry.lowlink === entry.index) {\n      var cmpt = [];\n      var w;\n      do {\n        w = stack.pop();\n        visited[w].onStack = false;\n        cmpt.push(w);\n      } while (v !== w);\n      results.push(cmpt);\n    }\n  }\n\n  g.nodes().forEach(function(v) {\n    if (!_.has(visited, v)) {\n      dfs(v);\n    }\n  });\n\n  return results;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/topsort.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/topsort.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\n\nmodule.exports = topsort;\ntopsort.CycleException = CycleException;\n\nfunction topsort(g) {\n  var visited = {};\n  var stack = {};\n  var results = [];\n\n  function visit(node) {\n    if (_.has(stack, node)) {\n      throw new CycleException();\n    }\n\n    if (!_.has(visited, node)) {\n      stack[node] = true;\n      visited[node] = true;\n      _.each(g.predecessors(node), visit);\n      delete stack[node];\n      results.push(node);\n    }\n  }\n\n  _.each(g.sinks(), visit);\n\n  if (_.size(visited) !== g.nodeCount()) {\n    throw new CycleException();\n  }\n\n  return results;\n}\n\nfunction CycleException() {}\nCycleException.prototype = new Error(); // must be an instance of Error to pass testing\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/data/priority-queue.js\":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/data/priority-queue.js ***!\n  \\**************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\n\nmodule.exports = PriorityQueue;\n\n/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\nfunction PriorityQueue() {\n  this._arr = [];\n  this._keyIndices = {};\n}\n\n/**\n * Returns the number of elements in the queue. Takes `O(1)` time.\n */\nPriorityQueue.prototype.size = function() {\n  return this._arr.length;\n};\n\n/**\n * Returns the keys that are in the queue. Takes `O(n)` time.\n */\nPriorityQueue.prototype.keys = function() {\n  return this._arr.map(function(x) { return x.key; });\n};\n\n/**\n * Returns `true` if **key** is in the queue and `false` if not.\n */\nPriorityQueue.prototype.has = function(key) {\n  return _.has(this._keyIndices, key);\n};\n\n/**\n * Returns the priority for **key**. If **key** is not present in the queue\n * then this function returns `undefined`. Takes `O(1)` time.\n *\n * @param {Object} key\n */\nPriorityQueue.prototype.priority = function(key) {\n  var index = this._keyIndices[key];\n  if (index !== undefined) {\n    return this._arr[index].priority;\n  }\n};\n\n/**\n * Returns the key for the minimum element in this queue. If the queue is\n * empty this function throws an Error. Takes `O(1)` time.\n */\nPriorityQueue.prototype.min = function() {\n  if (this.size() === 0) {\n    throw new Error(\"Queue underflow\");\n  }\n  return this._arr[0].key;\n};\n\n/**\n * Inserts a new key into the priority queue. If the key already exists in\n * the queue this function returns `false`; otherwise it will return `true`.\n * Takes `O(n)` time.\n *\n * @param {Object} key the key to add\n * @param {Number} priority the initial priority for the key\n */\nPriorityQueue.prototype.add = function(key, priority) {\n  var keyIndices = this._keyIndices;\n  key = String(key);\n  if (!_.has(keyIndices, key)) {\n    var arr = this._arr;\n    var index = arr.length;\n    keyIndices[key] = index;\n    arr.push({key: key, priority: priority});\n    this._decrease(index);\n    return true;\n  }\n  return false;\n};\n\n/**\n * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n */\nPriorityQueue.prototype.removeMin = function() {\n  this._swap(0, this._arr.length - 1);\n  var min = this._arr.pop();\n  delete this._keyIndices[min.key];\n  this._heapify(0);\n  return min.key;\n};\n\n/**\n * Decreases the priority for **key** to **priority**. If the new priority is\n * greater than the previous priority, this function will throw an Error.\n *\n * @param {Object} key the key for which to raise priority\n * @param {Number} priority the new priority for the key\n */\nPriorityQueue.prototype.decrease = function(key, priority) {\n  var index = this._keyIndices[key];\n  if (priority > this._arr[index].priority) {\n    throw new Error(\"New priority is greater than current priority. \" +\n        \"Key: \" + key + \" Old: \" + this._arr[index].priority + \" New: \" + priority);\n  }\n  this._arr[index].priority = priority;\n  this._decrease(index);\n};\n\nPriorityQueue.prototype._heapify = function(i) {\n  var arr = this._arr;\n  var l = 2 * i;\n  var r = l + 1;\n  var largest = i;\n  if (l < arr.length) {\n    largest = arr[l].priority < arr[largest].priority ? l : largest;\n    if (r < arr.length) {\n      largest = arr[r].priority < arr[largest].priority ? r : largest;\n    }\n    if (largest !== i) {\n      this._swap(i, largest);\n      this._heapify(largest);\n    }\n  }\n};\n\nPriorityQueue.prototype._decrease = function(index) {\n  var arr = this._arr;\n  var priority = arr[index].priority;\n  var parent;\n  while (index !== 0) {\n    parent = index >> 1;\n    if (arr[parent].priority < priority) {\n      break;\n    }\n    this._swap(index, parent);\n    index = parent;\n  }\n};\n\nPriorityQueue.prototype._swap = function(i, j) {\n  var arr = this._arr;\n  var keyIndices = this._keyIndices;\n  var origArrI = arr[i];\n  var origArrJ = arr[j];\n  arr[i] = origArrJ;\n  arr[j] = origArrI;\n  keyIndices[origArrJ.key] = i;\n  keyIndices[origArrI.key] = j;\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/graph.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/graph.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\n\nmodule.exports = Graph;\n\nvar DEFAULT_EDGE_NAME = \"\\x00\";\nvar GRAPH_NODE = \"\\x00\";\nvar EDGE_KEY_DELIM = \"\\x01\";\n\n// Implementation notes:\n//\n//  * Node id query functions should return string ids for the nodes\n//  * Edge id query functions should return an \"edgeObj\", edge object, that is\n//    composed of enough information to uniquely identify an edge: {v, w, name}.\n//  * Internally we use an \"edgeId\", a stringified form of the edgeObj, to\n//    reference edges. This is because we need a performant way to look these\n//    edges up and, object properties, which have string keys, are the closest\n//    we're going to get to a performant hashtable in JavaScript.\n\nfunction Graph(opts) {\n  this._isDirected = _.has(opts, \"directed\") ? opts.directed : true;\n  this._isMultigraph = _.has(opts, \"multigraph\") ? opts.multigraph : false;\n  this._isCompound = _.has(opts, \"compound\") ? opts.compound : false;\n\n  // Label for the graph itself\n  this._label = undefined;\n\n  // Defaults to be set when creating a new node\n  this._defaultNodeLabelFn = _.constant(undefined);\n\n  // Defaults to be set when creating a new edge\n  this._defaultEdgeLabelFn = _.constant(undefined);\n\n  // v -> label\n  this._nodes = {};\n\n  if (this._isCompound) {\n    // v -> parent\n    this._parent = {};\n\n    // v -> children\n    this._children = {};\n    this._children[GRAPH_NODE] = {};\n  }\n\n  // v -> edgeObj\n  this._in = {};\n\n  // u -> v -> Number\n  this._preds = {};\n\n  // v -> edgeObj\n  this._out = {};\n\n  // v -> w -> Number\n  this._sucs = {};\n\n  // e -> edgeObj\n  this._edgeObjs = {};\n\n  // e -> label\n  this._edgeLabels = {};\n}\n\n/* Number of nodes in the graph. Should only be changed by the implementation. */\nGraph.prototype._nodeCount = 0;\n\n/* Number of edges in the graph. Should only be changed by the implementation. */\nGraph.prototype._edgeCount = 0;\n\n\n/* === Graph functions ========= */\n\nGraph.prototype.isDirected = function() {\n  return this._isDirected;\n};\n\nGraph.prototype.isMultigraph = function() {\n  return this._isMultigraph;\n};\n\nGraph.prototype.isCompound = function() {\n  return this._isCompound;\n};\n\nGraph.prototype.setGraph = function(label) {\n  this._label = label;\n  return this;\n};\n\nGraph.prototype.graph = function() {\n  return this._label;\n};\n\n\n/* === Node functions ========== */\n\nGraph.prototype.setDefaultNodeLabel = function(newDefault) {\n  if (!_.isFunction(newDefault)) {\n    newDefault = _.constant(newDefault);\n  }\n  this._defaultNodeLabelFn = newDefault;\n  return this;\n};\n\nGraph.prototype.nodeCount = function() {\n  return this._nodeCount;\n};\n\nGraph.prototype.nodes = function() {\n  return _.keys(this._nodes);\n};\n\nGraph.prototype.sources = function() {\n  var self = this;\n  return _.filter(this.nodes(), function(v) {\n    return _.isEmpty(self._in[v]);\n  });\n};\n\nGraph.prototype.sinks = function() {\n  var self = this;\n  return _.filter(this.nodes(), function(v) {\n    return _.isEmpty(self._out[v]);\n  });\n};\n\nGraph.prototype.setNodes = function(vs, value) {\n  var args = arguments;\n  var self = this;\n  _.each(vs, function(v) {\n    if (args.length > 1) {\n      self.setNode(v, value);\n    } else {\n      self.setNode(v);\n    }\n  });\n  return this;\n};\n\nGraph.prototype.setNode = function(v, value) {\n  if (_.has(this._nodes, v)) {\n    if (arguments.length > 1) {\n      this._nodes[v] = value;\n    }\n    return this;\n  }\n\n  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);\n  if (this._isCompound) {\n    this._parent[v] = GRAPH_NODE;\n    this._children[v] = {};\n    this._children[GRAPH_NODE][v] = true;\n  }\n  this._in[v] = {};\n  this._preds[v] = {};\n  this._out[v] = {};\n  this._sucs[v] = {};\n  ++this._nodeCount;\n  return this;\n};\n\nGraph.prototype.node = function(v) {\n  return this._nodes[v];\n};\n\nGraph.prototype.hasNode = function(v) {\n  return _.has(this._nodes, v);\n};\n\nGraph.prototype.removeNode =  function(v) {\n  var self = this;\n  if (_.has(this._nodes, v)) {\n    var removeEdge = function(e) { self.removeEdge(self._edgeObjs[e]); };\n    delete this._nodes[v];\n    if (this._isCompound) {\n      this._removeFromParentsChildList(v);\n      delete this._parent[v];\n      _.each(this.children(v), function(child) {\n        self.setParent(child);\n      });\n      delete this._children[v];\n    }\n    _.each(_.keys(this._in[v]), removeEdge);\n    delete this._in[v];\n    delete this._preds[v];\n    _.each(_.keys(this._out[v]), removeEdge);\n    delete this._out[v];\n    delete this._sucs[v];\n    --this._nodeCount;\n  }\n  return this;\n};\n\nGraph.prototype.setParent = function(v, parent) {\n  if (!this._isCompound) {\n    throw new Error(\"Cannot set parent in a non-compound graph\");\n  }\n\n  if (_.isUndefined(parent)) {\n    parent = GRAPH_NODE;\n  } else {\n    // Coerce parent to string\n    parent += \"\";\n    for (var ancestor = parent;\n      !_.isUndefined(ancestor);\n      ancestor = this.parent(ancestor)) {\n      if (ancestor === v) {\n        throw new Error(\"Setting \" + parent+ \" as parent of \" + v +\n                        \" would create a cycle\");\n      }\n    }\n\n    this.setNode(parent);\n  }\n\n  this.setNode(v);\n  this._removeFromParentsChildList(v);\n  this._parent[v] = parent;\n  this._children[parent][v] = true;\n  return this;\n};\n\nGraph.prototype._removeFromParentsChildList = function(v) {\n  delete this._children[this._parent[v]][v];\n};\n\nGraph.prototype.parent = function(v) {\n  if (this._isCompound) {\n    var parent = this._parent[v];\n    if (parent !== GRAPH_NODE) {\n      return parent;\n    }\n  }\n};\n\nGraph.prototype.children = function(v) {\n  if (_.isUndefined(v)) {\n    v = GRAPH_NODE;\n  }\n\n  if (this._isCompound) {\n    var children = this._children[v];\n    if (children) {\n      return _.keys(children);\n    }\n  } else if (v === GRAPH_NODE) {\n    return this.nodes();\n  } else if (this.hasNode(v)) {\n    return [];\n  }\n};\n\nGraph.prototype.predecessors = function(v) {\n  var predsV = this._preds[v];\n  if (predsV) {\n    return _.keys(predsV);\n  }\n};\n\nGraph.prototype.successors = function(v) {\n  var sucsV = this._sucs[v];\n  if (sucsV) {\n    return _.keys(sucsV);\n  }\n};\n\nGraph.prototype.neighbors = function(v) {\n  var preds = this.predecessors(v);\n  if (preds) {\n    return _.union(preds, this.successors(v));\n  }\n};\n\nGraph.prototype.isLeaf = function (v) {\n  var neighbors;\n  if (this.isDirected()) {\n    neighbors = this.successors(v);\n  } else {\n    neighbors = this.neighbors(v);\n  }\n  return neighbors.length === 0;\n};\n\nGraph.prototype.filterNodes = function(filter) {\n  var copy = new this.constructor({\n    directed: this._isDirected,\n    multigraph: this._isMultigraph,\n    compound: this._isCompound\n  });\n\n  copy.setGraph(this.graph());\n\n  var self = this;\n  _.each(this._nodes, function(value, v) {\n    if (filter(v)) {\n      copy.setNode(v, value);\n    }\n  });\n\n  _.each(this._edgeObjs, function(e) {\n    if (copy.hasNode(e.v) && copy.hasNode(e.w)) {\n      copy.setEdge(e, self.edge(e));\n    }\n  });\n\n  var parents = {};\n  function findParent(v) {\n    var parent = self.parent(v);\n    if (parent === undefined || copy.hasNode(parent)) {\n      parents[v] = parent;\n      return parent;\n    } else if (parent in parents) {\n      return parents[parent];\n    } else {\n      return findParent(parent);\n    }\n  }\n\n  if (this._isCompound) {\n    _.each(copy.nodes(), function(v) {\n      copy.setParent(v, findParent(v));\n    });\n  }\n\n  return copy;\n};\n\n/* === Edge functions ========== */\n\nGraph.prototype.setDefaultEdgeLabel = function(newDefault) {\n  if (!_.isFunction(newDefault)) {\n    newDefault = _.constant(newDefault);\n  }\n  this._defaultEdgeLabelFn = newDefault;\n  return this;\n};\n\nGraph.prototype.edgeCount = function() {\n  return this._edgeCount;\n};\n\nGraph.prototype.edges = function() {\n  return _.values(this._edgeObjs);\n};\n\nGraph.prototype.setPath = function(vs, value) {\n  var self = this;\n  var args = arguments;\n  _.reduce(vs, function(v, w) {\n    if (args.length > 1) {\n      self.setEdge(v, w, value);\n    } else {\n      self.setEdge(v, w);\n    }\n    return w;\n  });\n  return this;\n};\n\n/*\n * setEdge(v, w, [value, [name]])\n * setEdge({ v, w, [name] }, [value])\n */\nGraph.prototype.setEdge = function() {\n  var v, w, name, value;\n  var valueSpecified = false;\n  var arg0 = arguments[0];\n\n  if (typeof arg0 === \"object\" && arg0 !== null && \"v\" in arg0) {\n    v = arg0.v;\n    w = arg0.w;\n    name = arg0.name;\n    if (arguments.length === 2) {\n      value = arguments[1];\n      valueSpecified = true;\n    }\n  } else {\n    v = arg0;\n    w = arguments[1];\n    name = arguments[3];\n    if (arguments.length > 2) {\n      value = arguments[2];\n      valueSpecified = true;\n    }\n  }\n\n  v = \"\" + v;\n  w = \"\" + w;\n  if (!_.isUndefined(name)) {\n    name = \"\" + name;\n  }\n\n  var e = edgeArgsToId(this._isDirected, v, w, name);\n  if (_.has(this._edgeLabels, e)) {\n    if (valueSpecified) {\n      this._edgeLabels[e] = value;\n    }\n    return this;\n  }\n\n  if (!_.isUndefined(name) && !this._isMultigraph) {\n    throw new Error(\"Cannot set a named edge when isMultigraph = false\");\n  }\n\n  // It didn't exist, so we need to create it.\n  // First ensure the nodes exist.\n  this.setNode(v);\n  this.setNode(w);\n\n  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);\n\n  var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);\n  // Ensure we add undirected edges in a consistent way.\n  v = edgeObj.v;\n  w = edgeObj.w;\n\n  Object.freeze(edgeObj);\n  this._edgeObjs[e] = edgeObj;\n  incrementOrInitEntry(this._preds[w], v);\n  incrementOrInitEntry(this._sucs[v], w);\n  this._in[w][e] = edgeObj;\n  this._out[v][e] = edgeObj;\n  this._edgeCount++;\n  return this;\n};\n\nGraph.prototype.edge = function(v, w, name) {\n  var e = (arguments.length === 1\n    ? edgeObjToId(this._isDirected, arguments[0])\n    : edgeArgsToId(this._isDirected, v, w, name));\n  return this._edgeLabels[e];\n};\n\nGraph.prototype.hasEdge = function(v, w, name) {\n  var e = (arguments.length === 1\n    ? edgeObjToId(this._isDirected, arguments[0])\n    : edgeArgsToId(this._isDirected, v, w, name));\n  return _.has(this._edgeLabels, e);\n};\n\nGraph.prototype.removeEdge = function(v, w, name) {\n  var e = (arguments.length === 1\n    ? edgeObjToId(this._isDirected, arguments[0])\n    : edgeArgsToId(this._isDirected, v, w, name));\n  var edge = this._edgeObjs[e];\n  if (edge) {\n    v = edge.v;\n    w = edge.w;\n    delete this._edgeLabels[e];\n    delete this._edgeObjs[e];\n    decrementOrRemoveEntry(this._preds[w], v);\n    decrementOrRemoveEntry(this._sucs[v], w);\n    delete this._in[w][e];\n    delete this._out[v][e];\n    this._edgeCount--;\n  }\n  return this;\n};\n\nGraph.prototype.inEdges = function(v, u) {\n  var inV = this._in[v];\n  if (inV) {\n    var edges = _.values(inV);\n    if (!u) {\n      return edges;\n    }\n    return _.filter(edges, function(edge) { return edge.v === u; });\n  }\n};\n\nGraph.prototype.outEdges = function(v, w) {\n  var outV = this._out[v];\n  if (outV) {\n    var edges = _.values(outV);\n    if (!w) {\n      return edges;\n    }\n    return _.filter(edges, function(edge) { return edge.w === w; });\n  }\n};\n\nGraph.prototype.nodeEdges = function(v, w) {\n  var inEdges = this.inEdges(v, w);\n  if (inEdges) {\n    return inEdges.concat(this.outEdges(v, w));\n  }\n};\n\nfunction incrementOrInitEntry(map, k) {\n  if (map[k]) {\n    map[k]++;\n  } else {\n    map[k] = 1;\n  }\n}\n\nfunction decrementOrRemoveEntry(map, k) {\n  if (!--map[k]) { delete map[k]; }\n}\n\nfunction edgeArgsToId(isDirected, v_, w_, name) {\n  var v = \"\" + v_;\n  var w = \"\" + w_;\n  if (!isDirected && v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM +\n             (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);\n}\n\nfunction edgeArgsToObj(isDirected, v_, w_, name) {\n  var v = \"\" + v_;\n  var w = \"\" + w_;\n  if (!isDirected && v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  var edgeObj =  { v: v, w: w };\n  if (name) {\n    edgeObj.name = name;\n  }\n  return edgeObj;\n}\n\nfunction edgeObjToId(isDirected, edgeObj) {\n  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/index.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/index.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Includes only the \"core\" of graphlib\nmodule.exports = {\n  Graph: __webpack_require__(/*! ./graph */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/graph.js\"),\n  version: __webpack_require__(/*! ./version */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/version.js\")\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/json.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/json.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\nvar Graph = __webpack_require__(/*! ./graph */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/graph.js\");\n\nmodule.exports = {\n  write: write,\n  read: read\n};\n\nfunction write(g) {\n  var json = {\n    options: {\n      directed: g.isDirected(),\n      multigraph: g.isMultigraph(),\n      compound: g.isCompound()\n    },\n    nodes: writeNodes(g),\n    edges: writeEdges(g)\n  };\n  if (!_.isUndefined(g.graph())) {\n    json.value = _.clone(g.graph());\n  }\n  return json;\n}\n\nfunction writeNodes(g) {\n  return _.map(g.nodes(), function(v) {\n    var nodeValue = g.node(v);\n    var parent = g.parent(v);\n    var node = { v: v };\n    if (!_.isUndefined(nodeValue)) {\n      node.value = nodeValue;\n    }\n    if (!_.isUndefined(parent)) {\n      node.parent = parent;\n    }\n    return node;\n  });\n}\n\nfunction writeEdges(g) {\n  return _.map(g.edges(), function(e) {\n    var edgeValue = g.edge(e);\n    var edge = { v: e.v, w: e.w };\n    if (!_.isUndefined(e.name)) {\n      edge.name = e.name;\n    }\n    if (!_.isUndefined(edgeValue)) {\n      edge.value = edgeValue;\n    }\n    return edge;\n  });\n}\n\nfunction read(json) {\n  var g = new Graph(json.options).setGraph(json.value);\n  _.each(json.nodes, function(entry) {\n    g.setNode(entry.v, entry.value);\n    if (entry.parent) {\n      g.setParent(entry.v, entry.parent);\n    }\n  });\n  _.each(json.edges, function(entry) {\n    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);\n  });\n  return g;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* global window */\n\nvar lodash;\n\nif (true) {\n  try {\n    lodash = {\n      clone: __webpack_require__(/*! lodash/clone */ \"./node_modules/_lodash@4.17.15@lodash/clone.js\"),\n      constant: __webpack_require__(/*! lodash/constant */ \"./node_modules/_lodash@4.17.15@lodash/constant.js\"),\n      each: __webpack_require__(/*! lodash/each */ \"./node_modules/_lodash@4.17.15@lodash/each.js\"),\n      filter: __webpack_require__(/*! lodash/filter */ \"./node_modules/_lodash@4.17.15@lodash/filter.js\"),\n      has:  __webpack_require__(/*! lodash/has */ \"./node_modules/_lodash@4.17.15@lodash/has.js\"),\n      isArray: __webpack_require__(/*! lodash/isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n      isEmpty: __webpack_require__(/*! lodash/isEmpty */ \"./node_modules/_lodash@4.17.15@lodash/isEmpty.js\"),\n      isFunction: __webpack_require__(/*! lodash/isFunction */ \"./node_modules/_lodash@4.17.15@lodash/isFunction.js\"),\n      isUndefined: __webpack_require__(/*! lodash/isUndefined */ \"./node_modules/_lodash@4.17.15@lodash/isUndefined.js\"),\n      keys: __webpack_require__(/*! lodash/keys */ \"./node_modules/_lodash@4.17.15@lodash/keys.js\"),\n      map: __webpack_require__(/*! lodash/map */ \"./node_modules/_lodash@4.17.15@lodash/map.js\"),\n      reduce: __webpack_require__(/*! lodash/reduce */ \"./node_modules/_lodash@4.17.15@lodash/reduce.js\"),\n      size: __webpack_require__(/*! lodash/size */ \"./node_modules/_lodash@4.17.15@lodash/size.js\"),\n      transform: __webpack_require__(/*! lodash/transform */ \"./node_modules/_lodash@4.17.15@lodash/transform.js\"),\n      union: __webpack_require__(/*! lodash/union */ \"./node_modules/_lodash@4.17.15@lodash/union.js\"),\n      values: __webpack_require__(/*! lodash/values */ \"./node_modules/_lodash@4.17.15@lodash/values.js\")\n    };\n  } catch (e) {\n    // continue regardless of error\n  }\n}\n\nif (!lodash) {\n  lodash = window._;\n}\n\nmodule.exports = lodash;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/version.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/version.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = '2.1.8';\n\n\n/***/ }),\n\n/***/ \"./node_modules/_isarray@0.0.1@isarray/index.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_isarray@0.0.1@isarray/index.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_DataView.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_DataView.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/_lodash@4.17.15@lodash/_getNative.js\"),\n    root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_Hash.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_Hash.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar hashClear = __webpack_require__(/*! ./_hashClear */ \"./node_modules/_lodash@4.17.15@lodash/_hashClear.js\"),\n    hashDelete = __webpack_require__(/*! ./_hashDelete */ \"./node_modules/_lodash@4.17.15@lodash/_hashDelete.js\"),\n    hashGet = __webpack_require__(/*! ./_hashGet */ \"./node_modules/_lodash@4.17.15@lodash/_hashGet.js\"),\n    hashHas = __webpack_require__(/*! ./_hashHas */ \"./node_modules/_lodash@4.17.15@lodash/_hashHas.js\"),\n    hashSet = __webpack_require__(/*! ./_hashSet */ \"./node_modules/_lodash@4.17.15@lodash/_hashSet.js\");\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_ListCache.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_ListCache.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar listCacheClear = __webpack_require__(/*! ./_listCacheClear */ \"./node_modules/_lodash@4.17.15@lodash/_listCacheClear.js\"),\n    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ \"./node_modules/_lodash@4.17.15@lodash/_listCacheDelete.js\"),\n    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ \"./node_modules/_lodash@4.17.15@lodash/_listCacheGet.js\"),\n    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ \"./node_modules/_lodash@4.17.15@lodash/_listCacheHas.js\"),\n    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ \"./node_modules/_lodash@4.17.15@lodash/_listCacheSet.js\");\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_Map.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_Map.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/_lodash@4.17.15@lodash/_getNative.js\"),\n    root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_MapCache.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_MapCache.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheClear.js\"),\n    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheDelete.js\"),\n    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheGet.js\"),\n    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheHas.js\"),\n    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheSet.js\");\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_Promise.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_Promise.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/_lodash@4.17.15@lodash/_getNative.js\"),\n    root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_Set.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_Set.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/_lodash@4.17.15@lodash/_getNative.js\"),\n    root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_SetCache.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_SetCache.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar MapCache = __webpack_require__(/*! ./_MapCache */ \"./node_modules/_lodash@4.17.15@lodash/_MapCache.js\"),\n    setCacheAdd = __webpack_require__(/*! ./_setCacheAdd */ \"./node_modules/_lodash@4.17.15@lodash/_setCacheAdd.js\"),\n    setCacheHas = __webpack_require__(/*! ./_setCacheHas */ \"./node_modules/_lodash@4.17.15@lodash/_setCacheHas.js\");\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_Stack.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_Stack.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ListCache = __webpack_require__(/*! ./_ListCache */ \"./node_modules/_lodash@4.17.15@lodash/_ListCache.js\"),\n    stackClear = __webpack_require__(/*! ./_stackClear */ \"./node_modules/_lodash@4.17.15@lodash/_stackClear.js\"),\n    stackDelete = __webpack_require__(/*! ./_stackDelete */ \"./node_modules/_lodash@4.17.15@lodash/_stackDelete.js\"),\n    stackGet = __webpack_require__(/*! ./_stackGet */ \"./node_modules/_lodash@4.17.15@lodash/_stackGet.js\"),\n    stackHas = __webpack_require__(/*! ./_stackHas */ \"./node_modules/_lodash@4.17.15@lodash/_stackHas.js\"),\n    stackSet = __webpack_require__(/*! ./_stackSet */ \"./node_modules/_lodash@4.17.15@lodash/_stackSet.js\");\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_Symbol.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_Symbol.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_Uint8Array.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_Uint8Array.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_WeakMap.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_WeakMap.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/_lodash@4.17.15@lodash/_getNative.js\"),\n    root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_apply.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_apply.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arrayEach.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arrayEach.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arrayFilter.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arrayFilter.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arrayIncludes.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arrayIncludes.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ \"./node_modules/_lodash@4.17.15@lodash/_baseIndexOf.js\");\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array == null ? 0 : array.length;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\nmodule.exports = arrayIncludes;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arrayIncludesWith.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arrayIncludesWith.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arrayIncludesWith;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arrayLikeKeys.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arrayLikeKeys.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseTimes = __webpack_require__(/*! ./_baseTimes */ \"./node_modules/_lodash@4.17.15@lodash/_baseTimes.js\"),\n    isArguments = __webpack_require__(/*! ./isArguments */ \"./node_modules/_lodash@4.17.15@lodash/isArguments.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isBuffer = __webpack_require__(/*! ./isBuffer */ \"./node_modules/_lodash@4.17.15@lodash/isBuffer.js\"),\n    isIndex = __webpack_require__(/*! ./_isIndex */ \"./node_modules/_lodash@4.17.15@lodash/_isIndex.js\"),\n    isTypedArray = __webpack_require__(/*! ./isTypedArray */ \"./node_modules/_lodash@4.17.15@lodash/isTypedArray.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arrayMap.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arrayMap.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arrayPush.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arrayPush.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arrayReduce.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arrayReduce.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayReduce;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arraySome.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arraySome.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_asciiSize.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_asciiSize.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseProperty = __webpack_require__(/*! ./_baseProperty */ \"./node_modules/_lodash@4.17.15@lodash/_baseProperty.js\");\n\n/**\n * Gets the size of an ASCII `string`.\n *\n * @private\n * @param {string} string The string inspect.\n * @returns {number} Returns the string size.\n */\nvar asciiSize = baseProperty('length');\n\nmodule.exports = asciiSize;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_assignMergeValue.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_assignMergeValue.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ \"./node_modules/_lodash@4.17.15@lodash/_baseAssignValue.js\"),\n    eq = __webpack_require__(/*! ./eq */ \"./node_modules/_lodash@4.17.15@lodash/eq.js\");\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignMergeValue;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_assignValue.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_assignValue.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ \"./node_modules/_lodash@4.17.15@lodash/_baseAssignValue.js\"),\n    eq = __webpack_require__(/*! ./eq */ \"./node_modules/_lodash@4.17.15@lodash/eq.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_assocIndexOf.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_assocIndexOf.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar eq = __webpack_require__(/*! ./eq */ \"./node_modules/_lodash@4.17.15@lodash/eq.js\");\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseAssign.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseAssign.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar copyObject = __webpack_require__(/*! ./_copyObject */ \"./node_modules/_lodash@4.17.15@lodash/_copyObject.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/_lodash@4.17.15@lodash/keys.js\");\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseAssignIn.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseAssignIn.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar copyObject = __webpack_require__(/*! ./_copyObject */ \"./node_modules/_lodash@4.17.15@lodash/_copyObject.js\"),\n    keysIn = __webpack_require__(/*! ./keysIn */ \"./node_modules/_lodash@4.17.15@lodash/keysIn.js\");\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseAssignValue.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseAssignValue.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar defineProperty = __webpack_require__(/*! ./_defineProperty */ \"./node_modules/_lodash@4.17.15@lodash/_defineProperty.js\");\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseClone.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseClone.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Stack = __webpack_require__(/*! ./_Stack */ \"./node_modules/_lodash@4.17.15@lodash/_Stack.js\"),\n    arrayEach = __webpack_require__(/*! ./_arrayEach */ \"./node_modules/_lodash@4.17.15@lodash/_arrayEach.js\"),\n    assignValue = __webpack_require__(/*! ./_assignValue */ \"./node_modules/_lodash@4.17.15@lodash/_assignValue.js\"),\n    baseAssign = __webpack_require__(/*! ./_baseAssign */ \"./node_modules/_lodash@4.17.15@lodash/_baseAssign.js\"),\n    baseAssignIn = __webpack_require__(/*! ./_baseAssignIn */ \"./node_modules/_lodash@4.17.15@lodash/_baseAssignIn.js\"),\n    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ \"./node_modules/_lodash@4.17.15@lodash/_cloneBuffer.js\"),\n    copyArray = __webpack_require__(/*! ./_copyArray */ \"./node_modules/_lodash@4.17.15@lodash/_copyArray.js\"),\n    copySymbols = __webpack_require__(/*! ./_copySymbols */ \"./node_modules/_lodash@4.17.15@lodash/_copySymbols.js\"),\n    copySymbolsIn = __webpack_require__(/*! ./_copySymbolsIn */ \"./node_modules/_lodash@4.17.15@lodash/_copySymbolsIn.js\"),\n    getAllKeys = __webpack_require__(/*! ./_getAllKeys */ \"./node_modules/_lodash@4.17.15@lodash/_getAllKeys.js\"),\n    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ \"./node_modules/_lodash@4.17.15@lodash/_getAllKeysIn.js\"),\n    getTag = __webpack_require__(/*! ./_getTag */ \"./node_modules/_lodash@4.17.15@lodash/_getTag.js\"),\n    initCloneArray = __webpack_require__(/*! ./_initCloneArray */ \"./node_modules/_lodash@4.17.15@lodash/_initCloneArray.js\"),\n    initCloneByTag = __webpack_require__(/*! ./_initCloneByTag */ \"./node_modules/_lodash@4.17.15@lodash/_initCloneByTag.js\"),\n    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ \"./node_modules/_lodash@4.17.15@lodash/_initCloneObject.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isBuffer = __webpack_require__(/*! ./isBuffer */ \"./node_modules/_lodash@4.17.15@lodash/isBuffer.js\"),\n    isMap = __webpack_require__(/*! ./isMap */ \"./node_modules/_lodash@4.17.15@lodash/isMap.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\"),\n    isSet = __webpack_require__(/*! ./isSet */ \"./node_modules/_lodash@4.17.15@lodash/isSet.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/_lodash@4.17.15@lodash/keys.js\");\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseCreate.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseCreate.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\");\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseEach.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseEach.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseForOwn = __webpack_require__(/*! ./_baseForOwn */ \"./node_modules/_lodash@4.17.15@lodash/_baseForOwn.js\"),\n    createBaseEach = __webpack_require__(/*! ./_createBaseEach */ \"./node_modules/_lodash@4.17.15@lodash/_createBaseEach.js\");\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseExtremum.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseExtremum.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/_lodash@4.17.15@lodash/isSymbol.js\");\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined\n          ? (current === current && !isSymbol(current))\n          : comparator(current, computed)\n        )) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseExtremum;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseFilter.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseFilter.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseEach = __webpack_require__(/*! ./_baseEach */ \"./node_modules/_lodash@4.17.15@lodash/_baseEach.js\");\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFilter;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseFindIndex.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseFindIndex.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseFlatten.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseFlatten.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayPush = __webpack_require__(/*! ./_arrayPush */ \"./node_modules/_lodash@4.17.15@lodash/_arrayPush.js\"),\n    isFlattenable = __webpack_require__(/*! ./_isFlattenable */ \"./node_modules/_lodash@4.17.15@lodash/_isFlattenable.js\");\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseFor.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseFor.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createBaseFor = __webpack_require__(/*! ./_createBaseFor */ \"./node_modules/_lodash@4.17.15@lodash/_createBaseFor.js\");\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseForOwn.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseForOwn.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFor = __webpack_require__(/*! ./_baseFor */ \"./node_modules/_lodash@4.17.15@lodash/_baseFor.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/_lodash@4.17.15@lodash/keys.js\");\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseGet.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseGet.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar castPath = __webpack_require__(/*! ./_castPath */ \"./node_modules/_lodash@4.17.15@lodash/_castPath.js\"),\n    toKey = __webpack_require__(/*! ./_toKey */ \"./node_modules/_lodash@4.17.15@lodash/_toKey.js\");\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseGetAllKeys.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseGetAllKeys.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayPush = __webpack_require__(/*! ./_arrayPush */ \"./node_modules/_lodash@4.17.15@lodash/_arrayPush.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\");\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/_lodash@4.17.15@lodash/_Symbol.js\"),\n    getRawTag = __webpack_require__(/*! ./_getRawTag */ \"./node_modules/_lodash@4.17.15@lodash/_getRawTag.js\"),\n    objectToString = __webpack_require__(/*! ./_objectToString */ \"./node_modules/_lodash@4.17.15@lodash/_objectToString.js\");\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseGt.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseGt.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.gt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is greater than `other`,\n *  else `false`.\n */\nfunction baseGt(value, other) {\n  return value > other;\n}\n\nmodule.exports = baseGt;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseHas.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseHas.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.has` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHas(object, key) {\n  return object != null && hasOwnProperty.call(object, key);\n}\n\nmodule.exports = baseHas;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseHasIn.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseHasIn.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIndexOf.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIndexOf.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ \"./node_modules/_lodash@4.17.15@lodash/_baseFindIndex.js\"),\n    baseIsNaN = __webpack_require__(/*! ./_baseIsNaN */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsNaN.js\"),\n    strictIndexOf = __webpack_require__(/*! ./_strictIndexOf */ \"./node_modules/_lodash@4.17.15@lodash/_strictIndexOf.js\");\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\nmodule.exports = baseIndexOf;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsArguments.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsArguments.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsEqual.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsEqual.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsEqualDeep = __webpack_require__(/*! ./_baseIsEqualDeep */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsEqualDeep.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsEqualDeep.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsEqualDeep.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Stack = __webpack_require__(/*! ./_Stack */ \"./node_modules/_lodash@4.17.15@lodash/_Stack.js\"),\n    equalArrays = __webpack_require__(/*! ./_equalArrays */ \"./node_modules/_lodash@4.17.15@lodash/_equalArrays.js\"),\n    equalByTag = __webpack_require__(/*! ./_equalByTag */ \"./node_modules/_lodash@4.17.15@lodash/_equalByTag.js\"),\n    equalObjects = __webpack_require__(/*! ./_equalObjects */ \"./node_modules/_lodash@4.17.15@lodash/_equalObjects.js\"),\n    getTag = __webpack_require__(/*! ./_getTag */ \"./node_modules/_lodash@4.17.15@lodash/_getTag.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isBuffer = __webpack_require__(/*! ./isBuffer */ \"./node_modules/_lodash@4.17.15@lodash/isBuffer.js\"),\n    isTypedArray = __webpack_require__(/*! ./isTypedArray */ \"./node_modules/_lodash@4.17.15@lodash/isTypedArray.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsMap.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsMap.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getTag = __webpack_require__(/*! ./_getTag */ \"./node_modules/_lodash@4.17.15@lodash/_getTag.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsMatch.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsMatch.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Stack = __webpack_require__(/*! ./_Stack */ \"./node_modules/_lodash@4.17.15@lodash/_Stack.js\"),\n    baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsEqual.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsNaN.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsNaN.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\nmodule.exports = baseIsNaN;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsNative.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsNative.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isFunction = __webpack_require__(/*! ./isFunction */ \"./node_modules/_lodash@4.17.15@lodash/isFunction.js\"),\n    isMasked = __webpack_require__(/*! ./_isMasked */ \"./node_modules/_lodash@4.17.15@lodash/_isMasked.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\"),\n    toSource = __webpack_require__(/*! ./_toSource */ \"./node_modules/_lodash@4.17.15@lodash/_toSource.js\");\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsSet.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsSet.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getTag = __webpack_require__(/*! ./_getTag */ \"./node_modules/_lodash@4.17.15@lodash/_getTag.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsTypedArray.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsTypedArray.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js\"),\n    isLength = __webpack_require__(/*! ./isLength */ \"./node_modules/_lodash@4.17.15@lodash/isLength.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseMatches = __webpack_require__(/*! ./_baseMatches */ \"./node_modules/_lodash@4.17.15@lodash/_baseMatches.js\"),\n    baseMatchesProperty = __webpack_require__(/*! ./_baseMatchesProperty */ \"./node_modules/_lodash@4.17.15@lodash/_baseMatchesProperty.js\"),\n    identity = __webpack_require__(/*! ./identity */ \"./node_modules/_lodash@4.17.15@lodash/identity.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    property = __webpack_require__(/*! ./property */ \"./node_modules/_lodash@4.17.15@lodash/property.js\");\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseKeys.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseKeys.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isPrototype = __webpack_require__(/*! ./_isPrototype */ \"./node_modules/_lodash@4.17.15@lodash/_isPrototype.js\"),\n    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ \"./node_modules/_lodash@4.17.15@lodash/_nativeKeys.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseKeysIn.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseKeysIn.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\"),\n    isPrototype = __webpack_require__(/*! ./_isPrototype */ \"./node_modules/_lodash@4.17.15@lodash/_isPrototype.js\"),\n    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ \"./node_modules/_lodash@4.17.15@lodash/_nativeKeysIn.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseLt.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseLt.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt(value, other) {\n  return value < other;\n}\n\nmodule.exports = baseLt;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseMap.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseMap.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseEach = __webpack_require__(/*! ./_baseEach */ \"./node_modules/_lodash@4.17.15@lodash/_baseEach.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\");\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseMatches.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseMatches.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsMatch = __webpack_require__(/*! ./_baseIsMatch */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsMatch.js\"),\n    getMatchData = __webpack_require__(/*! ./_getMatchData */ \"./node_modules/_lodash@4.17.15@lodash/_getMatchData.js\"),\n    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ \"./node_modules/_lodash@4.17.15@lodash/_matchesStrictComparable.js\");\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseMatchesProperty.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseMatchesProperty.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsEqual.js\"),\n    get = __webpack_require__(/*! ./get */ \"./node_modules/_lodash@4.17.15@lodash/get.js\"),\n    hasIn = __webpack_require__(/*! ./hasIn */ \"./node_modules/_lodash@4.17.15@lodash/hasIn.js\"),\n    isKey = __webpack_require__(/*! ./_isKey */ \"./node_modules/_lodash@4.17.15@lodash/_isKey.js\"),\n    isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ \"./node_modules/_lodash@4.17.15@lodash/_isStrictComparable.js\"),\n    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ \"./node_modules/_lodash@4.17.15@lodash/_matchesStrictComparable.js\"),\n    toKey = __webpack_require__(/*! ./_toKey */ \"./node_modules/_lodash@4.17.15@lodash/_toKey.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseMerge.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseMerge.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Stack = __webpack_require__(/*! ./_Stack */ \"./node_modules/_lodash@4.17.15@lodash/_Stack.js\"),\n    assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ \"./node_modules/_lodash@4.17.15@lodash/_assignMergeValue.js\"),\n    baseFor = __webpack_require__(/*! ./_baseFor */ \"./node_modules/_lodash@4.17.15@lodash/_baseFor.js\"),\n    baseMergeDeep = __webpack_require__(/*! ./_baseMergeDeep */ \"./node_modules/_lodash@4.17.15@lodash/_baseMergeDeep.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\"),\n    keysIn = __webpack_require__(/*! ./keysIn */ \"./node_modules/_lodash@4.17.15@lodash/keysIn.js\"),\n    safeGet = __webpack_require__(/*! ./_safeGet */ \"./node_modules/_lodash@4.17.15@lodash/_safeGet.js\");\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\nmodule.exports = baseMerge;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseMergeDeep.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseMergeDeep.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ \"./node_modules/_lodash@4.17.15@lodash/_assignMergeValue.js\"),\n    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ \"./node_modules/_lodash@4.17.15@lodash/_cloneBuffer.js\"),\n    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ \"./node_modules/_lodash@4.17.15@lodash/_cloneTypedArray.js\"),\n    copyArray = __webpack_require__(/*! ./_copyArray */ \"./node_modules/_lodash@4.17.15@lodash/_copyArray.js\"),\n    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ \"./node_modules/_lodash@4.17.15@lodash/_initCloneObject.js\"),\n    isArguments = __webpack_require__(/*! ./isArguments */ \"./node_modules/_lodash@4.17.15@lodash/isArguments.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLikeObject.js\"),\n    isBuffer = __webpack_require__(/*! ./isBuffer */ \"./node_modules/_lodash@4.17.15@lodash/isBuffer.js\"),\n    isFunction = __webpack_require__(/*! ./isFunction */ \"./node_modules/_lodash@4.17.15@lodash/isFunction.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\"),\n    isPlainObject = __webpack_require__(/*! ./isPlainObject */ \"./node_modules/_lodash@4.17.15@lodash/isPlainObject.js\"),\n    isTypedArray = __webpack_require__(/*! ./isTypedArray */ \"./node_modules/_lodash@4.17.15@lodash/isTypedArray.js\"),\n    safeGet = __webpack_require__(/*! ./_safeGet */ \"./node_modules/_lodash@4.17.15@lodash/_safeGet.js\"),\n    toPlainObject = __webpack_require__(/*! ./toPlainObject */ \"./node_modules/_lodash@4.17.15@lodash/toPlainObject.js\");\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\nmodule.exports = baseMergeDeep;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseOrderBy.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseOrderBy.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayMap = __webpack_require__(/*! ./_arrayMap */ \"./node_modules/_lodash@4.17.15@lodash/_arrayMap.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\"),\n    baseMap = __webpack_require__(/*! ./_baseMap */ \"./node_modules/_lodash@4.17.15@lodash/_baseMap.js\"),\n    baseSortBy = __webpack_require__(/*! ./_baseSortBy */ \"./node_modules/_lodash@4.17.15@lodash/_baseSortBy.js\"),\n    baseUnary = __webpack_require__(/*! ./_baseUnary */ \"./node_modules/_lodash@4.17.15@lodash/_baseUnary.js\"),\n    compareMultiple = __webpack_require__(/*! ./_compareMultiple */ \"./node_modules/_lodash@4.17.15@lodash/_compareMultiple.js\"),\n    identity = __webpack_require__(/*! ./identity */ \"./node_modules/_lodash@4.17.15@lodash/identity.js\");\n\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */\nfunction baseOrderBy(collection, iteratees, orders) {\n  var index = -1;\n  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));\n\n  var result = baseMap(collection, function(value, key, collection) {\n    var criteria = arrayMap(iteratees, function(iteratee) {\n      return iteratee(value);\n    });\n    return { 'criteria': criteria, 'index': ++index, 'value': value };\n  });\n\n  return baseSortBy(result, function(object, other) {\n    return compareMultiple(object, other, orders);\n  });\n}\n\nmodule.exports = baseOrderBy;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_basePick.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_basePick.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar basePickBy = __webpack_require__(/*! ./_basePickBy */ \"./node_modules/_lodash@4.17.15@lodash/_basePickBy.js\"),\n    hasIn = __webpack_require__(/*! ./hasIn */ \"./node_modules/_lodash@4.17.15@lodash/hasIn.js\");\n\n/**\n * The base implementation of `_.pick` without support for individual\n * property identifiers.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} paths The property paths to pick.\n * @returns {Object} Returns the new object.\n */\nfunction basePick(object, paths) {\n  return basePickBy(object, paths, function(value, path) {\n    return hasIn(object, path);\n  });\n}\n\nmodule.exports = basePick;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_basePickBy.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_basePickBy.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGet = __webpack_require__(/*! ./_baseGet */ \"./node_modules/_lodash@4.17.15@lodash/_baseGet.js\"),\n    baseSet = __webpack_require__(/*! ./_baseSet */ \"./node_modules/_lodash@4.17.15@lodash/_baseSet.js\"),\n    castPath = __webpack_require__(/*! ./_castPath */ \"./node_modules/_lodash@4.17.15@lodash/_castPath.js\");\n\n/**\n * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} paths The property paths to pick.\n * @param {Function} predicate The function invoked per property.\n * @returns {Object} Returns the new object.\n */\nfunction basePickBy(object, paths, predicate) {\n  var index = -1,\n      length = paths.length,\n      result = {};\n\n  while (++index < length) {\n    var path = paths[index],\n        value = baseGet(object, path);\n\n    if (predicate(value, path)) {\n      baseSet(result, castPath(path, object), value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = basePickBy;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseProperty.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseProperty.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_basePropertyDeep.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_basePropertyDeep.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGet = __webpack_require__(/*! ./_baseGet */ \"./node_modules/_lodash@4.17.15@lodash/_baseGet.js\");\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseRange.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseRange.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil,\n    nativeMax = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\n\nmodule.exports = baseRange;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseReduce.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseReduce.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initAccum Specify using the first or last element of\n *  `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */\nfunction baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n  eachFunc(collection, function(value, index, collection) {\n    accumulator = initAccum\n      ? (initAccum = false, value)\n      : iteratee(accumulator, value, index, collection);\n  });\n  return accumulator;\n}\n\nmodule.exports = baseReduce;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseRest.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseRest.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar identity = __webpack_require__(/*! ./identity */ \"./node_modules/_lodash@4.17.15@lodash/identity.js\"),\n    overRest = __webpack_require__(/*! ./_overRest */ \"./node_modules/_lodash@4.17.15@lodash/_overRest.js\"),\n    setToString = __webpack_require__(/*! ./_setToString */ \"./node_modules/_lodash@4.17.15@lodash/_setToString.js\");\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseSet.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseSet.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assignValue = __webpack_require__(/*! ./_assignValue */ \"./node_modules/_lodash@4.17.15@lodash/_assignValue.js\"),\n    castPath = __webpack_require__(/*! ./_castPath */ \"./node_modules/_lodash@4.17.15@lodash/_castPath.js\"),\n    isIndex = __webpack_require__(/*! ./_isIndex */ \"./node_modules/_lodash@4.17.15@lodash/_isIndex.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\"),\n    toKey = __webpack_require__(/*! ./_toKey */ \"./node_modules/_lodash@4.17.15@lodash/_toKey.js\");\n\n/**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */\nfunction baseSet(object, path, value, customizer) {\n  if (!isObject(object)) {\n    return object;\n  }\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object;\n\n  while (nested != null && ++index < length) {\n    var key = toKey(path[index]),\n        newValue = value;\n\n    if (index != lastIndex) {\n      var objValue = nested[key];\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\n      if (newValue === undefined) {\n        newValue = isObject(objValue)\n          ? objValue\n          : (isIndex(path[index + 1]) ? [] : {});\n      }\n    }\n    assignValue(nested, key, newValue);\n    nested = nested[key];\n  }\n  return object;\n}\n\nmodule.exports = baseSet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseSetToString.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseSetToString.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar constant = __webpack_require__(/*! ./constant */ \"./node_modules/_lodash@4.17.15@lodash/constant.js\"),\n    defineProperty = __webpack_require__(/*! ./_defineProperty */ \"./node_modules/_lodash@4.17.15@lodash/_defineProperty.js\"),\n    identity = __webpack_require__(/*! ./identity */ \"./node_modules/_lodash@4.17.15@lodash/identity.js\");\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseSortBy.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseSortBy.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\nmodule.exports = baseSortBy;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseTimes.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseTimes.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseToString.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseToString.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/_lodash@4.17.15@lodash/_Symbol.js\"),\n    arrayMap = __webpack_require__(/*! ./_arrayMap */ \"./node_modules/_lodash@4.17.15@lodash/_arrayMap.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/_lodash@4.17.15@lodash/isSymbol.js\");\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseUnary.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseUnary.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseUniq.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseUniq.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar SetCache = __webpack_require__(/*! ./_SetCache */ \"./node_modules/_lodash@4.17.15@lodash/_SetCache.js\"),\n    arrayIncludes = __webpack_require__(/*! ./_arrayIncludes */ \"./node_modules/_lodash@4.17.15@lodash/_arrayIncludes.js\"),\n    arrayIncludesWith = __webpack_require__(/*! ./_arrayIncludesWith */ \"./node_modules/_lodash@4.17.15@lodash/_arrayIncludesWith.js\"),\n    cacheHas = __webpack_require__(/*! ./_cacheHas */ \"./node_modules/_lodash@4.17.15@lodash/_cacheHas.js\"),\n    createSet = __webpack_require__(/*! ./_createSet */ \"./node_modules/_lodash@4.17.15@lodash/_createSet.js\"),\n    setToArray = __webpack_require__(/*! ./_setToArray */ \"./node_modules/_lodash@4.17.15@lodash/_setToArray.js\");\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseUniq;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseValues.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseValues.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayMap = __webpack_require__(/*! ./_arrayMap */ \"./node_modules/_lodash@4.17.15@lodash/_arrayMap.js\");\n\n/**\n * The base implementation of `_.values` and `_.valuesIn` which creates an\n * array of `object` property values corresponding to the property names\n * of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the array of property values.\n */\nfunction baseValues(object, props) {\n  return arrayMap(props, function(key) {\n    return object[key];\n  });\n}\n\nmodule.exports = baseValues;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseZipObject.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseZipObject.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n *\n * @private\n * @param {Array} props The property identifiers.\n * @param {Array} values The property values.\n * @param {Function} assignFunc The function to assign values.\n * @returns {Object} Returns the new object.\n */\nfunction baseZipObject(props, values, assignFunc) {\n  var index = -1,\n      length = props.length,\n      valsLength = values.length,\n      result = {};\n\n  while (++index < length) {\n    var value = index < valsLength ? values[index] : undefined;\n    assignFunc(result, props[index], value);\n  }\n  return result;\n}\n\nmodule.exports = baseZipObject;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_cacheHas.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_cacheHas.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_castFunction.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_castFunction.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar identity = __webpack_require__(/*! ./identity */ \"./node_modules/_lodash@4.17.15@lodash/identity.js\");\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\nmodule.exports = castFunction;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_castPath.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_castPath.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isKey = __webpack_require__(/*! ./_isKey */ \"./node_modules/_lodash@4.17.15@lodash/_isKey.js\"),\n    stringToPath = __webpack_require__(/*! ./_stringToPath */ \"./node_modules/_lodash@4.17.15@lodash/_stringToPath.js\"),\n    toString = __webpack_require__(/*! ./toString */ \"./node_modules/_lodash@4.17.15@lodash/toString.js\");\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_cloneArrayBuffer.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_cloneArrayBuffer.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Uint8Array = __webpack_require__(/*! ./_Uint8Array */ \"./node_modules/_lodash@4.17.15@lodash/_Uint8Array.js\");\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_cloneBuffer.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_cloneBuffer.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/** Detect free variable `exports`. */\nvar freeExports =   true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../_webpack@4.42.1@webpack/buildin/module.js */ \"./node_modules/_webpack@4.42.1@webpack/buildin/module.js\")(module)))\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_cloneDataView.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_cloneDataView.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ \"./node_modules/_lodash@4.17.15@lodash/_cloneArrayBuffer.js\");\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_cloneRegExp.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_cloneRegExp.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_cloneSymbol.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_cloneSymbol.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/_lodash@4.17.15@lodash/_Symbol.js\");\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_cloneTypedArray.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_cloneTypedArray.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ \"./node_modules/_lodash@4.17.15@lodash/_cloneArrayBuffer.js\");\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_compareAscending.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_compareAscending.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/_lodash@4.17.15@lodash/isSymbol.js\");\n\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined,\n        valIsNull = value === null,\n        valIsReflexive = value === value,\n        valIsSymbol = isSymbol(value);\n\n    var othIsDefined = other !== undefined,\n        othIsNull = other === null,\n        othIsReflexive = other === other,\n        othIsSymbol = isSymbol(other);\n\n    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n        (valIsNull && othIsDefined && othIsReflexive) ||\n        (!valIsDefined && othIsReflexive) ||\n        !valIsReflexive) {\n      return 1;\n    }\n    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n        (othIsNull && valIsDefined && valIsReflexive) ||\n        (!othIsDefined && valIsReflexive) ||\n        !othIsReflexive) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\nmodule.exports = compareAscending;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_compareMultiple.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_compareMultiple.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar compareAscending = __webpack_require__(/*! ./_compareAscending */ \"./node_modules/_lodash@4.17.15@lodash/_compareAscending.js\");\n\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareMultiple(object, other, orders) {\n  var index = -1,\n      objCriteria = object.criteria,\n      othCriteria = other.criteria,\n      length = objCriteria.length,\n      ordersLength = orders.length;\n\n  while (++index < length) {\n    var result = compareAscending(objCriteria[index], othCriteria[index]);\n    if (result) {\n      if (index >= ordersLength) {\n        return result;\n      }\n      var order = orders[index];\n      return result * (order == 'desc' ? -1 : 1);\n    }\n  }\n  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n  // that causes it, under certain circumstances, to provide the same value for\n  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n  // for more details.\n  //\n  // This also ensures a stable sort in V8 and other engines.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n  return object.index - other.index;\n}\n\nmodule.exports = compareMultiple;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_copyArray.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_copyArray.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_copyObject.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_copyObject.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assignValue = __webpack_require__(/*! ./_assignValue */ \"./node_modules/_lodash@4.17.15@lodash/_assignValue.js\"),\n    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ \"./node_modules/_lodash@4.17.15@lodash/_baseAssignValue.js\");\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_copySymbols.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_copySymbols.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar copyObject = __webpack_require__(/*! ./_copyObject */ \"./node_modules/_lodash@4.17.15@lodash/_copyObject.js\"),\n    getSymbols = __webpack_require__(/*! ./_getSymbols */ \"./node_modules/_lodash@4.17.15@lodash/_getSymbols.js\");\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_copySymbolsIn.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_copySymbolsIn.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar copyObject = __webpack_require__(/*! ./_copyObject */ \"./node_modules/_lodash@4.17.15@lodash/_copyObject.js\"),\n    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ \"./node_modules/_lodash@4.17.15@lodash/_getSymbolsIn.js\");\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_coreJsData.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_coreJsData.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_createAssigner.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_createAssigner.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseRest = __webpack_require__(/*! ./_baseRest */ \"./node_modules/_lodash@4.17.15@lodash/_baseRest.js\"),\n    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ \"./node_modules/_lodash@4.17.15@lodash/_isIterateeCall.js\");\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_createBaseEach.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_createBaseEach.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\");\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_createBaseFor.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_createBaseFor.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_createFind.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_createFind.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/_lodash@4.17.15@lodash/keys.js\");\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\nmodule.exports = createFind;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_createRange.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_createRange.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseRange = __webpack_require__(/*! ./_baseRange */ \"./node_modules/_lodash@4.17.15@lodash/_baseRange.js\"),\n    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ \"./node_modules/_lodash@4.17.15@lodash/_isIterateeCall.js\"),\n    toFinite = __webpack_require__(/*! ./toFinite */ \"./node_modules/_lodash@4.17.15@lodash/toFinite.js\");\n\n/**\n * Creates a `_.range` or `_.rangeRight` function.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new range function.\n */\nfunction createRange(fromRight) {\n  return function(start, end, step) {\n    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n      end = step = undefined;\n    }\n    // Ensure the sign of `-0` is preserved.\n    start = toFinite(start);\n    if (end === undefined) {\n      end = start;\n      start = 0;\n    } else {\n      end = toFinite(end);\n    }\n    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n    return baseRange(start, end, step, fromRight);\n  };\n}\n\nmodule.exports = createRange;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_createSet.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_createSet.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Set = __webpack_require__(/*! ./_Set */ \"./node_modules/_lodash@4.17.15@lodash/_Set.js\"),\n    noop = __webpack_require__(/*! ./noop */ \"./node_modules/_lodash@4.17.15@lodash/noop.js\"),\n    setToArray = __webpack_require__(/*! ./_setToArray */ \"./node_modules/_lodash@4.17.15@lodash/_setToArray.js\");\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\nmodule.exports = createSet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_defineProperty.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_defineProperty.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/_lodash@4.17.15@lodash/_getNative.js\");\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_equalArrays.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_equalArrays.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar SetCache = __webpack_require__(/*! ./_SetCache */ \"./node_modules/_lodash@4.17.15@lodash/_SetCache.js\"),\n    arraySome = __webpack_require__(/*! ./_arraySome */ \"./node_modules/_lodash@4.17.15@lodash/_arraySome.js\"),\n    cacheHas = __webpack_require__(/*! ./_cacheHas */ \"./node_modules/_lodash@4.17.15@lodash/_cacheHas.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_equalByTag.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_equalByTag.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/_lodash@4.17.15@lodash/_Symbol.js\"),\n    Uint8Array = __webpack_require__(/*! ./_Uint8Array */ \"./node_modules/_lodash@4.17.15@lodash/_Uint8Array.js\"),\n    eq = __webpack_require__(/*! ./eq */ \"./node_modules/_lodash@4.17.15@lodash/eq.js\"),\n    equalArrays = __webpack_require__(/*! ./_equalArrays */ \"./node_modules/_lodash@4.17.15@lodash/_equalArrays.js\"),\n    mapToArray = __webpack_require__(/*! ./_mapToArray */ \"./node_modules/_lodash@4.17.15@lodash/_mapToArray.js\"),\n    setToArray = __webpack_require__(/*! ./_setToArray */ \"./node_modules/_lodash@4.17.15@lodash/_setToArray.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_equalObjects.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_equalObjects.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getAllKeys = __webpack_require__(/*! ./_getAllKeys */ \"./node_modules/_lodash@4.17.15@lodash/_getAllKeys.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_flatRest.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_flatRest.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar flatten = __webpack_require__(/*! ./flatten */ \"./node_modules/_lodash@4.17.15@lodash/flatten.js\"),\n    overRest = __webpack_require__(/*! ./_overRest */ \"./node_modules/_lodash@4.17.15@lodash/_overRest.js\"),\n    setToString = __webpack_require__(/*! ./_setToString */ \"./node_modules/_lodash@4.17.15@lodash/_setToString.js\");\n\n/**\n * A specialized version of `baseRest` which flattens the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @returns {Function} Returns the new function.\n */\nfunction flatRest(func) {\n  return setToString(overRest(func, undefined, flatten), func + '');\n}\n\nmodule.exports = flatRest;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_freeGlobal.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_freeGlobal.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../_webpack@4.42.1@webpack/buildin/global.js */ \"./node_modules/_webpack@4.42.1@webpack/buildin/global.js\")))\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getAllKeys.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getAllKeys.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetAllKeys.js\"),\n    getSymbols = __webpack_require__(/*! ./_getSymbols */ \"./node_modules/_lodash@4.17.15@lodash/_getSymbols.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/_lodash@4.17.15@lodash/keys.js\");\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getAllKeysIn.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getAllKeysIn.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetAllKeys.js\"),\n    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ \"./node_modules/_lodash@4.17.15@lodash/_getSymbolsIn.js\"),\n    keysIn = __webpack_require__(/*! ./keysIn */ \"./node_modules/_lodash@4.17.15@lodash/keysIn.js\");\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getMapData.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getMapData.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isKeyable = __webpack_require__(/*! ./_isKeyable */ \"./node_modules/_lodash@4.17.15@lodash/_isKeyable.js\");\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getMatchData.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getMatchData.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ \"./node_modules/_lodash@4.17.15@lodash/_isStrictComparable.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/_lodash@4.17.15@lodash/keys.js\");\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getNative.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getNative.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsNative = __webpack_require__(/*! ./_baseIsNative */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsNative.js\"),\n    getValue = __webpack_require__(/*! ./_getValue */ \"./node_modules/_lodash@4.17.15@lodash/_getValue.js\");\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getPrototype.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getPrototype.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar overArg = __webpack_require__(/*! ./_overArg */ \"./node_modules/_lodash@4.17.15@lodash/_overArg.js\");\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getRawTag.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getRawTag.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/_lodash@4.17.15@lodash/_Symbol.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getSymbols.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getSymbols.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayFilter = __webpack_require__(/*! ./_arrayFilter */ \"./node_modules/_lodash@4.17.15@lodash/_arrayFilter.js\"),\n    stubArray = __webpack_require__(/*! ./stubArray */ \"./node_modules/_lodash@4.17.15@lodash/stubArray.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getSymbolsIn.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getSymbolsIn.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayPush = __webpack_require__(/*! ./_arrayPush */ \"./node_modules/_lodash@4.17.15@lodash/_arrayPush.js\"),\n    getPrototype = __webpack_require__(/*! ./_getPrototype */ \"./node_modules/_lodash@4.17.15@lodash/_getPrototype.js\"),\n    getSymbols = __webpack_require__(/*! ./_getSymbols */ \"./node_modules/_lodash@4.17.15@lodash/_getSymbols.js\"),\n    stubArray = __webpack_require__(/*! ./stubArray */ \"./node_modules/_lodash@4.17.15@lodash/stubArray.js\");\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getTag.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getTag.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DataView = __webpack_require__(/*! ./_DataView */ \"./node_modules/_lodash@4.17.15@lodash/_DataView.js\"),\n    Map = __webpack_require__(/*! ./_Map */ \"./node_modules/_lodash@4.17.15@lodash/_Map.js\"),\n    Promise = __webpack_require__(/*! ./_Promise */ \"./node_modules/_lodash@4.17.15@lodash/_Promise.js\"),\n    Set = __webpack_require__(/*! ./_Set */ \"./node_modules/_lodash@4.17.15@lodash/_Set.js\"),\n    WeakMap = __webpack_require__(/*! ./_WeakMap */ \"./node_modules/_lodash@4.17.15@lodash/_WeakMap.js\"),\n    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js\"),\n    toSource = __webpack_require__(/*! ./_toSource */ \"./node_modules/_lodash@4.17.15@lodash/_toSource.js\");\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getValue.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getValue.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_hasPath.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_hasPath.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar castPath = __webpack_require__(/*! ./_castPath */ \"./node_modules/_lodash@4.17.15@lodash/_castPath.js\"),\n    isArguments = __webpack_require__(/*! ./isArguments */ \"./node_modules/_lodash@4.17.15@lodash/isArguments.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isIndex = __webpack_require__(/*! ./_isIndex */ \"./node_modules/_lodash@4.17.15@lodash/_isIndex.js\"),\n    isLength = __webpack_require__(/*! ./isLength */ \"./node_modules/_lodash@4.17.15@lodash/isLength.js\"),\n    toKey = __webpack_require__(/*! ./_toKey */ \"./node_modules/_lodash@4.17.15@lodash/_toKey.js\");\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_hasUnicode.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_hasUnicode.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\nmodule.exports = hasUnicode;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_hashClear.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_hashClear.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar nativeCreate = __webpack_require__(/*! ./_nativeCreate */ \"./node_modules/_lodash@4.17.15@lodash/_nativeCreate.js\");\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_hashDelete.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_hashDelete.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_hashGet.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_hashGet.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar nativeCreate = __webpack_require__(/*! ./_nativeCreate */ \"./node_modules/_lodash@4.17.15@lodash/_nativeCreate.js\");\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_hashHas.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_hashHas.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar nativeCreate = __webpack_require__(/*! ./_nativeCreate */ \"./node_modules/_lodash@4.17.15@lodash/_nativeCreate.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_hashSet.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_hashSet.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar nativeCreate = __webpack_require__(/*! ./_nativeCreate */ \"./node_modules/_lodash@4.17.15@lodash/_nativeCreate.js\");\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_initCloneArray.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_initCloneArray.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_initCloneByTag.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_initCloneByTag.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ \"./node_modules/_lodash@4.17.15@lodash/_cloneArrayBuffer.js\"),\n    cloneDataView = __webpack_require__(/*! ./_cloneDataView */ \"./node_modules/_lodash@4.17.15@lodash/_cloneDataView.js\"),\n    cloneRegExp = __webpack_require__(/*! ./_cloneRegExp */ \"./node_modules/_lodash@4.17.15@lodash/_cloneRegExp.js\"),\n    cloneSymbol = __webpack_require__(/*! ./_cloneSymbol */ \"./node_modules/_lodash@4.17.15@lodash/_cloneSymbol.js\"),\n    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ \"./node_modules/_lodash@4.17.15@lodash/_cloneTypedArray.js\");\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_initCloneObject.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_initCloneObject.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseCreate = __webpack_require__(/*! ./_baseCreate */ \"./node_modules/_lodash@4.17.15@lodash/_baseCreate.js\"),\n    getPrototype = __webpack_require__(/*! ./_getPrototype */ \"./node_modules/_lodash@4.17.15@lodash/_getPrototype.js\"),\n    isPrototype = __webpack_require__(/*! ./_isPrototype */ \"./node_modules/_lodash@4.17.15@lodash/_isPrototype.js\");\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_isFlattenable.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_isFlattenable.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/_lodash@4.17.15@lodash/_Symbol.js\"),\n    isArguments = __webpack_require__(/*! ./isArguments */ \"./node_modules/_lodash@4.17.15@lodash/isArguments.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\");\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_isIndex.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_isIndex.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_isIterateeCall.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_isIterateeCall.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar eq = __webpack_require__(/*! ./eq */ \"./node_modules/_lodash@4.17.15@lodash/eq.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\"),\n    isIndex = __webpack_require__(/*! ./_isIndex */ \"./node_modules/_lodash@4.17.15@lodash/_isIndex.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\");\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_isKey.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_isKey.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/_lodash@4.17.15@lodash/isSymbol.js\");\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_isKeyable.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_isKeyable.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_isMasked.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_isMasked.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar coreJsData = __webpack_require__(/*! ./_coreJsData */ \"./node_modules/_lodash@4.17.15@lodash/_coreJsData.js\");\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_isPrototype.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_isPrototype.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_isStrictComparable.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_isStrictComparable.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\");\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_listCacheClear.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_listCacheClear.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_listCacheDelete.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_listCacheDelete.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ \"./node_modules/_lodash@4.17.15@lodash/_assocIndexOf.js\");\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_listCacheGet.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_listCacheGet.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ \"./node_modules/_lodash@4.17.15@lodash/_assocIndexOf.js\");\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_listCacheHas.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_listCacheHas.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ \"./node_modules/_lodash@4.17.15@lodash/_assocIndexOf.js\");\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_listCacheSet.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_listCacheSet.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ \"./node_modules/_lodash@4.17.15@lodash/_assocIndexOf.js\");\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheClear.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_mapCacheClear.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Hash = __webpack_require__(/*! ./_Hash */ \"./node_modules/_lodash@4.17.15@lodash/_Hash.js\"),\n    ListCache = __webpack_require__(/*! ./_ListCache */ \"./node_modules/_lodash@4.17.15@lodash/_ListCache.js\"),\n    Map = __webpack_require__(/*! ./_Map */ \"./node_modules/_lodash@4.17.15@lodash/_Map.js\");\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheDelete.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_mapCacheDelete.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getMapData = __webpack_require__(/*! ./_getMapData */ \"./node_modules/_lodash@4.17.15@lodash/_getMapData.js\");\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheGet.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_mapCacheGet.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getMapData = __webpack_require__(/*! ./_getMapData */ \"./node_modules/_lodash@4.17.15@lodash/_getMapData.js\");\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheHas.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_mapCacheHas.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getMapData = __webpack_require__(/*! ./_getMapData */ \"./node_modules/_lodash@4.17.15@lodash/_getMapData.js\");\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheSet.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_mapCacheSet.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getMapData = __webpack_require__(/*! ./_getMapData */ \"./node_modules/_lodash@4.17.15@lodash/_getMapData.js\");\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_mapToArray.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_mapToArray.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_matchesStrictComparable.js\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_matchesStrictComparable.js ***!\n  \\*************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_memoizeCapped.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_memoizeCapped.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar memoize = __webpack_require__(/*! ./memoize */ \"./node_modules/_lodash@4.17.15@lodash/memoize.js\");\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_nativeCreate.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_nativeCreate.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/_lodash@4.17.15@lodash/_getNative.js\");\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_nativeKeys.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_nativeKeys.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar overArg = __webpack_require__(/*! ./_overArg */ \"./node_modules/_lodash@4.17.15@lodash/_overArg.js\");\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_nativeKeysIn.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_nativeKeysIn.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_nodeUtil.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_nodeUtil.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ \"./node_modules/_lodash@4.17.15@lodash/_freeGlobal.js\");\n\n/** Detect free variable `exports`. */\nvar freeExports =   true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../_webpack@4.42.1@webpack/buildin/module.js */ \"./node_modules/_webpack@4.42.1@webpack/buildin/module.js\")(module)))\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_objectToString.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_objectToString.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_overArg.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_overArg.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_overRest.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_overRest.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar apply = __webpack_require__(/*! ./_apply */ \"./node_modules/_lodash@4.17.15@lodash/_apply.js\");\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_root.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_root.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar freeGlobal = __webpack_require__(/*! ./_freeGlobal */ \"./node_modules/_lodash@4.17.15@lodash/_freeGlobal.js\");\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_safeGet.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_safeGet.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\nmodule.exports = safeGet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_setCacheAdd.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_setCacheAdd.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_setCacheHas.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_setCacheHas.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_setToArray.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_setToArray.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_setToString.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_setToString.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseSetToString = __webpack_require__(/*! ./_baseSetToString */ \"./node_modules/_lodash@4.17.15@lodash/_baseSetToString.js\"),\n    shortOut = __webpack_require__(/*! ./_shortOut */ \"./node_modules/_lodash@4.17.15@lodash/_shortOut.js\");\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_shortOut.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_shortOut.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_stackClear.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_stackClear.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ListCache = __webpack_require__(/*! ./_ListCache */ \"./node_modules/_lodash@4.17.15@lodash/_ListCache.js\");\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_stackDelete.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_stackDelete.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_stackGet.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_stackGet.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_stackHas.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_stackHas.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_stackSet.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_stackSet.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ListCache = __webpack_require__(/*! ./_ListCache */ \"./node_modules/_lodash@4.17.15@lodash/_ListCache.js\"),\n    Map = __webpack_require__(/*! ./_Map */ \"./node_modules/_lodash@4.17.15@lodash/_Map.js\"),\n    MapCache = __webpack_require__(/*! ./_MapCache */ \"./node_modules/_lodash@4.17.15@lodash/_MapCache.js\");\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_strictIndexOf.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_strictIndexOf.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = strictIndexOf;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_stringSize.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_stringSize.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar asciiSize = __webpack_require__(/*! ./_asciiSize */ \"./node_modules/_lodash@4.17.15@lodash/_asciiSize.js\"),\n    hasUnicode = __webpack_require__(/*! ./_hasUnicode */ \"./node_modules/_lodash@4.17.15@lodash/_hasUnicode.js\"),\n    unicodeSize = __webpack_require__(/*! ./_unicodeSize */ \"./node_modules/_lodash@4.17.15@lodash/_unicodeSize.js\");\n\n/**\n * Gets the number of symbols in `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the string size.\n */\nfunction stringSize(string) {\n  return hasUnicode(string)\n    ? unicodeSize(string)\n    : asciiSize(string);\n}\n\nmodule.exports = stringSize;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_stringToPath.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_stringToPath.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar memoizeCapped = __webpack_require__(/*! ./_memoizeCapped */ \"./node_modules/_lodash@4.17.15@lodash/_memoizeCapped.js\");\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_toKey.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_toKey.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/_lodash@4.17.15@lodash/isSymbol.js\");\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_toSource.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_toSource.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_unicodeSize.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_unicodeSize.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange + ']',\n    rsCombo = '[' + rsComboRange + ']',\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n    rsNonAstral = '[^' + rsAstralRange + ']',\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n    rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?',\n    rsOptVar = '[' + rsVarRange + ']?',\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\n    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Gets the size of a Unicode `string`.\n *\n * @private\n * @param {string} string The string inspect.\n * @returns {number} Returns the string size.\n */\nfunction unicodeSize(string) {\n  var result = reUnicode.lastIndex = 0;\n  while (reUnicode.test(string)) {\n    ++result;\n  }\n  return result;\n}\n\nmodule.exports = unicodeSize;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/clone.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/clone.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseClone = __webpack_require__(/*! ./_baseClone */ \"./node_modules/_lodash@4.17.15@lodash/_baseClone.js\");\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = clone;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/cloneDeep.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/cloneDeep.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseClone = __webpack_require__(/*! ./_baseClone */ \"./node_modules/_lodash@4.17.15@lodash/_baseClone.js\");\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = cloneDeep;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/constant.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/constant.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/defaults.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/defaults.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseRest = __webpack_require__(/*! ./_baseRest */ \"./node_modules/_lodash@4.17.15@lodash/_baseRest.js\"),\n    eq = __webpack_require__(/*! ./eq */ \"./node_modules/_lodash@4.17.15@lodash/eq.js\"),\n    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ \"./node_modules/_lodash@4.17.15@lodash/_isIterateeCall.js\"),\n    keysIn = __webpack_require__(/*! ./keysIn */ \"./node_modules/_lodash@4.17.15@lodash/keysIn.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaultsDeep\n * @example\n *\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar defaults = baseRest(function(object, sources) {\n  object = Object(object);\n\n  var index = -1;\n  var length = sources.length;\n  var guard = length > 2 ? sources[2] : undefined;\n\n  if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n    length = 1;\n  }\n\n  while (++index < length) {\n    var source = sources[index];\n    var props = keysIn(source);\n    var propsIndex = -1;\n    var propsLength = props.length;\n\n    while (++propsIndex < propsLength) {\n      var key = props[propsIndex];\n      var value = object[key];\n\n      if (value === undefined ||\n          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        object[key] = source[key];\n      }\n    }\n  }\n\n  return object;\n});\n\nmodule.exports = defaults;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/each.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/each.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(/*! ./forEach */ \"./node_modules/_lodash@4.17.15@lodash/forEach.js\");\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/eq.js\":\n/*!***************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/eq.js ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/filter.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/filter.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayFilter = __webpack_require__(/*! ./_arrayFilter */ \"./node_modules/_lodash@4.17.15@lodash/_arrayFilter.js\"),\n    baseFilter = __webpack_require__(/*! ./_baseFilter */ \"./node_modules/_lodash@4.17.15@lodash/_baseFilter.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\");\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = filter;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/find.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/find.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createFind = __webpack_require__(/*! ./_createFind */ \"./node_modules/_lodash@4.17.15@lodash/_createFind.js\"),\n    findIndex = __webpack_require__(/*! ./findIndex */ \"./node_modules/_lodash@4.17.15@lodash/findIndex.js\");\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\nmodule.exports = find;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/findIndex.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/findIndex.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ \"./node_modules/_lodash@4.17.15@lodash/_baseFindIndex.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\"),\n    toInteger = __webpack_require__(/*! ./toInteger */ \"./node_modules/_lodash@4.17.15@lodash/toInteger.js\");\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nmodule.exports = findIndex;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/flatten.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/flatten.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFlatten = __webpack_require__(/*! ./_baseFlatten */ \"./node_modules/_lodash@4.17.15@lodash/_baseFlatten.js\");\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nmodule.exports = flatten;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/forEach.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/forEach.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayEach = __webpack_require__(/*! ./_arrayEach */ \"./node_modules/_lodash@4.17.15@lodash/_arrayEach.js\"),\n    baseEach = __webpack_require__(/*! ./_baseEach */ \"./node_modules/_lodash@4.17.15@lodash/_baseEach.js\"),\n    castFunction = __webpack_require__(/*! ./_castFunction */ \"./node_modules/_lodash@4.17.15@lodash/_castFunction.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\");\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\nmodule.exports = forEach;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/forIn.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/forIn.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFor = __webpack_require__(/*! ./_baseFor */ \"./node_modules/_lodash@4.17.15@lodash/_baseFor.js\"),\n    castFunction = __webpack_require__(/*! ./_castFunction */ \"./node_modules/_lodash@4.17.15@lodash/_castFunction.js\"),\n    keysIn = __webpack_require__(/*! ./keysIn */ \"./node_modules/_lodash@4.17.15@lodash/keysIn.js\");\n\n/**\n * Iterates over own and inherited enumerable string keyed properties of an\n * object and invokes `iteratee` for each property. The iteratee is invoked\n * with three arguments: (value, key, object). Iteratee functions may exit\n * iteration early by explicitly returning `false`.\n *\n * @static\n * @memberOf _\n * @since 0.3.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns `object`.\n * @see _.forInRight\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.forIn(new Foo, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n */\nfunction forIn(object, iteratee) {\n  return object == null\n    ? object\n    : baseFor(object, castFunction(iteratee), keysIn);\n}\n\nmodule.exports = forIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/get.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/get.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGet = __webpack_require__(/*! ./_baseGet */ \"./node_modules/_lodash@4.17.15@lodash/_baseGet.js\");\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/has.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/has.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseHas = __webpack_require__(/*! ./_baseHas */ \"./node_modules/_lodash@4.17.15@lodash/_baseHas.js\"),\n    hasPath = __webpack_require__(/*! ./_hasPath */ \"./node_modules/_lodash@4.17.15@lodash/_hasPath.js\");\n\n/**\n * Checks if `path` is a direct property of `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = { 'a': { 'b': 2 } };\n * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.has(object, 'a');\n * // => true\n *\n * _.has(object, 'a.b');\n * // => true\n *\n * _.has(object, ['a', 'b']);\n * // => true\n *\n * _.has(other, 'a');\n * // => false\n */\nfunction has(object, path) {\n  return object != null && hasPath(object, path, baseHas);\n}\n\nmodule.exports = has;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/hasIn.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/hasIn.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseHasIn = __webpack_require__(/*! ./_baseHasIn */ \"./node_modules/_lodash@4.17.15@lodash/_baseHasIn.js\"),\n    hasPath = __webpack_require__(/*! ./_hasPath */ \"./node_modules/_lodash@4.17.15@lodash/_hasPath.js\");\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/identity.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/identity.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isArguments.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isArguments.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsArguments.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isArray.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isArrayLike.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isFunction = __webpack_require__(/*! ./isFunction */ \"./node_modules/_lodash@4.17.15@lodash/isFunction.js\"),\n    isLength = __webpack_require__(/*! ./isLength */ \"./node_modules/_lodash@4.17.15@lodash/isLength.js\");\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isArrayLikeObject.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isArrayLikeObject.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\nmodule.exports = isArrayLikeObject;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isBuffer.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isBuffer.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\"),\n    stubFalse = __webpack_require__(/*! ./stubFalse */ \"./node_modules/_lodash@4.17.15@lodash/stubFalse.js\");\n\n/** Detect free variable `exports`. */\nvar freeExports =   true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../_webpack@4.42.1@webpack/buildin/module.js */ \"./node_modules/_webpack@4.42.1@webpack/buildin/module.js\")(module)))\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isEmpty.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isEmpty.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseKeys = __webpack_require__(/*! ./_baseKeys */ \"./node_modules/_lodash@4.17.15@lodash/_baseKeys.js\"),\n    getTag = __webpack_require__(/*! ./_getTag */ \"./node_modules/_lodash@4.17.15@lodash/_getTag.js\"),\n    isArguments = __webpack_require__(/*! ./isArguments */ \"./node_modules/_lodash@4.17.15@lodash/isArguments.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\"),\n    isBuffer = __webpack_require__(/*! ./isBuffer */ \"./node_modules/_lodash@4.17.15@lodash/isBuffer.js\"),\n    isPrototype = __webpack_require__(/*! ./_isPrototype */ \"./node_modules/_lodash@4.17.15@lodash/_isPrototype.js\"),\n    isTypedArray = __webpack_require__(/*! ./isTypedArray */ \"./node_modules/_lodash@4.17.15@lodash/isTypedArray.js\");\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if `value` is an empty object, collection, map, or set.\n *\n * Objects are considered empty if they have no own enumerable string keyed\n * properties.\n *\n * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n * jQuery-like collections are considered empty if they have a `length` of `0`.\n * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n * @example\n *\n * _.isEmpty(null);\n * // => true\n *\n * _.isEmpty(true);\n * // => true\n *\n * _.isEmpty(1);\n * // => true\n *\n * _.isEmpty([1, 2, 3]);\n * // => false\n *\n * _.isEmpty({ 'a': 1 });\n * // => false\n */\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  if (isArrayLike(value) &&\n      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n        isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n    return !value.length;\n  }\n  var tag = getTag(value);\n  if (tag == mapTag || tag == setTag) {\n    return !value.size;\n  }\n  if (isPrototype(value)) {\n    return !baseKeys(value).length;\n  }\n  for (var key in value) {\n    if (hasOwnProperty.call(value, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = isEmpty;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isFunction.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isFunction.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\");\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isLength.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isLength.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isMap.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isMap.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsMap = __webpack_require__(/*! ./_baseIsMap */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsMap.js\"),\n    baseUnary = __webpack_require__(/*! ./_baseUnary */ \"./node_modules/_lodash@4.17.15@lodash/_baseUnary.js\"),\n    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ \"./node_modules/_lodash@4.17.15@lodash/_nodeUtil.js\");\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isObject.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isObjectLike.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isPlainObject.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isPlainObject.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js\"),\n    getPrototype = __webpack_require__(/*! ./_getPrototype */ \"./node_modules/_lodash@4.17.15@lodash/_getPrototype.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isSet.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isSet.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsSet = __webpack_require__(/*! ./_baseIsSet */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsSet.js\"),\n    baseUnary = __webpack_require__(/*! ./_baseUnary */ \"./node_modules/_lodash@4.17.15@lodash/_baseUnary.js\"),\n    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ \"./node_modules/_lodash@4.17.15@lodash/_nodeUtil.js\");\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isString.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isString.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nmodule.exports = isString;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isSymbol.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isSymbol.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isTypedArray.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isTypedArray.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsTypedArray.js\"),\n    baseUnary = __webpack_require__(/*! ./_baseUnary */ \"./node_modules/_lodash@4.17.15@lodash/_baseUnary.js\"),\n    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ \"./node_modules/_lodash@4.17.15@lodash/_nodeUtil.js\");\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isUndefined.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isUndefined.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is `undefined`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n * @example\n *\n * _.isUndefined(void 0);\n * // => true\n *\n * _.isUndefined(null);\n * // => false\n */\nfunction isUndefined(value) {\n  return value === undefined;\n}\n\nmodule.exports = isUndefined;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/keys.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/keys.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ \"./node_modules/_lodash@4.17.15@lodash/_arrayLikeKeys.js\"),\n    baseKeys = __webpack_require__(/*! ./_baseKeys */ \"./node_modules/_lodash@4.17.15@lodash/_baseKeys.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\");\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/keysIn.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/keysIn.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ \"./node_modules/_lodash@4.17.15@lodash/_arrayLikeKeys.js\"),\n    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ \"./node_modules/_lodash@4.17.15@lodash/_baseKeysIn.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\");\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/last.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/last.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nmodule.exports = last;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/map.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/map.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayMap = __webpack_require__(/*! ./_arrayMap */ \"./node_modules/_lodash@4.17.15@lodash/_arrayMap.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\"),\n    baseMap = __webpack_require__(/*! ./_baseMap */ \"./node_modules/_lodash@4.17.15@lodash/_baseMap.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\");\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/mapValues.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/mapValues.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ \"./node_modules/_lodash@4.17.15@lodash/_baseAssignValue.js\"),\n    baseForOwn = __webpack_require__(/*! ./_baseForOwn */ \"./node_modules/_lodash@4.17.15@lodash/_baseForOwn.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\");\n\n/**\n * Creates an object with the same keys as `object` and values generated\n * by running each own enumerable string keyed property of `object` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, key, object).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns the new mapped object.\n * @see _.mapKeys\n * @example\n *\n * var users = {\n *   'fred':    { 'user': 'fred',    'age': 40 },\n *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n * };\n *\n * _.mapValues(users, function(o) { return o.age; });\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n *\n * // The `_.property` iteratee shorthand.\n * _.mapValues(users, 'age');\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n */\nfunction mapValues(object, iteratee) {\n  var result = {};\n  iteratee = baseIteratee(iteratee, 3);\n\n  baseForOwn(object, function(value, key, object) {\n    baseAssignValue(result, key, iteratee(value, key, object));\n  });\n  return result;\n}\n\nmodule.exports = mapValues;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/max.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/max.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseExtremum = __webpack_require__(/*! ./_baseExtremum */ \"./node_modules/_lodash@4.17.15@lodash/_baseExtremum.js\"),\n    baseGt = __webpack_require__(/*! ./_baseGt */ \"./node_modules/_lodash@4.17.15@lodash/_baseGt.js\"),\n    identity = __webpack_require__(/*! ./identity */ \"./node_modules/_lodash@4.17.15@lodash/identity.js\");\n\n/**\n * Computes the maximum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the maximum value.\n * @example\n *\n * _.max([4, 2, 8, 6]);\n * // => 8\n *\n * _.max([]);\n * // => undefined\n */\nfunction max(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseGt)\n    : undefined;\n}\n\nmodule.exports = max;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/memoize.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/memoize.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar MapCache = __webpack_require__(/*! ./_MapCache */ \"./node_modules/_lodash@4.17.15@lodash/_MapCache.js\");\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/merge.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/merge.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseMerge = __webpack_require__(/*! ./_baseMerge */ \"./node_modules/_lodash@4.17.15@lodash/_baseMerge.js\"),\n    createAssigner = __webpack_require__(/*! ./_createAssigner */ \"./node_modules/_lodash@4.17.15@lodash/_createAssigner.js\");\n\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */\nvar merge = createAssigner(function(object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\n\nmodule.exports = merge;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/min.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/min.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseExtremum = __webpack_require__(/*! ./_baseExtremum */ \"./node_modules/_lodash@4.17.15@lodash/_baseExtremum.js\"),\n    baseLt = __webpack_require__(/*! ./_baseLt */ \"./node_modules/_lodash@4.17.15@lodash/_baseLt.js\"),\n    identity = __webpack_require__(/*! ./identity */ \"./node_modules/_lodash@4.17.15@lodash/identity.js\");\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseLt)\n    : undefined;\n}\n\nmodule.exports = min;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/minBy.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/minBy.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseExtremum = __webpack_require__(/*! ./_baseExtremum */ \"./node_modules/_lodash@4.17.15@lodash/_baseExtremum.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\"),\n    baseLt = __webpack_require__(/*! ./_baseLt */ \"./node_modules/_lodash@4.17.15@lodash/_baseLt.js\");\n\n/**\n * This method is like `_.min` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * the value is ranked. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Math\n * @param {Array} array The array to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * var objects = [{ 'n': 1 }, { 'n': 2 }];\n *\n * _.minBy(objects, function(o) { return o.n; });\n * // => { 'n': 1 }\n *\n * // The `_.property` iteratee shorthand.\n * _.minBy(objects, 'n');\n * // => { 'n': 1 }\n */\nfunction minBy(array, iteratee) {\n  return (array && array.length)\n    ? baseExtremum(array, baseIteratee(iteratee, 2), baseLt)\n    : undefined;\n}\n\nmodule.exports = minBy;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/noop.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/noop.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/now.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/now.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/pick.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/pick.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar basePick = __webpack_require__(/*! ./_basePick */ \"./node_modules/_lodash@4.17.15@lodash/_basePick.js\"),\n    flatRest = __webpack_require__(/*! ./_flatRest */ \"./node_modules/_lodash@4.17.15@lodash/_flatRest.js\");\n\n/**\n * Creates an object composed of the picked `object` properties.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {...(string|string[])} [paths] The property paths to pick.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.pick(object, ['a', 'c']);\n * // => { 'a': 1, 'c': 3 }\n */\nvar pick = flatRest(function(object, paths) {\n  return object == null ? {} : basePick(object, paths);\n});\n\nmodule.exports = pick;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/property.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/property.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseProperty = __webpack_require__(/*! ./_baseProperty */ \"./node_modules/_lodash@4.17.15@lodash/_baseProperty.js\"),\n    basePropertyDeep = __webpack_require__(/*! ./_basePropertyDeep */ \"./node_modules/_lodash@4.17.15@lodash/_basePropertyDeep.js\"),\n    isKey = __webpack_require__(/*! ./_isKey */ \"./node_modules/_lodash@4.17.15@lodash/_isKey.js\"),\n    toKey = __webpack_require__(/*! ./_toKey */ \"./node_modules/_lodash@4.17.15@lodash/_toKey.js\");\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/range.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/range.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createRange = __webpack_require__(/*! ./_createRange */ \"./node_modules/_lodash@4.17.15@lodash/_createRange.js\");\n\n/**\n * Creates an array of numbers (positive and/or negative) progressing from\n * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n * `start` is specified without an `end` or `step`. If `end` is not specified,\n * it's set to `start` with `start` then set to `0`.\n *\n * **Note:** JavaScript follows the IEEE-754 standard for resolving\n * floating-point values which can produce unexpected results.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {number} [start=0] The start of the range.\n * @param {number} end The end of the range.\n * @param {number} [step=1] The value to increment or decrement by.\n * @returns {Array} Returns the range of numbers.\n * @see _.inRange, _.rangeRight\n * @example\n *\n * _.range(4);\n * // => [0, 1, 2, 3]\n *\n * _.range(-4);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 5);\n * // => [1, 2, 3, 4]\n *\n * _.range(0, 20, 5);\n * // => [0, 5, 10, 15]\n *\n * _.range(0, -4, -1);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 4, 0);\n * // => [1, 1, 1]\n *\n * _.range(0);\n * // => []\n */\nvar range = createRange();\n\nmodule.exports = range;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/reduce.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/reduce.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayReduce = __webpack_require__(/*! ./_arrayReduce */ \"./node_modules/_lodash@4.17.15@lodash/_arrayReduce.js\"),\n    baseEach = __webpack_require__(/*! ./_baseEach */ \"./node_modules/_lodash@4.17.15@lodash/_baseEach.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\"),\n    baseReduce = __webpack_require__(/*! ./_baseReduce */ \"./node_modules/_lodash@4.17.15@lodash/_baseReduce.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\");\n\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` thru `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not given, the first element of `collection` is used as the initial\n * value. The iteratee is invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n * and `sortBy`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @returns {*} Returns the accumulated value.\n * @see _.reduceRight\n * @example\n *\n * _.reduce([1, 2], function(sum, n) {\n *   return sum + n;\n * }, 0);\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n *   return result;\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n */\nfunction reduce(collection, iteratee, accumulator) {\n  var func = isArray(collection) ? arrayReduce : baseReduce,\n      initAccum = arguments.length < 3;\n\n  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n}\n\nmodule.exports = reduce;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/size.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/size.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseKeys = __webpack_require__(/*! ./_baseKeys */ \"./node_modules/_lodash@4.17.15@lodash/_baseKeys.js\"),\n    getTag = __webpack_require__(/*! ./_getTag */ \"./node_modules/_lodash@4.17.15@lodash/_getTag.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\"),\n    isString = __webpack_require__(/*! ./isString */ \"./node_modules/_lodash@4.17.15@lodash/isString.js\"),\n    stringSize = __webpack_require__(/*! ./_stringSize */ \"./node_modules/_lodash@4.17.15@lodash/_stringSize.js\");\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/**\n * Gets the size of `collection` by returning its length for array-like\n * values or the number of own enumerable string keyed properties for objects.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object|string} collection The collection to inspect.\n * @returns {number} Returns the collection size.\n * @example\n *\n * _.size([1, 2, 3]);\n * // => 3\n *\n * _.size({ 'a': 1, 'b': 2 });\n * // => 2\n *\n * _.size('pebbles');\n * // => 7\n */\nfunction size(collection) {\n  if (collection == null) {\n    return 0;\n  }\n  if (isArrayLike(collection)) {\n    return isString(collection) ? stringSize(collection) : collection.length;\n  }\n  var tag = getTag(collection);\n  if (tag == mapTag || tag == setTag) {\n    return collection.size;\n  }\n  return baseKeys(collection).length;\n}\n\nmodule.exports = size;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/sortBy.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/sortBy.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFlatten = __webpack_require__(/*! ./_baseFlatten */ \"./node_modules/_lodash@4.17.15@lodash/_baseFlatten.js\"),\n    baseOrderBy = __webpack_require__(/*! ./_baseOrderBy */ \"./node_modules/_lodash@4.17.15@lodash/_baseOrderBy.js\"),\n    baseRest = __webpack_require__(/*! ./_baseRest */ \"./node_modules/_lodash@4.17.15@lodash/_baseRest.js\"),\n    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ \"./node_modules/_lodash@4.17.15@lodash/_isIterateeCall.js\");\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 40 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n */\nvar sortBy = baseRest(function(collection, iteratees) {\n  if (collection == null) {\n    return [];\n  }\n  var length = iteratees.length;\n  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n    iteratees = [];\n  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n    iteratees = [iteratees[0]];\n  }\n  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\n\nmodule.exports = sortBy;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/stubArray.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/stubArray.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/stubFalse.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/stubFalse.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/toFinite.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/toFinite.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toNumber = __webpack_require__(/*! ./toNumber */ \"./node_modules/_lodash@4.17.15@lodash/toNumber.js\");\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/toInteger.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/toInteger.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toFinite = __webpack_require__(/*! ./toFinite */ \"./node_modules/_lodash@4.17.15@lodash/toFinite.js\");\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/toNumber.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/toNumber.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\"),\n    isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/_lodash@4.17.15@lodash/isSymbol.js\");\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/toPlainObject.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/toPlainObject.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar copyObject = __webpack_require__(/*! ./_copyObject */ \"./node_modules/_lodash@4.17.15@lodash/_copyObject.js\"),\n    keysIn = __webpack_require__(/*! ./keysIn */ \"./node_modules/_lodash@4.17.15@lodash/keysIn.js\");\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\nmodule.exports = toPlainObject;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/toString.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/toString.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseToString = __webpack_require__(/*! ./_baseToString */ \"./node_modules/_lodash@4.17.15@lodash/_baseToString.js\");\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/transform.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/transform.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayEach = __webpack_require__(/*! ./_arrayEach */ \"./node_modules/_lodash@4.17.15@lodash/_arrayEach.js\"),\n    baseCreate = __webpack_require__(/*! ./_baseCreate */ \"./node_modules/_lodash@4.17.15@lodash/_baseCreate.js\"),\n    baseForOwn = __webpack_require__(/*! ./_baseForOwn */ \"./node_modules/_lodash@4.17.15@lodash/_baseForOwn.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\"),\n    getPrototype = __webpack_require__(/*! ./_getPrototype */ \"./node_modules/_lodash@4.17.15@lodash/_getPrototype.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isBuffer = __webpack_require__(/*! ./isBuffer */ \"./node_modules/_lodash@4.17.15@lodash/isBuffer.js\"),\n    isFunction = __webpack_require__(/*! ./isFunction */ \"./node_modules/_lodash@4.17.15@lodash/isFunction.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\"),\n    isTypedArray = __webpack_require__(/*! ./isTypedArray */ \"./node_modules/_lodash@4.17.15@lodash/isTypedArray.js\");\n\n/**\n * An alternative to `_.reduce`; this method transforms `object` to a new\n * `accumulator` object which is the result of running each of its own\n * enumerable string keyed properties thru `iteratee`, with each invocation\n * potentially mutating the `accumulator` object. If `accumulator` is not\n * provided, a new object with the same `[[Prototype]]` will be used. The\n * iteratee is invoked with four arguments: (accumulator, value, key, object).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @static\n * @memberOf _\n * @since 1.3.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The custom accumulator value.\n * @returns {*} Returns the accumulated value.\n * @example\n *\n * _.transform([2, 3, 4], function(result, n) {\n *   result.push(n *= n);\n *   return n % 2 == 0;\n * }, []);\n * // => [4, 9]\n *\n * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] }\n */\nfunction transform(object, iteratee, accumulator) {\n  var isArr = isArray(object),\n      isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n  iteratee = baseIteratee(iteratee, 4);\n  if (accumulator == null) {\n    var Ctor = object && object.constructor;\n    if (isArrLike) {\n      accumulator = isArr ? new Ctor : [];\n    }\n    else if (isObject(object)) {\n      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n    }\n    else {\n      accumulator = {};\n    }\n  }\n  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n    return iteratee(accumulator, value, index, object);\n  });\n  return accumulator;\n}\n\nmodule.exports = transform;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/union.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/union.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFlatten = __webpack_require__(/*! ./_baseFlatten */ \"./node_modules/_lodash@4.17.15@lodash/_baseFlatten.js\"),\n    baseRest = __webpack_require__(/*! ./_baseRest */ \"./node_modules/_lodash@4.17.15@lodash/_baseRest.js\"),\n    baseUniq = __webpack_require__(/*! ./_baseUniq */ \"./node_modules/_lodash@4.17.15@lodash/_baseUniq.js\"),\n    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLikeObject.js\");\n\n/**\n * Creates an array of unique values, in order, from all given arrays using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @returns {Array} Returns the new array of combined values.\n * @example\n *\n * _.union([2], [1, 2]);\n * // => [2, 1]\n */\nvar union = baseRest(function(arrays) {\n  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n});\n\nmodule.exports = union;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/uniqueId.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/uniqueId.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toString = __webpack_require__(/*! ./toString */ \"./node_modules/_lodash@4.17.15@lodash/toString.js\");\n\n/** Used to generate unique IDs. */\nvar idCounter = 0;\n\n/**\n * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {string} [prefix=''] The value to prefix the ID with.\n * @returns {string} Returns the unique ID.\n * @example\n *\n * _.uniqueId('contact_');\n * // => 'contact_104'\n *\n * _.uniqueId();\n * // => '105'\n */\nfunction uniqueId(prefix) {\n  var id = ++idCounter;\n  return toString(prefix) + id;\n}\n\nmodule.exports = uniqueId;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/values.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/values.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseValues = __webpack_require__(/*! ./_baseValues */ \"./node_modules/_lodash@4.17.15@lodash/_baseValues.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/_lodash@4.17.15@lodash/keys.js\");\n\n/**\n * Creates an array of the own enumerable string keyed property values of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property values.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.values(new Foo);\n * // => [1, 2] (iteration order is not guaranteed)\n *\n * _.values('hi');\n * // => ['h', 'i']\n */\nfunction values(object) {\n  return object == null ? [] : baseValues(object, keys(object));\n}\n\nmodule.exports = values;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/zipObject.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/zipObject.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assignValue = __webpack_require__(/*! ./_assignValue */ \"./node_modules/_lodash@4.17.15@lodash/_assignValue.js\"),\n    baseZipObject = __webpack_require__(/*! ./_baseZipObject */ \"./node_modules/_lodash@4.17.15@lodash/_baseZipObject.js\");\n\n/**\n * This method is like `_.fromPairs` except that it accepts two arrays,\n * one of property identifiers and one of corresponding values.\n *\n * @static\n * @memberOf _\n * @since 0.4.0\n * @category Array\n * @param {Array} [props=[]] The property identifiers.\n * @param {Array} [values=[]] The property values.\n * @returns {Object} Returns the new object.\n * @example\n *\n * _.zipObject(['a', 'b'], [1, 2]);\n * // => { 'a': 1, 'b': 2 }\n */\nfunction zipObject(props, values) {\n  return baseZipObject(props || [], values || [], assignValue);\n}\n\nmodule.exports = zipObject;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_parse-svg-path@0.1.2@parse-svg-path/index.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_parse-svg-path@0.1.2@parse-svg-path/index.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_point-at-length@1.1.0@point-at-length/index.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_point-at-length@1.1.0@point-at-length/index.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar parse = __webpack_require__(/*! parse-svg-path */ \"./node_modules/_parse-svg-path@0.1.2@parse-svg-path/index.js\");\r\nvar isarray = __webpack_require__(/*! isarray */ \"./node_modules/_isarray@0.0.1@isarray/index.js\");\r\nvar abs = __webpack_require__(/*! abs-svg-path */ \"./node_modules/_abs-svg-path@0.1.1@abs-svg-path/index.js\");\r\n\r\nmodule.exports = Points;\r\n\r\nfunction Points (path) {\r\n    if (!(this instanceof Points)) return new Points(path);\r\n    this._path = isarray(path) ? path : parse(path);\r\n    this._path = abs(this._path);\r\n    this._path = zvhToL(this._path);\r\n    this._path = longhand(this._path);\r\n}\r\n\r\nPoints.prototype.at = function (pos, opts) {\r\n    return this._walk(pos, opts).pos;\r\n};\r\n\r\nPoints.prototype.length = function () {\r\n    return this._walk(null).length;\r\n};\r\n\r\nPoints.prototype._walk = function (pos, opts) {\r\n    var cur = [ 0, 0 ];\r\n    var prev = [ 0, 0, 0 ];\r\n    var p0 = [ 0, 0 ];\r\n    var len = 0;\r\n\r\n    for (var i = 0; i < this._path.length; i++) {\r\n        var p = this._path[i];\r\n        if (p[0] === 'M') {\r\n            cur[0] = p[1];\r\n            cur[1] = p[2];\r\n            if (pos === 0) {\r\n                return { length: len, pos: cur };\r\n            }\r\n        }\r\n        else if (p[0] === 'C') {\r\n            prev[0] = p0[0] = cur[0];\r\n            prev[1] = p0[1] = cur[1];\r\n            prev[2] = len;\r\n\r\n            var n = 100;\r\n            for (var j = 0; j <= n; j++) {\r\n                var t = j / n;\r\n                var x = xof_C(p, t);\r\n                var y = yof_C(p, t);\r\n                len += dist(cur[0], cur[1], x, y);\r\n\r\n                cur[0] = x;\r\n                cur[1] = y;\r\n\r\n                if (typeof pos === 'number' && len >= pos) {\r\n                    var dv = (len - pos) / (len - prev[2]);\r\n\r\n                    var npos = [\r\n                        cur[0] * (1 - dv) + prev[0] * dv,\r\n                        cur[1] * (1 - dv) + prev[1] * dv\r\n                    ];\r\n                    return { length: len, pos: npos };\r\n                }\r\n                prev[0] = cur[0];\r\n                prev[1] = cur[1];\r\n                prev[2] = len;\r\n            }\r\n        }\r\n        else if (p[0] === 'Q') {\r\n            prev[0] = p0[0] = cur[0];\r\n            prev[1] = p0[1] = cur[1];\r\n            prev[2] = len;\r\n\r\n            var n = 100;\r\n            for (var j = 0; j <= n; j++) {\r\n                var t = j / n;\r\n                var x = xof_Q(p, t);\r\n                var y = yof_Q(p, t);\r\n                len += dist(cur[0], cur[1], x, y);\r\n\r\n                cur[0] = x;\r\n                cur[1] = y;\r\n\r\n                if (typeof pos === 'number' && len >= pos) {\r\n                    var dv = (len - pos) / (len - prev[2]);\r\n\r\n                    var npos = [\r\n                        cur[0] * (1 - dv) + prev[0] * dv,\r\n                        cur[1] * (1 - dv) + prev[1] * dv\r\n                    ];\r\n                    return { length: len, pos: npos };\r\n                }\r\n                prev[0] = cur[0];\r\n                prev[1] = cur[1];\r\n                prev[2] = len;\r\n            }\r\n        }\r\n        else if (p[0] === 'L') {\r\n            prev[0] = cur[0];\r\n            prev[1] = cur[1];\r\n            prev[2] = len;\r\n\r\n            len   += dist(cur[0], cur[1], p[1], p[2]);\r\n            cur[0] = p[1];\r\n            cur[1] = p[2];\r\n\r\n            if (typeof pos === 'number' && len >= pos) {\r\n                var dv = (len - pos) / (len - prev[2]);\r\n                var npos = [\r\n                    cur[0] * (1 - dv) + prev[0] * dv,\r\n                    cur[1] * (1 - dv) + prev[1] * dv\r\n                ];\r\n                return { length: len, pos: npos };\r\n            }\r\n            prev[0] = cur[0];\r\n            prev[1] = cur[1];\r\n            prev[2] = len;\r\n        }\r\n    }\r\n\r\n    return { length: len, pos: cur };\r\n    function xof_C (p, t) {\r\n        return Math.pow((1-t), 3) * p0[0]\r\n            + 3 * Math.pow((1-t), 2) * t * p[1]\r\n            + 3 * (1-t) * Math.pow(t, 2) * p[3]\r\n            + Math.pow(t, 3) * p[5]\r\n        ;\r\n    }\r\n    function yof_C (p, t) {\r\n        return Math.pow((1-t), 3) * p0[1]\r\n            + 3 * Math.pow((1-t), 2) * t * p[2]\r\n            + 3 * (1-t) * Math.pow(t, 2) * p[4]\r\n            + Math.pow(t, 3) * p[6]\r\n        ;\r\n    }\r\n\r\n    function xof_Q (p, t) {\r\n        return Math.pow((1-t), 2) * p0[0]\r\n            + 2 * (1-t) * t * p[1]\r\n            + Math.pow(t, 2) * p[3]\r\n        ;\r\n    }\r\n    function yof_Q (p, t) {\r\n        return Math.pow((1-t), 2) * p0[1]\r\n            + 2 * (1-t) * t * p[2]\r\n            + Math.pow(t, 2) * p[4]\r\n        ;\r\n    }\r\n};\r\n\r\nfunction dist (ax, ay, bx, by) {\r\n    var x = ax - bx;\r\n    var y = ay - by;\r\n    return Math.sqrt(x*x + y*y);\r\n}\r\n\r\n// Expand shorthand curve commands to full versions; mutates the path in place for efficiency\r\n// Requires commands have already been converted to absolute versions\r\nfunction longhand(path){\r\n    var prev,x1=0,y1=0;\r\n    var conversion = { S:{to:'C',x:3}, T:{to:'Q',x:1} };\r\n    for(var i=0, len=path.length; i<len; i++){\r\n        var cmd = path[i];\r\n        var convert = conversion[cmd[0]];\r\n\r\n        if (convert) {\r\n            cmd[0] = convert.to;\r\n            if (prev) {\r\n                if (prev[0] === convert.to) {\r\n                    x1 = 2*prev[convert.x+2]-prev[convert.x  ];\r\n                    y1 = 2*prev[convert.x+3]-prev[convert.x+1];\r\n                } else {\r\n                    x1 = prev[prev.length-2];\r\n                    y1 = prev[prev.length-1];\r\n                }\r\n            }\r\n            cmd.splice(1,0,x1,y1);\r\n        }\r\n        prev=cmd;\r\n    }\r\n    return path;\r\n}\r\n\r\n// Convert 'Z', 'V' and 'H' segments to 'L' segments\r\nfunction zvhToL(path){\r\n    var ret = [];\r\n    var startPoint = ['L',0,0];\r\n    var last_point;\r\n\r\n    for(var i=0, len=path.length; i<len; i++){\r\n        var pt = path[i];\r\n        switch(pt[0]){\r\n            case 'M':\r\n                startPoint = ['L', pt[1], pt[2]];\r\n                ret.push(pt);\r\n                break;\r\n            case 'Z':\r\n                ret.push(startPoint);\r\n                break;\r\n            case 'H':\r\n                last_point = ret[ret.length - 1] || ['L',0,0];\r\n                ret.push( ['L', pt[1], last_point[last_point.length - 1]] );\r\n                break;\r\n            case 'V':\r\n                last_point = ret[ret.length - 1] || ['L',0,0];\r\n                ret.push( ['L', last_point[last_point.length - 2], pt[1]] );\r\n                break;\r\n            default:\r\n                ret.push(pt);\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\n\n/***/ }),\n\n/***/ \"./node_modules/_regression@2.0.1@regression/dist/regression.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_regression@2.0.1@regression/dist/regression.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (module) {\n  'use strict';\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  function _toConsumableArray(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n        arr2[i] = arr[i];\n      }\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  }\n\n  var DEFAULT_OPTIONS = { order: 2, precision: 2, period: null };\n\n  /**\n  * Determine the coefficient of determination (r^2) of a fit from the observations\n  * and predictions.\n  *\n  * @param {Array<Array<number>>} data - Pairs of observed x-y values\n  * @param {Array<Array<number>>} results - Pairs of observed predicted x-y values\n  *\n  * @return {number} - The r^2 value, or NaN if one cannot be calculated.\n  */\n  function determinationCoefficient(data, results) {\n    var predictions = [];\n    var observations = [];\n\n    data.forEach(function (d, i) {\n      if (d[1] !== null) {\n        observations.push(d);\n        predictions.push(results[i]);\n      }\n    });\n\n    var sum = observations.reduce(function (a, observation) {\n      return a + observation[1];\n    }, 0);\n    var mean = sum / observations.length;\n\n    var ssyy = observations.reduce(function (a, observation) {\n      var difference = observation[1] - mean;\n      return a + difference * difference;\n    }, 0);\n\n    var sse = observations.reduce(function (accum, observation, index) {\n      var prediction = predictions[index];\n      var residual = observation[1] - prediction[1];\n      return accum + residual * residual;\n    }, 0);\n\n    return 1 - sse / ssyy;\n  }\n\n  /**\n  * Determine the solution of a system of linear equations A * x = b using\n  * Gaussian elimination.\n  *\n  * @param {Array<Array<number>>} input - A 2-d matrix of data in row-major form [ A | b ]\n  * @param {number} order - How many degrees to solve for\n  *\n  * @return {Array<number>} - Vector of normalized solution coefficients matrix (x)\n  */\n  function gaussianElimination(input, order) {\n    var matrix = input;\n    var n = input.length - 1;\n    var coefficients = [order];\n\n    for (var i = 0; i < n; i++) {\n      var maxrow = i;\n      for (var j = i + 1; j < n; j++) {\n        if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {\n          maxrow = j;\n        }\n      }\n\n      for (var k = i; k < n + 1; k++) {\n        var tmp = matrix[k][i];\n        matrix[k][i] = matrix[k][maxrow];\n        matrix[k][maxrow] = tmp;\n      }\n\n      for (var _j = i + 1; _j < n; _j++) {\n        for (var _k = n; _k >= i; _k--) {\n          matrix[_k][_j] -= matrix[_k][i] * matrix[i][_j] / matrix[i][i];\n        }\n      }\n    }\n\n    for (var _j2 = n - 1; _j2 >= 0; _j2--) {\n      var total = 0;\n      for (var _k2 = _j2 + 1; _k2 < n; _k2++) {\n        total += matrix[_k2][_j2] * coefficients[_k2];\n      }\n\n      coefficients[_j2] = (matrix[n][_j2] - total) / matrix[_j2][_j2];\n    }\n\n    return coefficients;\n  }\n\n  /**\n  * Round a number to a precision, specificed in number of decimal places\n  *\n  * @param {number} number - The number to round\n  * @param {number} precision - The number of decimal places to round to:\n  *                             > 0 means decimals, < 0 means powers of 10\n  *\n  *\n  * @return {numbr} - The number, rounded\n  */\n  function round(number, precision) {\n    var factor = Math.pow(10, precision);\n    return Math.round(number * factor) / factor;\n  }\n\n  /**\n  * The set of all fitting methods\n  *\n  * @namespace\n  */\n  var methods = {\n    linear: function linear(data, options) {\n      var sum = [0, 0, 0, 0, 0];\n      var len = 0;\n\n      for (var n = 0; n < data.length; n++) {\n        if (data[n][1] !== null) {\n          len++;\n          sum[0] += data[n][0];\n          sum[1] += data[n][1];\n          sum[2] += data[n][0] * data[n][0];\n          sum[3] += data[n][0] * data[n][1];\n          sum[4] += data[n][1] * data[n][1];\n        }\n      }\n\n      var run = len * sum[2] - sum[0] * sum[0];\n      var rise = len * sum[3] - sum[0] * sum[1];\n      var gradient = run === 0 ? 0 : round(rise / run, options.precision);\n      var intercept = round(sum[1] / len - gradient * sum[0] / len, options.precision);\n\n      var predict = function predict(x) {\n        return [round(x, options.precision), round(gradient * x + intercept, options.precision)];\n      };\n\n      var points = data.map(function (point) {\n        return predict(point[0]);\n      });\n\n      return {\n        points: points,\n        predict: predict,\n        equation: [gradient, intercept],\n        r2: round(determinationCoefficient(data, points), options.precision),\n        string: intercept === 0 ? 'y = ' + gradient + 'x' : 'y = ' + gradient + 'x + ' + intercept\n      };\n    },\n    exponential: function exponential(data, options) {\n      var sum = [0, 0, 0, 0, 0, 0];\n\n      for (var n = 0; n < data.length; n++) {\n        if (data[n][1] !== null) {\n          sum[0] += data[n][0];\n          sum[1] += data[n][1];\n          sum[2] += data[n][0] * data[n][0] * data[n][1];\n          sum[3] += data[n][1] * Math.log(data[n][1]);\n          sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);\n          sum[5] += data[n][0] * data[n][1];\n        }\n      }\n\n      var denominator = sum[1] * sum[2] - sum[5] * sum[5];\n      var a = Math.exp((sum[2] * sum[3] - sum[5] * sum[4]) / denominator);\n      var b = (sum[1] * sum[4] - sum[5] * sum[3]) / denominator;\n      var coeffA = round(a, options.precision);\n      var coeffB = round(b, options.precision);\n      var predict = function predict(x) {\n        return [round(x, options.precision), round(coeffA * Math.exp(coeffB * x), options.precision)];\n      };\n\n      var points = data.map(function (point) {\n        return predict(point[0]);\n      });\n\n      return {\n        points: points,\n        predict: predict,\n        equation: [coeffA, coeffB],\n        string: 'y = ' + coeffA + 'e^(' + coeffB + 'x)',\n        r2: round(determinationCoefficient(data, points), options.precision)\n      };\n    },\n    logarithmic: function logarithmic(data, options) {\n      var sum = [0, 0, 0, 0];\n      var len = data.length;\n\n      for (var n = 0; n < len; n++) {\n        if (data[n][1] !== null) {\n          sum[0] += Math.log(data[n][0]);\n          sum[1] += data[n][1] * Math.log(data[n][0]);\n          sum[2] += data[n][1];\n          sum[3] += Math.pow(Math.log(data[n][0]), 2);\n        }\n      }\n\n      var a = (len * sum[1] - sum[2] * sum[0]) / (len * sum[3] - sum[0] * sum[0]);\n      var coeffB = round(a, options.precision);\n      var coeffA = round((sum[2] - coeffB * sum[0]) / len, options.precision);\n\n      var predict = function predict(x) {\n        return [round(x, options.precision), round(round(coeffA + coeffB * Math.log(x), options.precision), options.precision)];\n      };\n\n      var points = data.map(function (point) {\n        return predict(point[0]);\n      });\n\n      return {\n        points: points,\n        predict: predict,\n        equation: [coeffA, coeffB],\n        string: 'y = ' + coeffA + ' + ' + coeffB + ' ln(x)',\n        r2: round(determinationCoefficient(data, points), options.precision)\n      };\n    },\n    power: function power(data, options) {\n      var sum = [0, 0, 0, 0, 0];\n      var len = data.length;\n\n      for (var n = 0; n < len; n++) {\n        if (data[n][1] !== null) {\n          sum[0] += Math.log(data[n][0]);\n          sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);\n          sum[2] += Math.log(data[n][1]);\n          sum[3] += Math.pow(Math.log(data[n][0]), 2);\n        }\n      }\n\n      var b = (len * sum[1] - sum[0] * sum[2]) / (len * sum[3] - Math.pow(sum[0], 2));\n      var a = (sum[2] - b * sum[0]) / len;\n      var coeffA = round(Math.exp(a), options.precision);\n      var coeffB = round(b, options.precision);\n\n      var predict = function predict(x) {\n        return [round(x, options.precision), round(round(coeffA * Math.pow(x, coeffB), options.precision), options.precision)];\n      };\n\n      var points = data.map(function (point) {\n        return predict(point[0]);\n      });\n\n      return {\n        points: points,\n        predict: predict,\n        equation: [coeffA, coeffB],\n        string: 'y = ' + coeffA + 'x^' + coeffB,\n        r2: round(determinationCoefficient(data, points), options.precision)\n      };\n    },\n    polynomial: function polynomial(data, options) {\n      var lhs = [];\n      var rhs = [];\n      var a = 0;\n      var b = 0;\n      var len = data.length;\n      var k = options.order + 1;\n\n      for (var i = 0; i < k; i++) {\n        for (var l = 0; l < len; l++) {\n          if (data[l][1] !== null) {\n            a += Math.pow(data[l][0], i) * data[l][1];\n          }\n        }\n\n        lhs.push(a);\n        a = 0;\n\n        var c = [];\n        for (var j = 0; j < k; j++) {\n          for (var _l = 0; _l < len; _l++) {\n            if (data[_l][1] !== null) {\n              b += Math.pow(data[_l][0], i + j);\n            }\n          }\n          c.push(b);\n          b = 0;\n        }\n        rhs.push(c);\n      }\n      rhs.push(lhs);\n\n      var coefficients = gaussianElimination(rhs, k).map(function (v) {\n        return round(v, options.precision);\n      });\n\n      var predict = function predict(x) {\n        return [round(x, options.precision), round(coefficients.reduce(function (sum, coeff, power) {\n          return sum + coeff * Math.pow(x, power);\n        }, 0), options.precision)];\n      };\n\n      var points = data.map(function (point) {\n        return predict(point[0]);\n      });\n\n      var string = 'y = ';\n      for (var _i = coefficients.length - 1; _i >= 0; _i--) {\n        if (_i > 1) {\n          string += coefficients[_i] + 'x^' + _i + ' + ';\n        } else if (_i === 1) {\n          string += coefficients[_i] + 'x + ';\n        } else {\n          string += coefficients[_i];\n        }\n      }\n\n      return {\n        string: string,\n        points: points,\n        predict: predict,\n        equation: [].concat(_toConsumableArray(coefficients)).reverse(),\n        r2: round(determinationCoefficient(data, points), options.precision)\n      };\n    }\n  };\n\n  function createWrapper() {\n    var reduce = function reduce(accumulator, name) {\n      return _extends({\n        _round: round\n      }, accumulator, _defineProperty({}, name, function (data, supplied) {\n        return methods[name](data, _extends({}, DEFAULT_OPTIONS, supplied));\n      }));\n    };\n\n    return Object.keys(methods).reduce(reduce, {});\n  }\n\n  module.exports = createWrapper();\n});\n\n\n/***/ }),\n\n/***/ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\":\n/*!***********************************************************************************************!*\\\n  !*** ./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js ***!\n  \\***********************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n!function(t,r){ true?r(exports):undefined}(this,function(t){\"use strict\";function r(t){if(0===t.length)return 0;for(var r,n=t[0],e=0,a=1;a<t.length;a++)r=n+t[a],Math.abs(n)>=Math.abs(t[a])?e+=n-r+t[a]:e+=t[a]-r+n,n=r;return n+e}function g(t){if(0===t.length)throw new Error(\"mean requires at least one data point\");return r(t)/t.length}function n(t,r){var n,e,a=g(t),o=0;if(2===r)for(e=0;e<t.length;e++)o+=(n=t[e]-a)*n;else for(e=0;e<t.length;e++)o+=Math.pow(t[e]-a,r);return o}function e(t){if(0===t.length)throw new Error(\"variance requires at least one data point\");return n(t,2)/t.length}function a(t){if(1===t.length)return 0;var r=e(t);return Math.sqrt(r)}function o(t){if(0===t.length)throw new Error(\"mode requires at least one data point\");if(1===t.length)return t[0];for(var r=t[0],n=NaN,e=0,a=1,o=1;o<t.length+1;o++)t[o]!==r?(e<a&&(e=a,n=r),a=1,r=t[o]):a++;return n}function f(t){return t.slice().sort(function(t,r){return t-r})}function u(t){if(0===t.length)throw new Error(\"min requires at least one data point\");for(var r=t[0],n=1;n<t.length;n++)t[n]<r&&(r=t[n]);return r}function h(t){if(0===t.length)throw new Error(\"max requires at least one data point\");for(var r=t[0],n=1;n<t.length;n++)t[n]>r&&(r=t[n]);return r}function i(t,r){var n=t.length*r;if(0===t.length)throw new Error(\"quantile requires at least one data point.\");if(r<0||1<r)throw new Error(\"quantiles must be between 0 and 1\");return 1===r?t[t.length-1]:0===r?t[0]:n%1!=0?t[Math.ceil(n)-1]:t.length%2==0?(t[n-1]+t[n])/2:t[n]}function c(t,r,n,e){for(n=n||0,e=e||t.length-1;n<e;){if(600<e-n){var a=e-n+1,o=r-n+1,i=Math.log(a),u=.5*Math.exp(2*i/3),h=.5*Math.sqrt(i*u*(a-u)/a);o-a/2<0&&(h*=-1),c(t,r,Math.max(n,Math.floor(r-o*u/a+h)),Math.min(e,Math.floor(r+(a-o)*u/a+h)))}var f=t[r],s=n,l=e;for(p(t,n,r),t[e]>f&&p(t,n,e);s<l;){for(p(t,s,l),s++,l--;t[s]<f;)s++;for(;t[l]>f;)l--}t[n]===f?p(t,n,l):p(t,++l,e),l<=r&&(n=l+1),r<=l&&(e=l-1)}}function p(t,r,n){var e=t[r];t[r]=t[n],t[n]=e}function s(t,r){var n=t.slice();if(Array.isArray(r)){!function(t,r){for(var n=[0],e=0;e<r.length;e++)n.push(w(t.length,r[e]));n.push(t.length-1),n.sort(v);var a=[0,n.length-1];for(;a.length;){var o=Math.ceil(a.pop()),i=Math.floor(a.pop());if(!(o-i<=1)){var u=Math.floor((i+o)/2);l(t,n[u],n[i],n[o]),a.push(i,u,u,o)}}}(n,r);for(var e=[],a=0;a<r.length;a++)e[a]=i(n,r[a]);return e}return l(n,w(n.length,r),0,n.length-1),i(n,r)}function l(t,r,n,e){r%1==0?c(t,r,n,e):(c(t,r=Math.floor(r),n,e),c(t,r+1,r+1,e))}function v(t,r){return t-r}function w(t,r){var n=t*r;return 1===r?t-1:0===r?0:n%1!=0?Math.ceil(n)-1:t%2==0?n-.5:n}function M(t,r){if(r<t[0])return 0;if(r>t[t.length-1])return 1;var n=function(t,r){var n=0,e=0,a=t.length;for(;e<a;)r<=t[n=e+a>>>1]?a=n:e=-~n;return e}(t,r);if(t[n]!==r)return n/t.length;n++;var e=function(t,r){var n=0,e=0,a=t.length;for(;e<a;)r>=t[n=e+a>>>1]?e=-~n:a=n;return e}(t,r);if(e===n)return n/t.length;var a=e-n+1;return a*(e+n)/2/a/t.length}function m(t){var r=s(t,.75),n=s(t,.25);if(\"number\"==typeof r&&\"number\"==typeof n)return r-n}function d(t){return+s(t,.5)}function b(t){for(var r=d(t),n=[],e=0;e<t.length;e++)n.push(Math.abs(t[e]-r));return d(n)}function q(t,r){r=r||Math.random;for(var n,e,a=t.length;0<a;)e=Math.floor(r()*a--),n=t[a],t[a]=t[e],t[e]=n;return t}function E(t,r){return q(t.slice().slice(),r)}function y(t){for(var r,n=0,e=0;e<t.length;e++)0!==e&&t[e]===r||(r=t[e],n++);return n}function S(t,r){for(var n=[],e=0;e<t;e++){for(var a=[],o=0;o<r;o++)a.push(0);n.push(a)}return n}function x(t,r,n,e){var a;if(0<t){var o=(n[r]-n[t-1])/(r-t+1);a=e[r]-e[t-1]-(r-t+1)*o*o}else a=e[r]-n[r]*n[r]/(r+1);return a<0?0:a}function P(t,r,n,e,a,o,i){if(!(r<t)){var u=Math.floor((t+r)/2);e[n][u]=e[n-1][u-1],a[n][u]=u;var h=n;n<t&&(h=Math.max(h,a[n][t-1]||0)),h=Math.max(h,a[n-1][u]||0);var f,s,l,c=u-1;r<e.length-1&&(c=Math.min(c,a[n][r+1]||0));for(var g=c;h<=g&&!((f=x(g,u,o,i))+e[n-1][h-1]>=e[n][u]);--g)(s=x(h,u,o,i)+e[n-1][h-1])<e[n][u]&&(e[n][u]=s,a[n][u]=h),h++,(l=f+e[n-1][g-1])<e[n][u]&&(e[n][u]=l,a[n][u]=g);P(t,u-1,n,e,a,o,i),P(u+1,r,n,e,a,o,i)}}function k(t,r){if(t.length!==r.length)throw new Error(\"sampleCovariance requires samples with equal lengths\");if(t.length<2)throw new Error(\"sampleCovariance requires at least two data points in each sample\");for(var n=g(t),e=g(r),a=0,o=0;o<t.length;o++)a+=(t[o]-n)*(r[o]-e);return a/(t.length-1)}function I(t){if(t.length<2)throw new Error(\"sampleVariance requires at least two data points\");return n(t,2)/(t.length-1)}function D(t){var r=I(t);return Math.sqrt(r)}function C(t,r,n,e){return(t*r+n*e)/(r+e)}function T(t){if(0===t.length)throw new Error(\"rootMeanSquare requires at least one data point\");for(var r=0,n=0;n<t.length;n++)r+=Math.pow(t[n],2);return Math.sqrt(r/t.length)}function _(){this.totalCount=0,this.data={}}function F(){this.weights=[],this.bias=0}_.prototype.train=function(t,r){for(var n in this.data[r]||(this.data[r]={}),t){var e=t[n];void 0===this.data[r][n]&&(this.data[r][n]={}),void 0===this.data[r][n][e]&&(this.data[r][n][e]=0),this.data[r][n][e]++}this.totalCount++},_.prototype.score=function(t){var r,n={};for(var e in t){var a=t[e];for(r in this.data)n[r]={},this.data[r][e]?n[r][e+\"_\"+a]=(this.data[r][e][a]||0)/this.totalCount:n[r][e+\"_\"+a]=0}var o={};for(r in n)for(var i in o[r]=0,n[r])o[r]+=n[r][i];return o},F.prototype.predict=function(t){if(t.length!==this.weights.length)return null;for(var r=0,n=0;n<this.weights.length;n++)r+=this.weights[n]*t[n];return 0<(r+=this.bias)?1:0},F.prototype.train=function(t,r){if(0!==r&&1!==r)return null;t.length!==this.weights.length&&(this.weights=t,this.bias=1);var n=this.predict(t);if(n!==r){for(var e=r-n,a=0;a<this.weights.length;a++)this.weights[a]+=e*t[a];this.bias+=e}return this};var N=1e-4;function R(t){if(t<0)throw new Error(\"factorial requires a non-negative value\");if(Math.floor(t)!==t)throw new Error(\"factorial requires an integer input\");for(var r=1,n=2;n<=t;n++)r*=n;return r}var A=[.9999999999999971,57.15623566586292,-59.59796035547549,14.136097974741746,-.4919138160976202,3399464998481189e-20,4652362892704858e-20,-9837447530487956e-20,.0001580887032249125,-.00021026444172410488,.00021743961811521265,-.0001643181065367639,8441822398385275e-20,-26190838401581408e-21,36899182659531625e-22],z=Math.log(Math.sqrt(2*Math.PI));var V={1:{.995:0,.99:0,.975:0,.95:0,.9:.02,.5:.45,.1:2.71,.05:3.84,.025:5.02,.01:6.63,.005:7.88},2:{.995:.01,.99:.02,.975:.05,.95:.1,.9:.21,.5:1.39,.1:4.61,.05:5.99,.025:7.38,.01:9.21,.005:10.6},3:{.995:.07,.99:.11,.975:.22,.95:.35,.9:.58,.5:2.37,.1:6.25,.05:7.81,.025:9.35,.01:11.34,.005:12.84},4:{.995:.21,.99:.3,.975:.48,.95:.71,.9:1.06,.5:3.36,.1:7.78,.05:9.49,.025:11.14,.01:13.28,.005:14.86},5:{.995:.41,.99:.55,.975:.83,.95:1.15,.9:1.61,.5:4.35,.1:9.24,.05:11.07,.025:12.83,.01:15.09,.005:16.75},6:{.995:.68,.99:.87,.975:1.24,.95:1.64,.9:2.2,.5:5.35,.1:10.65,.05:12.59,.025:14.45,.01:16.81,.005:18.55},7:{.995:.99,.99:1.25,.975:1.69,.95:2.17,.9:2.83,.5:6.35,.1:12.02,.05:14.07,.025:16.01,.01:18.48,.005:20.28},8:{.995:1.34,.99:1.65,.975:2.18,.95:2.73,.9:3.49,.5:7.34,.1:13.36,.05:15.51,.025:17.53,.01:20.09,.005:21.96},9:{.995:1.73,.99:2.09,.975:2.7,.95:3.33,.9:4.17,.5:8.34,.1:14.68,.05:16.92,.025:19.02,.01:21.67,.005:23.59},10:{.995:2.16,.99:2.56,.975:3.25,.95:3.94,.9:4.87,.5:9.34,.1:15.99,.05:18.31,.025:20.48,.01:23.21,.005:25.19},11:{.995:2.6,.99:3.05,.975:3.82,.95:4.57,.9:5.58,.5:10.34,.1:17.28,.05:19.68,.025:21.92,.01:24.72,.005:26.76},12:{.995:3.07,.99:3.57,.975:4.4,.95:5.23,.9:6.3,.5:11.34,.1:18.55,.05:21.03,.025:23.34,.01:26.22,.005:28.3},13:{.995:3.57,.99:4.11,.975:5.01,.95:5.89,.9:7.04,.5:12.34,.1:19.81,.05:22.36,.025:24.74,.01:27.69,.005:29.82},14:{.995:4.07,.99:4.66,.975:5.63,.95:6.57,.9:7.79,.5:13.34,.1:21.06,.05:23.68,.025:26.12,.01:29.14,.005:31.32},15:{.995:4.6,.99:5.23,.975:6.27,.95:7.26,.9:8.55,.5:14.34,.1:22.31,.05:25,.025:27.49,.01:30.58,.005:32.8},16:{.995:5.14,.99:5.81,.975:6.91,.95:7.96,.9:9.31,.5:15.34,.1:23.54,.05:26.3,.025:28.85,.01:32,.005:34.27},17:{.995:5.7,.99:6.41,.975:7.56,.95:8.67,.9:10.09,.5:16.34,.1:24.77,.05:27.59,.025:30.19,.01:33.41,.005:35.72},18:{.995:6.26,.99:7.01,.975:8.23,.95:9.39,.9:10.87,.5:17.34,.1:25.99,.05:28.87,.025:31.53,.01:34.81,.005:37.16},19:{.995:6.84,.99:7.63,.975:8.91,.95:10.12,.9:11.65,.5:18.34,.1:27.2,.05:30.14,.025:32.85,.01:36.19,.005:38.58},20:{.995:7.43,.99:8.26,.975:9.59,.95:10.85,.9:12.44,.5:19.34,.1:28.41,.05:31.41,.025:34.17,.01:37.57,.005:40},21:{.995:8.03,.99:8.9,.975:10.28,.95:11.59,.9:13.24,.5:20.34,.1:29.62,.05:32.67,.025:35.48,.01:38.93,.005:41.4},22:{.995:8.64,.99:9.54,.975:10.98,.95:12.34,.9:14.04,.5:21.34,.1:30.81,.05:33.92,.025:36.78,.01:40.29,.005:42.8},23:{.995:9.26,.99:10.2,.975:11.69,.95:13.09,.9:14.85,.5:22.34,.1:32.01,.05:35.17,.025:38.08,.01:41.64,.005:44.18},24:{.995:9.89,.99:10.86,.975:12.4,.95:13.85,.9:15.66,.5:23.34,.1:33.2,.05:36.42,.025:39.36,.01:42.98,.005:45.56},25:{.995:10.52,.99:11.52,.975:13.12,.95:14.61,.9:16.47,.5:24.34,.1:34.28,.05:37.65,.025:40.65,.01:44.31,.005:46.93},26:{.995:11.16,.99:12.2,.975:13.84,.95:15.38,.9:17.29,.5:25.34,.1:35.56,.05:38.89,.025:41.92,.01:45.64,.005:48.29},27:{.995:11.81,.99:12.88,.975:14.57,.95:16.15,.9:18.11,.5:26.34,.1:36.74,.05:40.11,.025:43.19,.01:46.96,.005:49.65},28:{.995:12.46,.99:13.57,.975:15.31,.95:16.93,.9:18.94,.5:27.34,.1:37.92,.05:41.34,.025:44.46,.01:48.28,.005:50.99},29:{.995:13.12,.99:14.26,.975:16.05,.95:17.71,.9:19.77,.5:28.34,.1:39.09,.05:42.56,.025:45.72,.01:49.59,.005:52.34},30:{.995:13.79,.99:14.95,.975:16.79,.95:18.49,.9:20.6,.5:29.34,.1:40.26,.05:43.77,.025:46.98,.01:50.89,.005:53.67},40:{.995:20.71,.99:22.16,.975:24.43,.95:26.51,.9:29.05,.5:39.34,.1:51.81,.05:55.76,.025:59.34,.01:63.69,.005:66.77},50:{.995:27.99,.99:29.71,.975:32.36,.95:34.76,.9:37.69,.5:49.33,.1:63.17,.05:67.5,.025:71.42,.01:76.15,.005:79.49},60:{.995:35.53,.99:37.48,.975:40.48,.95:43.19,.9:46.46,.5:59.33,.1:74.4,.05:79.08,.025:83.3,.01:88.38,.005:91.95},70:{.995:43.28,.99:45.44,.975:48.76,.95:51.74,.9:55.33,.5:69.33,.1:85.53,.05:90.53,.025:95.02,.01:100.42,.005:104.22},80:{.995:51.17,.99:53.54,.975:57.15,.95:60.39,.9:64.28,.5:79.33,.1:96.58,.05:101.88,.025:106.63,.01:112.33,.005:116.32},90:{.995:59.2,.99:61.75,.975:65.65,.95:69.13,.9:73.29,.5:89.33,.1:107.57,.05:113.14,.025:118.14,.01:124.12,.005:128.3},100:{.995:67.33,.99:70.06,.975:74.22,.95:77.93,.9:82.36,.5:99.33,.1:118.5,.05:124.34,.025:129.56,.01:135.81,.005:140.17}};var j=Math.sqrt(2*Math.PI),B={gaussian:function(t){return Math.exp(-.5*t*t)/j}},K={nrd:function(t){var r=D(t),n=m(t);return\"number\"==typeof n&&(r=Math.min(r,n/1.34)),1.06*r*Math.pow(t.length,-.2)}};function O(e,t,r){var a,o;if(void 0===t)a=B.gaussian;else if(\"string\"==typeof t){if(!B[t])throw new Error('Unknown kernel \"'+t+'\"');a=B[t]}else a=t;if(void 0===r)o=K.nrd(e);else if(\"string\"==typeof r){if(!K[r])throw new Error('Unknown bandwidth method \"'+r+'\"');o=K[r](e)}else o=r;return function(t){var r=0,n=0;for(r=0;r<e.length;r++)n+=a((t-e[r])/o);return n/o/e.length}}var U=Math.sqrt(2*Math.PI);function G(t){for(var r=t,n=t,e=1;e<15;e++)r+=n*=t*t/(2*e+1);return Math.round(1e4*(.5+r/U*Math.exp(-t*t/2)))/1e4}for(var H=[],L=0;L<=3.09;L+=.01)H.push(G(L));function W(t){var r=1/(1+.5*Math.abs(t)),n=r*Math.exp(-Math.pow(t,2)-1.26551223+1.00002368*r+.37409196*Math.pow(r,2)+.09678418*Math.pow(r,3)-.18628806*Math.pow(r,4)+.27886807*Math.pow(r,5)-1.13520398*Math.pow(r,6)+1.48851587*Math.pow(r,7)-.82215223*Math.pow(r,8)+.17087277*Math.pow(r,9));return 0<=t?1-n:n-1}function J(t){var r=8*(Math.PI-3)/(3*Math.PI*(4-Math.PI)),n=Math.sqrt(Math.sqrt(Math.pow(2/(Math.PI*r)+Math.log(1-t*t)/2,2)-Math.log(1-t*t)/r)-(2/(Math.PI*r)+Math.log(1-t*t)/2));return 0<=t?n:-n}function Q(t){if(\"number\"==typeof t)return t<0?-1:0===t?0:1;throw new TypeError(\"not a number\")}t.linearRegression=function(t){var r,n,e=t.length;if(1===e)n=t[r=0][1];else{for(var a,o,i,u=0,h=0,f=0,s=0,l=0;l<e;l++)u+=o=(a=t[l])[0],h+=i=a[1],f+=o*o,s+=o*i;n=h/e-(r=(e*s-u*h)/(e*f-u*u))*u/e}return{m:r,b:n}},t.linearRegressionLine=function(r){return function(t){return r.b+r.m*t}},t.standardDeviation=a,t.rSquared=function(t,r){if(t.length<2)return 1;for(var n,e=0,a=0;a<t.length;a++)e+=t[a][1];n=e/t.length;for(var o=0,i=0;i<t.length;i++)o+=Math.pow(n-t[i][1],2);for(var u=0,h=0;h<t.length;h++)u+=Math.pow(t[h][1]-r(t[h][0]),2);return 1-u/o},t.mode=function(t){return o(f(t))},t.modeFast=function(t){for(var r,n=new Map,e=0,a=0;a<t.length;a++){var o=n.get(t[a]);void 0===o?o=1:o++,e<o&&(r=t[a],e=o),n.set(t[a],o)}if(0===e)throw new Error(\"mode requires at last one data point\");return r},t.modeSorted=o,t.min=u,t.max=h,t.extent=function(t){if(0===t.length)throw new Error(\"extent requires at least one data point\");for(var r=t[0],n=t[0],e=1;e<t.length;e++)t[e]>n&&(n=t[e]),t[e]<r&&(r=t[e]);return[r,n]},t.minSorted=function(t){return t[0]},t.maxSorted=function(t){return t[t.length-1]},t.extentSorted=function(t){return[t[0],t[t.length-1]]},t.sum=r,t.sumSimple=function(t){for(var r=0,n=0;n<t.length;n++)r+=t[n];return r},t.product=function(t){for(var r=1,n=0;n<t.length;n++)r*=t[n];return r},t.quantile=s,t.quantileSorted=i,t.quantileRank=function(t,r){return M(f(t),r)},t.quantileRankSorted=M,t.interquartileRange=m,t.iqr=m,t.medianAbsoluteDeviation=b,t.mad=b,t.chunk=function(t,r){var n=[];if(r<1)throw new Error(\"chunk size must be a positive number\");if(Math.floor(r)!==r)throw new Error(\"chunk size must be an integer\");for(var e=0;e<t.length;e+=r)n.push(t.slice(e,e+r));return n},t.sampleWithReplacement=function(t,r,n){if(0===t.length)return[];n=n||Math.random;for(var e=t.length,a=[],o=0;o<r;o++){var i=Math.floor(n()*e);a.push(t[i])}return a},t.shuffle=E,t.shuffleInPlace=q,t.sample=function(t,r,n){return E(t,n).slice(0,r)},t.ckmeans=function(t,r){if(r>t.length)throw new Error(\"cannot generate more classes than there are data values\");var n=f(t);if(1===y(n))return[n];var e=S(r,n.length),a=S(r,n.length);!function(t,r,n){for(var e,a=r[0].length,o=t[Math.floor(a/2)],i=[],u=[],h=0;h<a;++h)e=t[h]-o,0===h?(i.push(e),u.push(e*e)):(i.push(i[h-1]+e),u.push(u[h-1]+e*e)),r[0][h]=x(0,h,i,u),n[0][h]=0;for(var f=1;f<r.length;++f)P(f<r.length-1?f:a-1,a-1,f,r,n,i,u)}(n,e,a);for(var o=[],i=a[0].length-1,u=a.length-1;0<=u;u--){var h=a[u][i];o[u]=n.slice(h,i+1),0<u&&(i=h-1)}return o},t.uniqueCountSorted=y,t.sumNthPowerDeviations=n,t.equalIntervalBreaks=function(t,r){if(t.length<2)return t;for(var n=u(t),e=h(t),a=[n],o=(e-n)/r,i=1;i<r;i++)a.push(a[0]+o*i);return a.push(e),a},t.sampleCovariance=k,t.sampleCorrelation=function(t,r){return k(t,r)/D(t)/D(r)},t.sampleVariance=I,t.sampleStandardDeviation=D,t.sampleSkewness=function(t){if(t.length<3)throw new Error(\"sampleSkewness requires at least three data points\");for(var r,n=g(t),e=0,a=0,o=0;o<t.length;o++)e+=(r=t[o]-n)*r,a+=r*r*r;var i=t.length-1,u=Math.sqrt(e/i),h=t.length;return h*a/((h-1)*(h-2)*Math.pow(u,3))},t.sampleKurtosis=function(t){var r=t.length;if(r<4)throw new Error(\"sampleKurtosis requires at least four data points\");for(var n,e=g(t),a=0,o=0,i=0;i<r;i++)a+=(n=t[i]-e)*n,o+=n*n*n*n;return(r-1)/((r-2)*(r-3))*(r*(r+1)*o/(a*a)-3*(r-1))},t.permutationsHeap=function(t){for(var r=new Array(t.length),n=[t.slice()],e=0;e<t.length;e++)r[e]=0;for(e=0;e<t.length;)if(r[e]<e){var a=0;e%2!=0&&(a=r[e]);var o=t[a];t[a]=t[e],t[e]=o,n.push(t.slice()),r[e]++,e=0}else r[e]=0,e++;return n},t.combinations=function t(r,n){var e,a,o,i,u=[];for(e=0;e<r.length;e++)if(1===n)u.push([r[e]]);else for(o=t(r.slice(e+1,r.length),n-1),a=0;a<o.length;a++)(i=o[a]).unshift(r[e]),u.push(i);return u},t.combinationsReplacement=function t(r,n){for(var e=[],a=0;a<r.length;a++)if(1===n)e.push([r[a]]);else for(var o=t(r.slice(a,r.length),n-1),i=0;i<o.length;i++)e.push([r[a]].concat(o[i]));return e},t.addToMean=function(t,r,n){return t+(n-t)/(r+1)},t.combineMeans=C,t.combineVariances=function(t,r,n,e,a,o){var i=C(r,n,a,o);return(n*(t+Math.pow(r-i,2))+o*(e+Math.pow(a-i,2)))/(n+o)},t.geometricMean=function(t){if(0===t.length)throw new Error(\"geometricMean requires at least one data point\");for(var r=1,n=0;n<t.length;n++){if(t[n]<=0)throw new Error(\"geometricMean requires only positive numbers as input\");r*=t[n]}return Math.pow(r,1/t.length)},t.harmonicMean=function(t){if(0===t.length)throw new Error(\"harmonicMean requires at least one data point\");for(var r=0,n=0;n<t.length;n++){if(t[n]<=0)throw new Error(\"harmonicMean requires only positive numbers as input\");r+=1/t[n]}return t.length/r},t.average=g,t.mean=g,t.median=d,t.medianSorted=function(t){return i(t,.5)},t.subtractFromMean=function(t,r,n){return(t*r-n)/(r-1)},t.rootMeanSquare=T,t.rms=T,t.variance=e,t.tTest=function(t,r){return(g(t)-r)/(a(t)/Math.sqrt(t.length))},t.tTestTwoSample=function(t,r,n){var e=t.length,a=r.length;if(!e||!a)return null;n||(n=0);var o=g(t),i=g(r),u=I(t),h=I(r);if(\"number\"==typeof o&&\"number\"==typeof i&&\"number\"==typeof u&&\"number\"==typeof h){var f=((e-1)*u+(a-1)*h)/(e+a-2);return(o-i-n)/Math.sqrt(f*(1/e+1/a))}},t.BayesianClassifier=_,t.bayesian=_,t.PerceptronModel=F,t.perceptron=F,t.epsilon=N,t.factorial=R,t.gamma=function t(r){if(\"number\"==typeof(n=r)&&isFinite(n)&&Math.floor(n)===n)return r<=0?NaN:R(r-1);var n;if(--r<0)return Math.PI/(Math.sin(Math.PI*-r)*t(-r));var e=r+.25;return Math.pow(r/Math.E,r)*Math.sqrt(2*Math.PI*(r+1/6))*(1+1/144/Math.pow(e,2)-1/12960/Math.pow(e,3)-257/207360/Math.pow(e,4)-52/2612736/Math.pow(e,5)+5741173/9405849600/Math.pow(e,6)+37529/18811699200/Math.pow(e,7))},t.gammaln=function(t){if(t<=0)return 1/0;t--;for(var r=A[0],n=1;n<15;n++)r+=A[n]/(t+n);var e=5.2421875+t;return z+Math.log(r)-e+(t+.5)*Math.log(e)},t.bernoulliDistribution=function(t){if(t<0||1<t)throw new Error(\"bernoulliDistribution requires probability to be between 0 and 1 inclusive\");return[1-t,t]},t.binomialDistribution=function(t,r){if(!(r<0||1<r||t<=0||t%1!=0)){for(var n=0,e=0,a=[],o=1;a[n]=o*Math.pow(r,n)*Math.pow(1-r,t-n),e+=a[n],o=o*(t-++n+1)/n,e<1-N;);return a}},t.poissonDistribution=function(t){if(!(t<=0)){for(var r=0,n=0,e=[],a=1;e[r]=Math.exp(-t)*Math.pow(t,r)/a,n+=e[r],a*=++r,n<1-N;);return e}},t.chiSquaredDistributionTable=V,t.chiSquaredGoodnessOfFit=function(t,r,n){for(var e,a,o=0,i=r(g(t)),u=[],h=[],f=0;f<t.length;f++)void 0===u[t[f]]&&(u[t[f]]=0),u[t[f]]++;for(f=0;f<u.length;f++)void 0===u[f]&&(u[f]=0);for(a in i)a in u&&(h[+a]=i[a]*t.length);for(a=h.length-1;0<=a;a--)h[a]<3&&(h[a-1]+=h[a],h.pop(),u[a-1]+=u[a],u.pop());for(a=0;a<u.length;a++)o+=Math.pow(u[a]-h[a],2)/h[a];return e=u.length-1-1,V[e][n]<o},t.kernelDensityEstimation=O,t.kde=O,t.zScore=function(t,r,n){return(t-r)/n},t.cumulativeStdNormalProbability=function(t){var r=Math.abs(t),n=Math.min(Math.round(100*r),H.length-1);return 0<=t?H[n]:+(1-H[n]).toFixed(4)},t.standardNormalTable=H,t.errorFunction=W,t.erf=W,t.inverseErrorFunction=J,t.probit=function(t){return 0===t?t=N:1<=t&&(t=1-N),Math.sqrt(2)*J(2*t-1)},t.permutationTest=function(t,r,n,e){if(void 0===e&&(e=1e4),void 0===n&&(n=\"two_side\"),\"two_side\"!==n&&\"greater\"!==n&&\"less\"!==n)throw new Error(\"`alternative` must be either 'two_side', 'greater', or 'less'\");for(var a=g(t)-g(r),o=new Array(e),i=t.concat(r),u=Math.floor(i.length/2),h=0;h<e;h++){q(i);var f=i.slice(0,u),s=i.slice(u,i.length),l=g(f)-g(s);o[h]=l}var c=0;if(\"two_side\"===n)for(h=0;h<=e;h++)Math.abs(o[h])>=Math.abs(a)&&(c+=1);else if(\"greater\"===n)for(h=0;h<=e;h++)o[h]>=a&&(c+=1);else for(h=0;h<=e;h++)o[h]<=a&&(c+=1);return c/e},t.bisect=function(t,r,n,e,a){if(\"function\"!=typeof t)throw new TypeError(\"func must be a function\");for(var o=0;o<e;o++){var i=(r+n)/2;if(0===t(i)||Math.abs((n-r)/2)<a)return i;Q(t(i))===Q(t(r))?r=i:n=i}throw new Error(\"maximum number of iterations exceeded\")},t.quickselect=c,t.sign=Q,t.numericSort=f,Object.defineProperty(t,\"__esModule\",{value:!0})});\n//# sourceMappingURL=simple-statistics.min.js.map\n\n\n/***/ }),\n\n/***/ \"./node_modules/_topojson-client@3.1.0@topojson-client/dist/topojson-client.js\":\n/*!*************************************************************************************!*\\\n  !*** ./node_modules/_topojson-client@3.1.0@topojson-client/dist/topojson-client.js ***!\n  \\*************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://github.com/topojson/topojson-client v3.1.0 Copyright 2019 Mike Bostock\n(function (global, factory) {\n true ? factory(exports) :\nundefined;\n}(this, function (exports) { 'use strict';\n\nfunction identity(x) {\n  return x;\n}\n\nfunction transform(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n\nfunction bbox(topology) {\n  var t = transform(topology.transform), key,\n      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\n  function bboxPoint(p) {\n    p = t(p);\n    if (p[0] < x0) x0 = p[0];\n    if (p[0] > x1) x1 = p[0];\n    if (p[1] < y0) y0 = p[1];\n    if (p[1] > y1) y1 = p[1];\n  }\n\n  function bboxGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n      case \"Point\": bboxPoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n    }\n  }\n\n  topology.arcs.forEach(function(arc) {\n    var i = -1, n = arc.length, p;\n    while (++i < n) {\n      p = t(arc[i], i);\n      if (p[0] < x0) x0 = p[0];\n      if (p[0] > x1) x1 = p[0];\n      if (p[1] < y0) y0 = p[1];\n      if (p[1] > y1) y1 = p[1];\n    }\n  });\n\n  for (key in topology.objects) {\n    bboxGeometry(topology.objects[key]);\n  }\n\n  return [x0, y0, x1, y1];\n}\n\nfunction reverse(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n}\n\nfunction feature(topology, o) {\n  if (typeof o === \"string\") o = topology.objects[o];\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature$1(topology, o); })}\n      : feature$1(topology, o);\n}\n\nfunction feature$1(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nfunction object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n\nfunction stitch(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n    else p1 = arc[arc.length - 1];\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n  return fragments;\n}\n\nfunction mesh(topology) {\n  return object(topology, meshArcs.apply(this, arguments));\n}\n\nfunction meshArcs(topology, object, filter) {\n  var arcs, i, n;\n  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);\n  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;\n  return {type: \"MultiLineString\", arcs: stitch(topology, arcs)};\n}\n\nfunction extractArcs(topology, object, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n\n  return arcs;\n}\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area); // Note: doubled area!\n}\n\nfunction merge(topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n}\n\nfunction mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n\n  objects.forEach(geometry);\n\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"Polygon\": extract(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(extract); break;\n    }\n  }\n\n  function extract(polygon) {\n    polygon.forEach(function(ring) {\n      ring.forEach(function(arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n\n  function area(ring) {\n    return planarRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]);\n  }\n\n  polygons.forEach(function(polygon) {\n    if (!polygon._) {\n      var group = [],\n          neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n\n  polygons.forEach(function(polygon) {\n    delete polygon._;\n  });\n\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function(polygons) {\n      var arcs = [], n;\n\n      // Extract the exterior (unique) arcs.\n      polygons.forEach(function(polygon) {\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      });\n\n      // Stitch the arcs into one or more rings.\n      arcs = stitch(topology, arcs);\n\n      // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n\n      return arcs;\n    }).filter(function(arcs) {\n      return arcs.length > 0;\n    })\n  };\n}\n\nfunction bisect(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n}\n\nfunction neighbors(objects) {\n  var indexesByArc = {}, // arc index -> array of object indexes\n      neighbors = objects.map(function() { return []; });\n\n  function line(arcs, i) {\n    arcs.forEach(function(a) {\n      if (a < 0) a = ~a;\n      var o = indexesByArc[a];\n      if (o) o.push(i);\n      else indexesByArc[a] = [i];\n    });\n  }\n\n  function polygon(arcs, i) {\n    arcs.forEach(function(arc) { line(arc, i); });\n  }\n\n  function geometry(o, i) {\n    if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n  }\n\n  var geometryType = {\n    LineString: line,\n    MultiLineString: polygon,\n    Polygon: polygon,\n    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n  };\n\n  objects.forEach(geometry);\n\n  for (var i in indexesByArc) {\n    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n      for (var k = j + 1; k < m; ++k) {\n        var ij = indexes[j], ik = indexes[k], n;\n        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n      }\n    }\n  }\n\n  return neighbors;\n}\n\nfunction untransform(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2,\n        n = input.length,\n        output = new Array(n),\n        x1 = Math.round((input[0] - dx) / kx),\n        y1 = Math.round((input[1] - dy) / ky);\n    output[0] = x1 - x0, x0 = x1;\n    output[1] = y1 - y0, y0 = y1;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n\nfunction quantize(topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be ≥2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\n    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n      case \"MultiPoint\": output = {type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n}\n\nexports.bbox = bbox;\nexports.feature = feature;\nexports.merge = merge;\nexports.mergeArcs = mergeArcs;\nexports.mesh = mesh;\nexports.meshArcs = meshArcs;\nexports.neighbors = neighbors;\nexports.quantize = quantize;\nexports.transform = transform;\nexports.untransform = untransform;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\":\n/*!***************************************************!*\\\n  !*** ./node_modules/_tslib@1.11.1@tslib/tslib.js ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global global, define, System, Reflect, Promise */\r\nvar __extends;\r\nvar __assign;\r\nvar __rest;\r\nvar __decorate;\r\nvar __param;\r\nvar __metadata;\r\nvar __awaiter;\r\nvar __generator;\r\nvar __exportStar;\r\nvar __values;\r\nvar __read;\r\nvar __spread;\r\nvar __spreadArrays;\r\nvar __await;\r\nvar __asyncGenerator;\r\nvar __asyncDelegator;\r\nvar __asyncValues;\r\nvar __makeTemplateObject;\r\nvar __importStar;\r\nvar __importDefault;\r\nvar __classPrivateFieldGet;\r\nvar __classPrivateFieldSet;\r\n(function (factory) {\r\n    var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\r\n    if (true) {\r\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (exports) { factory(createExporter(root, createExporter(exports))); }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n    }\r\n    else {}\r\n    function createExporter(exports, previous) {\r\n        if (exports !== root) {\r\n            if (typeof Object.create === \"function\") {\r\n                Object.defineProperty(exports, \"__esModule\", { value: true });\r\n            }\r\n            else {\r\n                exports.__esModule = true;\r\n            }\r\n        }\r\n        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\r\n    }\r\n})\r\n(function (exporter) {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\n    __extends = function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n\r\n    __assign = Object.assign || function (t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    __rest = function (s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    };\r\n\r\n    __decorate = function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n\r\n    __param = function (paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    };\r\n\r\n    __metadata = function (metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    };\r\n\r\n    __awaiter = function (thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    };\r\n\r\n    __generator = function (thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    };\r\n\r\n    __exportStar = function (m, exports) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    };\r\n\r\n    __values = function (o) {\r\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n        if (m) return m.call(o);\r\n        if (o && typeof o.length === \"number\") return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n    };\r\n\r\n    __read = function (o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    };\r\n\r\n    __spread = function () {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    };\r\n\r\n    __spreadArrays = function () {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    };\r\n\r\n    __await = function (v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    };\r\n\r\n    __asyncGenerator = function (thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    };\r\n\r\n    __asyncDelegator = function (o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    };\r\n\r\n    __asyncValues = function (o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    };\r\n\r\n    __makeTemplateObject = function (cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    __importStar = function (mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n        result[\"default\"] = mod;\r\n        return result;\r\n    };\r\n\r\n    __importDefault = function (mod) {\r\n        return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n    };\r\n\r\n    __classPrivateFieldGet = function (receiver, privateMap) {\r\n        if (!privateMap.has(receiver)) {\r\n            throw new TypeError(\"attempted to get private field on non-instance\");\r\n        }\r\n        return privateMap.get(receiver);\r\n    };\r\n\r\n    __classPrivateFieldSet = function (receiver, privateMap, value) {\r\n        if (!privateMap.has(receiver)) {\r\n            throw new TypeError(\"attempted to set private field on non-instance\");\r\n        }\r\n        privateMap.set(receiver, value);\r\n        return value;\r\n    }\r\n\r\n    exporter(\"__extends\", __extends);\r\n    exporter(\"__assign\", __assign);\r\n    exporter(\"__rest\", __rest);\r\n    exporter(\"__decorate\", __decorate);\r\n    exporter(\"__param\", __param);\r\n    exporter(\"__metadata\", __metadata);\r\n    exporter(\"__awaiter\", __awaiter);\r\n    exporter(\"__generator\", __generator);\r\n    exporter(\"__exportStar\", __exportStar);\r\n    exporter(\"__values\", __values);\r\n    exporter(\"__read\", __read);\r\n    exporter(\"__spread\", __spread);\r\n    exporter(\"__spreadArrays\", __spreadArrays);\r\n    exporter(\"__await\", __await);\r\n    exporter(\"__asyncGenerator\", __asyncGenerator);\r\n    exporter(\"__asyncDelegator\", __asyncDelegator);\r\n    exporter(\"__asyncValues\", __asyncValues);\r\n    exporter(\"__makeTemplateObject\", __makeTemplateObject);\r\n    exporter(\"__importStar\", __importStar);\r\n    exporter(\"__importDefault\", __importDefault);\r\n    exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet);\r\n    exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet);\r\n});\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../_webpack@4.42.1@webpack/buildin/global.js */ \"./node_modules/_webpack@4.42.1@webpack/buildin/global.js\")))\n\n/***/ }),\n\n/***/ \"./node_modules/_webpack@4.42.1@webpack/buildin/global.js\":\n/*!***********************************!*\\\n  !*** (webpack)/buildin/global.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_webpack@4.42.1@webpack/buildin/module.js\":\n/*!***********************************!*\\\n  !*** (webpack)/buildin/module.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/_wolfy87-eventemitter@5.2.9@wolfy87-eventemitter/EventEmitter.js\":\n/*!***************************************************************************************!*\\\n  !*** ./node_modules/_wolfy87-eventemitter@5.2.9@wolfy87-eventemitter/EventEmitter.js ***!\n  \\***************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * EventEmitter v5.2.9 - git.io/ee\n * Unlicense - http://unlicense.org/\n * Oliver Caldwell - https://oli.me.uk/\n * @preserve\n */\n\n;(function (exports) {\n    'use strict';\n\n    /**\n     * Class for managing events.\n     * Can be extended to provide event functionality in other classes.\n     *\n     * @class EventEmitter Manages event registering and emitting.\n     */\n    function EventEmitter() {}\n\n    // Shortcuts to improve speed and size\n    var proto = EventEmitter.prototype;\n    var originalGlobalValue = exports.EventEmitter;\n\n    /**\n     * Finds the index of the listener for the event in its storage array.\n     *\n     * @param {Function[]} listeners Array of listeners to search through.\n     * @param {Function} listener Method to look for.\n     * @return {Number} Index of the specified listener, -1 if not found\n     * @api private\n     */\n    function indexOfListener(listeners, listener) {\n        var i = listeners.length;\n        while (i--) {\n            if (listeners[i].listener === listener) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Alias a method while keeping the context correct, to allow for overwriting of target method.\n     *\n     * @param {String} name The name of the target method.\n     * @return {Function} The aliased method\n     * @api private\n     */\n    function alias(name) {\n        return function aliasClosure() {\n            return this[name].apply(this, arguments);\n        };\n    }\n\n    /**\n     * Returns the listener array for the specified event.\n     * Will initialise the event object and listener arrays if required.\n     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.\n     * Each property in the object response is an array of listener functions.\n     *\n     * @param {String|RegExp} evt Name of the event to return the listeners from.\n     * @return {Function[]|Object} All listener functions for the event.\n     */\n    proto.getListeners = function getListeners(evt) {\n        var events = this._getEvents();\n        var response;\n        var key;\n\n        // Return a concatenated array of all matching events if\n        // the selector is a regular expression.\n        if (evt instanceof RegExp) {\n            response = {};\n            for (key in events) {\n                if (events.hasOwnProperty(key) && evt.test(key)) {\n                    response[key] = events[key];\n                }\n            }\n        }\n        else {\n            response = events[evt] || (events[evt] = []);\n        }\n\n        return response;\n    };\n\n    /**\n     * Takes a list of listener objects and flattens it into a list of listener functions.\n     *\n     * @param {Object[]} listeners Raw listener objects.\n     * @return {Function[]} Just the listener functions.\n     */\n    proto.flattenListeners = function flattenListeners(listeners) {\n        var flatListeners = [];\n        var i;\n\n        for (i = 0; i < listeners.length; i += 1) {\n            flatListeners.push(listeners[i].listener);\n        }\n\n        return flatListeners;\n    };\n\n    /**\n     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.\n     *\n     * @param {String|RegExp} evt Name of the event to return the listeners from.\n     * @return {Object} All listener functions for an event in an object.\n     */\n    proto.getListenersAsObject = function getListenersAsObject(evt) {\n        var listeners = this.getListeners(evt);\n        var response;\n\n        if (listeners instanceof Array) {\n            response = {};\n            response[evt] = listeners;\n        }\n\n        return response || listeners;\n    };\n\n    function isValidListener (listener) {\n        if (typeof listener === 'function' || listener instanceof RegExp) {\n            return true\n        } else if (listener && typeof listener === 'object') {\n            return isValidListener(listener.listener)\n        } else {\n            return false\n        }\n    }\n\n    /**\n     * Adds a listener function to the specified event.\n     * The listener will not be added if it is a duplicate.\n     * If the listener returns true then it will be removed after it is called.\n     * If you pass a regular expression as the event name then the listener will be added to all events that match it.\n     *\n     * @param {String|RegExp} evt Name of the event to attach the listener to.\n     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.addListener = function addListener(evt, listener) {\n        if (!isValidListener(listener)) {\n            throw new TypeError('listener must be a function');\n        }\n\n        var listeners = this.getListenersAsObject(evt);\n        var listenerIsWrapped = typeof listener === 'object';\n        var key;\n\n        for (key in listeners) {\n            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {\n                listeners[key].push(listenerIsWrapped ? listener : {\n                    listener: listener,\n                    once: false\n                });\n            }\n        }\n\n        return this;\n    };\n\n    /**\n     * Alias of addListener\n     */\n    proto.on = alias('addListener');\n\n    /**\n     * Semi-alias of addListener. It will add a listener that will be\n     * automatically removed after its first execution.\n     *\n     * @param {String|RegExp} evt Name of the event to attach the listener to.\n     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.addOnceListener = function addOnceListener(evt, listener) {\n        return this.addListener(evt, {\n            listener: listener,\n            once: true\n        });\n    };\n\n    /**\n     * Alias of addOnceListener.\n     */\n    proto.once = alias('addOnceListener');\n\n    /**\n     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.\n     * You need to tell it what event names should be matched by a regex.\n     *\n     * @param {String} evt Name of the event to create.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.defineEvent = function defineEvent(evt) {\n        this.getListeners(evt);\n        return this;\n    };\n\n    /**\n     * Uses defineEvent to define multiple events.\n     *\n     * @param {String[]} evts An array of event names to define.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.defineEvents = function defineEvents(evts) {\n        for (var i = 0; i < evts.length; i += 1) {\n            this.defineEvent(evts[i]);\n        }\n        return this;\n    };\n\n    /**\n     * Removes a listener function from the specified event.\n     * When passed a regular expression as the event name, it will remove the listener from all events that match it.\n     *\n     * @param {String|RegExp} evt Name of the event to remove the listener from.\n     * @param {Function} listener Method to remove from the event.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.removeListener = function removeListener(evt, listener) {\n        var listeners = this.getListenersAsObject(evt);\n        var index;\n        var key;\n\n        for (key in listeners) {\n            if (listeners.hasOwnProperty(key)) {\n                index = indexOfListener(listeners[key], listener);\n\n                if (index !== -1) {\n                    listeners[key].splice(index, 1);\n                }\n            }\n        }\n\n        return this;\n    };\n\n    /**\n     * Alias of removeListener\n     */\n    proto.off = alias('removeListener');\n\n    /**\n     * Adds listeners in bulk using the manipulateListeners method.\n     * If you pass an object as the first argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.\n     * You can also pass it a regular expression to add the array of listeners to all events that match it.\n     * Yeah, this function does quite a bit. That's probably a bad thing.\n     *\n     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.\n     * @param {Function[]} [listeners] An optional array of listener functions to add.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.addListeners = function addListeners(evt, listeners) {\n        // Pass through to manipulateListeners\n        return this.manipulateListeners(false, evt, listeners);\n    };\n\n    /**\n     * Removes listeners in bulk using the manipulateListeners method.\n     * If you pass an object as the first argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n     * You can also pass it an event name and an array of listeners to be removed.\n     * You can also pass it a regular expression to remove the listeners from all events that match it.\n     *\n     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.\n     * @param {Function[]} [listeners] An optional array of listener functions to remove.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.removeListeners = function removeListeners(evt, listeners) {\n        // Pass through to manipulateListeners\n        return this.manipulateListeners(true, evt, listeners);\n    };\n\n    /**\n     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.\n     * The first argument will determine if the listeners are removed (true) or added (false).\n     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n     * You can also pass it an event name and an array of listeners to be added/removed.\n     * You can also pass it a regular expression to manipulate the listeners of all events that match it.\n     *\n     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.\n     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.\n     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {\n        var i;\n        var value;\n        var single = remove ? this.removeListener : this.addListener;\n        var multiple = remove ? this.removeListeners : this.addListeners;\n\n        // If evt is an object then pass each of its properties to this method\n        if (typeof evt === 'object' && !(evt instanceof RegExp)) {\n            for (i in evt) {\n                if (evt.hasOwnProperty(i) && (value = evt[i])) {\n                    // Pass the single listener straight through to the singular method\n                    if (typeof value === 'function') {\n                        single.call(this, i, value);\n                    }\n                    else {\n                        // Otherwise pass back to the multiple function\n                        multiple.call(this, i, value);\n                    }\n                }\n            }\n        }\n        else {\n            // So evt must be a string\n            // And listeners must be an array of listeners\n            // Loop over it and pass each one to the multiple method\n            i = listeners.length;\n            while (i--) {\n                single.call(this, evt, listeners[i]);\n            }\n        }\n\n        return this;\n    };\n\n    /**\n     * Removes all listeners from a specified event.\n     * If you do not specify an event then all listeners will be removed.\n     * That means every event will be emptied.\n     * You can also pass a regex to remove all events that match it.\n     *\n     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.removeEvent = function removeEvent(evt) {\n        var type = typeof evt;\n        var events = this._getEvents();\n        var key;\n\n        // Remove different things depending on the state of evt\n        if (type === 'string') {\n            // Remove all listeners for the specified event\n            delete events[evt];\n        }\n        else if (evt instanceof RegExp) {\n            // Remove all events matching the regex.\n            for (key in events) {\n                if (events.hasOwnProperty(key) && evt.test(key)) {\n                    delete events[key];\n                }\n            }\n        }\n        else {\n            // Remove all listeners in all events\n            delete this._events;\n        }\n\n        return this;\n    };\n\n    /**\n     * Alias of removeEvent.\n     *\n     * Added to mirror the node API.\n     */\n    proto.removeAllListeners = alias('removeEvent');\n\n    /**\n     * Emits an event of your choice.\n     * When emitted, every listener attached to that event will be executed.\n     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.\n     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.\n     * So they will not arrive within the array on the other side, they will be separate.\n     * You can also pass a regular expression to emit to all events that match it.\n     *\n     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n     * @param {Array} [args] Optional array of arguments to be passed to each listener.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.emitEvent = function emitEvent(evt, args) {\n        var listenersMap = this.getListenersAsObject(evt);\n        var listeners;\n        var listener;\n        var i;\n        var key;\n        var response;\n\n        for (key in listenersMap) {\n            if (listenersMap.hasOwnProperty(key)) {\n                listeners = listenersMap[key].slice(0);\n\n                for (i = 0; i < listeners.length; i++) {\n                    // If the listener returns true then it shall be removed from the event\n                    // The function is executed either with a basic call or an apply if there is an args array\n                    listener = listeners[i];\n\n                    if (listener.once === true) {\n                        this.removeListener(evt, listener.listener);\n                    }\n\n                    response = listener.listener.apply(this, args || []);\n\n                    if (response === this._getOnceReturnValue()) {\n                        this.removeListener(evt, listener.listener);\n                    }\n                }\n            }\n        }\n\n        return this;\n    };\n\n    /**\n     * Alias of emitEvent\n     */\n    proto.trigger = alias('emitEvent');\n\n    /**\n     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.\n     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.\n     *\n     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n     * @param {...*} Optional additional arguments to be passed to each listener.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.emit = function emit(evt) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return this.emitEvent(evt, args);\n    };\n\n    /**\n     * Sets the current value to check against when executing listeners. If a\n     * listeners return value matches the one set here then it will be removed\n     * after execution. This value defaults to true.\n     *\n     * @param {*} value The new value to check for when executing listeners.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.setOnceReturnValue = function setOnceReturnValue(value) {\n        this._onceReturnValue = value;\n        return this;\n    };\n\n    /**\n     * Fetches the current value to check against when executing listeners. If\n     * the listeners return value matches this one then it should be removed\n     * automatically. It will return true by default.\n     *\n     * @return {*|Boolean} The current value to check for or the default, true.\n     * @api private\n     */\n    proto._getOnceReturnValue = function _getOnceReturnValue() {\n        if (this.hasOwnProperty('_onceReturnValue')) {\n            return this._onceReturnValue;\n        }\n        else {\n            return true;\n        }\n    };\n\n    /**\n     * Fetches the events object and creates one if required.\n     *\n     * @return {Object} The events storage object.\n     * @api private\n     */\n    proto._getEvents = function _getEvents() {\n        return this._events || (this._events = {});\n    };\n\n    /**\n     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.\n     *\n     * @return {Function} Non conflicting EventEmitter class.\n     */\n    EventEmitter.noConflict = function noConflict() {\n        exports.EventEmitter = originalGlobalValue;\n        return EventEmitter;\n    };\n\n    // Expose the class either via AMD, CommonJS or the global object\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n            return EventEmitter;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    else {}\n}(typeof window !== 'undefined' ? window : this || {}));\n\n\n/***/ }),\n\n/***/ \"./src/api/geo.ts\":\n/*!************************!*\\\n  !*** ./src/api/geo.ts ***!\n  \\************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3_geo_1 = __webpack_require__(/*! d3-geo */ \"./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js\");\nvar d3_geo_projection_1 = __webpack_require__(/*! d3-geo-projection */ \"./node_modules/_d3-geo-projection@2.1.2@d3-geo-projection/build/d3-geo-projection.js\");\nvar view_1 = __webpack_require__(/*! ../view */ \"./src/view.ts\");\nvar get_geo_projection_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/get-geo-projection */ \"./src/util/get-geo-projection.ts\"));\nvar api = {\n    // geo maintain\n    geoArea: function (feature) {\n        return d3_geo_1.geoArea(feature);\n    },\n    geoAreaByName: function (name) {\n        return d3_geo_1.geoArea(this.geoFeatureByName(name));\n    },\n    geoCentroid: function (feature) {\n        return d3_geo_1.geoCentroid(feature);\n    },\n    geoCentroidByName: function (name) {\n        return d3_geo_1.geoCentroid(this.geoFeatureByName(name));\n    },\n    geoDistance: function (p1, p2) {\n        return d3_geo_1.geoDistance(p1, p2);\n    },\n    geoLength: function (feature) {\n        return d3_geo_1.geoLength(feature);\n    },\n    geoLengthByName: function (name) {\n        return d3_geo_1.geoLength(this.geoFeatureByName(name));\n    },\n    geoContains: function (feature, position /* [longitude, latitude] */) {\n        return d3_geo_1.geoContains(feature, position);\n    },\n    geoFeatureByName: function (name) {\n        var rows = this.rows;\n        var result;\n        rows.some(function (feature) {\n            if (feature.name === name) {\n                result = feature;\n                return true;\n            }\n            return false;\n        });\n        return result;\n    },\n    geoFeatureByPosition: function (position) {\n        var rows = this.rows;\n        var result;\n        rows.some(function (feature) {\n            if (d3_geo_1.geoContains(feature, position)) {\n                result = feature;\n                return true;\n            }\n            return false;\n        });\n        return result;\n    },\n    geoNameByPosition: function (position) {\n        var feature = this.geoFeatureByPosition(position);\n        if (feature) {\n            return feature.name;\n        }\n    },\n    // projection\n    // export getGeoProjection for custom used.\n    getGeoProjection: get_geo_projection_1.default,\n    geoProject: function (feature, projection, exportRaw) {\n        projection = get_geo_projection_1.default(projection, exportRaw);\n        return d3_geo_projection_1.geoProject(feature, projection);\n    },\n    geoProjectByName: function (name, projection, exportRaw) {\n        projection = get_geo_projection_1.default(projection, exportRaw);\n        return d3_geo_projection_1.geoProject(this.geoFeatureByName(name), projection);\n    },\n    geoProjectPosition: function (position, projection, exportRaw) {\n        var func = get_geo_projection_1.default(projection, exportRaw);\n        return func(position);\n    },\n    geoProjectInvert: function (position /* [x, y] */, projection, exportRaw) {\n        var func = get_geo_projection_1.default(projection, exportRaw);\n        return func.invert(position);\n    },\n};\nutil_1.assign(view_1.View.prototype, api);\n\n\n/***/ }),\n\n/***/ \"./src/api/hierarchy.ts\":\n/*!******************************!*\\\n  !*** ./src/api/hierarchy.ts ***!\n  \\******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar view_1 = __webpack_require__(/*! ../view */ \"./src/view.ts\");\nutil_1.assign(view_1.View.prototype, {\n    getAllNodes: function () {\n        var nodes = [];\n        var root = this.root;\n        if (root && root.each) {\n            // d3-hierarchy\n            root.each(function (node) {\n                nodes.push(node);\n            });\n        }\n        else if (root && root.eachNode) {\n            // @antv/hierarchy\n            root.eachNode(function (node) {\n                nodes.push(node);\n            });\n        }\n        return nodes;\n    },\n    getAllLinks: function () {\n        var links = [];\n        var nodes = [this.root];\n        var node;\n        while ((node = nodes.pop())) {\n            var children = node.children;\n            if (children) {\n                children.forEach(function (child) {\n                    links.push({\n                        source: node,\n                        target: child,\n                    });\n                    nodes.push(child);\n                });\n            }\n        }\n        return links;\n    },\n});\nutil_1.assign(view_1.View.prototype, {\n    getAllEdges: view_1.View.prototype.getAllLinks,\n});\n\n\n/***/ }),\n\n/***/ \"./src/api/partition.ts\":\n/*!******************************!*\\\n  !*** ./src/api/partition.ts ***!\n  \\******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar view_1 = __webpack_require__(/*! ../view */ \"./src/view.ts\");\nutil_1.assign(view_1.View.prototype, {\n    partition: function (group_by, order_by) {\n        if (order_by === void 0) { order_by = []; }\n        return partition_1.default(this.rows, group_by, order_by);\n    },\n    group: function (group_by, order_by) {\n        if (order_by === void 0) { order_by = []; }\n        var groups = this.partition(group_by, order_by);\n        return util_1.values(groups);\n    },\n    groups: function (group_by, order_by) {\n        if (order_by === void 0) { order_by = []; }\n        return this.group(group_by, order_by);\n    },\n});\n\n\n/***/ }),\n\n/***/ \"./src/api/statistics.ts\":\n/*!*******************************!*\\\n  !*** ./src/api/statistics.ts ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar simpleStatistics = tslib_1.__importStar(__webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar view_1 = __webpack_require__(/*! ../view */ \"./src/view.ts\");\nvar p_by_fraction_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/p-by-fraction */ \"./src/util/p-by-fraction.ts\"));\nvar constants_1 = tslib_1.__importDefault(__webpack_require__(/*! ../constants */ \"./src/constants.ts\"));\nvar STATISTICS_METHODS = constants_1.default.STATISTICS_METHODS;\nfunction getColumnValues(view, column) {\n    var values = view.getColumn(column);\n    if (util_1.isArray(values) && util_1.isArray(values[0])) {\n        values = util_1.flattenDeep(values);\n    }\n    return values;\n}\n// statistics\nSTATISTICS_METHODS.forEach(function (method) {\n    // @ts-ignore;\n    view_1.View.prototype[method] = function (column) {\n        // @ts-ignore\n        return simpleStatistics[method](getColumnValues(this, column));\n    };\n});\nvar quantile = simpleStatistics.quantile;\nutil_1.assign(view_1.View.prototype, {\n    average: view_1.View.prototype.mean,\n    quantile: function (column, p) {\n        return quantile(getColumnValues(this, column), p);\n    },\n    quantiles: function (column, pArr) {\n        var columnArr = getColumnValues(this, column);\n        return pArr.map(function (p) { return quantile(columnArr, p); });\n    },\n    quantilesByFraction: function (column, fraction) {\n        return this.quantiles(column, p_by_fraction_1.default(fraction));\n    },\n    range: function (column) {\n        return [this.min(column), this.max(column)];\n    },\n    extent: function (column) {\n        // alias\n        return this.range(column);\n    },\n});\n\n\n/***/ }),\n\n/***/ \"./src/connector/default.ts\":\n/*!**********************************!*\\\n  !*** ./src/connector/default.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\ndata_set_1.DataSet.registerConnector('default', function (data, dataSet) {\n    var view;\n    if (util_1.isString(data)) {\n        view = dataSet.getView(data);\n    }\n    else {\n        view = data;\n    }\n    if (!view) {\n        throw new TypeError('Invalid dataView');\n    }\n    return util_1.deepMix([], view.rows);\n});\n\n\n/***/ }),\n\n/***/ \"./src/connector/dsv.ts\":\n/*!******************************!*\\\n  !*** ./src/connector/dsv.ts ***!\n  \\******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3_dsv_1 = __webpack_require__(/*! d3-dsv */ \"./node_modules/_d3-dsv@1.2.0@d3-dsv/dist/d3-dsv.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\ndata_set_1.DataSet.registerConnector('dsv', function (str, options) {\n    if (options === void 0) { options = {}; }\n    var delimiter = options.delimiter || ',';\n    if (!util_1.isString(delimiter)) {\n        throw new TypeError('Invalid delimiter: must be a string!');\n    }\n    return d3_dsv_1.dsvFormat(delimiter).parse(str);\n});\ndata_set_1.DataSet.registerConnector('csv', function (str) {\n    return d3_dsv_1.csvParse(str);\n});\ndata_set_1.DataSet.registerConnector('tsv', function (str) {\n    return d3_dsv_1.tsvParse(str);\n});\n\n\n/***/ }),\n\n/***/ \"./src/connector/geo-graticule.ts\":\n/*!****************************************!*\\\n  !*** ./src/connector/geo-graticule.ts ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar d3_geo_1 = __webpack_require__(/*! d3-geo */ \"./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nfunction connector(_options, dataView) {\n    dataView.dataType = 'geo-graticule';\n    var data = d3_geo_1.geoGraticule().lines();\n    data.map(function (row, index) {\n        row.index = \"\" + index;\n        return row;\n    });\n    dataView.rows = data;\n    return data;\n}\nexports.default = connector;\ndata_set_1.DataSet.registerConnector('geo-graticule', connector);\n\n\n/***/ }),\n\n/***/ \"./src/connector/geojson.ts\":\n/*!**********************************!*\\\n  !*** ./src/connector/geojson.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar point_at_length_1 = tslib_1.__importDefault(__webpack_require__(/*! point-at-length */ \"./node_modules/_point-at-length@1.1.0@point-at-length/index.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3_geo_1 = __webpack_require__(/*! d3-geo */ \"./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar geoPathGenerator = d3_geo_1.geoPath();\nfunction GeoJSONConnector(data, _options, dataView) {\n    dataView.dataType = data_set_1.DataSet.CONSTANTS.GEO;\n    var features = util_1.deepMix([], data.features);\n    // pre-process\n    features.forEach(function (feature) {\n        feature.name = feature.properties.name;\n        feature.longitude = [];\n        feature.latitude = [];\n        var pathData = (feature.pathData = geoPathGenerator(feature));\n        var points = point_at_length_1.default(pathData);\n        points._path.forEach(function (point) {\n            feature.longitude.push(point[1]);\n            feature.latitude.push(point[2]);\n        });\n        var centroid = geoPathGenerator.centroid(feature);\n        feature.centroidX = centroid[0];\n        feature.centroidY = centroid[1];\n    });\n    // dataView.origin = features;\n    return features;\n}\ndata_set_1.DataSet.registerConnector('geo', GeoJSONConnector);\ndata_set_1.DataSet.registerConnector('geojson', GeoJSONConnector);\ndata_set_1.DataSet.registerConnector('GeoJSON', GeoJSONConnector);\nexports.default = GeoJSONConnector;\n\n\n/***/ }),\n\n/***/ \"./src/connector/graph.ts\":\n/*!********************************!*\\\n  !*** ./src/connector/graph.ts ***!\n  \\********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {\n    nodes: function (d) {\n        // optional\n        return d.nodes;\n    },\n    edges: function (d) {\n        // optional\n        return d.edges;\n    },\n};\nfunction connector(data, options, dataView) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    dataView.dataType = data_set_1.DataSet.CONSTANTS.GRAPH;\n    var nodes = options.nodes, edges = options.edges;\n    if (nodes && !util_1.isFunction(nodes)) {\n        throw new TypeError('Invalid nodes: must be a function!');\n    }\n    if (edges && !util_1.isFunction(edges)) {\n        throw new TypeError('Invalid edges: must be a function!');\n    }\n    // @ts-ignore\n    dataView.rows = dataView.graph = {\n        nodes: nodes(data),\n        edges: edges(data),\n    };\n    util_1.assign(dataView, dataView.graph);\n    return dataView.rows;\n}\ndata_set_1.DataSet.registerConnector('graph', connector);\ndata_set_1.DataSet.registerConnector('diagram', connector);\n\n\n/***/ }),\n\n/***/ \"./src/connector/hexjson.ts\":\n/*!**********************************!*\\\n  !*** ./src/connector/hexjson.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3_hexjson_1 = __webpack_require__(/*! d3-hexjson */ \"./node_modules/_d3-hexjson@1.1.0@d3-hexjson/build/d3-hexjson.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {\n    width: 1,\n    height: 1,\n};\nfunction processRow(row) {\n    row.cx = row.x;\n    row.cy = row.y;\n    row.x = [];\n    row.y = [];\n    row.vertices.forEach(function (v) {\n        row.x.push(v.x + row.cx);\n        row.y.push(v.y + row.cy);\n    });\n    return row;\n}\nfunction HexJSONConnector(data, options, dataView) {\n    dataView.dataType = data_set_1.DataSet.CONSTANTS.HEX;\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var width = options.width, height = options.height;\n    var HexJSON = util_1.deepMix([], data);\n    dataView._HexJSON = HexJSON;\n    var grid = (dataView._GridHexJSON = d3_hexjson_1.getGridForHexJSON(HexJSON));\n    var rows = (dataView.rows = d3_hexjson_1.renderHexJSON(HexJSON, width, height).map(processRow));\n    dataView._gridRows = d3_hexjson_1.renderHexJSON(grid, width, height).map(processRow);\n    return rows;\n}\ndata_set_1.DataSet.registerConnector('hex', HexJSONConnector);\ndata_set_1.DataSet.registerConnector('hexjson', HexJSONConnector);\ndata_set_1.DataSet.registerConnector('hex-json', HexJSONConnector);\ndata_set_1.DataSet.registerConnector('HexJSON', HexJSONConnector);\nexports.default = HexJSONConnector;\n\n\n/***/ }),\n\n/***/ \"./src/connector/hierarchy.ts\":\n/*!************************************!*\\\n  !*** ./src/connector/hierarchy.ts ***!\n  \\************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3_hierarchy_1 = __webpack_require__(/*! d3-hierarchy */ \"./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nfunction connector(data, options, dataView) {\n    dataView.dataType = data_set_1.DataSet.CONSTANTS.HIERARCHY;\n    var children = options && options.children ? options.children : null;\n    if (children && !util_1.isFunction(children)) {\n        throw new TypeError('Invalid children: must be a function!');\n    }\n    if (!options.pureData) {\n        // @ts-ignore\n        dataView.rows = dataView.root = d3_hierarchy_1.hierarchy(data, children);\n    }\n    else {\n        dataView.rows = dataView.root = data;\n    }\n    return data;\n}\ndata_set_1.DataSet.registerConnector('hierarchy', connector);\ndata_set_1.DataSet.registerConnector('tree', connector);\n\n\n/***/ }),\n\n/***/ \"./src/connector/topojson.ts\":\n/*!***********************************!*\\\n  !*** ./src/connector/topojson.ts ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar topojson_client_1 = __webpack_require__(/*! topojson-client */ \"./node_modules/_topojson-client@3.1.0@topojson-client/dist/topojson-client.js\");\nvar geojson_1 = tslib_1.__importDefault(__webpack_require__(/*! ./geojson */ \"./src/connector/geojson.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nfunction TopoJSONConnector(data, options, dataView) {\n    var object = options.object;\n    if (!util_1.isString(object)) {\n        throw new TypeError('Invalid object: must be a string!');\n    }\n    var geoData = topojson_client_1.feature(data, data.objects[object]);\n    return geojson_1.default(geoData, undefined, dataView);\n}\ndata_set_1.DataSet.registerConnector('topojson', TopoJSONConnector);\ndata_set_1.DataSet.registerConnector('TopoJSON', TopoJSONConnector);\n\n\n/***/ }),\n\n/***/ \"./src/constants.ts\":\n/*!**************************!*\\\n  !*** ./src/constants.ts ***!\n  \\**************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = {\n    HIERARCHY: 'hierarchy',\n    GEO: 'geo',\n    HEX: 'hex',\n    GRAPH: 'graph',\n    TABLE: 'table',\n    GEO_GRATICULE: 'geo-graticule',\n    STATISTICS_METHODS: [\n        'max',\n        'mean',\n        'median',\n        'min',\n        'mode',\n        'product',\n        'standardDeviation',\n        'sum',\n        'sumSimple',\n        'variance',\n    ],\n};\n\n\n/***/ }),\n\n/***/ \"./src/data-set.ts\":\n/*!*************************!*\\\n  !*** ./src/data-set.ts ***!\n  \\*************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar wolfy87_eventemitter_1 = tslib_1.__importDefault(__webpack_require__(/*! wolfy87-eventemitter */ \"./node_modules/_wolfy87-eventemitter@5.2.9@wolfy87-eventemitter/EventEmitter.js\"));\nvar view_1 = __webpack_require__(/*! ./view */ \"./src/view.ts\");\nvar constants_1 = tslib_1.__importDefault(__webpack_require__(/*! ./constants */ \"./src/constants.ts\"));\n/**\n * 数据集\n * @public\n */\nvar DataSet = /** @class */ (function (_super) {\n    tslib_1.__extends(DataSet, _super);\n    /**\n     * @param initialProps - 初始状态\n     */\n    function DataSet(initialProps) {\n        if (initialProps === void 0) { initialProps = { state: {} }; }\n        var _this = _super.call(this) || this;\n        /**\n         * 否是 DataSet\n         */\n        _this.isDataSet = true;\n        _this._onChangeTimer = null;\n        /**\n         * 所有挂在数据集上的数据视图（key-value 对）\n         */\n        _this.views = {};\n        /**\n         * 存储数据集上的状态量（key-value 对）\n         */\n        _this.state = {};\n        // assign(me, initialProps);\n        _this.state = initialProps.state;\n        return _this;\n    }\n    /**\n     * 注册一个数据连接函数，注册后所有数据视图都可以使用 name 来引用这个数据连接函数，从而接入某种数据源。\n     * @param name - 类型\n     * @param connector - 解析逻辑\n     */\n    DataSet.registerConnector = function (name, connector) {\n        DataSet.connectors[name] = connector;\n    };\n    DataSet.getConnector = function (name) {\n        return DataSet.connectors[name] || DataSet.connectors.default;\n    };\n    /**\n     * 注册一个数据处理函数，注册后所有数据视图都可以使用 name 来引用这个数据处理函数，从而进行某种数据处理\n     * @param name - transform 类型\n     * @param transform - transform逻辑\n     */\n    DataSet.registerTransform = function (name, transform) {\n        DataSet.transforms[name] = transform;\n    };\n    DataSet.getTransform = function (name) {\n        return DataSet.transforms[name] || DataSet.transforms.default;\n    };\n    DataSet.prototype._getUniqueViewName = function () {\n        var name = util_1.uniqueId('view_');\n        while (this.views[name]) {\n            name = util_1.uniqueId('view_');\n        }\n        return name;\n    };\n    DataSet.prototype.createView = function (name, options) {\n        if (util_1.isNil(name)) {\n            name = this._getUniqueViewName();\n        }\n        if (util_1.isObject(name)) {\n            options = name;\n            name = this._getUniqueViewName();\n        }\n        if (this.views[name]) {\n            throw new Error(\"data view exists: \" + name);\n        }\n        var view = new view_1.View(this, options);\n        this.views[name] = view;\n        return view;\n    };\n    /**\n     * 返回 name 对应的数据视图实例\n     * @param name - name\n     */\n    DataSet.prototype.getView = function (name) {\n        return this.views[name];\n    };\n    /**\n     * 设置 name 对应的数据视图实例为 dv\n     * @param name - 名称\n     * @param view - data view\n     */\n    DataSet.prototype.setView = function (name, view) {\n        this.views[name] = view;\n    };\n    /**\n     * 设置状态量 name 的值为 value\n     * @param name - 状态名\n     * @param value - 值\n     */\n    DataSet.prototype.setState = function (name, value) {\n        var _this = this;\n        this.state[name] = value;\n        if (this._onChangeTimer) {\n            window.clearTimeout(this._onChangeTimer);\n            this._onChangeTimer = null;\n        }\n        this._onChangeTimer = window.setTimeout(function () {\n            _this.emit('statechange', name, value);\n        }, 16); // execute after one frame\n    };\n    /**\n     * 常量，譬如 DataSet.CONSTANTS.HIERARCHY 是树形结构的名称\n     */\n    DataSet.CONSTANTS = constants_1.default;\n    /**\n     * 注册的 Connector（key-value 对）\n     */\n    DataSet.connectors = {};\n    /**\n     * 已注册的 Transform（key-value 对）\n     */\n    DataSet.transforms = {};\n    DataSet.DataSet = DataSet;\n    DataSet.DataView = view_1.View; // alias\n    DataSet.View = view_1.View;\n    DataSet.version = '____DATASET_VERSION____';\n    return DataSet;\n}(wolfy87_eventemitter_1.default));\nexports.DataSet = DataSet;\n// @ts-ignore\nutil_1.assign(DataSet, constants_1.default);\n// @ts-ignore\nutil_1.assign(DataSet.prototype, {\n    view: DataSet.prototype.createView,\n});\nview_1.View.DataSet = DataSet;\n\n\n/***/ }),\n\n/***/ \"./src/index.ts\":\n/*!**********************!*\\\n  !*** ./src/index.ts ***!\n  \\**********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// extra APIs\n__webpack_require__(/*! ./api/geo */ \"./src/api/geo.ts\");\n__webpack_require__(/*! ./api/hierarchy */ \"./src/api/hierarchy.ts\");\n__webpack_require__(/*! ./api/partition */ \"./src/api/partition.ts\");\n__webpack_require__(/*! ./api/statistics */ \"./src/api/statistics.ts\");\n// connectors\n__webpack_require__(/*! ./connector/default */ \"./src/connector/default.ts\");\n__webpack_require__(/*! ./connector/dsv */ \"./src/connector/dsv.ts\");\n__webpack_require__(/*! ./connector/geo-graticule */ \"./src/connector/geo-graticule.ts\");\n__webpack_require__(/*! ./connector/geojson */ \"./src/connector/geojson.ts\");\n__webpack_require__(/*! ./connector/graph */ \"./src/connector/graph.ts\");\n__webpack_require__(/*! ./connector/hexjson */ \"./src/connector/hexjson.ts\");\n__webpack_require__(/*! ./connector/hierarchy */ \"./src/connector/hierarchy.ts\");\n__webpack_require__(/*! ./connector/topojson */ \"./src/connector/topojson.ts\");\n// transforms\n// static\n__webpack_require__(/*! ./transform/default */ \"./src/transform/default.ts\");\n__webpack_require__(/*! ./transform/filter */ \"./src/transform/filter.ts\");\n__webpack_require__(/*! ./transform/fold */ \"./src/transform/fold.ts\");\n__webpack_require__(/*! ./transform/map */ \"./src/transform/map.ts\");\n__webpack_require__(/*! ./transform/partition */ \"./src/transform/partition.ts\");\n__webpack_require__(/*! ./transform/percent */ \"./src/transform/percent.ts\");\n__webpack_require__(/*! ./transform/pick */ \"./src/transform/pick.ts\");\n__webpack_require__(/*! ./transform/proportion */ \"./src/transform/proportion.ts\");\n__webpack_require__(/*! ./transform/rename */ \"./src/transform/rename.ts\");\n__webpack_require__(/*! ./transform/reverse */ \"./src/transform/reverse.ts\");\n__webpack_require__(/*! ./transform/sort */ \"./src/transform/sort.ts\");\n__webpack_require__(/*! ./transform/sort-by */ \"./src/transform/sort-by.ts\");\n__webpack_require__(/*! ./transform/subset */ \"./src/transform/subset.ts\");\n// imputation\n__webpack_require__(/*! ./transform/fill-rows */ \"./src/transform/fill-rows.ts\");\n__webpack_require__(/*! ./transform/impute */ \"./src/transform/impute.ts\");\n// statistics\n__webpack_require__(/*! ./transform/aggregate */ \"./src/transform/aggregate.ts\");\n// regression\n__webpack_require__(/*! ./transform/regression */ \"./src/transform/regression.ts\");\n// KDE\n__webpack_require__(/*! ./transform/kde */ \"./src/transform/kde.ts\");\n// binning\n__webpack_require__(/*! ./transform/bin/hexagon */ \"./src/transform/bin/hexagon.ts\");\n__webpack_require__(/*! ./transform/bin/histogram */ \"./src/transform/bin/histogram.ts\");\n__webpack_require__(/*! ./transform/bin/quantile */ \"./src/transform/bin/quantile.ts\");\n__webpack_require__(/*! ./transform/bin/rectangle */ \"./src/transform/bin/rectangle.ts\");\n// geo\n__webpack_require__(/*! ./transform/geo/centroid */ \"./src/transform/geo/centroid.ts\");\n__webpack_require__(/*! ./transform/geo/projection */ \"./src/transform/geo/projection.ts\");\n__webpack_require__(/*! ./transform/geo/region */ \"./src/transform/geo/region.ts\");\n// diagram\n__webpack_require__(/*! ./transform/diagram/arc */ \"./src/transform/diagram/arc.ts\");\n__webpack_require__(/*! ./transform/diagram/dagre */ \"./src/transform/diagram/dagre.ts\");\n__webpack_require__(/*! ./transform/diagram/sankey */ \"./src/transform/diagram/sankey.ts\");\n__webpack_require__(/*! ./transform/diagram/voronoi */ \"./src/transform/diagram/voronoi.ts\");\n// hierarchy\n__webpack_require__(/*! ./transform/hierarchy/cluster */ \"./src/transform/hierarchy/cluster.ts\");\n__webpack_require__(/*! ./transform/hierarchy/compact-box */ \"./src/transform/hierarchy/compact-box.ts\");\n__webpack_require__(/*! ./transform/hierarchy/dendrogram */ \"./src/transform/hierarchy/dendrogram.ts\");\n__webpack_require__(/*! ./transform/hierarchy/indented */ \"./src/transform/hierarchy/indented.ts\");\n__webpack_require__(/*! ./transform/hierarchy/pack */ \"./src/transform/hierarchy/pack.ts\");\n__webpack_require__(/*! ./transform/hierarchy/partition */ \"./src/transform/hierarchy/partition.ts\");\n__webpack_require__(/*! ./transform/hierarchy/tree */ \"./src/transform/hierarchy/tree.ts\");\n__webpack_require__(/*! ./transform/hierarchy/treemap */ \"./src/transform/hierarchy/treemap.ts\");\n// tag cloud\n__webpack_require__(/*! ./transform/tag-cloud */ \"./src/transform/tag-cloud.ts\");\n// waffle\n__webpack_require__(/*! ./transform/waffle */ \"./src/transform/waffle.ts\");\n// kernel smoothing\n__webpack_require__(/*! ./transform/kernel-smooth/density */ \"./src/transform/kernel-smooth/density.ts\");\n__webpack_require__(/*! ./transform/kernel-smooth/regression */ \"./src/transform/kernel-smooth/regression.ts\");\nvar data_set_1 = __webpack_require__(/*! ./data-set */ \"./src/data-set.ts\");\nmodule.exports = data_set_1.DataSet;\n\n\n/***/ }),\n\n/***/ \"./src/transform/aggregate.ts\":\n/*!************************************!*\\\n  !*** ./src/transform/aggregate.ts ***!\n  \\************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar simpleStatistics = tslib_1.__importStar(__webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\"));\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar registerTransform = data_set_1.DataSet.registerTransform;\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    as: [],\n    fields: [],\n    groupBy: [],\n    operations: [],\n};\nvar DEFAULT_OPERATION = 'count';\nvar aggregates = {\n    count: function (data) {\n        return data.length;\n    },\n    distinct: function (data, field) {\n        var values = util_1.uniq(data.map(function (row) { return row[field]; }));\n        return values.length;\n    },\n};\ndata_set_1.DataSet.CONSTANTS.STATISTICS_METHODS.forEach(function (method) {\n    aggregates[method] = function (data, field) {\n        var values = data.map(function (row) { return row[field]; });\n        if (util_1.isArray(values) && util_1.isArray(values[0])) {\n            values = util_1.flattenDeep(values);\n        }\n        // @ts-ignore\n        return simpleStatistics[method](values);\n    };\n});\naggregates.average = aggregates.mean;\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var fields = option_parser_1.getFields(options);\n    if (!util_1.isArray(fields)) {\n        throw new TypeError('Invalid fields: it must be an array with one or more strings!');\n    }\n    var outputNames = options.as || [];\n    if (util_1.isString(outputNames)) {\n        outputNames = [outputNames];\n    }\n    var operations = options.operations;\n    if (util_1.isString(operations)) {\n        operations = [operations];\n    }\n    var DEFAULT_OPERATIONS = [DEFAULT_OPERATION];\n    if (!util_1.isArray(operations) || !operations.length) {\n        console.warn('operations is not defined, will use [ \"count\" ] directly.');\n        operations = DEFAULT_OPERATIONS;\n        outputNames = operations;\n    }\n    if (!(operations.length === 1 && operations[0] === DEFAULT_OPERATION)) {\n        if (operations.length !== fields.length) {\n            throw new TypeError(\"Invalid operations: it's length must be the same as fields!\");\n        }\n        if (outputNames.length !== fields.length) {\n            throw new TypeError(\"Invalid as: it's length must be the same as fields!\");\n        }\n    }\n    var groups = partition_1.default(dataView.rows, options.groupBy);\n    var results = [];\n    util_1.forIn(groups, function (group) {\n        var result = group[0];\n        operations.forEach(function (operation, i) {\n            var outputName = outputNames[i];\n            var field = fields[i];\n            result[outputName] = aggregates[operation](group, field);\n        });\n        results.push(result);\n    });\n    dataView.rows = results;\n}\nregisterTransform('aggregate', transform);\nregisterTransform('summary', transform);\nexports.default = {\n    VALID_AGGREGATES: util_1.keys(aggregates),\n};\n\n\n/***/ }),\n\n/***/ \"./src/transform/bin/hexagon.ts\":\n/*!**************************************!*\\\n  !*** ./src/transform/bin/hexagon.ts ***!\n  \\**************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    as: ['x', 'y', 'count'],\n    bins: [30, 30],\n    offset: [0, 0],\n    sizeByCount: false,\n};\nvar SQRT3 = Math.sqrt(3);\nvar THIRD_PI = Math.PI / 3;\nvar ANGLES = [0, THIRD_PI, 2 * THIRD_PI, 3 * THIRD_PI, 4 * THIRD_PI, 5 * THIRD_PI];\nfunction distance(x0, y0, x1, y1) {\n    return Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1));\n}\nfunction nearestBinsCenters(value, scale, offset) {\n    var temp = value - offset;\n    scale = scale / 2;\n    var div = Math.floor(temp / scale);\n    var rounded = scale * (div + (Math.abs(div % 2) === 1 ? 1 : 0));\n    var roundedScaled = scale * (div + (Math.abs(div % 2) === 1 ? 0 : 1));\n    return [rounded + offset, roundedScaled + offset];\n}\nfunction generateBins(points, binWidth, offset) {\n    if (binWidth === void 0) { binWidth = [1, 1]; }\n    if (offset === void 0) { offset = [0, 0]; }\n    // processing aligned data\n    var bins = {};\n    var _a = tslib_1.__read(binWidth, 2), binWidthX = _a[0], binWidthY = _a[1];\n    var _b = tslib_1.__read(offset, 2), offsetX = _b[0], offsetY = _b[1];\n    points.forEach(function (point) {\n        var _a, _b;\n        var _c = tslib_1.__read(point, 2), x = _c[0], y = _c[1];\n        // step3.1: nearest two centers\n        var _d = tslib_1.__read(nearestBinsCenters(x, binWidthX, offsetX), 2), xRounded = _d[0], xRoundedScaled = _d[1];\n        var _e = tslib_1.__read(nearestBinsCenters(y, binWidthY, offsetY), 2), yRounded = _e[0], yRoundedScaled = _e[1];\n        // step3.2: compare distances\n        var d1 = distance(x, y, xRounded, yRounded);\n        var d2 = distance(x, y, xRoundedScaled, yRoundedScaled);\n        var binKey;\n        var binX;\n        var binY;\n        if (d1 < d2) {\n            binKey = \"x\" + xRounded + \"y\" + yRounded;\n            _a = tslib_1.__read([xRounded, yRounded], 2), binX = _a[0], binY = _a[1];\n        }\n        else {\n            binKey = \"x\" + xRoundedScaled + \"y\" + yRoundedScaled;\n            _b = tslib_1.__read([xRoundedScaled, yRoundedScaled], 2), binX = _b[0], binY = _b[1];\n        }\n        bins[binKey] = bins[binKey] || {\n            x: binX,\n            y: binY,\n            count: 0,\n        };\n        bins[binKey].count++;\n    });\n    return bins;\n}\nfunction transform(dataView, options) {\n    // step1: get binWidth, etc.\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var fields = option_parser_1.getFields(options);\n    if (!util_1.isArray(fields) || fields.length !== 2) {\n        throw new TypeError('Invalid fields: it must be an array with 2 strings!');\n    }\n    var _a = tslib_1.__read(fields, 2), fieldX = _a[0], fieldY = _a[1];\n    var rangeFieldX = dataView.range(fieldX);\n    var rangeFieldY = dataView.range(fieldY);\n    var widthX = rangeFieldX[1] - rangeFieldX[0];\n    var widthY = rangeFieldY[1] - rangeFieldY[0];\n    var binWidth = options.binWidth || [];\n    if (binWidth.length !== 2) {\n        var _b = tslib_1.__read(options.bins, 2), binsX = _b[0], binsY = _b[1];\n        if (binsX <= 0 || binsY <= 0) {\n            throw new TypeError('Invalid bins: must be an array with two positive numbers (e.g. [ 30, 30 ])!');\n        }\n        binWidth = [widthX / binsX, widthY / binsY];\n    }\n    // step2: align scale (squash Y)\n    /*\n     * binWidthX / binWidthY should be Math.sqrt3 / 1.5\n     * -: binWidthX |: binWidthY\n     *           3\n     *           |\n     *   4       |        2\n     *           |\n     *           |\n     *   5----------------1\n     *\n     *           0\n     */\n    var _c = tslib_1.__read(options.offset, 2), offsetX = _c[0], offsetY = _c[1];\n    var yScale = (3 * binWidth[0]) / (SQRT3 * binWidth[1]);\n    // const yScale = binWidth[0] / (SQRT3 * binWidth[1]);\n    var points = dataView.rows.map(function (row) { return [row[fieldX], yScale * row[fieldY]]; });\n    // step3: binning\n    var bins = generateBins(points, [binWidth[0], yScale * binWidth[1]], [offsetX, yScale * offsetY]);\n    // step4: restore scale (for Y)\n    var _d = tslib_1.__read(options.as, 3), asX = _d[0], asY = _d[1], asCount = _d[2];\n    if (!asX || !asY || !asCount) {\n        throw new TypeError('Invalid as: it must be an array with three elements (e.g. [ \"x\", \"y\", \"count\" ])!');\n    }\n    var radius = binWidth[0] / SQRT3;\n    var hexagonPoints = ANGLES.map(function (angle) { return [Math.sin(angle) * radius, -Math.cos(angle) * radius]; });\n    var result = [];\n    var maxCount = 0;\n    if (options.sizeByCount) {\n        util_1.forIn(bins, function (bin) {\n            if (bin.count > maxCount) {\n                maxCount = bin.count;\n            }\n        });\n    }\n    util_1.forIn(bins, function (bin) {\n        var x = bin.x, y = bin.y, count = bin.count;\n        var row = {};\n        row[asCount] = count;\n        if (options.sizeByCount) {\n            row[asX] = hexagonPoints.map(function (p) { return x + (bin.count / maxCount) * p[0]; });\n            row[asY] = hexagonPoints.map(function (p) { return (y + (bin.count / maxCount) * p[1]) / yScale; });\n        }\n        else {\n            row[asX] = hexagonPoints.map(function (p) { return x + p[0]; });\n            row[asY] = hexagonPoints.map(function (p) { return (y + p[1]) / yScale; });\n        }\n        result.push(row);\n    });\n    dataView.rows = result;\n}\ndata_set_1.DataSet.registerTransform('bin.hexagon', transform);\ndata_set_1.DataSet.registerTransform('bin.hex', transform);\ndata_set_1.DataSet.registerTransform('hexbin', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/bin/histogram.ts\":\n/*!****************************************!*\\\n  !*** ./src/transform/bin/histogram.ts ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    as: ['x', 'count'],\n    bins: 30,\n    offset: 0,\n    groupBy: [],\n};\nfunction nearestBin(value, scale, offset) {\n    var temp = value - offset;\n    var div = Math.floor(temp / scale);\n    return [div * scale + offset, (div + 1) * scale + offset];\n}\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var field = option_parser_1.getField(options);\n    if (dataView.rows.length === 0) {\n        return;\n    }\n    var range = dataView.range(field);\n    var width = range[1] - range[0];\n    var binWidth = options.binWidth;\n    if (!binWidth) {\n        var bins = options.bins;\n        if (bins <= 0) {\n            throw new TypeError('Invalid bins: it must be a positive number!');\n        }\n        binWidth = width / bins;\n    }\n    var offset = options.offset % binWidth;\n    // grouping\n    var rows = [];\n    var groupBy = options.groupBy;\n    var groups = partition_1.default(dataView.rows, groupBy);\n    util_1.forIn(groups, function (group) {\n        var bins = {};\n        var column = group.map(function (row) { return row[field]; });\n        column.forEach(function (value) {\n            var _a = tslib_1.__read(nearestBin(value, binWidth, offset), 2), x0 = _a[0], x1 = _a[1];\n            var binKey = x0 + \"-\" + x1;\n            bins[binKey] = bins[binKey] || {\n                x0: x0,\n                x1: x1,\n                count: 0,\n            };\n            bins[binKey].count++;\n        });\n        var _a = tslib_1.__read(options.as, 2), asX = _a[0], asCount = _a[1];\n        if (!asX || !asCount) {\n            throw new TypeError('Invalid as: it must be an array with 2 elements (e.g. [ \"x\", \"count\" ])!');\n        }\n        var meta = util_1.pick(group[0], groupBy);\n        util_1.forIn(bins, function (bin) {\n            var row = util_1.assign({}, meta);\n            row[asX] = [bin.x0, bin.x1];\n            row[asCount] = bin.count;\n            rows.push(row);\n        });\n    });\n    dataView.rows = rows;\n}\ndata_set_1.DataSet.registerTransform('bin.histogram', transform);\ndata_set_1.DataSet.registerTransform('bin.dot', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/bin/quantile.ts\":\n/*!***************************************!*\\\n  !*** ./src/transform/bin/quantile.ts ***!\n  \\***************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar simple_statistics_1 = __webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\");\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../util/partition */ \"./src/util/partition.ts\"));\nvar p_by_fraction_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../util/p-by-fraction */ \"./src/util/p-by-fraction.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar registerTransform = data_set_1.DataSet.registerTransform;\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    as: '_bin',\n    groupBy: [],\n    fraction: 4,\n};\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var field = option_parser_1.getField(options);\n    var as = options.as;\n    if (!util_1.isString(as)) {\n        throw new TypeError('Invalid as: it must be a string (e.g. \"_bin\")!');\n    }\n    var pArray = options.p;\n    var fraction = options.fraction;\n    if (!util_1.isArray(pArray) || pArray.length === 0) {\n        pArray = p_by_fraction_1.default(fraction);\n    }\n    var rows = dataView.rows;\n    var groupBy = options.groupBy;\n    var groups = partition_1.default(rows, groupBy);\n    var result = [];\n    util_1.forIn(groups, function (group) {\n        // const resultRow = pick(group[0], groupBy);\n        var resultRow = group[0];\n        var binningColumn = group.map(function (row) { return row[field]; });\n        var quantiles = pArray.map(function (p) { return simple_statistics_1.quantile(binningColumn, p); });\n        resultRow[as] = quantiles;\n        result.push(resultRow);\n    });\n    dataView.rows = result;\n}\nregisterTransform('bin.quantile', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/bin/rectangle.ts\":\n/*!****************************************!*\\\n  !*** ./src/transform/bin/rectangle.ts ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar registerTransform = data_set_1.DataSet.registerTransform;\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    as: ['x', 'y', 'count'],\n    bins: [30, 30],\n    offset: [0, 0],\n    sizeByCount: false,\n};\nfunction nearestBin(value, scale, offset) {\n    var temp = value - offset;\n    var div = Math.floor(temp / scale);\n    return [div * scale + offset, (div + 1) * scale + offset];\n}\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var _a = tslib_1.__read(option_parser_1.getFields(options), 2), fieldX = _a[0], fieldY = _a[1];\n    if (!fieldX || !fieldY) {\n        throw new TypeError('Invalid fields: must be an array with 2 strings!');\n    }\n    var rangeFieldX = dataView.range(fieldX);\n    var rangeFieldY = dataView.range(fieldY);\n    var widthX = rangeFieldX[1] - rangeFieldX[0];\n    var widthY = rangeFieldY[1] - rangeFieldY[0];\n    var binWidth = options.binWidth || [];\n    if (binWidth.length !== 2) {\n        var _b = tslib_1.__read(options.bins, 2), binsX = _b[0], binsY = _b[1];\n        if (binsX <= 0 || binsY <= 0) {\n            throw new TypeError('Invalid bins: must be an array with 2 positive numbers (e.g. [ 30, 30 ])!');\n        }\n        binWidth = [widthX / binsX, widthY / binsY];\n    }\n    var points = dataView.rows.map(function (row) { return [row[fieldX], row[fieldY]]; });\n    var bins = {};\n    var _c = tslib_1.__read(options.offset, 2), offsetX = _c[0], offsetY = _c[1];\n    points.forEach(function (point) {\n        var _a = tslib_1.__read(nearestBin(point[0], binWidth[0], offsetX), 2), x0 = _a[0], x1 = _a[1];\n        var _b = tslib_1.__read(nearestBin(point[1], binWidth[1], offsetY), 2), y0 = _b[0], y1 = _b[1];\n        var binKey = x0 + \"-\" + x1 + \"-\" + y0 + \"-\" + y1;\n        bins[binKey] = bins[binKey] || {\n            x0: x0,\n            x1: x1,\n            y0: y0,\n            y1: y1,\n            count: 0,\n        };\n        bins[binKey].count++;\n    });\n    var rows = [];\n    var _d = tslib_1.__read(options.as, 3), asX = _d[0], asY = _d[1], asCount = _d[2];\n    if (!asX || !asY || !asCount) {\n        throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ \"x\", \"y\", \"count\" ])!');\n    }\n    /* points\n     * 3---2\n     * |   |\n     * 0---1\n     */\n    if (!options.sizeByCount) {\n        util_1.forIn(bins, function (bin) {\n            var row = {};\n            row[asX] = [bin.x0, bin.x1, bin.x1, bin.x0];\n            row[asY] = [bin.y0, bin.y0, bin.y1, bin.y1];\n            row[asCount] = bin.count;\n            rows.push(row);\n        });\n    }\n    else {\n        var maxCount_1 = 0;\n        util_1.forIn(bins, function (bin) {\n            if (bin.count > maxCount_1) {\n                maxCount_1 = bin.count;\n            }\n        });\n        util_1.forIn(bins, function (bin) {\n            var x0 = bin.x0, x1 = bin.x1, y0 = bin.y0, y1 = bin.y1, count = bin.count;\n            var scale = count / maxCount_1;\n            var _a = tslib_1.__read([(x0 + x1) / 2, (y0 + y1) / 2], 2), cx = _a[0], cy = _a[1];\n            var rx = ((x1 - x0) * scale) / 2;\n            var ry = ((y1 - y0) * scale) / 2;\n            var x01 = cx - rx;\n            var x11 = cx + rx;\n            var y01 = cy - ry;\n            var y11 = cy + ry;\n            var row = {};\n            row[asX] = [x01, x11, x11, x01];\n            row[asY] = [y01, y01, y11, y11];\n            row[asCount] = count;\n            rows.push(row);\n        });\n    }\n    dataView.rows = rows;\n}\nregisterTransform('bin.rectangle', transform);\nregisterTransform('bin.rect', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/default.ts\":\n/*!**********************************!*\\\n  !*** ./src/transform/default.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\ndata_set_1.DataSet.registerTransform('default', function (dataView) {\n    return dataView;\n});\n\n\n/***/ }),\n\n/***/ \"./src/transform/diagram/arc.ts\":\n/*!**************************************!*\\\n  !*** ./src/transform/diagram/arc.ts ***!\n  \\**************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * for Arc Diagram (edges without weight) / Chord Diagram (edges with source and target weight)\n * graph data required (nodes, edges)\n */\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {\n    y: 0,\n    thickness: 0.05,\n    weight: false,\n    marginRatio: 0.1,\n    id: function (node) { return node.id; },\n    source: function (edge) { return edge.source; },\n    target: function (edge) { return edge.target; },\n    sourceWeight: function (edge) { return edge.value || 1; },\n    targetWeight: function (edge) { return edge.value || 1; },\n    sortBy: null,\n};\nfunction _nodesFromEdges(edges, options, map) {\n    if (map === void 0) { map = {}; }\n    edges.forEach(function (edge) {\n        var sId = options.edgeSource(edge);\n        var tId = options.edgeTarget(edge);\n        if (!map[sId]) {\n            map[sId] = {\n                id: sId,\n            };\n        }\n        if (!map[tId]) {\n            map[tId] = {\n                id: tId,\n            };\n        }\n    });\n    return util_1.values(map);\n}\nfunction _processGraph(nodeById, edges, options) {\n    util_1.forIn(nodeById, function (node, id) {\n        // in edges, out edges\n        node.inEdges = edges.filter(function (edge) { return \"\" + options.target(edge) === \"\" + id; });\n        node.outEdges = edges.filter(function (edge) { return \"\" + options.source(edge) === \"\" + id; });\n        // frequency\n        node.edges = node.outEdges.concat(node.inEdges);\n        node.frequency = node.edges.length;\n        // weight\n        node.value = 0;\n        node.inEdges.forEach(function (edge) {\n            node.value += options.targetWeight(edge);\n        });\n        node.outEdges.forEach(function (edge) {\n            node.value += options.sourceWeight(edge);\n        });\n    });\n}\nfunction _sortNodes(nodes, options) {\n    var sortMethods = {\n        weight: function (a, b) { return b.value - a.value; },\n        frequency: function (a, b) { return b.frequency - a.frequency; },\n        id: function (a, b) { return (\"\" + options.id(a)).localeCompare(\"\" + options.id(b)); },\n    };\n    var method = sortMethods[options.sortBy];\n    if (!method && util_1.isFunction(options.sortBy)) {\n        method = options.sortBy;\n    }\n    if (method) {\n        nodes.sort(method);\n    }\n}\nfunction _layoutNodes(nodes, options) {\n    var len = nodes.length;\n    if (!len) {\n        throw new TypeError(\"Invalid nodes: it's empty!\");\n    }\n    if (options.weight) {\n        var marginRatio_1 = options.marginRatio;\n        if (marginRatio_1 < 0 || marginRatio_1 >= 1) {\n            throw new TypeError('Invalid marginRatio: it must be in range [0, 1)!');\n        }\n        var margin_1 = marginRatio_1 / (2 * len);\n        var thickness_1 = options.thickness;\n        if (thickness_1 <= 0 || thickness_1 >= 1) {\n            throw new TypeError('Invalid thickness: it must be in range (0, 1)!');\n        }\n        var totalValue_1 = 0;\n        nodes.forEach(function (node) {\n            totalValue_1 += node.value;\n        });\n        nodes.forEach(function (node) {\n            node.weight = node.value / totalValue_1;\n            node.width = node.weight * (1 - marginRatio_1);\n            node.height = thickness_1;\n        });\n        nodes.forEach(function (node, index) {\n            // x\n            var deltaX = 0;\n            for (var i = index - 1; i >= 0; i--) {\n                deltaX += nodes[i].width + 2 * margin_1;\n            }\n            var minX = (node.minX = margin_1 + deltaX);\n            var maxX = (node.maxX = node.minX + node.width);\n            var minY = (node.minY = options.y - thickness_1 / 2);\n            var maxY = (node.maxY = minY + thickness_1);\n            node.x = [minX, maxX, maxX, minX];\n            node.y = [minY, minY, maxY, maxY];\n            /* points\n             * 3---2\n             * |   |\n             * 0---1\n             */\n            // node.x = minX + 0.5 * node.width;\n            // node.y = options.y;\n        });\n    }\n    else {\n        var deltaX_1 = 1 / len;\n        nodes.forEach(function (node, index) {\n            node.x = (index + 0.5) * deltaX_1;\n            node.y = options.y;\n        });\n    }\n}\nfunction _locatingEdges(nodeById, edges, options) {\n    if (options.weight) {\n        var valueById_1 = {};\n        util_1.forIn(nodeById, function (node, id) {\n            valueById_1[id] = node.value;\n        });\n        edges.forEach(function (edge) {\n            var sId = options.source(edge);\n            var tId = options.target(edge);\n            var sNode = nodeById[sId];\n            var tNode = nodeById[tId];\n            if (sNode && tNode) {\n                var sValue = valueById_1[sId];\n                var currentSValue = options.sourceWeight(edge);\n                var sStart = sNode.minX + ((sNode.value - sValue) / sNode.value) * sNode.width;\n                var sEnd = sStart + (currentSValue / sNode.value) * sNode.width;\n                valueById_1[sId] -= currentSValue;\n                var tValue = valueById_1[tId];\n                var currentTValue = options.targetWeight(edge);\n                var tStart = tNode.minX + ((tNode.value - tValue) / tNode.value) * tNode.width;\n                var tEnd = tStart + (currentTValue / tNode.value) * tNode.width;\n                valueById_1[tId] -= currentTValue;\n                var y = options.y;\n                edge.x = [sStart, sEnd, tStart, tEnd];\n                edge.y = [y, y, y, y];\n            }\n        });\n    }\n    else {\n        edges.forEach(function (edge) {\n            var sNode = nodeById[options.source(edge)];\n            var tNode = nodeById[options.target(edge)];\n            if (sNode && tNode) {\n                edge.x = [sNode.x, tNode.x];\n                edge.y = [sNode.y, tNode.y];\n            }\n        });\n    }\n}\nfunction transform(dv, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var nodeById = {};\n    var nodes = dv.nodes;\n    var edges = dv.edges;\n    if (!util_1.isArray(nodes) || nodes.length === 0) {\n        nodes = _nodesFromEdges(edges, options, nodeById);\n    }\n    nodes.forEach(function (node) {\n        var id = options.id(node);\n        nodeById[id] = node;\n    });\n    _processGraph(nodeById, edges, options);\n    _sortNodes(nodes, options);\n    _layoutNodes(nodes, options);\n    _locatingEdges(nodeById, edges, options);\n    dv.nodes = nodes;\n    dv.edges = edges;\n}\ndata_set_1.DataSet.registerTransform('diagram.arc', transform);\ndata_set_1.DataSet.registerTransform('arc', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/diagram/dagre.ts\":\n/*!****************************************!*\\\n  !*** ./src/transform/diagram/dagre.ts ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\n/*\n * for DAG\n * graph data required (nodes, edges)\n */\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar dagre_1 = tslib_1.__importDefault(__webpack_require__(/*! dagre */ \"./node_modules/_dagre@0.8.5@dagre/index.js\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {\n    // nodeId: node => node.index,\n    rankdir: 'TB',\n    align: 'TB',\n    nodesep: 50,\n    edgesep: 10,\n    ranksep: 50,\n    source: function (edge) { return edge.source; },\n    target: function (edge) { return edge.target; },\n};\nfunction transform(dv, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var g = new dagre_1.default.graphlib.Graph();\n    // Set an object for the graph label\n    g.setGraph({});\n    // Default to assigning a new object as a label for each new edge.\n    g.setDefaultEdgeLabel(function () {\n        return {};\n    });\n    dv.nodes.forEach(function (node) {\n        var nodeId = options.nodeId ? options.nodeId(node) : node.id;\n        if (!node.height && !node.width) {\n            node.height = node.width = options.edgesep;\n        }\n        g.setNode(nodeId, node);\n    });\n    dv.edges.forEach(function (edge) {\n        g.setEdge(options.source(edge), options.target(edge));\n    });\n    dagre_1.default.layout(g);\n    var nodes = [];\n    var edges = [];\n    g.nodes().forEach(function (node) {\n        var n = g.node(node);\n        var x = n.x, y = n.y, height = n.height, width = n.width;\n        /* points\n         * 3---2\n         * |   |\n         * 0---1\n         */\n        // @ts-ignore\n        n.x = [x - width / 2, x + width / 2, x + width / 2, x - width / 2];\n        // @ts-ignore\n        n.y = [y + height / 2, y + height / 2, y - height / 2, y - height / 2];\n        nodes.push(n);\n    });\n    g.edges().forEach(function (edge) {\n        var points = g.edge(edge).points;\n        var e = {};\n        e.x = points.map(function (p) { return p.x; });\n        e.y = points.map(function (p) { return p.y; });\n        edges.push(e);\n    });\n    dv.nodes = nodes;\n    dv.edges = edges;\n}\ndata_set_1.DataSet.registerTransform('diagram.dagre', transform);\ndata_set_1.DataSet.registerTransform('dagre', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/diagram/sankey.ts\":\n/*!*****************************************!*\\\n  !*** ./src/transform/diagram/sankey.ts ***!\n  \\*****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * for Sankey Diagram\n * graph data required (nodes, edges)\n */\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3_sankey_1 = __webpack_require__(/*! d3-sankey */ \"./node_modules/_d3-sankey@0.9.1@d3-sankey/dist/d3-sankey.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar ALIGN_METHOD = {\n    sankeyLeft: d3_sankey_1.sankeyLeft,\n    sankeyRight: d3_sankey_1.sankeyRight,\n    sankeyCenter: d3_sankey_1.sankeyCenter,\n    sankeyJustify: d3_sankey_1.sankeyJustify,\n};\nvar DEFAULT_OPTIONS = {\n    // nodeId: node => node.index,\n    value: function (node) { return node.value; },\n    source: function (edge) { return edge.source; },\n    target: function (edge) { return edge.target; },\n    nodeAlign: 'sankeyJustify',\n    nodeWidth: 0.02,\n    nodePadding: 0.02,\n    sort: undefined,\n};\nfunction transform(dv, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var nodeAlign = null;\n    if (util_1.isString(options.nodeAlign)) {\n        nodeAlign = ALIGN_METHOD[options.nodeAlign];\n    }\n    else if (util_1.isFunction(options.nodeAlign)) {\n        nodeAlign = options.nodeAlign;\n    }\n    var sankeyProcessor = d3_sankey_1.sankey()\n        .nodeSort(options.sort)\n        .links(function (d) { return d.edges; })\n        .nodeWidth(options.nodeWidth)\n        .nodePadding(options.nodePadding)\n        .extent([\n        [0, 0],\n        [1, 1],\n    ]);\n    if (util_1.isFunction(options.nodeId)) {\n        sankeyProcessor.nodeId(options.nodeId);\n    }\n    if (nodeAlign) {\n        sankeyProcessor.nodeAlign(nodeAlign);\n    }\n    // TODO:\n    // @ts-ignore\n    sankeyProcessor(dv);\n    // post process (x, y), etc.\n    dv.nodes.forEach(function (node) {\n        var x0 = node.x0, x1 = node.x1, y0 = node.y0, y1 = node.y1;\n        /* points\n         * 3---2\n         * |   |\n         * 0---1\n         */\n        node.x = [x0, x1, x1, x0];\n        node.y = [y0, y0, y1, y1];\n    });\n    dv.edges.forEach(function (edge) {\n        var source = edge.source, target = edge.target;\n        var sx = source.x1;\n        var tx = target.x0;\n        edge.x = [sx, sx, tx, tx];\n        var offset = edge.width / 2;\n        edge.y = [edge.y0 + offset, edge.y0 - offset, edge.y1 + offset, edge.y1 - offset];\n    });\n}\ndata_set_1.DataSet.registerTransform('diagram.sankey', transform);\ndata_set_1.DataSet.registerTransform('sankey', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/diagram/voronoi.ts\":\n/*!******************************************!*\\\n  !*** ./src/transform/diagram/voronoi.ts ***!\n  \\******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar d3Voronoi = tslib_1.__importStar(__webpack_require__(/*! d3-voronoi */ \"./node_modules/_d3-voronoi@1.1.4@d3-voronoi/dist/d3-voronoi.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar registerTransform = data_set_1.DataSet.registerTransform;\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    // fields: [ 'x', 'y' ] // field x and field y, required\n    // extend: [[x0, y0], [x1, y1]], // optional\n    // size: [width, height], // optional\n    as: ['_x', '_y'],\n};\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 2) {\n        throw new TypeError('Invalid as: must be an array with two strings!');\n    }\n    var xField = as[0];\n    var yField = as[1];\n    var fields = option_parser_1.getFields(options);\n    if (!util_1.isArray(fields) || fields.length !== 2) {\n        throw new TypeError('Invalid fields: must be an array with two strings!');\n    }\n    var x = fields[0];\n    var y = fields[1];\n    var rows = dataView.rows;\n    var data = rows.map(function (row) { return [row[x], row[y]]; });\n    var voronoi = d3Voronoi.voronoi();\n    if (options.extend) {\n        voronoi.extent(options.extend);\n    }\n    if (options.size) {\n        voronoi.size(options.size);\n    }\n    var polygons = voronoi(data).polygons();\n    rows.forEach(function (row, i) {\n        var polygon = polygons[i].filter(function (point) { return !!point; }); // some points are null\n        row[xField] = polygon.map(function (point) { return point[0]; });\n        row[yField] = polygon.map(function (point) { return point[1]; });\n    });\n}\nregisterTransform('diagram.voronoi', transform);\nregisterTransform('voronoi', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/fill-rows.ts\":\n/*!************************************!*\\\n  !*** ./src/transform/fill-rows.ts ***!\n  \\************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {\n    fillBy: 'group',\n    groupBy: [],\n    orderBy: [],\n};\nfunction arrayDifference(arr1, arr2) {\n    // arrayDifference([1, 1, 1, 2], [1, 2]) => [1, 1]\n    var shadow = arr1.map(function (item) { return item; }); // shadow copy\n    arr2.forEach(function (item) {\n        var index = shadow.indexOf(item);\n        if (index > -1) {\n            shadow.splice(index, 1);\n        }\n    });\n    return shadow;\n}\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var rows = dataView.rows;\n    var groupBy = options.groupBy;\n    var orderBy = options.orderBy;\n    var groups = partition_1.default(rows, groupBy, orderBy);\n    var maxLength = 0;\n    var referenceGroup = [];\n    util_1.forIn(groups, function (group) {\n        if (group.length > maxLength) {\n            maxLength = group.length;\n            referenceGroup = group;\n        }\n    });\n    var referenceOrderByKeys = [];\n    var referenceRowByOrderByKey = {};\n    referenceGroup.forEach(function (row) {\n        var key = orderBy.map(function (col) { return row[col]; }).join('-');\n        referenceOrderByKeys.push(key);\n        referenceRowByOrderByKey[key] = row;\n    });\n    if (options.fillBy === 'order') {\n        var first_1 = referenceGroup[0];\n        var allOrderByKeys_1 = [];\n        var rowByOrderByKey_1 = {};\n        rows.forEach(function (row) {\n            var key = orderBy.map(function (col) { return row[col]; }).join('-');\n            if (allOrderByKeys_1.indexOf(key) === -1) {\n                allOrderByKeys_1.push(key);\n                rowByOrderByKey_1[key] = row;\n            }\n        });\n        var _missingOrderByKeys = arrayDifference(allOrderByKeys_1, referenceOrderByKeys);\n        _missingOrderByKeys.forEach(function (key) {\n            var row = {};\n            groupBy.forEach(function (col) {\n                row[col] = first_1[col];\n            });\n            orderBy.forEach(function (col) {\n                row[col] = rowByOrderByKey_1[key][col];\n            });\n            rows.push(row);\n            referenceGroup.push(row);\n            referenceOrderByKeys.push(key);\n            referenceRowByOrderByKey[key] = row;\n        });\n        maxLength = referenceGroup.length;\n    }\n    util_1.forIn(groups, function (group) {\n        if (group !== referenceGroup && group.length < maxLength) {\n            var first_2 = group[0];\n            // missing orderBy keys\n            var orderByKeys_1 = [];\n            group.forEach(function (row) {\n                orderByKeys_1.push(orderBy.map(function (col) { return row[col]; }).join('-'));\n            });\n            var missingOrderByKeys = arrayDifference(referenceOrderByKeys, orderByKeys_1);\n            missingOrderByKeys.some(function (key, i) {\n                if (i >= maxLength - group.length) {\n                    // group length overflow\n                    return true;\n                }\n                var referenceRow = referenceRowByOrderByKey[key];\n                var row = {};\n                groupBy.forEach(function (col) {\n                    row[col] = first_2[col];\n                });\n                orderBy.forEach(function (col) {\n                    row[col] = referenceRow[col];\n                });\n                rows.push(row);\n                return false;\n            });\n        }\n    });\n}\ndata_set_1.DataSet.registerTransform('fill-rows', transform);\ndata_set_1.DataSet.registerTransform('fillRows', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/filter.ts\":\n/*!*********************************!*\\\n  !*** ./src/transform/filter.ts ***!\n  \\*********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nfunction defaultCallback(row) {\n    return !!row;\n}\ndata_set_1.DataSet.registerTransform('filter', function (dataView, options) {\n    dataView.rows = dataView.rows.filter(options.callback || defaultCallback);\n});\n\n\n/***/ }),\n\n/***/ \"./src/transform/fold.ts\":\n/*!*******************************!*\\\n  !*** ./src/transform/fold.ts ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    fields: [],\n    key: 'key',\n    retains: [],\n    value: 'value',\n};\ndata_set_1.DataSet.registerTransform('fold', function (dataView, options) {\n    var columns = dataView.getColumnNames();\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var fields = option_parser_1.getFields(options);\n    if (fields.length === 0) {\n        console.warn('warning: option fields is not specified, will fold all columns.');\n        fields = columns;\n    }\n    var key = options.key;\n    var value = options.value;\n    var retains = options.retains;\n    if (!retains || retains.length === 0) {\n        retains = util_1.difference(columns, fields);\n    }\n    var resultRows = [];\n    dataView.rows.forEach(function (row) {\n        fields.forEach(function (field) {\n            var resultRow = util_1.pick(row, retains);\n            resultRow[key] = field;\n            resultRow[value] = row[field];\n            resultRows.push(resultRow);\n        });\n    });\n    dataView.rows = resultRows;\n});\n\n\n/***/ }),\n\n/***/ \"./src/transform/geo/centroid.ts\":\n/*!***************************************!*\\\n  !*** ./src/transform/geo/centroid.ts ***!\n  \\***************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar registerTransform = data_set_1.DataSet.registerTransform;\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    // field: 'name', // required\n    // geoView: view, // required\n    // geoDataView: view, // alias\n    as: ['_centroid_x', '_centroid_y'],\n};\nfunction transform(view, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var field = option_parser_1.getField(options);\n    // @ts-ignore\n    var geoView = options.geoView || options.geoDataView; // alias\n    if (util_1.isString(geoView) && view.dataSet) {\n        geoView = view.dataSet.getView(geoView);\n    }\n    if (!geoView || geoView.dataType !== 'geo') {\n        throw new TypeError('Invalid geoView: must be a DataView of GEO dataType!');\n    }\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 2) {\n        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"cX\", \"cY\" ])!');\n    }\n    var centroidX = as[0];\n    var centroidY = as[1];\n    view.rows.forEach(function (row) {\n        var feature = geoView.geoFeatureByName(row[field]);\n        if (feature) {\n            if (geoView._projectedAs) {\n                row[centroidX] = feature[geoView._projectedAs[2]];\n                row[centroidY] = feature[geoView._projectedAs[3]];\n            }\n            else {\n                row[centroidX] = feature.centroidX;\n                row[centroidY] = feature.centroidY;\n            }\n        }\n    });\n}\nregisterTransform('geo.centroid', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/geo/projection.ts\":\n/*!*****************************************!*\\\n  !*** ./src/transform/geo/projection.ts ***!\n  \\*****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3_geo_1 = __webpack_require__(/*! d3-geo */ \"./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js\");\nvar point_at_length_1 = tslib_1.__importDefault(__webpack_require__(/*! point-at-length */ \"./node_modules/_point-at-length@1.1.0@point-at-length/index.js\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar registerTransform = data_set_1.DataSet.registerTransform;\nvar get_geo_projection_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../util/get-geo-projection */ \"./src/util/get-geo-projection.ts\"));\nvar DEFAULT_OPTIONS = {\n    // projection: '', // default to null\n    as: ['_x', '_y', '_centroid_x', '_centroid_y'],\n};\nfunction transform(dataView, options) {\n    if (dataView.dataType !== 'geo' && dataView.dataType !== 'geo-graticule') {\n        throw new TypeError('Invalid dataView: this transform is for Geo data only!');\n    }\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var projection = options.projection;\n    if (!projection) {\n        throw new TypeError('Invalid projection!');\n    }\n    projection = get_geo_projection_1.default(projection);\n    // @ts-ignore;\n    var geoPathGenerator = d3_geo_1.geoPath(projection);\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 4) {\n        throw new TypeError('Invalid as: it must be an array with 4 strings (e.g. [ \"x\", \"y\", \"cX\", \"cY\" ])!');\n    }\n    dataView._projectedAs = as;\n    var _a = tslib_1.__read(as, 4), lonField = _a[0], latField = _a[1], centroidX = _a[2], centroidY = _a[3];\n    dataView.rows.forEach(function (row) {\n        row[lonField] = [];\n        row[latField] = [];\n        var pathData = geoPathGenerator(row);\n        if (pathData) {\n            // TODO projection returns null\n            var points = point_at_length_1.default(pathData);\n            points._path.forEach(function (point) {\n                row[lonField].push(point[1]);\n                row[latField].push(point[2]);\n            });\n            var centroid = geoPathGenerator.centroid(row);\n            row[centroidX] = centroid[0];\n            row[centroidY] = centroid[1];\n        }\n    });\n    dataView.rows = dataView.rows.filter(function (row) { return row[lonField].length !== 0; });\n}\nregisterTransform('geo.projection', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/geo/region.ts\":\n/*!*************************************!*\\\n  !*** ./src/transform/geo/region.ts ***!\n  \\*************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar registerTransform = data_set_1.DataSet.registerTransform;\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    // field: 'name', // required\n    // geoView: view, // required\n    // geoDataView: view, // alias\n    as: ['_x', '_y'],\n};\nfunction transform(view, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var field = option_parser_1.getField(options);\n    // @ts-ignore\n    var geoView = options.geoView || options.geoDataView; // alias\n    if (util_1.isString(geoView)) {\n        geoView = view.dataSet.getView(geoView);\n    }\n    if (!geoView || geoView.dataType !== 'geo') {\n        throw new TypeError('Invalid geoView: must be a DataView of GEO dataType!');\n    }\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 2) {\n        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n    }\n    var lonField = as[0];\n    var latField = as[1];\n    view.rows.forEach(function (row) {\n        var feature = geoView.geoFeatureByName(row[field]);\n        if (feature) {\n            if (geoView._projectedAs) {\n                row[lonField] = feature[geoView._projectedAs[0]];\n                row[latField] = feature[geoView._projectedAs[1]];\n            }\n            else {\n                row[lonField] = feature.longitude;\n                row[latField] = feature.latitude;\n            }\n        }\n    });\n}\nregisterTransform('geo.region', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/hierarchy/cluster.ts\":\n/*!********************************************!*\\\n  !*** ./src/transform/hierarchy/cluster.ts ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar d3Hierarchy = tslib_1.__importStar(__webpack_require__(/*! d3-hierarchy */ \"./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    field: 'value',\n    size: [1, 1],\n    nodeSize: null,\n    separation: null,\n    as: ['x', 'y'],\n};\nfunction transform(dataView, options) {\n    if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY || !dataView.root) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    var root = dataView.root;\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 2) {\n        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n    }\n    var field = undefined;\n    try {\n        field = option_parser_1.getField(options);\n    }\n    catch (e) {\n        console.warn(e);\n    }\n    if (field) {\n        root.sum(function (d) { return d[field]; });\n    }\n    var clusterLayout = d3Hierarchy.cluster();\n    clusterLayout.size(options.size);\n    if (options.nodeSize) {\n        clusterLayout.nodeSize(options.nodeSize);\n    }\n    if (options.separation) {\n        clusterLayout.separation(options.separation);\n    }\n    clusterLayout(root);\n    var x = as[0];\n    var y = as[1];\n    root.each(function (node) {\n        node[x] = node.x;\n        node[y] = node.y;\n    });\n}\ndata_set_1.DataSet.registerTransform('hierarchy.cluster', transform);\ndata_set_1.DataSet.registerTransform('dendrogram', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/hierarchy/compact-box.ts\":\n/*!************************************************!*\\\n  !*** ./src/transform/hierarchy/compact-box.ts ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar hierarchy_1 = tslib_1.__importDefault(__webpack_require__(/*! @antv/hierarchy */ \"./node_modules/_@antv_hierarchy@0.6.2@@antv/hierarchy/build/hierarchy.js\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {};\nfunction transform(dataView, options) {\n    var root = dataView.root;\n    options = Object.assign({}, DEFAULT_OPTIONS, options);\n    if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    dataView.root = hierarchy_1.default.compactBox(root, options);\n}\ndata_set_1.DataSet.registerTransform('hierarchy.compact-box', transform);\ndata_set_1.DataSet.registerTransform('compact-box-tree', transform);\ndata_set_1.DataSet.registerTransform('non-layered-tidy-tree', transform);\ndata_set_1.DataSet.registerTransform('mindmap-logical', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/hierarchy/dendrogram.ts\":\n/*!***********************************************!*\\\n  !*** ./src/transform/hierarchy/dendrogram.ts ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar hierarchy_1 = tslib_1.__importDefault(__webpack_require__(/*! @antv/hierarchy */ \"./node_modules/_@antv_hierarchy@0.6.2@@antv/hierarchy/build/hierarchy.js\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {};\nfunction transform(dataView, options) {\n    var root = dataView.root;\n    options = Object.assign({}, DEFAULT_OPTIONS, options);\n    if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    dataView.root = hierarchy_1.default.dendrogram(root, options);\n}\ndata_set_1.DataSet.registerTransform('hierarchy.dendrogram', transform);\ndata_set_1.DataSet.registerTransform('dendrogram', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/hierarchy/indented.ts\":\n/*!*********************************************!*\\\n  !*** ./src/transform/hierarchy/indented.ts ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar hierarchy_1 = tslib_1.__importDefault(__webpack_require__(/*! @antv/hierarchy */ \"./node_modules/_@antv_hierarchy@0.6.2@@antv/hierarchy/build/hierarchy.js\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {};\nfunction transform(dataView, options) {\n    var root = dataView.root;\n    options = Object.assign({}, DEFAULT_OPTIONS, options);\n    if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    dataView.root = hierarchy_1.default.indented(root, options);\n}\ndata_set_1.DataSet.registerTransform('hierarchy.indented', transform);\ndata_set_1.DataSet.registerTransform('indented-tree', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/hierarchy/pack.ts\":\n/*!*****************************************!*\\\n  !*** ./src/transform/hierarchy/pack.ts ***!\n  \\*****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3Hierarchy = tslib_1.__importStar(__webpack_require__(/*! d3-hierarchy */ \"./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    field: 'value',\n    size: [1, 1],\n    padding: 0,\n    as: ['x', 'y', 'r'],\n};\nfunction transform(dataView, options) {\n    if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    var root = dataView.root;\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 3) {\n        throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ \"x\", \"y\", \"r\" ])!');\n    }\n    var field;\n    try {\n        field = option_parser_1.getField(options);\n    }\n    catch (e) {\n        console.warn(e);\n    }\n    if (field) {\n        root.sum(function (d) { return d[field]; }).sort(function (a, b) { return b[field] - a[field]; });\n    }\n    var packLayout = d3Hierarchy.pack();\n    packLayout.size(options.size);\n    if (options.padding) {\n        packLayout.padding(options.padding);\n    }\n    packLayout(root);\n    var x = as[0];\n    var y = as[1];\n    var r = as[2];\n    root.each(function (node) {\n        node[x] = node.x;\n        node[y] = node.y;\n        node[r] = node.r;\n    });\n}\ndata_set_1.DataSet.registerTransform('hierarchy.pack', transform);\ndata_set_1.DataSet.registerTransform('hierarchy.circle-packing', transform);\ndata_set_1.DataSet.registerTransform('circle-packing', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/hierarchy/partition.ts\":\n/*!**********************************************!*\\\n  !*** ./src/transform/hierarchy/partition.ts ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar d3Hierarchy = tslib_1.__importStar(__webpack_require__(/*! d3-hierarchy */ \"./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    field: 'value',\n    size: [1, 1],\n    round: false,\n    // ratio: 1.618033988749895, // golden ratio\n    padding: 0,\n    sort: true,\n    as: ['x', 'y'],\n};\nfunction transform(dataView, options) {\n    if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    var root = dataView.root;\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 2) {\n        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n    }\n    var field;\n    try {\n        field = option_parser_1.getField(options);\n    }\n    catch (e) {\n        console.warn(e);\n    }\n    if (field) {\n        root.sum(function (d) { return d[field]; });\n    }\n    var partitionLayout = d3Hierarchy.partition();\n    partitionLayout\n        .size(options.size)\n        .round(options.round)\n        .padding(options.padding);\n    partitionLayout(root);\n    /*\n     * points:\n     *   3  2\n     *   0  1\n     */\n    var x = as[0];\n    var y = as[1];\n    root.each(function (node) {\n        node[x] = [node.x0, node.x1, node.x1, node.x0];\n        node[y] = [node.y1, node.y1, node.y0, node.y0];\n        ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {\n            if (as.indexOf(prop) === -1) {\n                delete node[prop];\n            }\n        });\n    });\n}\ndata_set_1.DataSet.registerTransform('hierarchy.partition', transform);\ndata_set_1.DataSet.registerTransform('adjacency', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/hierarchy/tree.ts\":\n/*!*****************************************!*\\\n  !*** ./src/transform/hierarchy/tree.ts ***!\n  \\*****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar d3Hierarchy = tslib_1.__importStar(__webpack_require__(/*! d3-hierarchy */ \"./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    field: 'value',\n    size: [1, 1],\n    nodeSize: null,\n    separation: null,\n    as: ['x', 'y'],\n};\nfunction transform(dataView, options) {\n    if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    var root = dataView.root;\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 2) {\n        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n    }\n    var field;\n    try {\n        field = option_parser_1.getField(options);\n    }\n    catch (e) {\n        console.warn(e);\n    }\n    if (field) {\n        root.sum(function (d) { return d[field]; });\n    }\n    var treeLayout = d3Hierarchy.tree();\n    treeLayout.size(options.size);\n    if (options.nodeSize) {\n        treeLayout.nodeSize(options.nodeSize);\n    }\n    if (options.separation) {\n        treeLayout.separation(options.separation);\n    }\n    treeLayout(root);\n    var x = as[0];\n    var y = as[1];\n    root.each(function (node) {\n        node[x] = node.x;\n        node[y] = node.y;\n    });\n}\ndata_set_1.DataSet.registerTransform('hierarchy.tree', transform);\ndata_set_1.DataSet.registerTransform('tree', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/hierarchy/treemap.ts\":\n/*!********************************************!*\\\n  !*** ./src/transform/hierarchy/treemap.ts ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar d3Hierarchy = tslib_1.__importStar(__webpack_require__(/*! d3-hierarchy */ \"./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    field: 'value',\n    tile: 'treemapSquarify',\n    size: [1, 1],\n    round: false,\n    // ratio: 1.618033988749895, // golden ratio\n    padding: 0,\n    paddingInner: 0,\n    paddingOuter: 0,\n    paddingTop: 0,\n    paddingRight: 0,\n    paddingBottom: 0,\n    paddingLeft: 0,\n    as: ['x', 'y'],\n};\nfunction transform(dataView, options) {\n    if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    var root = dataView.root;\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 2) {\n        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n    }\n    var field;\n    try {\n        field = option_parser_1.getField(options);\n    }\n    catch (e) {\n        console.warn(e);\n    }\n    if (field) {\n        root.sum(function (d) { return d[field]; });\n    }\n    var treemapLayout = d3Hierarchy.treemap();\n    treemapLayout\n        .tile(d3Hierarchy[options.tile])\n        .size(options.size)\n        .round(options.round)\n        .padding(options.padding)\n        .paddingInner(options.paddingInner)\n        .paddingOuter(options.paddingOuter)\n        .paddingTop(options.paddingTop)\n        .paddingRight(options.paddingRight)\n        .paddingBottom(options.paddingBottom)\n        .paddingLeft(options.paddingLeft);\n    treemapLayout(root);\n    /*\n     * points:\n     *   3  2\n     *   0  1\n     */\n    var x = as[0];\n    var y = as[1];\n    root.each(function (node) {\n        node[x] = [node.x0, node.x1, node.x1, node.x0];\n        node[y] = [node.y1, node.y1, node.y0, node.y0];\n        ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {\n            if (as.indexOf(prop) === -1) {\n                delete node[prop];\n            }\n        });\n    });\n}\ndata_set_1.DataSet.registerTransform('hierarchy.treemap', transform);\ndata_set_1.DataSet.registerTransform('treemap', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/impute.ts\":\n/*!*********************************!*\\\n  !*** ./src/transform/impute.ts ***!\n  \\*********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar simpleStatistics = tslib_1.__importStar(__webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\"));\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    // field: '', // required\n    // method: 'value', // required\n    // value: 10, // required if (method === 'value')\n    groupBy: [],\n};\nfunction notUndefinedValues(values) {\n    return values.filter(function (value) { return !util_1.isUndefined(value); });\n}\nvar STATISTICS_METHODS = ['mean', 'median', 'max', 'min'];\nvar imputations = {};\nSTATISTICS_METHODS.forEach(function (method) {\n    // @ts-ignore\n    imputations[method] = function (row, values) { return simpleStatistics[method](values); };\n});\nimputations.value = function (_row, _values, value) { return value; };\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var field = option_parser_1.getField(options);\n    var method = options.method;\n    if (!method) {\n        throw new TypeError('Invalid method!');\n    }\n    if (method === 'value' && !util_1.has(options, 'value')) {\n        throw new TypeError('Invalid value: it is nil.');\n    }\n    var column = notUndefinedValues(dataView.getColumn(field));\n    var groups = partition_1.default(dataView.rows, options.groupBy);\n    util_1.forIn(groups, function (group) {\n        var fieldValues = notUndefinedValues(group.map(function (row) { return row[field]; }));\n        if (fieldValues.length === 0) {\n            fieldValues = column;\n        }\n        group.forEach(function (row) {\n            if (util_1.isUndefined(row[field])) {\n                if (util_1.isFunction(method)) {\n                    row[field] = method(row, fieldValues, options.value, group);\n                }\n                else if (util_1.isString(method)) {\n                    row[field] = imputations[method](row, fieldValues, options.value);\n                }\n                else {\n                    throw new TypeError(\"Invalid method: must be a function or one of \" + STATISTICS_METHODS.join(', '));\n                }\n            }\n        });\n    });\n}\ndata_set_1.DataSet.registerTransform('impute', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/kde.ts\":\n/*!******************************!*\\\n  !*** ./src/transform/kde.ts ***!\n  \\******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\n/*\n * kernel density estimation\n */\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar get_series_values_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/get-series-values */ \"./src/util/get-series-values.ts\"));\nvar kernel_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/kernel */ \"./src/util/kernel.ts\"));\nvar bandwidth = tslib_1.__importStar(__webpack_require__(/*! ../util/bandwidth */ \"./src/util/bandwidth.ts\"));\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar simple_statistics_1 = __webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\");\nvar DEFAULT_OPTIONS = {\n    minSize: 0.01,\n    as: ['key', 'y', 'size'],\n    // fields: [ 'y1', 'y2' ], // required, one or more fields\n    extent: [],\n    method: 'gaussian',\n    bandwidth: 'nrd',\n    step: 0,\n    groupBy: [],\n};\nvar KERNEL_METHODS = util_1.keys(kernel_1.default);\nvar BANDWIDTH_METHODS = util_1.keys(bandwidth);\nfunction transform(dv, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var fields = option_parser_1.getFields(options);\n    if (!util_1.isArray(fields) || fields.length < 1) {\n        throw new TypeError('invalid fields: must be an array of at least 1 strings!');\n    }\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 3) {\n        throw new TypeError('invalid as: must be an array of 3 strings!');\n    }\n    var method = options.method;\n    if (util_1.isString(method)) {\n        if (KERNEL_METHODS.indexOf(method) === -1) {\n            throw new TypeError(\"invalid method: \" + method + \". Must be one of \" + KERNEL_METHODS.join(', '));\n        }\n        method = kernel_1.default[method];\n    }\n    if (!util_1.isFunction(method)) {\n        throw new TypeError('invalid method: kernel method must be a function!');\n    }\n    var extent = options.extent;\n    if (!util_1.isArray(extent) || extent.length === 0) {\n        var rangeArr_1 = [];\n        util_1.each(fields, function (field) {\n            var range = dv.range(field);\n            rangeArr_1 = rangeArr_1.concat(range);\n        });\n        extent = [Math.min.apply(Math, tslib_1.__spread(rangeArr_1)), Math.max.apply(Math, tslib_1.__spread(rangeArr_1))];\n    }\n    var bw = options.bandwidth;\n    if (util_1.isString(bw) && bandwidth[bw]) {\n        bw = bandwidth[bw](dv.getColumn(fields[0]));\n    }\n    else if (util_1.isFunction(bw)) {\n        bw = bw(dv.getColumn(fields[0]));\n    }\n    else if (!util_1.isNumber(bw) || bw <= 0) {\n        bw = bandwidth.nrd(dv.getColumn(fields[0]));\n    }\n    var seriesValues = get_series_values_1.default(extent, options.step ? options.step : bw);\n    var result = [];\n    var groupBy = options.groupBy;\n    var groups = partition_1.default(dv.rows, groupBy);\n    util_1.forIn(groups, function (group) {\n        var probalityDensityFunctionByField = {};\n        util_1.each(fields, function (field) {\n            var row = util_1.pick(group[0], groupBy);\n            probalityDensityFunctionByField[field] = simple_statistics_1.kernelDensityEstimation(group.map(function (item) { return item[field]; }), method, bw);\n            var _a = tslib_1.__read(as, 3), key = _a[0], y = _a[1], size = _a[2];\n            row[key] = field;\n            row[y] = [];\n            row[size] = [];\n            util_1.each(seriesValues, function (yValue) {\n                var sizeValue = probalityDensityFunctionByField[field](yValue);\n                if (sizeValue >= options.minSize) {\n                    row[y].push(yValue);\n                    row[size].push(sizeValue);\n                }\n            });\n            result.push(row);\n        });\n    });\n    dv.rows = result;\n}\ndata_set_1.DataSet.registerTransform('kernel-density-estimation', transform);\ndata_set_1.DataSet.registerTransform('kde', transform);\ndata_set_1.DataSet.registerTransform('KDE', transform);\nexports.default = {\n    KERNEL_METHODS: KERNEL_METHODS,\n    BANDWIDTH_METHODS: BANDWIDTH_METHODS,\n};\n\n\n/***/ }),\n\n/***/ \"./src/transform/kernel-smooth/density.ts\":\n/*!************************************************!*\\\n  !*** ./src/transform/kernel-smooth/density.ts ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\n/*\n * @reference: https://github.com/Planeshifter/kernel-smooth/blob/master/lib/index.js\n */\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar get_series_values_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../util/get-series-values */ \"./src/util/get-series-values.ts\"));\nvar kernel_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../util/kernel */ \"./src/util/kernel.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar bandwidth_1 = __webpack_require__(/*! ../../util/bandwidth */ \"./src/util/bandwidth.ts\");\nvar DEFAULT_OPTIONS = {\n    as: ['x', 'y', 'z'],\n    // fields: [ 'x', 'y' ], // required, one or two fields\n    method: 'gaussian',\n};\nvar KERNEL_METHODS = util_1.keys(kernel_1.default);\nfunction transform(dv, options) {\n    var _a, _b;\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var fields = option_parser_1.getFields(options);\n    if (!util_1.isArray(fields) || fields.length !== 2) {\n        throw new TypeError('invalid fields: must be an array of 2 strings!');\n    }\n    var _c = tslib_1.__read(options.as, 3), asX = _c[0], asY = _c[1], asZ = _c[2];\n    if (!util_1.isString(asX) || !util_1.isString(asY) || !util_1.isString(asZ)) {\n        throw new TypeError('invalid as: must be an array of 3 strings!');\n    }\n    var method;\n    if (util_1.isString(options.method)) {\n        if (KERNEL_METHODS.indexOf(options.method) === -1) {\n            throw new TypeError(\"invalid method: \" + options.method + \". Must be one of \" + KERNEL_METHODS.join(', '));\n        }\n        method = kernel_1.default[options.method];\n    }\n    var _d = tslib_1.__read(fields, 2), xField = _d[0], yField = _d[1];\n    var extent = options.extent, bandwidth = options.bandwidth;\n    var extentX;\n    var extentY;\n    if (extent && Array.isArray(extent) && Array.isArray(extent[0]) && Array.isArray(extent[1])) {\n        _a = tslib_1.__read(extent, 2), extentX = _a[0], extentY = _a[1];\n    }\n    else {\n        extentX = dv.range(xField);\n        extentY = dv.range(yField);\n    }\n    var bwX, bwY;\n    if (bandwidth &&\n        Array.isArray(bandwidth) &&\n        bandwidth.slice(0, 2).every(util_1.isNumber) &&\n        bandwidth.slice(0, 2).every(function (item) { return item > 0; })) {\n        _b = tslib_1.__read(bandwidth, 2), bwX = _b[0], bwY = _b[1];\n    }\n    else {\n        bwX = bandwidth_1.silverman(dv.getColumn(xField));\n        bwY = bandwidth_1.silverman(dv.getColumn(yField));\n    }\n    var seriesValuesX = get_series_values_1.default(extentX, bwX);\n    var seriesValuesY = get_series_values_1.default(extentY, bwY);\n    var count = dv.rows.length;\n    var result = [];\n    for (var i = 0; i < seriesValuesX.length; i++) {\n        for (var j = 0; j < seriesValuesY.length; j++) {\n            var sum = 0;\n            var x = seriesValuesX[i];\n            var y = seriesValuesY[j];\n            for (var k = 0; k < count; k++) {\n                sum += method((x - dv.rows[k][xField]) / bwX) * method((y - dv.rows[k][yField]) / bwY);\n            }\n            var z = (1 / (count * bwX * bwY)) * sum;\n            var row = {};\n            row[asX] = x;\n            row[asY] = y;\n            row[asZ] = z;\n            result.push(row);\n        }\n    }\n    dv.rows = result;\n}\ndata_set_1.DataSet.registerTransform('kernel-smooth.density', transform);\ndata_set_1.DataSet.registerTransform('kernel.density', transform);\nexports.default = {\n    KERNEL_METHODS: KERNEL_METHODS,\n};\n\n\n/***/ }),\n\n/***/ \"./src/transform/kernel-smooth/regression.ts\":\n/*!***************************************************!*\\\n  !*** ./src/transform/kernel-smooth/regression.ts ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\n/*\n * @reference: https://github.com/Planeshifter/kernel-smooth/blob/master/lib/index.js\n */\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar get_series_values_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../util/get-series-values */ \"./src/util/get-series-values.ts\"));\nvar kernel_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../util/kernel */ \"./src/util/kernel.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar simple_statistics_1 = __webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar bandwidth_1 = __webpack_require__(/*! ../../util/bandwidth */ \"./src/util/bandwidth.ts\");\nvar DEFAULT_OPTIONS = {\n    as: ['x', 'y'],\n    // fields: [ 'x', 'y' ], // required, one or two fields\n    method: 'gaussian',\n};\nvar KERNEL_METHODS = util_1.keys(kernel_1.default);\n// calculates weight for i-th obs\nfunction weight(kernel, bandwidth, x_0, x_i) {\n    var arg = (x_i - x_0) / bandwidth;\n    return kernel(arg);\n}\n// calculates weight for i-th obs when p > 1\n// function weight_vectors(kernel, bandwidth, x_0, x_i) {\n//   const arg = enclideanDistance(x_i, x_0) / bandwidth;\n//   return kernel(arg);\n// }\nfunction vectorize(fun) {\n    return function (x) {\n        if (!util_1.isArray(x)) {\n            return fun(x);\n        }\n        return x.map(function (x) {\n            return fun(x);\n        });\n    };\n}\nfunction transform(dv, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var fields = option_parser_1.getFields(options);\n    if (!util_1.isArray(fields) || !(fields.length === 1 || fields.length === 2)) {\n        throw new TypeError('invalid fields: must be an array of 1 or 2 strings!');\n    }\n    var _a = tslib_1.__read(options.as, 2), asX = _a[0], asY = _a[1];\n    if (!util_1.isString(asX) || !util_1.isString(asY)) {\n        throw new TypeError('invalid as: must be an array of 2 strings!');\n    }\n    var func;\n    var method = options.method;\n    if (util_1.isString(method)) {\n        if (KERNEL_METHODS.indexOf(method) === -1) {\n            throw new TypeError(\"invalid method: \" + method + \". Must be one of \" + KERNEL_METHODS.join(', '));\n        }\n        func = kernel_1.default[method];\n    }\n    var _b = tslib_1.__read(fields, 2), xField = _b[0], yField = _b[1];\n    var xs = dv.getColumn(xField);\n    var extent = options.extent;\n    if (extent || !util_1.isArray(extent)) {\n        extent = dv.range(xField);\n    }\n    var bandwidth = options.bandwidth;\n    if (!bandwidth || !util_1.isNumber(bandwidth) || bandwidth <= 0) {\n        bandwidth = bandwidth_1.silverman(xs);\n    }\n    var seriesValues = get_series_values_1.default(extent, bandwidth);\n    var xCount = xs.length;\n    var weightFunc = weight.bind(null, func, bandwidth);\n    var kernelSmoother;\n    if (util_1.isNil(yField)) {\n        // KDE\n        kernelSmoother = vectorize(function (x) {\n            var weights = xs.map(function (x_i) { return weightFunc(x, x_i); });\n            var num = simple_statistics_1.sum(weights);\n            var denom = xCount * bandwidth;\n            if (!num || !denom)\n                return 0;\n            return num / denom;\n        });\n    }\n    else {\n        // kernel regression smoothing\n        var ys_1 = dv.getColumn(yField);\n        kernelSmoother = vectorize(function (x) {\n            var weights = xs.map(function (x_i) { return weightFunc(x, x_i); });\n            var num = simple_statistics_1.sum(weights.map(function (w, i) { return w * ys_1[i]; }));\n            var denom = simple_statistics_1.sum(weights);\n            if (!num || !denom)\n                return 0;\n            return num / denom;\n        });\n    }\n    var result = seriesValues.map(function (x) {\n        var row = {};\n        row[asX] = x;\n        row[asY] = kernelSmoother(x);\n        return row;\n    });\n    dv.rows = result;\n}\ndata_set_1.DataSet.registerTransform('kernel-smooth.regression', transform);\ndata_set_1.DataSet.registerTransform('kernel.regression', transform);\nexports.default = {\n    KERNEL_METHODS: KERNEL_METHODS,\n};\n\n\n/***/ }),\n\n/***/ \"./src/transform/map.ts\":\n/*!******************************!*\\\n  !*** ./src/transform/map.ts ***!\n  \\******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nfunction defaultCallback(row) {\n    return row;\n}\ndata_set_1.DataSet.registerTransform('map', function (dataView, options) {\n    dataView.rows = dataView.rows.map(options.callback || defaultCallback);\n});\n\n\n/***/ }),\n\n/***/ \"./src/transform/partition.ts\":\n/*!************************************!*\\\n  !*** ./src/transform/partition.ts ***!\n  \\************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {\n    groupBy: [],\n    orderBy: [],\n};\ndata_set_1.DataSet.registerTransform('partition', function (dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    // TODO: rows 是否都只能是数组\n    // @ts-ignore;\n    dataView.rows = partition_1.default(dataView.rows, options.groupBy, options.orderBy);\n});\nfunction group(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    dataView.rows = util_1.values(partition_1.default(dataView.rows, options.groupBy, options.orderBy));\n}\ndata_set_1.DataSet.registerTransform('group', group);\ndata_set_1.DataSet.registerTransform('groups', group);\n\n\n/***/ }),\n\n/***/ \"./src/transform/percent.ts\":\n/*!**********************************!*\\\n  !*** ./src/transform/percent.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar simple_statistics_1 = __webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\");\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    // field: 'y', // required\n    // dimension: 'x', // required\n    groupBy: [],\n    as: '_percent',\n};\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var field = option_parser_1.getField(options);\n    var dimension = options.dimension, groupBy = options.groupBy;\n    var as = options.as;\n    if (!util_1.isString(dimension)) {\n        throw new TypeError('Invalid dimension: must be a string!');\n    }\n    if (util_1.isArray(as)) {\n        console.warn('Invalid as: must be a string, will use the first element of the array specified.');\n        as = as[0];\n    }\n    if (!util_1.isString(as)) {\n        throw new TypeError('Invalid as: must be a string!');\n    }\n    var rows = dataView.rows;\n    var result = [];\n    var groups = partition_1.default(rows, groupBy);\n    util_1.forIn(groups, function (group) {\n        var totalSum = simple_statistics_1.sum(group.map(function (row) { return row[field]; }));\n        if (totalSum === 0) {\n            console.warn(\"Invalid data: total sum of field \" + field + \" is 0!\");\n        }\n        var innerGroups = partition_1.default(group, [dimension]);\n        util_1.forIn(innerGroups, function (innerGroup) {\n            var innerSum = simple_statistics_1.sum(innerGroup.map(function (row) { return row[field]; }));\n            // const resultRow = pick(innerGroup[0], union(groupBy, [ dimension ]));\n            var resultRow = innerGroup[0];\n            // FIXME in case dimension and field is the same\n            var dimensionValue = resultRow[dimension];\n            resultRow[field] = innerSum;\n            resultRow[dimension] = dimensionValue;\n            if (totalSum === 0) {\n                resultRow[as] = 0;\n            }\n            else {\n                resultRow[as] = innerSum / totalSum;\n            }\n            result.push(resultRow);\n        });\n    });\n    dataView.rows = result;\n}\ndata_set_1.DataSet.registerTransform('percent', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/pick.ts\":\n/*!*******************************!*\\\n  !*** ./src/transform/pick.ts ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\ndata_set_1.DataSet.registerTransform('pick', function (dataView, options) {\n    var columns = option_parser_1.getFields(options, dataView.getColumnNames());\n    dataView.rows = dataView.rows.map(function (row) { return util_1.pick(row, columns); });\n});\n\n\n/***/ }),\n\n/***/ \"./src/transform/proportion.ts\":\n/*!*************************************!*\\\n  !*** ./src/transform/proportion.ts ***!\n  \\*************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    // field: 'y', // required\n    // dimension: 'x', // required\n    groupBy: [],\n    as: '_proportion',\n};\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var field = option_parser_1.getField(options);\n    var dimension = options.dimension;\n    var groupBy = options.groupBy;\n    var as = options.as;\n    if (!util_1.isString(dimension)) {\n        throw new TypeError('Invalid dimension: must be a string!');\n    }\n    if (util_1.isArray(as)) {\n        console.warn('Invalid as: must be a string, will use the first element of the array specified.');\n        as = as[0];\n    }\n    if (!util_1.isString(as)) {\n        throw new TypeError('Invalid as: must be a string!');\n    }\n    var rows = dataView.rows;\n    var result = [];\n    var groups = partition_1.default(rows, groupBy);\n    util_1.forIn(groups, function (group) {\n        var totalCount = group.length;\n        var innerGroups = partition_1.default(group, [dimension]);\n        util_1.forIn(innerGroups, function (innerGroup) {\n            var innerCount = innerGroup.length;\n            // const resultRow = pick(innerGroup[0], union(groupBy, [ dimension ]));\n            var resultRow = innerGroup[0];\n            // FIXME in case dimension and field is the same\n            var dimensionValue = resultRow[dimension];\n            resultRow[field] = innerCount;\n            resultRow[dimension] = dimensionValue;\n            resultRow[as] = innerCount / totalCount;\n            result.push(resultRow);\n        });\n    });\n    dataView.rows = result;\n}\ndata_set_1.DataSet.registerTransform('proportion', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/regression.ts\":\n/*!*************************************!*\\\n  !*** ./src/transform/regression.ts ***!\n  \\*************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar regression_1 = tslib_1.__importDefault(__webpack_require__(/*! regression */ \"./node_modules/_regression@2.0.1@regression/dist/regression.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar get_series_values_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/get-series-values */ \"./src/util/get-series-values.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar bandwidth_1 = __webpack_require__(/*! ../util/bandwidth */ \"./src/util/bandwidth.ts\");\nvar DEFAULT_OPTIONS = {\n    as: ['x', 'y'],\n    // fields: [ 'x', 'y' ], // required two fields\n    method: 'linear',\n    // extent: [], // extent to execute regression function, default: [ min(x), max(x) ]\n    // bandwidth: 1, // bandWidth to execute regression function\n    order: 2,\n    precision: 2,\n};\nvar REGRESSION_METHODS = ['linear', 'exponential', 'logarithmic', 'power', 'polynomial'];\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var fields = option_parser_1.getFields(options);\n    if (!util_1.isArray(fields) || fields.length !== 2) {\n        throw new TypeError('invalid fields: must be an array of 2 strings.');\n    }\n    var _a = tslib_1.__read(fields, 2), xField = _a[0], yField = _a[1];\n    var method = options.method;\n    if (REGRESSION_METHODS.indexOf(method) === -1) {\n        throw new TypeError(\"invalid method: \" + method + \". Must be one of \" + REGRESSION_METHODS.join(', '));\n    }\n    var points = dataView.rows.map(function (row) { return [row[xField], row[yField]]; });\n    var regressionResult = regression_1.default[method](points, options);\n    var extent = options.extent;\n    if (!util_1.isArray(extent) || extent.length !== 2) {\n        extent = dataView.range(xField);\n    }\n    var bandwidth = options.bandwidth;\n    if (!util_1.isNumber(bandwidth) || bandwidth <= 0) {\n        bandwidth = bandwidth_1.silverman(dataView.getColumn(xField));\n    }\n    var valuesToPredict = get_series_values_1.default(extent, bandwidth);\n    var result = [];\n    var _b = tslib_1.__read(options.as, 2), asX = _b[0], asY = _b[1];\n    valuesToPredict.forEach(function (value) {\n        var row = {};\n        var _a = tslib_1.__read(regressionResult.predict(value), 2), x = _a[0], y = _a[1];\n        row[asX] = x;\n        row[asY] = y;\n        if (isFinite(y)) {\n            result.push(row);\n        }\n    });\n    dataView.rows = result;\n}\ndata_set_1.DataSet.registerTransform('regression', transform);\nexports.default = {\n    REGRESSION_METHODS: REGRESSION_METHODS,\n};\n\n\n/***/ }),\n\n/***/ \"./src/transform/rename.ts\":\n/*!*********************************!*\\\n  !*** ./src/transform/rename.ts ***!\n  \\*********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nfunction transform(dataView, options) {\n    var map = options.map || {};\n    var cleanMap = {};\n    if (util_1.isPlainObject(map)) {\n        util_1.forIn(map, function (value, key) {\n            if (util_1.isString(value) && util_1.isString(key)) {\n                cleanMap[key] = value;\n            }\n        });\n    }\n    dataView.rows.forEach(function (row) {\n        util_1.forIn(cleanMap, function (newKey, key) {\n            var temp = row[key];\n            delete row[key];\n            row[newKey] = temp;\n        });\n    });\n}\ndata_set_1.DataSet.registerTransform('rename', transform);\ndata_set_1.DataSet.registerTransform('rename-fields', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/reverse.ts\":\n/*!**********************************!*\\\n  !*** ./src/transform/reverse.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\ndata_set_1.DataSet.registerTransform('reverse', function (dataView) {\n    dataView.rows.reverse();\n});\n\n\n/***/ }),\n\n/***/ \"./src/transform/sort-by.ts\":\n/*!**********************************!*\\\n  !*** ./src/transform/sort-by.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\n/*\n * options: {\n *   type: 'sort-by',\n *   fields: [],\n *   order: 'ASC' // 'DESC'\n * }\n */\nvar VALID_ORDERS = ['ASC', 'DESC'];\nfunction transform(dataView, options) {\n    var fields = option_parser_1.getFields(options, [dataView.getColumnName(0)]);\n    if (!util_1.isArray(fields)) {\n        throw new TypeError('Invalid fields: must be an array with strings!');\n    }\n    dataView.rows = util_1.sortBy(dataView.rows, fields);\n    var order = options.order;\n    if (order && VALID_ORDERS.indexOf(order) === -1) {\n        throw new TypeError(\"Invalid order: \" + order + \" must be one of \" + VALID_ORDERS.join(', '));\n    }\n    else if (order === 'DESC') {\n        dataView.rows.reverse();\n    }\n}\ndata_set_1.DataSet.registerTransform('sort-by', transform);\ndata_set_1.DataSet.registerTransform('sortBy', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/sort.ts\":\n/*!*******************************!*\\\n  !*** ./src/transform/sort.ts ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\ndata_set_1.DataSet.registerTransform('sort', function (dataView, options) {\n    var columnName = dataView.getColumnName(0);\n    dataView.rows.sort(options.callback || (function (a, b) { return a[columnName] - b[columnName]; }));\n});\n\n\n/***/ }),\n\n/***/ \"./src/transform/subset.ts\":\n/*!*********************************!*\\\n  !*** ./src/transform/subset.ts ***!\n  \\*********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\ndata_set_1.DataSet.registerTransform('subset', function (dataView, options) {\n    var startIndex = options.startRowIndex || 0;\n    var endIndex = options.endRowIndex || dataView.rows.length - 1;\n    var columns = option_parser_1.getFields(options, dataView.getColumnNames());\n    dataView.rows = dataView.getSubset(startIndex, endIndex, columns);\n});\n\n\n/***/ }),\n\n/***/ \"./src/transform/tag-cloud.ts\":\n/*!************************************!*\\\n  !*** ./src/transform/tag-cloud.ts ***!\n  \\************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar tag_cloud_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/tag-cloud */ \"./src/util/tag-cloud.ts\"));\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    fields: ['text', 'value'],\n    font: function () { return 'serif'; },\n    padding: 1,\n    size: [500, 500],\n    spiral: 'archimedean',\n    // timeInterval: Infinity // max execute time\n    timeInterval: 500,\n};\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var layout = tag_cloud_1.default();\n    ['font', 'fontSize', 'padding', 'rotate', 'size', 'spiral', 'timeInterval'].forEach(function (key) {\n        // @ts-ignore\n        if (options[key]) {\n            // @ts-ignore\n            layout[key](options[key]);\n        }\n    });\n    var fields = option_parser_1.getFields(options);\n    var _a = tslib_1.__read(fields, 2), text = _a[0], value = _a[1];\n    if (!util_1.isString(text) || !util_1.isString(value)) {\n        throw new TypeError('Invalid fields: must be an array with 2 strings (e.g. [ \"text\", \"value\" ])!');\n    }\n    var words = dataView.rows.map(function (row) {\n        row.text = row[text];\n        row.value = row[value];\n        return row;\n    });\n    layout.words(words);\n    if (options.imageMask) {\n        layout.createMask(options.imageMask);\n    }\n    var result = layout.start();\n    var tags = result._tags;\n    var bounds = result._bounds;\n    tags.forEach(function (tag) {\n        tag.x += options.size[0] / 2;\n        tag.y += options.size[1] / 2;\n    });\n    var _b = tslib_1.__read(options.size, 2), w = _b[0], h = _b[1];\n    var hasImage = result.hasImage;\n    tags.push({\n        text: '',\n        value: 0,\n        x: hasImage ? 0 : bounds[0].x,\n        y: hasImage ? 0 : bounds[0].y,\n        opacity: 0,\n    });\n    tags.push({\n        text: '',\n        value: 0,\n        x: hasImage ? w : bounds[1].x,\n        y: hasImage ? h : bounds[1].y,\n        opacity: 0,\n    });\n    dataView.rows = tags;\n    dataView._tagCloud = result;\n}\ndata_set_1.DataSet.registerTransform('tag-cloud', transform);\ndata_set_1.DataSet.registerTransform('word-cloud', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/waffle.ts\":\n/*!*********************************!*\\\n  !*** ./src/transform/waffle.ts ***!\n  \\*********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar simple_statistics_1 = __webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\");\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    fields: ['name', 'value'],\n    rows: 5,\n    size: [1, 1],\n    scale: 1,\n    groupBy: [],\n    maxCount: 1000,\n    gapRatio: 0.1,\n    as: ['x', 'y'],\n};\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var fields = option_parser_1.getFields(options);\n    var _a = tslib_1.__read(fields, 2), nameField = _a[0], valueField = _a[1];\n    var _b = tslib_1.__read(options.as, 2), asX = _b[0], asY = _b[1];\n    var groupBy = options.groupBy;\n    var groups = partition_1.default(dataView.rows, groupBy);\n    var groupKeys = util_1.keys(groups);\n    var _c = tslib_1.__read(options.size, 2), width = _c[0], height = _c[1];\n    var maxCount = options.maxCount;\n    var groupCount = groupKeys.length;\n    var partHeight = height / groupCount;\n    var rows = options.rows;\n    var gapRatio = options.gapRatio;\n    var result = [];\n    var scale = options.scale;\n    var currentGroupIndex = 0;\n    var wStep = 0;\n    // getting suitable scale and width step\n    util_1.forIn(groups, function (group) {\n        var totalValue = simple_statistics_1.sum(util_1.map(group, function (row) { return row[valueField]; }));\n        var cols = Math.ceil((totalValue * scale) / rows);\n        if (totalValue * scale > maxCount) {\n            scale = maxCount / totalValue;\n            cols = Math.ceil((totalValue * scale) / rows);\n        }\n        wStep = width / cols;\n    });\n    // distributing values into grid\n    util_1.forIn(groups, function (group) {\n        var heightRange = [currentGroupIndex * partHeight, (currentGroupIndex + 1) * partHeight];\n        var h = heightRange[1] - heightRange[0];\n        var hStep = (h * (1 - gapRatio)) / rows;\n        var currentCol = 0;\n        var currentRow = 0;\n        util_1.each(group, function (row) {\n            var value = row[valueField];\n            var count = Math.round(value * scale);\n            for (var i = 0; i < count; i++) {\n                if (currentRow === rows) {\n                    currentRow = 0;\n                    currentCol++;\n                }\n                var resultRow = util_1.pick(row, [nameField, valueField].concat(groupBy));\n                resultRow[asX] = currentCol * wStep + wStep / 2;\n                resultRow[asY] = currentRow * hStep + hStep / 2 + heightRange[0];\n                resultRow._wStep = wStep;\n                resultRow._hStep = hStep;\n                currentRow++;\n                result.push(resultRow);\n            }\n        });\n        currentGroupIndex += 1;\n    });\n    dataView.rows = result;\n}\ndata_set_1.DataSet.registerTransform('waffle', transform);\n\n\n/***/ }),\n\n/***/ \"./src/util/bandwidth.ts\":\n/*!*******************************!*\\\n  !*** ./src/util/bandwidth.ts ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar simple_statistics_1 = __webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\");\nfunction silverman(arr) {\n    var stdev = simple_statistics_1.standardDeviation(arr);\n    var num = 4 * Math.pow(stdev, 5);\n    var denom = 3 * arr.length;\n    return Math.pow(num / denom, 0.2);\n}\nexports.silverman = silverman;\nfunction nrd(arr) {\n    var s = simple_statistics_1.standardDeviation(arr);\n    var iqr = simple_statistics_1.interquartileRange(arr);\n    if (typeof iqr === 'number') {\n        s = Math.min(s, iqr / 1.34);\n    }\n    return 1.06 * s * Math.pow(arr.length, -0.2);\n}\nexports.nrd = nrd;\n\n\n/***/ }),\n\n/***/ \"./src/util/get-geo-projection.ts\":\n/*!****************************************!*\\\n  !*** ./src/util/get-geo-projection.ts ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3Geo = tslib_1.__importStar(__webpack_require__(/*! d3-geo */ \"./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js\"));\nvar d3GeoProjection = tslib_1.__importStar(__webpack_require__(/*! d3-geo-projection */ \"./node_modules/_d3-geo-projection@2.1.2@d3-geo-projection/build/d3-geo-projection.js\"));\nvar d3CompositeProjection = tslib_1.__importStar(__webpack_require__(/*! d3-composite-projections */ \"./node_modules/_d3-composite-projections@1.3.2@d3-composite-projections/d3-composite-projections.js\"));\n/*\n * getGeoProjection\n *\n * @param {string|function} projection  projection name or projection function\n * @param {boolean} [exportRaw = false] - whether return the raw projection or not\n * */\nexports.default = (function (projection, exportRaw) {\n    if (exportRaw === void 0) { exportRaw = false; }\n    if (util_1.isFunction(projection)) {\n        return exportRaw ? projection : projection();\n    }\n    if (util_1.isString(projection)) {\n        // @ts-ignore\n        if (d3Geo[projection]) {\n            // @ts-ignore\n            return exportRaw ? d3Geo[projection] : d3Geo[projection]();\n        }\n        if (d3GeoProjection[projection]) {\n            return exportRaw ? d3GeoProjection[projection] : d3GeoProjection[projection]();\n        }\n        if (d3CompositeProjection[projection]) {\n            return exportRaw ? d3CompositeProjection[projection] : d3CompositeProjection[projection]();\n        }\n    }\n    return null;\n});\n\n\n/***/ }),\n\n/***/ \"./src/util/get-series-values.ts\":\n/*!***************************************!*\\\n  !*** ./src/util/get-series-values.ts ***!\n  \\***************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nexports.default = (function (extent, bw) {\n    var bandwidth = bw || 1;\n    var _a = tslib_1.__read(extent, 2), min = _a[0], max = _a[1];\n    var values = [];\n    var tmp = min;\n    while (tmp < max) {\n        values.push(tmp);\n        tmp += bandwidth;\n    }\n    values.push(max);\n    return values;\n});\n\n\n/***/ }),\n\n/***/ \"./src/util/kernel.ts\":\n/*!****************************!*\\\n  !*** ./src/util/kernel.ts ***!\n  \\****************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * @reference: https://github.com/jasondavies/science.js/blob/master/src/stats/kernel.js\n * @reference: https://github.com/Planeshifter/kernel-smooth/blob/master/lib/index.js#L16\n */\nfunction uniform(u) {\n    return Math.abs(u) <= 1 ? 0.5 : 0;\n}\nfunction tricubed(u) {\n    var abs = 1 - Math.pow(Math.abs(u), 3);\n    return Math.pow(abs, 3);\n}\nexports.default = {\n    boxcar: uniform,\n    cosine: function (u) {\n        if (Math.abs(u) <= 1) {\n            return (Math.PI / 4) * Math.cos((Math.PI / 2) * u);\n        }\n        return 0;\n    },\n    epanechnikov: function (u) {\n        return Math.abs(u) < 1 ? 0.75 * (1 - u * u) : 0;\n    },\n    gaussian: function (u) {\n        // return 1 / Math.sqrt(2 * Math.PI) * Math.exp(-0.5 * u * u);\n        return 0.3989422804 * Math.exp(-0.5 * u * u);\n    },\n    quartic: function (u) {\n        if (Math.abs(u) < 1) {\n            var tmp = 1 - u * u;\n            return (15 / 16) * tmp * tmp;\n        }\n        return 0;\n    },\n    triangular: function (u) {\n        var abs = Math.abs(u);\n        return abs < 1 ? 1 - abs : 0;\n    },\n    tricube: function (u) {\n        return Math.abs(u) < 1 ? (70 / 81) * tricubed(u) : 0;\n    },\n    triweight: function (u) {\n        if (Math.abs(u) < 1) {\n            var tmp = 1 - u * u;\n            return (35 / 32) * tmp * tmp * tmp;\n        }\n        return 0;\n    },\n    uniform: uniform,\n};\n\n\n/***/ }),\n\n/***/ \"./src/util/option-parser.ts\":\n/*!***********************************!*\\\n  !*** ./src/util/option-parser.ts ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar INVALID_FIELD_ERR_MSG = 'Invalid field: it must be a string!';\nvar INVALID_FIELDS_ERR_MSG = 'Invalid fields: it must be an array!';\nfunction getField(options, defaultField) {\n    var field = options.field, fields = options.fields;\n    if (util_1.isString(field)) {\n        return field;\n    }\n    if (util_1.isArray(field)) {\n        console.warn(INVALID_FIELD_ERR_MSG);\n        return field[0];\n    }\n    console.warn(INVALID_FIELD_ERR_MSG + \" will try to get fields instead.\");\n    if (util_1.isString(fields)) {\n        return fields;\n    }\n    if (util_1.isArray(fields) && fields.length) {\n        return fields[0];\n    }\n    if (defaultField) {\n        return defaultField;\n    }\n    throw new TypeError(INVALID_FIELD_ERR_MSG);\n}\nexports.getField = getField;\nfunction getFields(options, defaultFields) {\n    var field = options.field, fields = options.fields;\n    if (util_1.isArray(fields)) {\n        return fields;\n    }\n    if (util_1.isString(fields)) {\n        console.warn(INVALID_FIELDS_ERR_MSG);\n        return [fields];\n    }\n    console.warn(INVALID_FIELDS_ERR_MSG + \" will try to get field instead.\");\n    if (util_1.isString(field)) {\n        console.warn(INVALID_FIELDS_ERR_MSG);\n        return [field];\n    }\n    if (util_1.isArray(field) && field.length) {\n        console.warn(INVALID_FIELDS_ERR_MSG);\n        return field;\n    }\n    if (defaultFields) {\n        return defaultFields;\n    }\n    throw new TypeError(INVALID_FIELDS_ERR_MSG);\n}\nexports.getFields = getFields;\n\n\n/***/ }),\n\n/***/ \"./src/util/p-by-fraction.ts\":\n/*!***********************************!*\\\n  !*** ./src/util/p-by-fraction.ts ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = (function (fraction) {\n    var step = 1 / fraction;\n    var pArr = [];\n    for (var i = 0; i <= 1; i = i + step) {\n        pArr.push(i);\n    }\n    return pArr;\n});\n\n\n/***/ }),\n\n/***/ \"./src/util/partition.ts\":\n/*!*******************************!*\\\n  !*** ./src/util/partition.ts ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar simple_sort_by_1 = tslib_1.__importDefault(__webpack_require__(/*! ./simple-sort-by */ \"./src/util/simple-sort-by.ts\"));\nexports.default = (function (rows, group_by, order_by) {\n    if (order_by === void 0) { order_by = []; }\n    var newRows = rows;\n    if (order_by && order_by.length) {\n        newRows = simple_sort_by_1.default(rows, order_by);\n    }\n    var groupingFn;\n    if (util_1.isFunction(group_by)) {\n        groupingFn = group_by;\n    }\n    else if (util_1.isArray(group_by)) {\n        groupingFn = function (row) { return \"_\" + group_by.map(function (col) { return row[col]; }).join('-'); };\n        // NOTE: Object.keys({'b': 'b', '2': '2', '1': '1', 'a': 'a'}) => [ '1', '2', 'b', 'a' ]\n        // that is why we have to add a prefix\n    }\n    else if (util_1.isString(group_by)) {\n        groupingFn = function (row) { return \"_\" + row[group_by]; };\n    }\n    var groups = util_1.groupBy(newRows, groupingFn);\n    return groups;\n});\n\n\n/***/ }),\n\n/***/ \"./src/util/simple-sort-by.ts\":\n/*!************************************!*\\\n  !*** ./src/util/simple-sort-by.ts ***!\n  \\************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nfunction sortBy(arr, keys) {\n    if (keys === void 0) { keys = []; }\n    var comparer = undefined;\n    if (util_1.isFunction(keys)) {\n        comparer = keys;\n    }\n    else if (util_1.isArray(keys)) {\n        comparer = function (a, b) {\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                if (a[key] < b[key]) {\n                    return -1;\n                }\n                if (a[key] > b[key]) {\n                    return 1;\n                }\n            }\n            return 0;\n        };\n    }\n    else if (util_1.isString(keys)) {\n        comparer = function (a, b) {\n            if (a[keys] < b[keys]) {\n                return -1;\n            }\n            if (a[keys] > b[keys]) {\n                return 1;\n            }\n            return 0;\n        };\n    }\n    return arr.sort(comparer);\n}\nexports.default = sortBy;\n\n\n/***/ }),\n\n/***/ \"./src/util/tag-cloud.ts\":\n/*!*******************************!*\\\n  !*** ./src/util/tag-cloud.ts ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/*\n * Synchronous version of d3-cloud\n */\n// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/\n// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf\n/* eslint-disable no-return-assign, no-cond-assign */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar cloudRadians = Math.PI / 180, cw = (1 << 11) >> 5, ch = 1 << 11;\nfunction cloudText(d) {\n    return d.text;\n}\nfunction cloudFont() {\n    return 'serif';\n}\nfunction cloudFontNormal() {\n    return 'normal';\n}\nfunction cloudFontSize(d) {\n    return d.value;\n}\nfunction cloudRotate() {\n    return ~~(Math.random() * 2) * 90;\n}\nfunction cloudPadding() {\n    return 1;\n}\n// Fetches a monochrome sprite bitmap for the specified text.\n// Load in batches for speed.\nfunction cloudSprite(contextAndRatio, d, data, di) {\n    if (d.sprite)\n        return;\n    var c = contextAndRatio.context, ratio = contextAndRatio.ratio;\n    c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\n    var x = 0, y = 0, maxh = 0;\n    var n = data.length;\n    --di;\n    while (++di < n) {\n        d = data[di];\n        c.save();\n        c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;\n        var w = c.measureText(d.text + 'm').width * ratio, h = d.size << 1;\n        if (d.rotate) {\n            var sr = Math.sin(d.rotate * cloudRadians), cr = Math.cos(d.rotate * cloudRadians), wcr = w * cr, wsr = w * sr, hcr = h * cr, hsr = h * sr;\n            w = ((Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5) << 5;\n            h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n        }\n        else {\n            w = ((w + 0x1f) >> 5) << 5;\n        }\n        if (h > maxh)\n            maxh = h;\n        if (x + w >= cw << 5) {\n            x = 0;\n            y += maxh;\n            maxh = 0;\n        }\n        if (y + h >= ch)\n            break;\n        c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\n        if (d.rotate)\n            c.rotate(d.rotate * cloudRadians);\n        c.fillText(d.text, 0, 0);\n        if (d.padding) {\n            c.lineWidth = 2 * d.padding;\n            c.strokeText(d.text, 0, 0);\n        }\n        c.restore();\n        d.width = w;\n        d.height = h;\n        d.xoff = x;\n        d.yoff = y;\n        d.x1 = w >> 1;\n        d.y1 = h >> 1;\n        d.x0 = -d.x1;\n        d.y0 = -d.y1;\n        d.hasText = true;\n        x += w;\n    }\n    var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];\n    while (--di >= 0) {\n        d = data[di];\n        if (!d.hasText)\n            continue;\n        var w = d.width, w32 = w >> 5;\n        var h = d.y1 - d.y0;\n        // Zero the buffer\n        for (var i = 0; i < h * w32; i++)\n            sprite[i] = 0;\n        x = d.xoff;\n        if (x == null)\n            return;\n        y = d.yoff;\n        var seen = 0, seenRow = -1;\n        for (var j = 0; j < h; j++) {\n            for (var i = 0; i < w; i++) {\n                var k = w32 * j + (i >> 5), m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;\n                sprite[k] |= m;\n                seen |= m;\n            }\n            if (seen)\n                seenRow = j;\n            else {\n                d.y0++;\n                h--;\n                j--;\n                y++;\n            }\n        }\n        d.y1 = d.y0 + seenRow;\n        d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\n    }\n}\n// Use mask-based collision detection.\nfunction cloudCollide(tag, board, sw) {\n    sw >>= 5;\n    var sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 0x7f, msx = 32 - sx, h = tag.y1 - tag.y0;\n    var x = (tag.y + tag.y0) * sw + (lx >> 5), last;\n    for (var j = 0; j < h; j++) {\n        last = 0;\n        for (var i = 0; i <= w; i++) {\n            if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i])\n                return true;\n        }\n        x += sw;\n    }\n    return false;\n}\nfunction cloudBounds(bounds, d) {\n    var b0 = bounds[0], b1 = bounds[1];\n    if (d.x + d.x0 < b0.x)\n        b0.x = d.x + d.x0;\n    if (d.y + d.y0 < b0.y)\n        b0.y = d.y + d.y0;\n    if (d.x + d.x1 > b1.x)\n        b1.x = d.x + d.x1;\n    if (d.y + d.y1 > b1.y)\n        b1.y = d.y + d.y1;\n}\nfunction collideRects(a, b) {\n    return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\n}\nfunction archimedeanSpiral(size) {\n    var e = size[0] / size[1];\n    return function (t) {\n        return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];\n    };\n}\nfunction rectangularSpiral(size) {\n    var dy = 4, dx = (dy * size[0]) / size[1];\n    var x = 0, y = 0;\n    return function (t) {\n        var sign = t < 0 ? -1 : 1;\n        // See triangular numbers: T_n = n * (n + 1) / 2.\n        switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {\n            case 0:\n                x += dx;\n                break;\n            case 1:\n                y += dy;\n                break;\n            case 2:\n                x -= dx;\n                break;\n            default:\n                y -= dy;\n                break;\n        }\n        return [x, y];\n    };\n}\n// TODO reuse arrays?\nfunction zeroArray(n) {\n    var a = [];\n    var i = -1;\n    while (++i < n)\n        a[i] = 0;\n    return a;\n}\nfunction cloudCanvas() {\n    return document.createElement('canvas');\n}\nfunction functor(d) {\n    return typeof d === 'function'\n        ? d\n        : function () {\n            return d;\n        };\n}\nvar spirals = {\n    archimedean: archimedeanSpiral,\n    rectangular: rectangularSpiral,\n};\nfunction default_1() {\n    var size = [256, 256], text = cloudText, font = cloudFont, fontSize = cloudFontSize, fontStyle = cloudFontNormal, fontWeight = cloudFontNormal, rotate = cloudRotate, padding = cloudPadding, spiral = archimedeanSpiral, words = [], timeInterval = Infinity, random = Math.random, canvas = cloudCanvas;\n    var cloud = {};\n    cloud.canvas = function (_) {\n        return arguments.length ? ((canvas = functor(_)), cloud) : canvas;\n    };\n    cloud.start = function () {\n        var _a = tslib_1.__read(size, 2), width = _a[0], height = _a[1];\n        var contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]), n = words.length, tags = [], data = words\n            .map(function (d, i) {\n            d.text = text.call(this, d, i);\n            d.font = font.call(this, d, i);\n            d.style = fontStyle.call(this, d, i);\n            d.weight = fontWeight.call(this, d, i);\n            d.rotate = rotate.call(this, d, i);\n            d.size = ~~fontSize.call(this, d, i);\n            d.padding = padding.call(this, d, i);\n            return d;\n        })\n            .sort(function (a, b) {\n            return b.size - a.size;\n        });\n        var i = -1, bounds = !cloud.board\n            ? null\n            : [\n                {\n                    x: 0,\n                    y: 0,\n                },\n                {\n                    x: width,\n                    y: height,\n                },\n            ];\n        step();\n        function step() {\n            var start = Date.now();\n            while (Date.now() - start < timeInterval && ++i < n) {\n                var d = data[i];\n                d.x = (width * (random() + 0.5)) >> 1;\n                d.y = (height * (random() + 0.5)) >> 1;\n                cloudSprite(contextAndRatio, d, data, i);\n                if (d.hasText && place(board, d, bounds)) {\n                    tags.push(d);\n                    if (bounds) {\n                        if (!cloud.hasImage) {\n                            // update bounds if image mask not set\n                            cloudBounds(bounds, d);\n                        }\n                    }\n                    else {\n                        bounds = [\n                            { x: d.x + d.x0, y: d.y + d.y0 },\n                            { x: d.x + d.x1, y: d.y + d.y1 },\n                        ];\n                    }\n                    // Temporary hack\n                    d.x -= size[0] >> 1;\n                    d.y -= size[1] >> 1;\n                }\n            }\n            cloud._tags = tags;\n            cloud._bounds = bounds;\n        }\n        return cloud;\n    };\n    function getContext(canvas) {\n        canvas.width = canvas.height = 1;\n        var ratio = Math.sqrt(canvas.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2);\n        canvas.width = (cw << 5) / ratio;\n        canvas.height = ch / ratio;\n        var context = canvas.getContext('2d');\n        context.fillStyle = context.strokeStyle = 'red';\n        context.textAlign = 'center';\n        return { context: context, ratio: ratio };\n    }\n    function place(board, tag, bounds) {\n        // const perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],\n        var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), s = spiral(size), dt = random() < 0.5 ? 1 : -1;\n        var dxdy, t = -dt, dx, dy;\n        while ((dxdy = s((t += dt)))) {\n            dx = ~~dxdy[0];\n            dy = ~~dxdy[1];\n            if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)\n                break;\n            tag.x = startX + dx;\n            tag.y = startY + dy;\n            if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1])\n                continue;\n            // TODO only check for collisions within current bounds.\n            if (!bounds || !cloudCollide(tag, board, size[0])) {\n                if (!bounds || collideRects(tag, bounds)) {\n                    var sprite = tag.sprite, w = tag.width >> 5, sw = size[0] >> 5, lx = tag.x - (w << 4), sx = lx & 0x7f, msx = 32 - sx, h = tag.y1 - tag.y0;\n                    var last = void 0, x = (tag.y + tag.y0) * sw + (lx >> 5);\n                    for (var j = 0; j < h; j++) {\n                        last = 0;\n                        for (var i = 0; i <= w; i++) {\n                            board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n                        }\n                        x += sw;\n                    }\n                    delete tag.sprite;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    cloud.createMask = function (img) {\n        var can = document.createElement('canvas');\n        var _a = tslib_1.__read(size, 2), width = _a[0], height = _a[1];\n        var w32 = width >> 5;\n        var board = zeroArray((width >> 5) * height);\n        can.width = width;\n        can.height = height;\n        var cxt = can.getContext('2d');\n        cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);\n        var imageData = cxt.getImageData(0, 0, width, height).data;\n        for (var j = 0; j < height; j++) {\n            for (var i = 0; i < width; i++) {\n                var k = w32 * j + (i >> 5);\n                var tmp = (j * width + i) << 2;\n                var flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;\n                var m = flag ? 1 << (31 - (i % 32)) : 0;\n                board[k] |= m;\n            }\n        }\n        cloud.board = board;\n        cloud.hasImage = true;\n    };\n    cloud.timeInterval = function (_) {\n        return arguments.length ? ((timeInterval = _ == null ? Infinity : _), cloud) : timeInterval;\n    };\n    cloud.words = function (_) {\n        return arguments.length ? ((words = _), cloud) : words;\n    };\n    cloud.size = function (_) {\n        return arguments.length ? ((size = [+_[0], +_[1]]), cloud) : size;\n    };\n    cloud.font = function (_) {\n        return arguments.length ? ((font = functor(_)), cloud) : font;\n    };\n    cloud.fontStyle = function (_) {\n        return arguments.length ? ((fontStyle = functor(_)), cloud) : fontStyle;\n    };\n    cloud.fontWeight = function (_) {\n        return arguments.length ? ((fontWeight = functor(_)), cloud) : fontWeight;\n    };\n    cloud.rotate = function (_) {\n        return arguments.length ? ((rotate = functor(_)), cloud) : rotate;\n    };\n    cloud.text = function (_) {\n        return arguments.length ? ((text = functor(_)), cloud) : text;\n    };\n    cloud.spiral = function (_) {\n        return arguments.length ? ((spiral = spirals[_] || _), cloud) : spiral;\n    };\n    cloud.fontSize = function (_) {\n        return arguments.length ? ((fontSize = functor(_)), cloud) : fontSize;\n    };\n    cloud.padding = function (_) {\n        return arguments.length ? ((padding = functor(_)), cloud) : padding;\n    };\n    cloud.random = function (_) {\n        return arguments.length ? ((random = _), cloud) : random;\n    };\n    return cloud;\n}\nexports.default = default_1;\n\n\n/***/ }),\n\n/***/ \"./src/view.ts\":\n/*!*********************!*\\\n  !*** ./src/view.ts ***!\n  \\*********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar wolfy87_eventemitter_1 = tslib_1.__importDefault(__webpack_require__(/*! wolfy87-eventemitter */ \"./node_modules/_wolfy87-eventemitter@5.2.9@wolfy87-eventemitter/EventEmitter.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nfunction cloneOptions(options) {\n    var result = {};\n    util_1.forIn(options, function (value, key) {\n        if (util_1.isObject(value) && value.isView) {\n            result[key] = value;\n        }\n        else if (util_1.isArray(value)) {\n            result[key] = value.concat([]);\n        }\n        else if (util_1.isPlainObject(value)) {\n            result[key] = util_1.clone(value);\n        }\n        else {\n            result[key] = value;\n        }\n    });\n    return result;\n}\n/**\n * 数据视图\n * @public\n */\nvar View = /** @class */ (function (_super) {\n    tslib_1.__extends(View, _super);\n    function View(dataSet, options) {\n        var _this = _super.call(this) || this;\n        /**\n         * 是否是View\n         */\n        _this.isView = true;\n        /**\n         * 是否是View\n         */\n        _this.isDataView = true; // alias\n        /**\n         *\n         */\n        _this.watchingStates = null;\n        /**\n         * 数据视图类型\n         */\n        _this.dataType = 'table';\n        /**\n         * 已应用的 transform\n         */\n        _this.transforms = [];\n        /**\n         * 原始数据\n         */\n        _this.origin = [];\n        /**\n         * 存储处理后的数据\n         */\n        _this.rows = [];\n        if (dataSet && dataSet.isDataSet) {\n            _this.dataSet = dataSet;\n        }\n        else {\n            _this.dataSet = null;\n            options = dataSet;\n        }\n        _this.loose = !_this.dataSet;\n        // TODO:\n        // assign(me, options);\n        if (options) {\n            _this.watchingStates = options.watchingStates;\n        }\n        if (!_this.loose) {\n            var watchingStates_1 = _this.watchingStates;\n            dataSet.on('statechange', function (name) {\n                if (util_1.isArray(watchingStates_1)) {\n                    if (watchingStates_1.indexOf(name) > -1) {\n                        _this._reExecute();\n                    }\n                }\n                else {\n                    _this._reExecute();\n                }\n            });\n        }\n        return _this;\n    }\n    View.prototype._parseStateExpression = function (expr) {\n        var dataSet = this.dataSet;\n        if (dataSet === null)\n            return undefined;\n        var matched = /^\\$state\\.(\\w+)/.exec(expr);\n        if (matched) {\n            return dataSet.state[matched[1]];\n        }\n        return expr;\n    };\n    View.prototype._preparseOptions = function (options) {\n        var _this = this;\n        var optionsCloned = cloneOptions(options);\n        if (this.loose) {\n            return optionsCloned;\n        }\n        util_1.forIn(optionsCloned, function (value, key) {\n            if (util_1.isString(value) && /^\\$state\\./.test(value)) {\n                optionsCloned[key] = _this._parseStateExpression(value);\n            }\n        });\n        return optionsCloned;\n    };\n    // connectors\n    View.prototype._prepareSource = function (source, options) {\n        // warning me.origin is protected\n        this._source = { source: source, options: options };\n        if (!options) {\n            if (source instanceof View || util_1.isString(source)) {\n                this.origin = View.DataSet.getConnector('default')(source, this.dataSet);\n            }\n            else if (util_1.isArray(source)) {\n                // TODO branch: if source is like ['dataview1', 'dataview2']\n                this.origin = source;\n            }\n            else if (util_1.isObject(source) && source.type) {\n                var opts = this._preparseOptions(source); // connector without source\n                this.origin = View.DataSet.getConnector(opts.type)(opts, this);\n            }\n            else {\n                throw new TypeError('Invalid source');\n            }\n        }\n        else {\n            var opts = this._preparseOptions(options);\n            this.origin = View.DataSet.getConnector(opts.type)(source, opts, this);\n        }\n        this.rows = util_1.deepMix([], this.origin);\n        return this;\n    };\n    View.prototype.source = function (source, options) {\n        this._prepareSource(source, options)._reExecuteTransforms();\n        this.trigger('change', []);\n        return this;\n    };\n    /**\n     *  执行数据处理数据。执行完这个函数后，transform 会被存储\n     * @param options - 某种类型的transform\n     */\n    View.prototype.transform = function (options) {\n        if (options && options.type) {\n            this.transforms.push(options);\n            this._executeTransform(options);\n        }\n        return this;\n    };\n    View.prototype._executeTransform = function (options) {\n        options = this._preparseOptions(options);\n        var transform = View.DataSet.getTransform(options.type);\n        transform(this, options);\n    };\n    View.prototype._reExecuteTransforms = function () {\n        var _this = this;\n        this.transforms.forEach(function (options) {\n            _this._executeTransform(options);\n        });\n    };\n    View.prototype.addRow = function (row) {\n        this.rows.push(row);\n    };\n    View.prototype.removeRow = function (index) {\n        this.rows.splice(index, 1);\n    };\n    View.prototype.updateRow = function (index, newRow) {\n        util_1.assign(this.rows[index], newRow);\n    };\n    View.prototype.findRows = function (query) {\n        return this.rows.filter(function (row) { return util_1.isMatch(row, query); });\n    };\n    View.prototype.findRow = function (query) {\n        return util_1.find(this.rows, query);\n    };\n    // columns\n    View.prototype.getColumnNames = function () {\n        var firstRow = this.rows[0];\n        if (firstRow) {\n            return util_1.keys(firstRow);\n        }\n        return [];\n    };\n    View.prototype.getColumnName = function (index) {\n        return this.getColumnNames()[index];\n    };\n    View.prototype.getColumnIndex = function (columnName) {\n        var columnNames = this.getColumnNames();\n        return columnNames.indexOf(columnName);\n    };\n    View.prototype.getColumn = function (columnName) {\n        return this.rows.map(function (row) { return row[columnName]; });\n    };\n    View.prototype.getColumnData = function (columnName) {\n        return this.getColumn(columnName);\n    };\n    // data process\n    View.prototype.getSubset = function (startRowIndex, endRowIndex, columnNames) {\n        var subset = [];\n        for (var i = startRowIndex; i <= endRowIndex; i++) {\n            subset.push(util_1.pick(this.rows[i], columnNames));\n        }\n        return subset;\n    };\n    View.prototype.toString = function (prettyPrint) {\n        if (prettyPrint === void 0) { prettyPrint = false; }\n        if (prettyPrint) {\n            return JSON.stringify(this.rows, null, 2);\n        }\n        return JSON.stringify(this.rows);\n    };\n    View.prototype._reExecute = function () {\n        var _a = this._source, source = _a.source, options = _a.options;\n        this._prepareSource(source, options);\n        this._reExecuteTransforms();\n        this.trigger('change', []);\n    };\n    return View;\n}(wolfy87_eventemitter_1.default));\nexports.View = View;\n\n\n/***/ })\n\n/******/ });\n});\n//# sourceMappingURL=data-set.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2RhdGEtc2V0L2J1aWxkL2RhdGEtc2V0LmpzPzcxMDQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiRGF0YVNldFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJEYXRhU2V0XCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXgudHNcIik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovICh7XG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X2hpZXJhcmNoeUAwLjYuMkBAYW50di9oaWVyYXJjaHkvYnVpbGQvaGllcmFyY2h5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfaGllcmFyY2h5QDAuNi4yQEBhbnR2L2hpZXJhcmNoeS9idWlsZC9oaWVyYXJjaHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHRydWUpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2Uge31cbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNSk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXNzaWduOiBhc3NpZ25cbn07XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaGllcmFyY2h5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIExheW91dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExheW91dChyb290LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgbWUub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgbWUucm9vdE5vZGUgPSBoaWVyYXJjaHkocm9vdCwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTGF5b3V0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uZXhlY3V0ZSA9IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwbGVhc2Ugb3ZlcnJpZGUgdGhpcyBtZXRob2QnKTtcbiAgfTtcblxuICByZXR1cm4gTGF5b3V0O1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExheW91dDtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBzZXBhcmF0ZVRyZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgVkFMSURfRElSRUNUSU9OUyA9IFsnTFInLCAvLyBsZWZ0IHRvIHJpZ2h0XG4nUkwnLCAvLyByaWdodCB0byBsZWZ0XG4nVEInLCAvLyB0b3AgdG8gYm90dG9tXG4nQlQnLCAvLyBib3R0b20gdG8gdG9wXG4nSCcsIC8vIGhvcml6b250YWxcbidWJyAvLyB2ZXJ0aWNhbFxuXTtcbnZhciBIT1JJWk9OVEFMX0RJUkVDVElPTlMgPSBbJ0xSJywgJ1JMJywgJ0gnXTtcblxudmFyIGlzSG9yaXpvbnRhbCA9IGZ1bmN0aW9uIGlzSG9yaXpvbnRhbChkaXJlY3Rpb24pIHtcbiAgcmV0dXJuIEhPUklaT05UQUxfRElSRUNUSU9OUy5pbmRleE9mKGRpcmVjdGlvbikgPiAtMTtcbn07XG5cbnZhciBERUZBVUxUX0RJUkVDVElPTiA9IFZBTElEX0RJUkVDVElPTlNbMF07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3QsIG9wdGlvbnMsIGxheW91dEFsZ3JpdGhtKSB7XG4gIHZhciBkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbiB8fCBERUZBVUxUX0RJUkVDVElPTjtcbiAgb3B0aW9ucy5pc0hvcml6b250YWwgPSBpc0hvcml6b250YWwoZGlyZWN0aW9uKTtcblxuICBpZiAoZGlyZWN0aW9uICYmIFZBTElEX0RJUkVDVElPTlMuaW5kZXhPZihkaXJlY3Rpb24pID09PSAtMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGRpcmVjdGlvbjogXCIgKyBkaXJlY3Rpb24pO1xuICB9XG5cbiAgaWYgKGRpcmVjdGlvbiA9PT0gVkFMSURfRElSRUNUSU9OU1swXSkge1xuICAgIC8vIExSXG4gICAgbGF5b3V0QWxncml0aG0ocm9vdCwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBWQUxJRF9ESVJFQ1RJT05TWzFdKSB7XG4gICAgLy8gUkxcbiAgICBsYXlvdXRBbGdyaXRobShyb290LCBvcHRpb25zKTtcbiAgICByb290LnJpZ2h0MmxlZnQoKTtcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFZBTElEX0RJUkVDVElPTlNbMl0pIHtcbiAgICAvLyBUQlxuICAgIGxheW91dEFsZ3JpdGhtKHJvb3QsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gVkFMSURfRElSRUNUSU9OU1szXSkge1xuICAgIC8vIEJUXG4gICAgbGF5b3V0QWxncml0aG0ocm9vdCwgb3B0aW9ucyk7XG4gICAgcm9vdC5ib3R0b20ydG9wKCk7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBWQUxJRF9ESVJFQ1RJT05TWzRdIHx8IGRpcmVjdGlvbiA9PT0gVkFMSURfRElSRUNUSU9OU1s1XSkge1xuICAgIC8vIEggb3IgVlxuICAgIC8vIHNlcGFyYXRlIGludG8gbGVmdCBhbmQgcmlnaHQgdHJlZXNcbiAgICB2YXIgX3NlcGFyYXRlVHJlZSA9IHNlcGFyYXRlVHJlZShyb290LCBvcHRpb25zKSxcbiAgICAgICAgbGVmdCA9IF9zZXBhcmF0ZVRyZWUubGVmdCxcbiAgICAgICAgcmlnaHQgPSBfc2VwYXJhdGVUcmVlLnJpZ2h0OyAvLyBkbyBsYXlvdXQgZm9yIGxlZnQgYW5kIHJpZ2h0IHRyZWVzXG5cblxuICAgIGxheW91dEFsZ3JpdGhtKGxlZnQsIG9wdGlvbnMpO1xuICAgIGxheW91dEFsZ3JpdGhtKHJpZ2h0LCBvcHRpb25zKTtcbiAgICBvcHRpb25zLmlzSG9yaXpvbnRhbCA/IGxlZnQucmlnaHQybGVmdCgpIDogbGVmdC5ib3R0b20ydG9wKCk7IC8vIGNvbWJpbmUgbGVmdCBhbmQgcmlnaHQgdHJlZXNcblxuICAgIHJpZ2h0LnRyYW5zbGF0ZShsZWZ0LnggLSByaWdodC54LCBsZWZ0LnkgLSByaWdodC55KTsgLy8gdHJhbnNsYXRlIHJvb3RcblxuICAgIHJvb3QueCA9IGxlZnQueDtcbiAgICByb290LnkgPSByaWdodC55O1xuICAgIHZhciBiYiA9IHJvb3QuZ2V0Qm91bmRpbmdCb3goKTtcblxuICAgIGlmIChvcHRpb25zLmlzSG9yaXpvbnRhbCkge1xuICAgICAgaWYgKGJiLnRvcCA8IDApIHtcbiAgICAgICAgcm9vdC50cmFuc2xhdGUoMCwgLWJiLnRvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChiYi5sZWZ0IDwgMCkge1xuICAgICAgICByb290LnRyYW5zbGF0ZSgtYmIubGVmdCwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIGZpeGVkIHJvb3QgcG9zaXRpb24sIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuXG5cbiAgdmFyIGZpeGVkUm9vdCA9IG9wdGlvbnMuZml4ZWRSb290O1xuICBpZiAoZml4ZWRSb290ID09PSB1bmRlZmluZWQpIGZpeGVkUm9vdCA9IHRydWU7XG5cbiAgaWYgKGZpeGVkUm9vdCkge1xuICAgIHJvb3QudHJhbnNsYXRlKC0ocm9vdC54ICsgcm9vdC53aWR0aCAvIDIgKyByb290LmhnYXApLCAtKHJvb3QueSArIHJvb3QuaGVpZ2h0IC8gMiArIHJvb3QudmdhcCkpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3Q7XG59O1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFBFTSA9IDE4O1xudmFyIERFRkFVTFRfSEVJR0hUID0gUEVNICogMjtcbnZhciBERUZBVUxUX0dBUCA9IFBFTTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIGdldElkOiBmdW5jdGlvbiBnZXRJZChkKSB7XG4gICAgcmV0dXJuIGQuaWQgfHwgZC5uYW1lO1xuICB9LFxuICBnZXRIR2FwOiBmdW5jdGlvbiBnZXRIR2FwKGQpIHtcbiAgICByZXR1cm4gZC5oZ2FwIHx8IERFRkFVTFRfR0FQO1xuICB9LFxuICBnZXRWR2FwOiBmdW5jdGlvbiBnZXRWR2FwKGQpIHtcbiAgICByZXR1cm4gZC52Z2FwIHx8IERFRkFVTFRfR0FQO1xuICB9LFxuICBnZXRDaGlsZHJlbjogZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oZCkge1xuICAgIHJldHVybiBkLmNoaWxkcmVuO1xuICB9LFxuICBnZXRIZWlnaHQ6IGZ1bmN0aW9uIGdldEhlaWdodChkKSB7XG4gICAgcmV0dXJuIGQuaGVpZ2h0IHx8IERFRkFVTFRfSEVJR0hUO1xuICB9LFxuICBnZXRXaWR0aDogZnVuY3Rpb24gZ2V0V2lkdGgoZCkge1xuICAgIHZhciBuYW1lID0gZC5uYW1lIHx8ICcgJztcbiAgICByZXR1cm4gZC53aWR0aCB8fCBuYW1lLnNwbGl0KCcnKS5sZW5ndGggKiBQRU07IC8vIEZJWE1FIERPIE5PVCBnZXQgd2lkdGggbGlrZSB0aGlzXG4gIH1cbn07XG5cbmZ1bmN0aW9uIE5vZGUoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgbWUgPSB0aGlzO1xuICBtZS52Z2FwID0gbWUuaGdhcCA9IDA7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTm9kZSkgcmV0dXJuIGRhdGE7XG4gIG1lLmRhdGEgPSBkYXRhO1xuICAvKlxuICAgKiBHYXBzOiBmaWxsaW5nIHNwYWNlIGJldHdlZW4gbm9kZXNcbiAgICogKHgsIHkpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogfCAgICAgICAgICAgIHZnYXAgICAgICAgICAgICB8XG4gICAqIHwgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0gICAgaFxuICAgKiB8IGggfCAgICAgICAgICAgICAgICAgICAgfCAgIGVcbiAgICogfCBnIHwgICAgICAgICAgICAgICAgICAgIHwgICBpXG4gICAqIHwgYSB8ICAgICAgICAgICAgICAgICAgICB8ICAgZ1xuICAgKiB8IHAgfCAgICAgICAgICAgICAgICAgICAgfCAgIGhcbiAgICogfCAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgICB0XG4gICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiAgLS0tLS0tLS0tLS13aWR0aC0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgaGdhcCA9IG9wdGlvbnMuZ2V0SEdhcChkYXRhKTtcbiAgdmFyIHZnYXAgPSBvcHRpb25zLmdldFZHYXAoZGF0YSk7XG4gIG1lLndpZHRoID0gb3B0aW9ucy5nZXRXaWR0aChkYXRhKTtcbiAgbWUuaGVpZ2h0ID0gb3B0aW9ucy5nZXRIZWlnaHQoZGF0YSk7XG4gIG1lLmlkID0gb3B0aW9ucy5nZXRJZChkYXRhKTtcbiAgbWUueCA9IG1lLnkgPSAwO1xuICBtZS5kZXB0aCA9IDA7XG5cbiAgaWYgKCFtZS5jaGlsZHJlbikge1xuICAgIG1lLmNoaWxkcmVuID0gW107XG4gIH1cblxuICBtZS5hZGRHYXAoaGdhcCwgdmdhcCk7XG4gIHJldHVybiBtZTtcbn1cblxudXRpbC5hc3NpZ24oTm9kZS5wcm90b3R5cGUsIHtcbiAgaXNSb290OiBmdW5jdGlvbiBpc1Jvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVwdGggPT09IDA7XG4gIH0sXG4gIGlzTGVhZjogZnVuY3Rpb24gaXNMZWFmKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMDtcbiAgfSxcbiAgYWRkR2FwOiBmdW5jdGlvbiBhZGRHYXAoaGdhcCwgdmdhcCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgbWUuaGdhcCArPSBoZ2FwO1xuICAgIG1lLnZnYXAgKz0gdmdhcDtcbiAgICBtZS53aWR0aCArPSAyICogaGdhcDtcbiAgICBtZS5oZWlnaHQgKz0gMiAqIHZnYXA7XG4gIH0sXG4gIGVhY2hOb2RlOiBmdW5jdGlvbiBlYWNoTm9kZShjYWxsYmFjaykge1xuICAgIC8vIERlcHRoIEZpcnN0IHRyYXZlcnNlXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgbm9kZXMgPSBbbWVdO1xuICAgIHZhciBjdXJyZW50O1xuXG4gICAgd2hpbGUgKGN1cnJlbnQgPSBub2Rlcy5wb3AoKSkge1xuICAgICAgY2FsbGJhY2soY3VycmVudCk7XG4gICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChjdXJyZW50LmNoaWxkcmVuKTtcbiAgICB9XG4gIH0sXG4gIERGVHJhdmVyc2U6IGZ1bmN0aW9uIERGVHJhdmVyc2UoY2FsbGJhY2spIHtcbiAgICAvLyBEZXB0aCBGaXJzdCB0cmF2ZXJzZVxuICAgIHRoaXMuZWFjaE5vZGUoY2FsbGJhY2spO1xuICB9LFxuICBCRlRyYXZlcnNlOiBmdW5jdGlvbiBCRlRyYXZlcnNlKGNhbGxiYWNrKSB7XG4gICAgLy8gQnJlYWR0aCBGaXJzdCB0cmF2ZXJzZVxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIG5vZGVzID0gW21lXTtcbiAgICB2YXIgY3VycmVudDtcblxuICAgIHdoaWxlIChjdXJyZW50ID0gbm9kZXMuc2hpZnQoKSkge1xuICAgICAgY2FsbGJhY2soY3VycmVudCk7XG4gICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChjdXJyZW50LmNoaWxkcmVuKTtcbiAgICB9XG4gIH0sXG4gIGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveCgpIHtcbiAgICAvLyBCQm94IGZvciBqdXN0IG9uZSB0cmVlIG5vZGVcbiAgICB2YXIgYmIgPSB7XG4gICAgICBsZWZ0OiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgdG9wOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIHRoaXMuZWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGJiLmxlZnQgPSBNYXRoLm1pbihiYi5sZWZ0LCBub2RlLngpO1xuICAgICAgYmIudG9wID0gTWF0aC5taW4oYmIudG9wLCBub2RlLnkpO1xuICAgICAgYmIud2lkdGggPSBNYXRoLm1heChiYi53aWR0aCwgbm9kZS54ICsgbm9kZS53aWR0aCk7XG4gICAgICBiYi5oZWlnaHQgPSBNYXRoLm1heChiYi5oZWlnaHQsIG5vZGUueSArIG5vZGUuaGVpZ2h0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYmI7XG4gIH0sXG4gIC8vIHRyYW5zbGF0ZVxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uIHRyYW5zbGF0ZSh0eCwgdHkpIHtcbiAgICBpZiAodHggPT09IHZvaWQgMCkge1xuICAgICAgdHggPSAwO1xuICAgIH1cblxuICAgIGlmICh0eSA9PT0gdm9pZCAwKSB7XG4gICAgICB0eSA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5lYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgbm9kZS54ICs9IHR4O1xuICAgICAgbm9kZS55ICs9IHR5O1xuICAgIH0pO1xuICB9LFxuICByaWdodDJsZWZ0OiBmdW5jdGlvbiByaWdodDJsZWZ0KCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGJiID0gbWUuZ2V0Qm91bmRpbmdCb3goKTtcbiAgICBtZS5lYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgbm9kZS54ID0gbm9kZS54IC0gKG5vZGUueCAtIGJiLmxlZnQpICogMiAtIG5vZGUud2lkdGg7IC8vIG5vZGUueCA9IC0gbm9kZS54O1xuICAgIH0pO1xuICAgIG1lLnRyYW5zbGF0ZShiYi53aWR0aCwgMCk7XG4gIH0sXG4gIGJvdHRvbTJ0b3A6IGZ1bmN0aW9uIGJvdHRvbTJ0b3AoKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgYmIgPSBtZS5nZXRCb3VuZGluZ0JveCgpO1xuICAgIG1lLmVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBub2RlLnkgPSBub2RlLnkgLSAobm9kZS55IC0gYmIudG9wKSAqIDIgLSBub2RlLmhlaWdodDsgLy8gbm9kZS55ID0gLSBub2RlLnk7XG4gICAgfSk7XG4gICAgbWUudHJhbnNsYXRlKDAsIGJiLmhlaWdodCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBoaWVyYXJjaHkoZGF0YSwgb3B0aW9ucywgaXNvbGF0ZWQpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIG9wdGlvbnMgPSB1dGlsLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgdmFyIHJvb3QgPSBuZXcgTm9kZShkYXRhLCBvcHRpb25zKTtcbiAgdmFyIG5vZGVzID0gW3Jvb3RdO1xuICB2YXIgbm9kZTtcblxuICBpZiAoIWlzb2xhdGVkICYmICFkYXRhLmNvbGxhcHNlZCkge1xuICAgIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICAgIGlmICghbm9kZS5kYXRhLmNvbGxhcHNlZCkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBvcHRpb25zLmdldENoaWxkcmVuKG5vZGUuZGF0YSk7XG4gICAgICAgIHZhciBsZW5ndGggPSBjaGlsZHJlbiA/IGNoaWxkcmVuLmxlbmd0aCA6IDA7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4gPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICBpZiAoY2hpbGRyZW4gJiYgbGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbmV3IE5vZGUoY2hpbGRyZW5baV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbltpXSA9IGNoaWxkO1xuICAgICAgICAgICAgbm9kZXMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgY2hpbGQuZGVwdGggPSBub2RlLmRlcHRoICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm9vdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoaWVyYXJjaHk7XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaGllcmFyY2h5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgb3B0aW9ucykge1xuICAvLyBzZXBhcmF0ZSBpbnRvIGxlZnQgYW5kIHJpZ2h0IHRyZWVzXG4gIHZhciBsZWZ0ID0gaGllcmFyY2h5KHJvb3QuZGF0YSwgb3B0aW9ucywgdHJ1ZSk7IC8vIHJvb3Qgb25seVxuXG4gIHZhciByaWdodCA9IGhpZXJhcmNoeShyb290LmRhdGEsIG9wdGlvbnMsIHRydWUpOyAvLyByb290IG9ubHlcbiAgLy8gYXV0b21hdGljYWxseVxuXG4gIHZhciB0cmVlU2l6ZSA9IHJvb3QuY2hpbGRyZW4ubGVuZ3RoO1xuICB2YXIgcmlnaHRUcmVlU2l6ZSA9IE1hdGgucm91bmQodHJlZVNpemUgLyAyKTsgLy8gc2VwYXJhdGUgbGVmdCBhbmQgcmlnaHQgdHJlZSBieSBtZXRhIGRhdGFcblxuICB2YXIgZ2V0U2lkZSA9IG9wdGlvbnMuZ2V0U2lkZSB8fCBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgcmlnaHRUcmVlU2l6ZSkge1xuICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdsZWZ0JztcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWVTaXplOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSByb290LmNoaWxkcmVuW2ldO1xuICAgIHZhciBzaWRlID0gZ2V0U2lkZShjaGlsZCwgaSk7XG5cbiAgICBpZiAoc2lkZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgcmlnaHQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgbGVmdC5lYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmICghbm9kZS5pc1Jvb3QoKSkge1xuICAgICAgbm9kZS5zaWRlID0gJ2xlZnQnO1xuICAgIH1cbiAgfSk7XG4gIHJpZ2h0LmVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKCFub2RlLmlzUm9vdCgpKSB7XG4gICAgICBub2RlLnNpZGUgPSAncmlnaHQnO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgbGVmdDogbGVmdCxcbiAgICByaWdodDogcmlnaHRcbiAgfTtcbn07XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaGllcmFyY2h5ID0ge1xuICBjb21wYWN0Qm94OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLFxuICBkZW5kcm9ncmFtOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLFxuICBpbmRlbnRlZDogX193ZWJwYWNrX3JlcXVpcmVfXygxMSksXG4gIG1pbmRtYXA6IF9fd2VicGFja19yZXF1aXJlX18oMTMpXG59O1xubW9kdWxlLmV4cG9ydHMgPSBoaWVyYXJjaHk7XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFRyZWVMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgbm9uTGF5ZXJlZFRpZHlUcmVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIGRvVHJlZUxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIENvbXBhY3RCb3hUcmVlTGF5b3V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVHJlZUxheW91dCkge1xuICBfaW5oZXJpdHNMb29zZShDb21wYWN0Qm94VHJlZUxheW91dCwgX1RyZWVMYXlvdXQpO1xuXG4gIGZ1bmN0aW9uIENvbXBhY3RCb3hUcmVlTGF5b3V0KCkge1xuICAgIHJldHVybiBfVHJlZUxheW91dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ29tcGFjdEJveFRyZWVMYXlvdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5leGVjdXRlID0gZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHJldHVybiBkb1RyZWVMYXlvdXQobWUucm9vdE5vZGUsIG1lLm9wdGlvbnMsIG5vbkxheWVyZWRUaWR5VHJlZSk7XG4gIH07XG5cbiAgcmV0dXJuIENvbXBhY3RCb3hUcmVlTGF5b3V0O1xufShUcmVlTGF5b3V0KTtcblxudmFyIERFRkFVTFRfT1BUSU9OUyA9IHt9O1xuXG5mdW5jdGlvbiBjb21wYWN0Qm94TGF5b3V0KHJvb3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IHV0aWwuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICByZXR1cm4gbmV3IENvbXBhY3RCb3hUcmVlTGF5b3V0KHJvb3QsIG9wdGlvbnMpLmV4ZWN1dGUoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYWN0Qm94TGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gX21peChkaXN0LCBvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkgIT09ICdjb25zdHJ1Y3RvcicgJiYgb2JqW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGlzdFtrZXldID0gb2JqW2tleV07XG4gICAgfVxuICB9XG59XG5cbnZhciBtaXggPSBmdW5jdGlvbiBtaXgoZGlzdCwgc3JjMSwgc3JjMiwgc3JjMykge1xuICBpZiAoc3JjMSkgX21peChkaXN0LCBzcmMxKTtcbiAgaWYgKHNyYzIpIF9taXgoZGlzdCwgc3JjMik7XG4gIGlmIChzcmMzKSBfbWl4KGRpc3QsIHNyYzMpO1xuICByZXR1cm4gZGlzdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWl4O1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gd3JhcCB0cmVlIG5vZGVcbmZ1bmN0aW9uIFdyYXBwZWRUcmVlKHcsIGgsIHksIGMpIHtcbiAgaWYgKGMgPT09IHZvaWQgMCkge1xuICAgIGMgPSBbXTtcbiAgfVxuXG4gIHZhciBtZSA9IHRoaXM7IC8vIHNpemVcblxuICBtZS53ID0gdyB8fCAwO1xuICBtZS5oID0gaCB8fCAwOyAvLyBwb3NpdGlvblxuXG4gIG1lLnkgPSB5IHx8IDA7XG4gIG1lLnggPSAwOyAvLyBjaGlsZHJlblxuXG4gIG1lLmMgPSBjIHx8IFtdO1xuICBtZS5jcyA9IGMubGVuZ3RoOyAvLyBtb2RpZmllZFxuXG4gIG1lLnByZWxpbSA9IDA7XG4gIG1lLm1vZCA9IDA7XG4gIG1lLnNoaWZ0ID0gMDtcbiAgbWUuY2hhbmdlID0gMDsgLy8gbGVmdC9yaWdodCB0cmVlXG5cbiAgbWUudGwgPSBudWxsO1xuICBtZS50ciA9IG51bGw7IC8vIGV4dHJlbWUgbGVmdC9yaWdodCB0cmVlXG5cbiAgbWUuZWwgPSBudWxsO1xuICBtZS5lciA9IG51bGw7IC8vIG1vZGlmaWVkIGxlZnQvcmlnaHQgdHJlZVxuXG4gIG1lLm1zZWwgPSAwO1xuICBtZS5tc2VyID0gMDtcbn1cblxuV3JhcHBlZFRyZWUuZnJvbU5vZGUgPSBmdW5jdGlvbiAocm9vdCwgaXNIb3Jpem9udGFsKSB7XG4gIGlmICghcm9vdCkgcmV0dXJuIG51bGw7XG4gIHZhciBjaGlsZHJlbiA9IFtdO1xuICByb290LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgY2hpbGRyZW4ucHVzaChXcmFwcGVkVHJlZS5mcm9tTm9kZShjaGlsZCwgaXNIb3Jpem9udGFsKSk7XG4gIH0pO1xuICBpZiAoaXNIb3Jpem9udGFsKSByZXR1cm4gbmV3IFdyYXBwZWRUcmVlKHJvb3QuaGVpZ2h0LCByb290LndpZHRoLCByb290LngsIGNoaWxkcmVuKTtcbiAgcmV0dXJuIG5ldyBXcmFwcGVkVHJlZShyb290LndpZHRoLCByb290LmhlaWdodCwgcm9vdC55LCBjaGlsZHJlbik7XG59OyAvLyBub2RlIHV0aWxzXG5cblxuZnVuY3Rpb24gbW92ZVJpZ2h0KG5vZGUsIG1vdmUsIGlzSG9yaXpvbnRhbCkge1xuICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgbm9kZS55ICs9IG1vdmU7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS54ICs9IG1vdmU7XG4gIH1cblxuICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgbW92ZVJpZ2h0KGNoaWxkLCBtb3ZlLCBpc0hvcml6b250YWwpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TWluKG5vZGUsIGlzSG9yaXpvbnRhbCkge1xuICB2YXIgcmVzID0gaXNIb3Jpem9udGFsID8gbm9kZS55IDogbm9kZS54O1xuICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmVzID0gTWF0aC5taW4oZ2V0TWluKGNoaWxkLCBpc0hvcml6b250YWwpLCByZXMpO1xuICB9KTtcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKG5vZGUsIGlzSG9yaXpvbnRhbCkge1xuICB2YXIgbWluID0gZ2V0TWluKG5vZGUsIGlzSG9yaXpvbnRhbCk7XG4gIG1vdmVSaWdodChub2RlLCAtbWluLCBpc0hvcml6b250YWwpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0QmFjayhjb252ZXJ0ZWRcbi8qIFdyYXBwZWRUcmVlICovXG4sIHJvb3Rcbi8qIFRyZWVOb2RlICovXG4sIGlzSG9yaXpvbnRhbCkge1xuICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgcm9vdC55ID0gY29udmVydGVkLng7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC54ID0gY29udmVydGVkLng7XG4gIH1cblxuICBjb252ZXJ0ZWQuYy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgIGNvbnZlcnRCYWNrKGNoaWxkLCByb290LmNoaWxkcmVuW2ldLCBpc0hvcml6b250YWwpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbGF5ZXIobm9kZSwgaXNIb3Jpem9udGFsLCBkKSB7XG4gIGlmIChkID09PSB2b2lkIDApIHtcbiAgICBkID0gMDtcbiAgfVxuXG4gIGlmIChpc0hvcml6b250YWwpIHtcbiAgICBub2RlLnggPSBkO1xuICAgIGQgKz0gbm9kZS53aWR0aDtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnkgPSBkO1xuICAgIGQgKz0gbm9kZS5oZWlnaHQ7XG4gIH1cblxuICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgbGF5ZXIoY2hpbGQsIGlzSG9yaXpvbnRhbCwgZCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgaXNIb3Jpem9udGFsID0gb3B0aW9ucy5pc0hvcml6b250YWw7XG5cbiAgZnVuY3Rpb24gZmlyc3RXYWxrKHQpIHtcbiAgICBpZiAodC5jcyA9PT0gMCkge1xuICAgICAgc2V0RXh0cmVtZXModCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmlyc3RXYWxrKHQuY1swXSk7XG4gICAgdmFyIGloID0gdXBkYXRlSVlMKGJvdHRvbSh0LmNbMF0uZWwpLCAwLCBudWxsKTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdC5jczsgKytpKSB7XG4gICAgICBmaXJzdFdhbGsodC5jW2ldKTtcbiAgICAgIHZhciBtaW4gPSBib3R0b20odC5jW2ldLmVyKTtcbiAgICAgIHNlcGFyYXRlKHQsIGksIGloKTtcbiAgICAgIGloID0gdXBkYXRlSVlMKG1pbiwgaSwgaWgpO1xuICAgIH1cblxuICAgIHBvc2l0aW9uUm9vdCh0KTtcbiAgICBzZXRFeHRyZW1lcyh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEV4dHJlbWVzKHQpIHtcbiAgICBpZiAodC5jcyA9PT0gMCkge1xuICAgICAgdC5lbCA9IHQ7XG4gICAgICB0LmVyID0gdDtcbiAgICAgIHQubXNlbCA9IHQubXNlciA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQuZWwgPSB0LmNbMF0uZWw7XG4gICAgICB0Lm1zZWwgPSB0LmNbMF0ubXNlbDtcbiAgICAgIHQuZXIgPSB0LmNbdC5jcyAtIDFdLmVyO1xuICAgICAgdC5tc2VyID0gdC5jW3QuY3MgLSAxXS5tc2VyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlcGFyYXRlKHQsIGksIGloKSB7XG4gICAgdmFyIHNyID0gdC5jW2kgLSAxXTtcbiAgICB2YXIgbXNzciA9IHNyLm1vZDtcbiAgICB2YXIgY2wgPSB0LmNbaV07XG4gICAgdmFyIG1zY2wgPSBjbC5tb2Q7XG5cbiAgICB3aGlsZSAoc3IgIT09IG51bGwgJiYgY2wgIT09IG51bGwpIHtcbiAgICAgIGlmIChib3R0b20oc3IpID4gaWgubG93KSBpaCA9IGloLm54dDtcbiAgICAgIHZhciBkaXN0ID0gbXNzciArIHNyLnByZWxpbSArIHNyLncgLSAobXNjbCArIGNsLnByZWxpbSk7XG5cbiAgICAgIGlmIChkaXN0ID4gMCkge1xuICAgICAgICBtc2NsICs9IGRpc3Q7XG4gICAgICAgIG1vdmVTdWJ0cmVlKHQsIGksIGloLmluZGV4LCBkaXN0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN5ID0gYm90dG9tKHNyKTtcbiAgICAgIHZhciBjeSA9IGJvdHRvbShjbCk7XG5cbiAgICAgIGlmIChzeSA8PSBjeSkge1xuICAgICAgICBzciA9IG5leHRSaWdodENvbnRvdXIoc3IpO1xuICAgICAgICBpZiAoc3IgIT09IG51bGwpIG1zc3IgKz0gc3IubW9kO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3kgPj0gY3kpIHtcbiAgICAgICAgY2wgPSBuZXh0TGVmdENvbnRvdXIoY2wpO1xuICAgICAgICBpZiAoY2wgIT09IG51bGwpIG1zY2wgKz0gY2wubW9kO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc3IgJiYgISFjbCkge1xuICAgICAgc2V0TGVmdFRocmVhZCh0LCBpLCBjbCwgbXNjbCk7XG4gICAgfSBlbHNlIGlmICghIXNyICYmICFjbCkge1xuICAgICAgc2V0UmlnaHRUaHJlYWQodCwgaSwgc3IsIG1zc3IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVTdWJ0cmVlKHQsIGksIHNpLCBkaXN0KSB7XG4gICAgdC5jW2ldLm1vZCArPSBkaXN0O1xuICAgIHQuY1tpXS5tc2VsICs9IGRpc3Q7XG4gICAgdC5jW2ldLm1zZXIgKz0gZGlzdDtcbiAgICBkaXN0cmlidXRlRXh0cmEodCwgaSwgc2ksIGRpc3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dExlZnRDb250b3VyKHQpIHtcbiAgICByZXR1cm4gdC5jcyA9PT0gMCA/IHQudGwgOiB0LmNbMF07XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0UmlnaHRDb250b3VyKHQpIHtcbiAgICByZXR1cm4gdC5jcyA9PT0gMCA/IHQudHIgOiB0LmNbdC5jcyAtIDFdO1xuICB9XG5cbiAgZnVuY3Rpb24gYm90dG9tKHQpIHtcbiAgICByZXR1cm4gdC55ICsgdC5oO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGVmdFRocmVhZCh0LCBpLCBjbCwgbW9kc3VtY2wpIHtcbiAgICB2YXIgbGkgPSB0LmNbMF0uZWw7XG4gICAgbGkudGwgPSBjbDtcbiAgICB2YXIgZGlmZiA9IG1vZHN1bWNsIC0gY2wubW9kIC0gdC5jWzBdLm1zZWw7XG4gICAgbGkubW9kICs9IGRpZmY7XG4gICAgbGkucHJlbGltIC09IGRpZmY7XG4gICAgdC5jWzBdLmVsID0gdC5jW2ldLmVsO1xuICAgIHQuY1swXS5tc2VsID0gdC5jW2ldLm1zZWw7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRSaWdodFRocmVhZCh0LCBpLCBzciwgbW9kc3Vtc3IpIHtcbiAgICB2YXIgcmkgPSB0LmNbaV0uZXI7XG4gICAgcmkudHIgPSBzcjtcbiAgICB2YXIgZGlmZiA9IG1vZHN1bXNyIC0gc3IubW9kIC0gdC5jW2ldLm1zZXI7XG4gICAgcmkubW9kICs9IGRpZmY7XG4gICAgcmkucHJlbGltIC09IGRpZmY7XG4gICAgdC5jW2ldLmVyID0gdC5jW2kgLSAxXS5lcjtcbiAgICB0LmNbaV0ubXNlciA9IHQuY1tpIC0gMV0ubXNlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uUm9vdCh0KSB7XG4gICAgdC5wcmVsaW0gPSAodC5jWzBdLnByZWxpbSArIHQuY1swXS5tb2QgKyB0LmNbdC5jcyAtIDFdLm1vZCArIHQuY1t0LmNzIC0gMV0ucHJlbGltICsgdC5jW3QuY3MgLSAxXS53KSAvIDIgLSB0LncgLyAyO1xuICB9XG5cbiAgZnVuY3Rpb24gc2Vjb25kV2Fsayh0LCBtb2RzdW0pIHtcbiAgICBtb2RzdW0gKz0gdC5tb2Q7XG4gICAgdC54ID0gdC5wcmVsaW0gKyBtb2RzdW07XG4gICAgYWRkQ2hpbGRTcGFjaW5nKHQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0LmNzOyBpKyspIHtcbiAgICAgIHNlY29uZFdhbGsodC5jW2ldLCBtb2RzdW0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3RyaWJ1dGVFeHRyYSh0LCBpLCBzaSwgZGlzdCkge1xuICAgIGlmIChzaSAhPT0gaSAtIDEpIHtcbiAgICAgIHZhciBuciA9IGkgLSBzaTtcbiAgICAgIHQuY1tzaSArIDFdLnNoaWZ0ICs9IGRpc3QgLyBucjtcbiAgICAgIHQuY1tpXS5zaGlmdCAtPSBkaXN0IC8gbnI7XG4gICAgICB0LmNbaV0uY2hhbmdlIC09IGRpc3QgLSBkaXN0IC8gbnI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkQ2hpbGRTcGFjaW5nKHQpIHtcbiAgICB2YXIgZCA9IDA7XG4gICAgdmFyIG1vZHN1bWRlbHRhID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdC5jczsgaSsrKSB7XG4gICAgICBkICs9IHQuY1tpXS5zaGlmdDtcbiAgICAgIG1vZHN1bWRlbHRhICs9IGQgKyB0LmNbaV0uY2hhbmdlO1xuICAgICAgdC5jW2ldLm1vZCArPSBtb2RzdW1kZWx0YTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVJWUwobG93LCBpbmRleCwgaWgpIHtcbiAgICB3aGlsZSAoaWggIT09IG51bGwgJiYgbG93ID49IGloLmxvdykge1xuICAgICAgaWggPSBpaC5ueHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxvdzogbG93LFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgbnh0OiBpaFxuICAgIH07XG4gIH0gLy8gZG8gbGF5b3V0XG5cblxuICBsYXllcihyb290LCBpc0hvcml6b250YWwpO1xuICB2YXIgd3QgPSBXcmFwcGVkVHJlZS5mcm9tTm9kZShyb290LCBpc0hvcml6b250YWwpO1xuICBmaXJzdFdhbGsod3QpO1xuICBzZWNvbmRXYWxrKHd0LCAwKTtcbiAgY29udmVydEJhY2sod3QsIHJvb3QsIGlzSG9yaXpvbnRhbCk7XG4gIG5vcm1hbGl6ZShyb290LCBpc0hvcml6b250YWwpO1xuICByZXR1cm4gcm9vdDtcbn07XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFRyZWVMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgZGVuZHJvZ3JhbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgZG9UcmVlTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgRGVuZHJvZ3JhbUxheW91dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RyZWVMYXlvdXQpIHtcbiAgX2luaGVyaXRzTG9vc2UoRGVuZHJvZ3JhbUxheW91dCwgX1RyZWVMYXlvdXQpO1xuXG4gIGZ1bmN0aW9uIERlbmRyb2dyYW1MYXlvdXQoKSB7XG4gICAgcmV0dXJuIF9UcmVlTGF5b3V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBEZW5kcm9ncmFtTGF5b3V0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uZXhlY3V0ZSA9IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICBtZS5yb290Tm9kZS53aWR0aCA9IDA7XG4gICAgcmV0dXJuIGRvVHJlZUxheW91dChtZS5yb290Tm9kZSwgbWUub3B0aW9ucywgZGVuZHJvZ3JhbSk7XG4gIH07XG5cbiAgcmV0dXJuIERlbmRyb2dyYW1MYXlvdXQ7XG59KFRyZWVMYXlvdXQpO1xuXG52YXIgREVGQVVMVF9PUFRJT05TID0ge307XG5cbmZ1bmN0aW9uIGRlbmRyb2dyYW1MYXlvdXQocm9vdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gdXRpbC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gIHJldHVybiBuZXcgRGVuZHJvZ3JhbUxheW91dChyb290LCBvcHRpb25zKS5leGVjdXRlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVuZHJvZ3JhbUxheW91dDtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyB3cmFwIHRyZWUgbm9kZVxuLy8gVE9ETyBjb25zaWRlcmluZyBzaXplXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbmZ1bmN0aW9uIFdyYXBwZWRUcmVlKGhlaWdodCwgY2hpbGRyZW4pIHtcbiAgaWYgKGhlaWdodCA9PT0gdm9pZCAwKSB7XG4gICAgaGVpZ2h0ID0gMDtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgY2hpbGRyZW4gPSBbXTtcbiAgfVxuXG4gIHZhciBtZSA9IHRoaXM7XG4gIG1lLnggPSBtZS55ID0gMDtcbiAgbWUubGVmdENoaWxkID0gbWUucmlnaHRDaGlsZCA9IG51bGw7XG4gIG1lLmhlaWdodCA9IDA7XG4gIG1lLmNoaWxkcmVuID0gY2hpbGRyZW47XG59XG5cbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIGlzSG9yaXpvbnRhbDogdHJ1ZSxcbiAgbm9kZVNlcDogMjAsXG4gIG5vZGVTaXplOiAyMCxcbiAgcmFua1NlcDogMjAwLFxuICBzdWJUcmVlU2VwOiAxMFxufTtcblxuZnVuY3Rpb24gY29udmVydEJhY2soY29udmVydGVkXG4vKiBXcmFwcGVkVHJlZSAqL1xuLCByb290XG4vKiBUcmVlTm9kZSAqL1xuLCBpc0hvcml6b250YWwpIHtcbiAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgIHJvb3QueCA9IGNvbnZlcnRlZC54O1xuICAgIHJvb3QueSA9IGNvbnZlcnRlZC55O1xuICB9IGVsc2Uge1xuICAgIHJvb3QueCA9IGNvbnZlcnRlZC55O1xuICAgIHJvb3QueSA9IGNvbnZlcnRlZC54O1xuICB9XG5cbiAgY29udmVydGVkLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgY29udmVydEJhY2soY2hpbGQsIHJvb3QuY2hpbGRyZW5baV0sIGlzSG9yaXpvbnRhbCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBvcHRpb25zID0gdXRpbC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gIHZhciBtYXhEZXB0aCA9IDA7XG5cbiAgZnVuY3Rpb24gd3JhcHBlZFRyZWVGcm9tTm9kZShuKSB7XG4gICAgaWYgKCFuKSByZXR1cm4gbnVsbDtcbiAgICBuLndpZHRoID0gMDtcblxuICAgIGlmIChuLmRlcHRoICYmIG4uZGVwdGggPiBtYXhEZXB0aCkge1xuICAgICAgbWF4RGVwdGggPSBuLmRlcHRoOyAvLyBnZXQgdGhlIG1heCBkZXB0aFxuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbiA9IG4uY2hpbGRyZW47XG4gICAgdmFyIGNoaWxkcmVuQ291bnQgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgdmFyIHQgPSBuZXcgV3JhcHBlZFRyZWUobi5oZWlnaHQsIFtdKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgICAgdmFyIGNoaWxkV1QgPSB3cmFwcGVkVHJlZUZyb21Ob2RlKGNoaWxkKTtcbiAgICAgIHQuY2hpbGRyZW4ucHVzaChjaGlsZFdUKTtcblxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgLy8gdC5sZWZ0Q2hpbGQgPSBjaGlsZFdULmxlZnRDaGlsZCA/IGNoaWxkV1QubGVmdENoaWxkIDogY2hpbGRXVFxuICAgICAgICB0LmxlZnRDaGlsZCA9IGNoaWxkV1Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID09PSBjaGlsZHJlbkNvdW50IC0gMSkge1xuICAgICAgICAvLyB0LnJpZ2h0Q2hpbGQgPSBjaGlsZFdULnJpZ2h0Q2hpbGQgPyBjaGlsZFdULnJpZ2h0Q2hpbGQgOiBjaGlsZFdUXG4gICAgICAgIHQucmlnaHRDaGlsZCA9IGNoaWxkV1Q7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdC5vcmlnaW5Ob2RlID0gbjtcbiAgICB0LmlzTGVhZiA9IG4uaXNMZWFmKCk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREcmF3aW5nRGVwdGgodCkge1xuICAgIGlmICh0LmlzTGVhZiB8fCB0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdC5kcmF3aW5nRGVwdGggPSBtYXhEZXB0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRlcHRocyA9IHQuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZ2V0RHJhd2luZ0RlcHRoKGNoaWxkKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG1pbkNoaWxkRGVwdGggPSBNYXRoLm1pbi5hcHBseShudWxsLCBkZXB0aHMpO1xuICAgICAgdC5kcmF3aW5nRGVwdGggPSBtaW5DaGlsZERlcHRoIC0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdC5kcmF3aW5nRGVwdGg7XG4gIH1cblxuICB2YXIgcHJldkxlYWY7XG5cbiAgZnVuY3Rpb24gcG9zaXRpb24odCkge1xuICAgIHQueCA9IHQuZHJhd2luZ0RlcHRoICogb3B0aW9ucy5yYW5rU2VwO1xuXG4gICAgaWYgKHQuaXNMZWFmKSB7XG4gICAgICB0LnkgPSAwO1xuXG4gICAgICBpZiAocHJldkxlYWYpIHtcbiAgICAgICAgdC55ID0gcHJldkxlYWYueSArIHByZXZMZWFmLmhlaWdodCArIG9wdGlvbnMubm9kZVNlcDtcblxuICAgICAgICBpZiAodC5vcmlnaW5Ob2RlLnBhcmVudCAhPT0gcHJldkxlYWYub3JpZ2luTm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICB0LnkgKz0gb3B0aW9ucy5zdWJUcmVlU2VwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByZXZMZWFmID0gdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBwb3NpdGlvbihjaGlsZCk7XG4gICAgICB9KTtcbiAgICAgIHQueSA9ICh0LmxlZnRDaGlsZC55ICsgdC5yaWdodENoaWxkLnkpIC8gMjtcbiAgICB9XG4gIH0gLy8gd3JhcCBub2RlXG5cblxuICB2YXIgd3QgPSB3cmFwcGVkVHJlZUZyb21Ob2RlKHJvb3QpOyAvLyBnZXQgZGVwdGggZm9yIGRyYXdpbmdcblxuICBnZXREcmF3aW5nRGVwdGgod3QpOyAvLyBnZXQgcG9zaXRpb25cblxuICBwb3NpdGlvbih3dCk7IC8vIGdldCB4LCB5XG5cbiAgY29udmVydEJhY2sod3QsIHJvb3QsIG9wdGlvbnMuaXNIb3Jpem9udGFsKTtcbiAgcmV0dXJuIHJvb3Q7XG59O1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVHJlZUxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBpbmRlbnRlZFRyZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxudmFyIHNlcGFyYXRlVHJlZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFZBTElEX0RJUkVDVElPTlMgPSBbJ0xSJywgLy8gbGVmdCB0byByaWdodFxuJ1JMJywgLy8gcmlnaHQgdG8gbGVmdFxuJ0gnIC8vIGhvcml6b250YWxcbl07XG52YXIgREVGQVVMVF9ESVJFQ1RJT04gPSBWQUxJRF9ESVJFQ1RJT05TWzBdO1xuXG52YXIgSW5kZW50ZWRMYXlvdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UcmVlTGF5b3V0KSB7XG4gIF9pbmhlcml0c0xvb3NlKEluZGVudGVkTGF5b3V0LCBfVHJlZUxheW91dCk7XG5cbiAgZnVuY3Rpb24gSW5kZW50ZWRMYXlvdXQoKSB7XG4gICAgcmV0dXJuIF9UcmVlTGF5b3V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBJbmRlbnRlZExheW91dC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmV4ZWN1dGUgPSBmdW5jdGlvbiBleGVjdXRlKCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuICAgIHZhciByb290ID0gbWUucm9vdE5vZGU7XG4gICAgb3B0aW9ucy5pc0hvcml6b250YWwgPSB0cnVlO1xuICAgIHZhciBpbmRlbnQgPSBvcHRpb25zLmluZGVudDtcbiAgICB2YXIgZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24gfHwgREVGQVVMVF9ESVJFQ1RJT047XG5cbiAgICBpZiAoZGlyZWN0aW9uICYmIFZBTElEX0RJUkVDVElPTlMuaW5kZXhPZihkaXJlY3Rpb24pID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgZGlyZWN0aW9uOiBcIiArIGRpcmVjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gVkFMSURfRElSRUNUSU9OU1swXSkge1xuICAgICAgLy8gTFJcbiAgICAgIGluZGVudGVkVHJlZShyb290LCBpbmRlbnQpO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBWQUxJRF9ESVJFQ1RJT05TWzFdKSB7XG4gICAgICAvLyBSTFxuICAgICAgaW5kZW50ZWRUcmVlKHJvb3QsIGluZGVudCk7XG4gICAgICByb290LnJpZ2h0MmxlZnQoKTtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gVkFMSURfRElSRUNUSU9OU1syXSkge1xuICAgICAgLy8gSFxuICAgICAgLy8gc2VwYXJhdGUgaW50byBsZWZ0IGFuZCByaWdodCB0cmVlc1xuICAgICAgdmFyIF9zZXBhcmF0ZVRyZWUgPSBzZXBhcmF0ZVRyZWUocm9vdCwgb3B0aW9ucyksXG4gICAgICAgICAgbGVmdCA9IF9zZXBhcmF0ZVRyZWUubGVmdCxcbiAgICAgICAgICByaWdodCA9IF9zZXBhcmF0ZVRyZWUucmlnaHQ7XG5cbiAgICAgIGluZGVudGVkVHJlZShsZWZ0LCBpbmRlbnQpO1xuICAgICAgbGVmdC5yaWdodDJsZWZ0KCk7XG4gICAgICBpbmRlbnRlZFRyZWUocmlnaHQsIGluZGVudCk7XG4gICAgICB2YXIgYmJveCA9IGxlZnQuZ2V0Qm91bmRpbmdCb3goKTtcbiAgICAgIHJpZ2h0LnRyYW5zbGF0ZShiYm94LndpZHRoLCAwKTtcbiAgICAgIHJvb3QueCA9IHJpZ2h0LnggLSByb290LndpZHRoIC8gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdDtcbiAgfTtcblxuICByZXR1cm4gSW5kZW50ZWRMYXlvdXQ7XG59KFRyZWVMYXlvdXQpO1xuXG52YXIgREVGQVVMVF9PUFRJT05TID0ge307XG5cbmZ1bmN0aW9uIGluZGVudGVkTGF5b3V0KHJvb3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IHV0aWwuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICByZXR1cm4gbmV3IEluZGVudGVkTGF5b3V0KHJvb3QsIG9wdGlvbnMpLmV4ZWN1dGUoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbmRlbnRlZExheW91dDtcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgREVGQVVMVF9JTkRFTlQgPSAyMDtcblxuZnVuY3Rpb24gcG9zaXRpb25Ob2RlKG5vZGUsIHByZXZpb3VzTm9kZSwgZHgpIHtcbiAgbm9kZS54ICs9IGR4ICogbm9kZS5kZXB0aDtcbiAgbm9kZS55ID0gcHJldmlvdXNOb2RlID8gcHJldmlvdXNOb2RlLnkgKyBwcmV2aW91c05vZGUuaGVpZ2h0IDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgaW5kZW50KSB7XG4gIGlmIChpbmRlbnQgPT09IHZvaWQgMCkge1xuICAgIGluZGVudCA9IERFRkFVTFRfSU5ERU5UO1xuICB9XG5cbiAgdmFyIHByZXZpb3VzTm9kZSA9IG51bGw7XG4gIHJvb3QuZWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBwb3NpdGlvbk5vZGUobm9kZSwgcHJldmlvdXNOb2RlLCBpbmRlbnQpO1xuICAgIHByZXZpb3VzTm9kZSA9IG5vZGU7XG4gIH0pO1xufTtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFRyZWVMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgbWluZG1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG52YXIgZG9UcmVlTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgTWluZG1hcExheW91dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RyZWVMYXlvdXQpIHtcbiAgX2luaGVyaXRzTG9vc2UoTWluZG1hcExheW91dCwgX1RyZWVMYXlvdXQpO1xuXG4gIGZ1bmN0aW9uIE1pbmRtYXBMYXlvdXQoKSB7XG4gICAgcmV0dXJuIF9UcmVlTGF5b3V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBNaW5kbWFwTGF5b3V0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uZXhlY3V0ZSA9IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICByZXR1cm4gZG9UcmVlTGF5b3V0KG1lLnJvb3ROb2RlLCBtZS5vcHRpb25zLCBtaW5kbWFwKTtcbiAgfTtcblxuICByZXR1cm4gTWluZG1hcExheW91dDtcbn0oVHJlZUxheW91dCk7XG5cbnZhciBERUZBVUxUX09QVElPTlMgPSB7fTtcblxuZnVuY3Rpb24gbWluZG1hcExheW91dChyb290LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSB1dGlsLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgcmV0dXJuIG5ldyBNaW5kbWFwTGF5b3V0KHJvb3QsIG9wdGlvbnMpLmV4ZWN1dGUoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtaW5kbWFwTGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuZnVuY3Rpb24gc2Vjb25kV2Fsayhub2RlLCBvcHRpb25zKSB7XG4gIHZhciB0b3RhbEhlaWdodCA9IDA7XG5cbiAgaWYgKCFub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHRvdGFsSGVpZ2h0ID0gbm9kZS5oZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICB0b3RhbEhlaWdodCArPSBzZWNvbmRXYWxrKGMsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG5cbiAgbm9kZS5fc3ViVHJlZVNlcCA9IG9wdGlvbnMuZ2V0U3ViVHJlZVNlcChub2RlLmRhdGEpO1xuICBub2RlLnRvdGFsSGVpZ2h0ID0gTWF0aC5tYXgobm9kZS5oZWlnaHQsIHRvdGFsSGVpZ2h0KSArIDIgKiBub2RlLl9zdWJUcmVlU2VwO1xuICByZXR1cm4gbm9kZS50b3RhbEhlaWdodDtcbn1cblxuZnVuY3Rpb24gdGhpcmRXYWxrKG5vZGUpIHtcbiAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgdmFyIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICBpZiAobGVuKSB7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgdGhpcmRXYWxrKGMpO1xuICAgIH0pO1xuICAgIHZhciBmaXJzdCA9IGNoaWxkcmVuWzBdO1xuICAgIHZhciBsYXN0ID0gY2hpbGRyZW5bbGVuIC0gMV07XG4gICAgdmFyIGNoaWxkcmVuSGVpZ2h0ID0gbGFzdC55IC0gZmlyc3QueSArIGxhc3QuaGVpZ2h0O1xuICAgIHZhciBjaGlsZHJlblRvdGFsSGVpZ2h0ID0gMDtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgY2hpbGRyZW5Ub3RhbEhlaWdodCArPSBjaGlsZC50b3RhbEhlaWdodDtcbiAgICB9KTtcblxuICAgIGlmIChjaGlsZHJlbkhlaWdodCA+IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAvLyDlvZPlrZDoioLngrnmgLvpq5jluqblpKfkuo7niLboioLngrnpq5jluqZcbiAgICAgIG5vZGUueSA9IGZpcnN0LnkgKyBjaGlsZHJlbkhlaWdodCAvIDIgLSBub2RlLmhlaWdodCAvIDI7XG4gICAgfSBlbHNlIGlmIChjaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgbm9kZS5oZWlnaHQgPiBjaGlsZHJlblRvdGFsSGVpZ2h0KSB7XG4gICAgICAvLyDlpJrkuo7kuIDkuKrlrZDoioLngrnmiJbogIXniLboioLngrnlpKfkuo7miYDmnInlrZDoioLngrnnmoTmgLvpq5jluqZcbiAgICAgIHZhciBvZmZzZXQgPSBub2RlLnkgKyAobm9kZS5oZWlnaHQgLSBjaGlsZHJlbkhlaWdodCkgLyAyIC0gZmlyc3QueTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgYy50cmFuc2xhdGUoMCwgb2Zmc2V0KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyDlj6rmnInkuIDkuKrlrZDoioLngrlcbiAgICAgIG5vZGUueSA9IChmaXJzdC55ICsgZmlyc3QuaGVpZ2h0IC8gMiArIGxhc3QueSArIGxhc3QuaGVpZ2h0IC8gMikgLyAyIC0gbm9kZS5oZWlnaHQgLyAyO1xuICAgIH1cbiAgfVxufVxuXG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBnZXRTdWJUcmVlU2VwOiBmdW5jdGlvbiBnZXRTdWJUcmVlU2VwKCkge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBvcHRpb25zID0gdXRpbC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gIHJvb3QucGFyZW50ID0ge1xuICAgIHg6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIHk6IDBcbiAgfTsgLy8gZmlyc3Qgd2Fsa1xuXG4gIHJvb3QuQkZUcmF2ZXJzZShmdW5jdGlvbiAobm9kZSkge1xuICAgIG5vZGUueCA9IG5vZGUucGFyZW50LnggKyBub2RlLnBhcmVudC53aWR0aDsgLy8gc2ltcGx5IGdldCB4XG4gIH0pO1xuICByb290LnBhcmVudCA9IG51bGw7IC8vIHNlY29uZCB3YWxrXG5cbiAgc2Vjb25kV2Fsayhyb290LCBvcHRpb25zKTsgLy8gYXNzaWduIHN1YiB0cmVlIHRvdGFsSGVpZ2h0XG4gIC8vIGFkanVzdGluZ1xuICAvLyBzZXBhcmF0aW5nIG5vZGVzXG5cbiAgcm9vdC5zdGFydFkgPSAwO1xuICByb290LnkgPSByb290LnRvdGFsSGVpZ2h0IC8gMiAtIHJvb3QuaGVpZ2h0IC8gMjtcbiAgcm9vdC5lYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICAgIGlmIChsZW4pIHtcbiAgICAgIHZhciBmaXJzdCA9IGNoaWxkcmVuWzBdO1xuICAgICAgZmlyc3Quc3RhcnRZID0gbm9kZS5zdGFydFkgKyBub2RlLl9zdWJUcmVlU2VwO1xuXG4gICAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICAgIGZpcnN0LnkgPSBub2RlLnkgKyBub2RlLmhlaWdodCAvIDIgLSBmaXJzdC5oZWlnaHQgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3QueSA9IGZpcnN0LnN0YXJ0WSArIGZpcnN0LnRvdGFsSGVpZ2h0IC8gMiAtIGZpcnN0LmhlaWdodCAvIDI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgYy5zdGFydFkgPSBjaGlsZHJlbltpIC0gMV0uc3RhcnRZICsgY2hpbGRyZW5baSAtIDFdLnRvdGFsSGVpZ2h0O1xuICAgICAgICAgIGMueSA9IGMuc3RhcnRZICsgYy50b3RhbEhlaWdodCAvIDIgLSBjLmhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyB0aGlyZCB3YWxrXG5cbiAgdGhpcmRXYWxrKHJvb3QpO1xufTtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oaWVyYXJjaHkuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2F1Z21lbnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9hdWdtZW50LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtaXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWl4ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbWl4LmpzXCIpO1xudmFyIGlzX2Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWZ1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZnVuY3Rpb24uanNcIik7XG52YXIgYXVnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGMgPSBhcmdzWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb2JqID0gYXJnc1tpXTtcbiAgICAgICAgaWYgKGlzX2Z1bmN0aW9uXzEuZGVmYXVsdChvYmopKSB7XG4gICAgICAgICAgICBvYmogPSBvYmoucHJvdG90eXBlO1xuICAgICAgICB9XG4gICAgICAgIG1peF8xLmRlZmF1bHQoYy5wcm90b3R5cGUsIG9iaik7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGF1Z21lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdWdtZW50LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9jYWNoZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9jYWNoZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBrLXYg5a2Y5YKoXG4gKi9cbnZhciBkZWZhdWx0XzEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZGVmYXVsdF8xKCkge1xuICAgICAgICB0aGlzLm1hcCA9IHt9O1xuICAgIH1cbiAgICBkZWZhdWx0XzEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIGRlZmF1bHRfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSwgZGVmKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5tYXBba2V5XTtcbiAgICAgICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCA/IGRlZiA6IHY7XG4gICAgfTtcbiAgICBkZWZhdWx0XzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWFwW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIGRlZmF1bHRfMS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWFwID0ge307XG4gICAgfTtcbiAgICBkZWZhdWx0XzEucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubWFwW2tleV07XG4gICAgfTtcbiAgICBkZWZhdWx0XzEucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm1hcCkubGVuZ3RoO1xuICAgIH07XG4gICAgcmV0dXJuIGRlZmF1bHRfMTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0XzE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvY2xhbXAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvY2xhbXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjbGFtcCA9IGZ1bmN0aW9uIChhLCBtaW4sIG1heCkge1xuICAgIGlmIChhIDwgbWluKSB7XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPiBtYXgpIHtcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gY2xhbXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGFtcC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvY2xlYXItYW5pbWF0aW9uLWZyYW1lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9jbGVhci1hbmltYXRpb24tZnJhbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGVyKSB7XG4gICAgdmFyIG1ldGhvZCA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICBjbGVhclRpbWVvdXQ7XG4gICAgbWV0aG9kKGhhbmRsZXIpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gY2FuY2VsQW5pbWF0aW9uRnJhbWU7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGVhci1hbmltYXRpb24tZnJhbWUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2Nsb25lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2Nsb25lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbnZhciBjbG9uZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciByc3Q7XG4gICAgaWYgKGlzX2FycmF5XzEuZGVmYXVsdChvYmopKSB7XG4gICAgICAgIHJzdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2ldID09PSAnb2JqZWN0JyAmJiBvYmpbaV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJzdFtpXSA9IGNsb25lKG9ialtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByc3RbaV0gPSBvYmpbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJzdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmpba10gPT09ICdvYmplY3QnICYmIG9ialtrXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcnN0W2tdID0gY2xvbmUob2JqW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJzdFtrXSA9IG9ialtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnN0O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNsb25lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvbmUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2NvbnRhaW5zLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2NvbnRhaW5zLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfYXJyYXlfbGlrZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheS1saWtlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXktbGlrZS5qc1wiKTtcbnZhciBjb250YWlucyA9IGZ1bmN0aW9uIChhcnIsIHZhbHVlKSB7XG4gICAgaWYgKCFpc19hcnJheV9saWtlXzEuZGVmYXVsdChhcnIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGFyci5pbmRleE9mKHZhbHVlKSA+IC0xO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNvbnRhaW5zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGFpbnMuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2RlYm91bmNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2RlYm91bmNlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlYm91bmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2UuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2RlZXAtbWl4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2RlZXAtbWl4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbnZhciBpc19wbGFpbl9vYmplY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtcGxhaW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtcGxhaW4tb2JqZWN0LmpzXCIpO1xudmFyIE1BWF9NSVhfTEVWRUwgPSA1O1xuZnVuY3Rpb24gX2RlZXBNaXgoZGlzdCwgc3JjLCBsZXZlbCwgbWF4TGV2ZWwpIHtcbiAgICBsZXZlbCA9IGxldmVsIHx8IDA7XG4gICAgbWF4TGV2ZWwgPSBtYXhMZXZlbCB8fCBNQVhfTUlYX0xFVkVMO1xuICAgIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzcmNba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiBpc19wbGFpbl9vYmplY3RfMS5kZWZhdWx0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNfcGxhaW5fb2JqZWN0XzEuZGVmYXVsdChkaXN0W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Rba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPCBtYXhMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBfZGVlcE1peChkaXN0W2tleV0sIHZhbHVlLCBsZXZlbCArIDEsIG1heExldmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Rba2V5XSA9IHNyY1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzX2FycmF5XzEuZGVmYXVsdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBkaXN0W2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICBkaXN0W2tleV0gPSBkaXN0W2tleV0uY29uY2F0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkaXN0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIHRvZG8g6YeN5YaZXG52YXIgZGVlcE1peCA9IGZ1bmN0aW9uIChyc3QpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBfZGVlcE1peChyc3QsIGFyZ3NbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcnN0O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZXBNaXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWVwLW1peC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZGlmZmVyZW5jZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2RpZmZlcmVuY2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGZpbHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9maWx0ZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9maWx0ZXIuanNcIik7XG52YXIgY29udGFpbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udGFpbnMgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9jb250YWlucy5qc1wiKTtcbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKiBkaWZmZXJlbmNlKFsyLCAxXSwgWzIsIDNdKTsgIC8vID0+IFsxXVxuICovXG52YXIgZGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChhcnIsIHZhbHVlcykge1xuICAgIGlmICh2YWx1ZXMgPT09IHZvaWQgMCkgeyB2YWx1ZXMgPSBbXTsgfVxuICAgIHJldHVybiBmaWx0ZXJfMS5kZWZhdWx0KGFyciwgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAhY29udGFpbnNfMS5kZWZhdWx0KHZhbHVlcywgdmFsdWUpOyB9KTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkaWZmZXJlbmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlmZmVyZW5jZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZWFjaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2VhY2guanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX2FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXkuanNcIik7XG52YXIgaXNfb2JqZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW9iamVjdC5qc1wiKTtcbmZ1bmN0aW9uIGVhY2goZWxlbWVudHMsIGZ1bmMpIHtcbiAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJzdDtcbiAgICBpZiAoaXNfYXJyYXlfMS5kZWZhdWx0KGVsZW1lbnRzKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHJzdCA9IGZ1bmMoZWxlbWVudHNbaV0sIGkpO1xuICAgICAgICAgICAgaWYgKHJzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc19vYmplY3RfMS5kZWZhdWx0KGVsZW1lbnRzKSkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICByc3QgPSBmdW5jKGVsZW1lbnRzW2tdLCBrKTtcbiAgICAgICAgICAgICAgICBpZiAocnN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBlYWNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWFjaC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZW5kcy13aXRoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9lbmRzLXdpdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbnZhciBpc19zdHJpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtc3RyaW5nLmpzXCIpO1xuZnVuY3Rpb24gZW5kc1dpdGgoYXJyLCBlKSB7XG4gICAgcmV0dXJuIChpc19hcnJheV8xLmRlZmF1bHQoYXJyKSB8fCBpc19zdHJpbmdfMS5kZWZhdWx0KGFycikpID8gYXJyW2Fyci5sZW5ndGggLSAxXSA9PT0gZSA6IGZhbHNlO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZW5kc1dpdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmRzLXdpdGguanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2V2ZXJ5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2V2ZXJ5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIOWPquimgeacieS4gOS4quS4jea7oei2s+adoeS7tuWwsei/lOWbniBmYWxzZVxuICogQHBhcmFtIGFyclxuICogQHBhcmFtIGZ1bmNcbiAqL1xudmFyIGV2ZXJ5ID0gZnVuY3Rpb24gKGFyciwgZnVuYykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghZnVuYyhhcnJbaV0sIGkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBldmVyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZXJ5LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9leHRlbmQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2V4dGVuZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtaXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWl4ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbWl4LmpzXCIpO1xudmFyIGlzX2Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWZ1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZnVuY3Rpb24uanNcIik7XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKHN1YmNsYXNzLCBzdXBlcmNsYXNzLCBvdmVycmlkZXMsIHN0YXRpY092ZXJyaWRlcykge1xuICAgIC8vIOWmguaenOWPquaPkOS+m+eItuexu+aehOmAoOWHveaVsO+8jOWImeiHquWKqOeUn+aIkOWtkOexu+aehOmAoOWHveaVsFxuICAgIGlmICghaXNfZnVuY3Rpb25fMS5kZWZhdWx0KHN1cGVyY2xhc3MpKSB7XG4gICAgICAgIG92ZXJyaWRlcyA9IHN1cGVyY2xhc3M7XG4gICAgICAgIHN1cGVyY2xhc3MgPSBzdWJjbGFzcztcbiAgICAgICAgc3ViY2xhc3MgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgfVxuICAgIHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlID9cbiAgICAgICAgZnVuY3Rpb24gKHByb3RvLCBjKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShwcm90bywge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gOlxuICAgICAgICBmdW5jdGlvbiAocHJvdG8sIGMpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRtcCgpIHsgfVxuICAgICAgICAgICAgVG1wLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICAgICAgdmFyIG8gPSBuZXcgVG1wKCk7XG4gICAgICAgICAgICBvLmNvbnN0cnVjdG9yID0gYztcbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9O1xuICAgIHZhciBzdXBlck9iaiA9IGNyZWF0ZShzdXBlcmNsYXNzLnByb3RvdHlwZSwgc3ViY2xhc3MpOyAvLyBuZXcgc3VwZXJjbGFzcygpLC8v5a6e5L6L5YyW54i257G75L2c5Li65a2Q57G755qEcHJvdG90eXBlXG4gICAgc3ViY2xhc3MucHJvdG90eXBlID0gbWl4XzEuZGVmYXVsdChzdXBlck9iaiwgc3ViY2xhc3MucHJvdG90eXBlKTsgLy8g5oyH5a6a5a2Q57G755qEcHJvdG90eXBlXG4gICAgc3ViY2xhc3Muc3VwZXJjbGFzcyA9IGNyZWF0ZShzdXBlcmNsYXNzLnByb3RvdHlwZSwgc3VwZXJjbGFzcyk7XG4gICAgbWl4XzEuZGVmYXVsdChzdXBlck9iaiwgb3ZlcnJpZGVzKTtcbiAgICBtaXhfMS5kZWZhdWx0KHN1YmNsYXNzLCBzdGF0aWNPdmVycmlkZXMpO1xuICAgIHJldHVybiBzdWJjbGFzcztcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBleHRlbmQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRlbmQuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2ZpbHRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZmlsdGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVhY2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2VhY2guanNcIik7XG52YXIgaXNfYXJyYXlfbGlrZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheS1saWtlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXktbGlrZS5qc1wiKTtcbnZhciBmaWx0ZXIgPSBmdW5jdGlvbiAoYXJyLCBmdW5jKSB7XG4gICAgaWYgKCFpc19hcnJheV9saWtlXzEuZGVmYXVsdChhcnIpKSB7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBlYWNoXzEuZGVmYXVsdChhcnIsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGZ1bmModmFsdWUsIGluZGV4KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBmaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXIuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2ZpbmQtaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9maW5kLWluZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgaWYgKGZyb21JbmRleCA9PT0gdm9pZCAwKSB7IGZyb21JbmRleCA9IDA7IH1cbiAgICBmb3IgKHZhciBpID0gZnJvbUluZGV4OyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyW2ldLCBpKSkge1xuICAgICAgICAgICAgLy8g5om+5Yiw57uI5q2i5b6q546vXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBmaW5kSW5kZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5kLWluZGV4LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9maW5kLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZmluZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfZnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtZnVuY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1mdW5jdGlvbi5qc1wiKTtcbnZhciBpc19tYXRjaF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1tYXRjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW1hdGNoLmpzXCIpO1xudmFyIGlzX2FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXkuanNcIik7XG52YXIgaXNfcGxhaW5fb2JqZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXBsYWluLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXBsYWluLW9iamVjdC5qc1wiKTtcbmZ1bmN0aW9uIGZpbmQoYXJyLCBwcmVkaWNhdGUpIHtcbiAgICBpZiAoIWlzX2FycmF5XzEuZGVmYXVsdChhcnIpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB2YXIgX3ByZWRpY2F0ZTtcbiAgICBpZiAoaXNfZnVuY3Rpb25fMS5kZWZhdWx0KHByZWRpY2F0ZSkpIHtcbiAgICAgICAgX3ByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICB9XG4gICAgaWYgKGlzX3BsYWluX29iamVjdF8xLmRlZmF1bHQocHJlZGljYXRlKSkge1xuICAgICAgICBfcHJlZGljYXRlID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGlzX21hdGNoXzEuZGVmYXVsdChhLCBwcmVkaWNhdGUpOyB9O1xuICAgIH1cbiAgICBpZiAoX3ByZWRpY2F0ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKF9wcmVkaWNhdGUoYXJyW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBmaW5kO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZmlyc3QtdmFsdWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZmlyc3QtdmFsdWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19uaWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtbmlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbmlsLmpzXCIpO1xudmFyIGlzX2FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXkuanNcIik7XG52YXIgZmlyc3RWYWx1ZSA9IGZ1bmN0aW9uIChkYXRhLCBuYW1lKSB7XG4gICAgdmFyIHJzdCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvYmogPSBkYXRhW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpbbmFtZV07XG4gICAgICAgIGlmICghaXNfbmlsXzEuZGVmYXVsdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChpc19hcnJheV8xLmRlZmF1bHQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcnN0ID0gdmFsdWVbMF07IC8vIHRvZG8g6L+Z6YeM5piv5ZCm5bqU6K+l5L2/55So6YCS5b2S77yM6LCD55SoIGZpcnN0VmFsdWUgQOe7neS6kVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcnN0ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnN0O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZpcnN0VmFsdWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXJzdC12YWx1ZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZml4ZWQtYmFzZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2ZpeGVkLWJhc2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGZpeGVkQmFzZSA9IGZ1bmN0aW9uICh2LCBiYXNlKSB7XG4gICAgdmFyIHN0ciA9IGJhc2UudG9TdHJpbmcoKTtcbiAgICB2YXIgaW5kZXggPSBzdHIuaW5kZXhPZignLicpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodik7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBzdHIuc3Vic3RyKGluZGV4ICsgMSkubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiAyMCkge1xuICAgICAgICBsZW5ndGggPSAyMDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodi50b0ZpeGVkKGxlbmd0aCkpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZpeGVkQmFzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkLWJhc2UuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2ZsYXR0ZW4tZGVlcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZmxhdHRlbi1kZWVwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX2FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXkuanNcIik7XG4vKipcbiAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge0FycmF5fSByZXN1bHQgVGhlIGFycmF5IHRvIHJldHVybi5cbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmbGF0dGVuRGVlcChbMSwgWzIsIFszLCBbNF1dLCA1XV0pOyAgLy8gPT4gWzEsIDIsIDMsIDQsIDVdXG4gKi9cbnZhciBmbGF0dGVuRGVlcCA9IGZ1bmN0aW9uIChhcnIsIHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgeyByZXN1bHQgPSBbXTsgfVxuICAgIGlmICghaXNfYXJyYXlfMS5kZWZhdWx0KGFycikpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYXJyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBmbGF0dGVuRGVlcChhcnJbaV0sIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBmbGF0dGVuRGVlcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZsYXR0ZW4tZGVlcC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZmxhdHRlbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2ZsYXR0ZW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX2FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXkuanNcIik7XG4vKipcbiAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pOyAgLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG52YXIgZmxhdHRlbiA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICBpZiAoIWlzX2FycmF5XzEuZGVmYXVsdChhcnIpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHJzdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJzdCA9IHJzdC5jb25jYXQoYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJzdDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBmbGF0dGVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmxhdHRlbi5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZm9yLWluLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9mb3ItaW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZWFjaF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lYWNoICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZWFjaC5qc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGVhY2hfMS5kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9yLWluLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9nZXQtcmFuZ2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2dldC1yYW5nZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19hcnJheV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LmpzXCIpO1xudmFyIGZpbHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9maWx0ZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9maWx0ZXIuanNcIik7XG52YXIgZ2V0UmFuZ2UgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgLy8g5a2Y5ZyoIE5hTiDml7bvvIxtaW4sbWF4IOWIpOWumuS8muWHuumXrumimFxuICAgIHZhbHVlcyA9IGZpbHRlcl8xLmRlZmF1bHQodmFsdWVzLCBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gIWlzTmFOKHYpO1xuICAgIH0pO1xuICAgIGlmICghdmFsdWVzLmxlbmd0aCkgeyAvLyDlpoLmnpzmsqHmnInmlbDlgLzliJnnm7TmjqXov5Tlm54wXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IDBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzX2FycmF5XzEuZGVmYXVsdCh2YWx1ZXNbMF0pKSB7XG4gICAgICAgIHZhciB0bXAgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRtcCA9IHRtcC5jb25jYXQodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMgPSB0bXA7XG4gICAgfVxuICAgIHZhciBtYXggPSBNYXRoLm1heC5hcHBseShudWxsLCB2YWx1ZXMpO1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbi5hcHBseShudWxsLCB2YWx1ZXMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogbWluLFxuICAgICAgICBtYXg6IG1heFxuICAgIH07XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0UmFuZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtcmFuZ2UuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2dldC10eXBlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2dldC10eXBlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcbnZhciBnZXRUeXBlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpLnJlcGxhY2UoL15cXFtvYmplY3QgLywgJycpLnJlcGxhY2UoL10kLywgJycpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdldFR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtdHlwZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ2V0LXdyYXAtYmVoYXZpb3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ2V0LXdyYXAtYmVoYXZpb3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICog6I635Y+W5bCB6KOF55qE5LqL5Lu2XG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iaiAgIOWvueixoVxuICogQHBhcmFtICB7U3RyaW5nfSBhY3Rpb24g5LqL5Lu25ZCN56ewXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gICAgICAgIOi/lOWbnuS6i+S7tuWkhOeQhuWHveaVsFxuICovXG5mdW5jdGlvbiBnZXRXcmFwQmVoYXZpb3Iob2JqLCBhY3Rpb24pIHtcbiAgICByZXR1cm4gb2JqWydfd3JhcF8nICsgYWN0aW9uXTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGdldFdyYXBCZWhhdmlvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC13cmFwLWJlaGF2aW9yLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9nZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2dldC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19zdHJpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtc3RyaW5nLmpzXCIpO1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L2Rsdi9ibG9iL21hc3Rlci9pbmRleC5qc1xuICogQHBhcmFtIG9ialxuICogQHBhcmFtIGtleVxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZVxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKG9iaiwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICB2YXIgcCA9IDA7XG4gICAgdmFyIGtleUFyciA9IGlzX3N0cmluZ18xLmRlZmF1bHQoa2V5KSA/IGtleS5zcGxpdCgnLicpIDoga2V5O1xuICAgIHdoaWxlIChvYmogJiYgcCA8IGtleUFyci5sZW5ndGgpIHtcbiAgICAgICAgb2JqID0gb2JqW2tleUFycltwKytdXTtcbiAgICB9XG4gICAgcmV0dXJuIChvYmogPT09IHVuZGVmaW5lZCB8fCBwIDwga2V5QXJyLmxlbmd0aCkgPyBkZWZhdWx0VmFsdWUgOiBvYmo7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ3JvdXAtYnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ3JvdXAtYnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlYWNoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9lYWNoLmpzXCIpO1xudmFyIGlzX2FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXkuanNcIik7XG52YXIgaXNfZnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtZnVuY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1mdW5jdGlvbi5qc1wiKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBncm91cEJ5KGRhdGEsIGNvbmRpdGlvbikge1xuICAgIGlmICghY29uZGl0aW9uIHx8ICFpc19hcnJheV8xLmRlZmF1bHQoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgLy8g5YW85a655pa55rOV5ZKMIOWtl+espuS4sueahOWGmeazlVxuICAgIHZhciBwcmVkaWNhdGUgPSBpc19mdW5jdGlvbl8xLmRlZmF1bHQoY29uZGl0aW9uKSA/IGNvbmRpdGlvbiA6IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtW2NvbmRpdGlvbl07IH07XG4gICAgdmFyIGtleTtcbiAgICBlYWNoXzEuZGVmYXVsdChkYXRhLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBrZXkgPSBwcmVkaWNhdGUoaXRlbSk7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0ucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gW2l0ZW1dO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGdyb3VwQnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncm91cC1ieS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ3JvdXAtdG8tbWFwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9ncm91cC10by1tYXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbnZhciBpc19mdW5jdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1mdW5jdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWZ1bmN0aW9uLmpzXCIpO1xudmFyIGdyb3VwX2J5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dyb3VwLWJ5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ3JvdXAtYnkuanNcIik7XG52YXIgZ3JvdXBUb01hcCA9IGZ1bmN0aW9uIChkYXRhLCBjb25kaXRpb24pIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgMDogZGF0YVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWlzX2Z1bmN0aW9uXzEuZGVmYXVsdChjb25kaXRpb24pKSB7XG4gICAgICAgIHZhciBwYXJhbXNDb25kaXRpb25fMSA9IGlzX2FycmF5XzEuZGVmYXVsdChjb25kaXRpb24pID8gY29uZGl0aW9uIDogY29uZGl0aW9uLnJlcGxhY2UoL1xccysvZywgJycpLnNwbGl0KCcqJyk7XG4gICAgICAgIGNvbmRpdGlvbiA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIHZhciB1bmlxdWUgPSAnXyc7IC8vIOmBv+WFjeWHuueOsOaVsOWtl+S9nOS4uktleeeahOaDheWGte+8jOS8mui/m+ihjOaMieeFp+aVsOWtl+eahOaOkuW6j1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJhbXNDb25kaXRpb25fMS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB1bmlxdWUgKz0gcm93W3BhcmFtc0NvbmRpdGlvbl8xW2ldXSAmJiByb3dbcGFyYW1zQ29uZGl0aW9uXzFbaV1dLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5pcXVlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgZ3JvdXBzID0gZ3JvdXBfYnlfMS5kZWZhdWx0KGRhdGEsIGNvbmRpdGlvbik7XG4gICAgcmV0dXJuIGdyb3Vwcztcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBncm91cFRvTWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JvdXAtdG8tbWFwLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9ncm91cC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9ncm91cC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyb3VwX3RvX21hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ncm91cC10by1tYXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9ncm91cC10by1tYXAuanNcIik7XG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGRhdGEsIGNvbmRpdGlvbikge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIC8vIOayoeacieadoeS7tu+8jOWImeiHqui6q+aUueaIkOaVsOe7hFxuICAgICAgICByZXR1cm4gW2RhdGFdO1xuICAgIH1cbiAgICB2YXIgZ3JvdXBzID0gZ3JvdXBfdG9fbWFwXzEuZGVmYXVsdChkYXRhLCBjb25kaXRpb24pO1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgaW4gZ3JvdXBzKSB7XG4gICAgICAgIGFycmF5LnB1c2goZ3JvdXBzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncm91cC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaGFzLWtleS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2hhcy1rZXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGhhc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9oYXMuanNcIik7XG5leHBvcnRzLmRlZmF1bHQgPSBoYXNfMS5kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLWtleS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaGFzLXZhbHVlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9oYXMtdmFsdWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGFpbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udGFpbnMgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9jb250YWlucy5qc1wiKTtcbnZhciB2YWx1ZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdmFsdWVzICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdmFsdWVzLmpzXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChvYmosIHZhbHVlKSB7IHJldHVybiBjb250YWluc18xLmRlZmF1bHQodmFsdWVzXzEuZGVmYXVsdChvYmopLCB2YWx1ZSk7IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLXZhbHVlLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9oYXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2hhcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAob2JqLCBrZXkpIHsgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpOyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaGVhZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2hlYWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX2FycmF5X2xpa2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXktbGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LWxpa2UuanNcIik7XG5mdW5jdGlvbiBoZWFkKG8pIHtcbiAgICBpZiAoaXNfYXJyYXlfbGlrZV8xLmRlZmF1bHQobykpIHtcbiAgICAgICAgcmV0dXJuIG9bMF07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBoZWFkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaWRlbnRpdHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaWRlbnRpdHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAodikgeyByZXR1cm4gdjsgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZGVudGl0eS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXgtb2YuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXgtb2YuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19hcnJheV9saWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5LWxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS1saWtlLmpzXCIpO1xudmFyIGluZGV4T2YgPSBmdW5jdGlvbiAoYXJyLCBvYmopIHtcbiAgICBpZiAoIWlzX2FycmF5X2xpa2VfMS5kZWZhdWx0KGFycikpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICB2YXIgbSA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIGlmIChtKSB7XG4gICAgICAgIHJldHVybiBtLmNhbGwoYXJyLCBvYmopO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJyW2ldID09PSBvYmopIHtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpbmRleE9mO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgtb2YuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBhcnJheVxudmFyIGNvbnRhaW5zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRhaW5zICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvY29udGFpbnMuanNcIik7XG5leHBvcnRzLmNvbnRhaW5zID0gY29udGFpbnNfMS5kZWZhdWx0O1xuZXhwb3J0cy5pbmNsdWRlcyA9IGNvbnRhaW5zXzEuZGVmYXVsdDtcbnZhciBkaWZmZXJlbmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RpZmZlcmVuY2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9kaWZmZXJlbmNlLmpzXCIpO1xuZXhwb3J0cy5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZV8xLmRlZmF1bHQ7XG52YXIgZmluZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9maW5kICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZmluZC5qc1wiKTtcbmV4cG9ydHMuZmluZCA9IGZpbmRfMS5kZWZhdWx0O1xudmFyIGZpbmRfaW5kZXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmluZC1pbmRleCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2ZpbmQtaW5kZXguanNcIik7XG5leHBvcnRzLmZpbmRJbmRleCA9IGZpbmRfaW5kZXhfMS5kZWZhdWx0O1xudmFyIGZpcnN0X3ZhbHVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZpcnN0LXZhbHVlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZmlyc3QtdmFsdWUuanNcIik7XG5leHBvcnRzLmZpcnN0VmFsdWUgPSBmaXJzdF92YWx1ZV8xLmRlZmF1bHQ7XG52YXIgZmxhdHRlbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mbGF0dGVuICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZmxhdHRlbi5qc1wiKTtcbmV4cG9ydHMuZmxhdHRlbiA9IGZsYXR0ZW5fMS5kZWZhdWx0O1xudmFyIGZsYXR0ZW5fZGVlcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mbGF0dGVuLWRlZXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9mbGF0dGVuLWRlZXAuanNcIik7XG5leHBvcnRzLmZsYXR0ZW5EZWVwID0gZmxhdHRlbl9kZWVwXzEuZGVmYXVsdDtcbnZhciBnZXRfcmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0LXJhbmdlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ2V0LXJhbmdlLmpzXCIpO1xuZXhwb3J0cy5nZXRSYW5nZSA9IGdldF9yYW5nZV8xLmRlZmF1bHQ7XG52YXIgcHVsbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wdWxsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcHVsbC5qc1wiKTtcbmV4cG9ydHMucHVsbCA9IHB1bGxfMS5kZWZhdWx0O1xudmFyIHB1bGxfYXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcHVsbC1hdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3B1bGwtYXQuanNcIik7XG5leHBvcnRzLnB1bGxBdCA9IHB1bGxfYXRfMS5kZWZhdWx0O1xudmFyIHJlZHVjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZWR1Y2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9yZWR1Y2UuanNcIik7XG5leHBvcnRzLnJlZHVjZSA9IHJlZHVjZV8xLmRlZmF1bHQ7XG52YXIgcmVtb3ZlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JlbW92ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3JlbW92ZS5qc1wiKTtcbmV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlXzEuZGVmYXVsdDtcbnZhciBzb3J0X2J5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NvcnQtYnkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9zb3J0LWJ5LmpzXCIpO1xuZXhwb3J0cy5zb3J0QnkgPSBzb3J0X2J5XzEuZGVmYXVsdDtcbnZhciB1bmlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91bmlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3VuaW9uLmpzXCIpO1xuZXhwb3J0cy51bmlvbiA9IHVuaW9uXzEuZGVmYXVsdDtcbnZhciB1bmlxXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3VuaXEgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi91bmlxLmpzXCIpO1xuZXhwb3J0cy51bmlxID0gdW5pcV8xLmRlZmF1bHQ7XG52YXIgdmFsdWVzX29mX2tleV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92YWx1ZXMtb2Yta2V5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdmFsdWVzLW9mLWtleS5qc1wiKTtcbmV4cG9ydHMudmFsdWVzT2ZLZXkgPSB2YWx1ZXNfb2Zfa2V5XzEuZGVmYXVsdDtcbnZhciBoZWFkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hlYWQgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9oZWFkLmpzXCIpO1xuZXhwb3J0cy5oZWFkID0gaGVhZF8xLmRlZmF1bHQ7XG52YXIgbGFzdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sYXN0ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbGFzdC5qc1wiKTtcbmV4cG9ydHMubGFzdCA9IGxhc3RfMS5kZWZhdWx0O1xudmFyIHN0YXJ0c193aXRoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0YXJ0cy13aXRoICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvc3RhcnRzLXdpdGguanNcIik7XG5leHBvcnRzLnN0YXJ0c1dpdGggPSBzdGFydHNfd2l0aF8xLmRlZmF1bHQ7XG52YXIgZW5kc193aXRoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VuZHMtd2l0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2VuZHMtd2l0aC5qc1wiKTtcbmV4cG9ydHMuZW5kc1dpdGggPSBlbmRzX3dpdGhfMS5kZWZhdWx0O1xudmFyIGZpbHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9maWx0ZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9maWx0ZXIuanNcIik7XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcl8xLmRlZmF1bHQ7XG52YXIgZXZlcnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXZlcnkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9ldmVyeS5qc1wiKTtcbmV4cG9ydHMuZXZlcnkgPSBldmVyeV8xLmRlZmF1bHQ7XG52YXIgc29tZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zb21lICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvc29tZS5qc1wiKTtcbmV4cG9ydHMuc29tZSA9IHNvbWVfMS5kZWZhdWx0O1xudmFyIGdyb3VwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dyb3VwICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ3JvdXAuanNcIik7XG5leHBvcnRzLmdyb3VwID0gZ3JvdXBfMS5kZWZhdWx0O1xudmFyIGdyb3VwX2J5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dyb3VwLWJ5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ3JvdXAtYnkuanNcIik7XG5leHBvcnRzLmdyb3VwQnkgPSBncm91cF9ieV8xLmRlZmF1bHQ7XG52YXIgZ3JvdXBfdG9fbWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dyb3VwLXRvLW1hcCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2dyb3VwLXRvLW1hcC5qc1wiKTtcbmV4cG9ydHMuZ3JvdXBUb01hcCA9IGdyb3VwX3RvX21hcF8xLmRlZmF1bHQ7XG4vLyBldmVudFxudmFyIGdldF93cmFwX2JlaGF2aW9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldC13cmFwLWJlaGF2aW9yICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ2V0LXdyYXAtYmVoYXZpb3IuanNcIik7XG5leHBvcnRzLmdldFdyYXBCZWhhdmlvciA9IGdldF93cmFwX2JlaGF2aW9yXzEuZGVmYXVsdDtcbnZhciB3cmFwX2JlaGF2aW9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3dyYXAtYmVoYXZpb3IgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi93cmFwLWJlaGF2aW9yLmpzXCIpO1xuZXhwb3J0cy53cmFwQmVoYXZpb3IgPSB3cmFwX2JlaGF2aW9yXzEuZGVmYXVsdDtcbi8vIGZvcm1hdFxudmFyIG51bWJlcjJjb2xvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9udW1iZXIyY29sb3IgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9udW1iZXIyY29sb3IuanNcIik7XG5leHBvcnRzLm51bWJlcjJjb2xvciA9IG51bWJlcjJjb2xvcl8xLmRlZmF1bHQ7XG52YXIgcGFyc2VfcmFkaXVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BhcnNlLXJhZGl1cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3BhcnNlLXJhZGl1cy5qc1wiKTtcbmV4cG9ydHMucGFyc2VSYWRpdXMgPSBwYXJzZV9yYWRpdXNfMS5kZWZhdWx0O1xuLy8gbWF0aFxudmFyIGNsYW1wXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NsYW1wICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvY2xhbXAuanNcIik7XG5leHBvcnRzLmNsYW1wID0gY2xhbXBfMS5kZWZhdWx0O1xudmFyIGZpeGVkX2Jhc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZml4ZWQtYmFzZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2ZpeGVkLWJhc2UuanNcIik7XG5leHBvcnRzLmZpeGVkQmFzZSA9IGZpeGVkX2Jhc2VfMS5kZWZhdWx0O1xudmFyIGlzX2RlY2ltYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtZGVjaW1hbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWRlY2ltYWwuanNcIik7XG5leHBvcnRzLmlzRGVjaW1hbCA9IGlzX2RlY2ltYWxfMS5kZWZhdWx0O1xudmFyIGlzX2V2ZW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtZXZlbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWV2ZW4uanNcIik7XG5leHBvcnRzLmlzRXZlbiA9IGlzX2V2ZW5fMS5kZWZhdWx0O1xudmFyIGlzX2ludGVnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtaW50ZWdlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWludGVnZXIuanNcIik7XG5leHBvcnRzLmlzSW50ZWdlciA9IGlzX2ludGVnZXJfMS5kZWZhdWx0O1xudmFyIGlzX25lZ2F0aXZlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW5lZ2F0aXZlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbmVnYXRpdmUuanNcIik7XG5leHBvcnRzLmlzTmVnYXRpdmUgPSBpc19uZWdhdGl2ZV8xLmRlZmF1bHQ7XG52YXIgaXNfbnVtYmVyX2VxdWFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW51bWJlci1lcXVhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW51bWJlci1lcXVhbC5qc1wiKTtcbmV4cG9ydHMuaXNOdW1iZXJFcXVhbCA9IGlzX251bWJlcl9lcXVhbF8xLmRlZmF1bHQ7XG52YXIgaXNfb2RkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW9kZCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW9kZC5qc1wiKTtcbmV4cG9ydHMuaXNPZGQgPSBpc19vZGRfMS5kZWZhdWx0O1xudmFyIGlzX3Bvc2l0aXZlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXBvc2l0aXZlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtcG9zaXRpdmUuanNcIik7XG5leHBvcnRzLmlzUG9zaXRpdmUgPSBpc19wb3NpdGl2ZV8xLmRlZmF1bHQ7XG52YXIgbWF4X2J5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21heC1ieSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL21heC1ieS5qc1wiKTtcbmV4cG9ydHMubWF4QnkgPSBtYXhfYnlfMS5kZWZhdWx0O1xudmFyIG1pbl9ieV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9taW4tYnkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9taW4tYnkuanNcIik7XG5leHBvcnRzLm1pbkJ5ID0gbWluX2J5XzEuZGVmYXVsdDtcbnZhciBtb2RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbW9kLmpzXCIpO1xuZXhwb3J0cy5tb2QgPSBtb2RfMS5kZWZhdWx0O1xudmFyIHRvX2RlZ3JlZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90by1kZWdyZWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi90by1kZWdyZWUuanNcIik7XG5leHBvcnRzLnRvRGVncmVlID0gdG9fZGVncmVlXzEuZGVmYXVsdDtcbnZhciB0b19pbnRlZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvLWludGVnZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi90by1pbnRlZ2VyLmpzXCIpO1xuZXhwb3J0cy50b0ludGVnZXIgPSB0b19pbnRlZ2VyXzEuZGVmYXVsdDtcbnZhciB0b19yYWRpYW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG8tcmFkaWFuICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdG8tcmFkaWFuLmpzXCIpO1xuZXhwb3J0cy50b1JhZGlhbiA9IHRvX3JhZGlhbl8xLmRlZmF1bHQ7XG4vLyBvYmplY3RcbnZhciBmb3JfaW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm9yLWluICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZm9yLWluLmpzXCIpO1xuZXhwb3J0cy5mb3JJbiA9IGZvcl9pbl8xLmRlZmF1bHQ7XG52YXIgaGFzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2hhcy5qc1wiKTtcbmV4cG9ydHMuaGFzID0gaGFzXzEuZGVmYXVsdDtcbnZhciBoYXNfa2V5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hhcy1rZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9oYXMta2V5LmpzXCIpO1xuZXhwb3J0cy5oYXNLZXkgPSBoYXNfa2V5XzEuZGVmYXVsdDtcbnZhciBoYXNfdmFsdWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaGFzLXZhbHVlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaGFzLXZhbHVlLmpzXCIpO1xuZXhwb3J0cy5oYXNWYWx1ZSA9IGhhc192YWx1ZV8xLmRlZmF1bHQ7XG52YXIga2V5c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIva2V5cy5qc1wiKTtcbmV4cG9ydHMua2V5cyA9IGtleXNfMS5kZWZhdWx0O1xudmFyIGlzX21hdGNoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW1hdGNoICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbWF0Y2guanNcIik7XG5leHBvcnRzLmlzTWF0Y2ggPSBpc19tYXRjaF8xLmRlZmF1bHQ7XG52YXIgdmFsdWVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ZhbHVlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3ZhbHVlcy5qc1wiKTtcbmV4cG9ydHMudmFsdWVzID0gdmFsdWVzXzEuZGVmYXVsdDtcbi8vIHN0cmluZ1xudmFyIGxvd2VyX2Nhc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG93ZXItY2FzZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2xvd2VyLWNhc2UuanNcIik7XG5leHBvcnRzLmxvd2VyQ2FzZSA9IGxvd2VyX2Nhc2VfMS5kZWZhdWx0O1xudmFyIGxvd2VyX2ZpcnN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvd2VyLWZpcnN0ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbG93ZXItZmlyc3QuanNcIik7XG5leHBvcnRzLmxvd2VyRmlyc3QgPSBsb3dlcl9maXJzdF8xLmRlZmF1bHQ7XG52YXIgc3Vic3RpdHV0ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zdWJzdGl0dXRlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvc3Vic3RpdHV0ZS5qc1wiKTtcbmV4cG9ydHMuc3Vic3RpdHV0ZSA9IHN1YnN0aXR1dGVfMS5kZWZhdWx0O1xudmFyIHVwcGVyX2Nhc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXBwZXItY2FzZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3VwcGVyLWNhc2UuanNcIik7XG5leHBvcnRzLnVwcGVyQ2FzZSA9IHVwcGVyX2Nhc2VfMS5kZWZhdWx0O1xudmFyIHVwcGVyX2ZpcnN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3VwcGVyLWZpcnN0ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdXBwZXItZmlyc3QuanNcIik7XG5leHBvcnRzLnVwcGVyRmlyc3QgPSB1cHBlcl9maXJzdF8xLmRlZmF1bHQ7XG4vLyB0eXBlXG52YXIgZ2V0X3R5cGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0LXR5cGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9nZXQtdHlwZS5qc1wiKTtcbmV4cG9ydHMuZ2V0VHlwZSA9IGdldF90eXBlXzEuZGVmYXVsdDtcbnZhciBpc19hcmd1bWVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJndW1lbnRzICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJndW1lbnRzLmpzXCIpO1xuZXhwb3J0cy5pc0FyZ3VtZW50cyA9IGlzX2FyZ3VtZW50c18xLmRlZmF1bHQ7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbmV4cG9ydHMuaXNBcnJheSA9IGlzX2FycmF5XzEuZGVmYXVsdDtcbnZhciBpc19hcnJheV9saWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5LWxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS1saWtlLmpzXCIpO1xuZXhwb3J0cy5pc0FycmF5TGlrZSA9IGlzX2FycmF5X2xpa2VfMS5kZWZhdWx0O1xudmFyIGlzX2Jvb2xlYW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYm9vbGVhbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWJvb2xlYW4uanNcIik7XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzX2Jvb2xlYW5fMS5kZWZhdWx0O1xudmFyIGlzX2RhdGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtZGF0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWRhdGUuanNcIik7XG5leHBvcnRzLmlzRGF0ZSA9IGlzX2RhdGVfMS5kZWZhdWx0O1xudmFyIGlzX2Vycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWVycm9yICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZXJyb3IuanNcIik7XG5leHBvcnRzLmlzRXJyb3IgPSBpc19lcnJvcl8xLmRlZmF1bHQ7XG52YXIgaXNfZnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtZnVuY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1mdW5jdGlvbi5qc1wiKTtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzX2Z1bmN0aW9uXzEuZGVmYXVsdDtcbnZhciBpc19maW5pdGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtZmluaXRlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZmluaXRlLmpzXCIpO1xuZXhwb3J0cy5pc0Zpbml0ZSA9IGlzX2Zpbml0ZV8xLmRlZmF1bHQ7XG52YXIgaXNfbmlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW5pbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW5pbC5qc1wiKTtcbmV4cG9ydHMuaXNOaWwgPSBpc19uaWxfMS5kZWZhdWx0O1xudmFyIGlzX251bGxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtbnVsbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW51bGwuanNcIik7XG5leHBvcnRzLmlzTnVsbCA9IGlzX251bGxfMS5kZWZhdWx0O1xudmFyIGlzX251bWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1udW1iZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1udW1iZXIuanNcIik7XG5leHBvcnRzLmlzTnVtYmVyID0gaXNfbnVtYmVyXzEuZGVmYXVsdDtcbnZhciBpc19vYmplY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtb2JqZWN0LmpzXCIpO1xuZXhwb3J0cy5pc09iamVjdCA9IGlzX29iamVjdF8xLmRlZmF1bHQ7XG52YXIgaXNfb2JqZWN0X2xpa2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtb2JqZWN0LWxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1vYmplY3QtbGlrZS5qc1wiKTtcbmV4cG9ydHMuaXNPYmplY3RMaWtlID0gaXNfb2JqZWN0X2xpa2VfMS5kZWZhdWx0O1xudmFyIGlzX3BsYWluX29iamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1wbGFpbi1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1wbGFpbi1vYmplY3QuanNcIik7XG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc19wbGFpbl9vYmplY3RfMS5kZWZhdWx0O1xudmFyIGlzX3Byb3RvdHlwZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1wcm90b3R5cGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1wcm90b3R5cGUuanNcIik7XG5leHBvcnRzLmlzUHJvdG90eXBlID0gaXNfcHJvdG90eXBlXzEuZGVmYXVsdDtcbnZhciBpc19yZWdfZXhwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXJlZy1leHAgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1yZWctZXhwLmpzXCIpO1xuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzX3JlZ19leHBfMS5kZWZhdWx0O1xudmFyIGlzX3N0cmluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1zdHJpbmcuanNcIik7XG5leHBvcnRzLmlzU3RyaW5nID0gaXNfc3RyaW5nXzEuZGVmYXVsdDtcbnZhciBpc190eXBlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXR5cGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy10eXBlLmpzXCIpO1xuZXhwb3J0cy5pc1R5cGUgPSBpc190eXBlXzEuZGVmYXVsdDtcbnZhciBpc191bmRlZmluZWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtdW5kZWZpbmVkICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtdW5kZWZpbmVkLmpzXCIpO1xuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzX3VuZGVmaW5lZF8xLmRlZmF1bHQ7XG52YXIgaXNfZWxlbWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1lbGVtZW50ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZWxlbWVudC5qc1wiKTtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNfZWxlbWVudF8xLmRlZmF1bHQ7XG52YXIgcmVxdWVzdF9hbmltYXRpb25fZnJhbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVxdWVzdC1hbmltYXRpb24tZnJhbWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9yZXF1ZXN0LWFuaW1hdGlvbi1mcmFtZS5qc1wiKTtcbmV4cG9ydHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdF9hbmltYXRpb25fZnJhbWVfMS5kZWZhdWx0O1xudmFyIGNsZWFyX2FuaW1hdGlvbl9mcmFtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jbGVhci1hbmltYXRpb24tZnJhbWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9jbGVhci1hbmltYXRpb24tZnJhbWUuanNcIik7XG5leHBvcnRzLmNsZWFyQW5pbWF0aW9uRnJhbWUgPSBjbGVhcl9hbmltYXRpb25fZnJhbWVfMS5kZWZhdWx0O1xuLy8gb3RoZXJcbnZhciBhdWdtZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2F1Z21lbnQgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9hdWdtZW50LmpzXCIpO1xuZXhwb3J0cy5hdWdtZW50ID0gYXVnbWVudF8xLmRlZmF1bHQ7XG52YXIgY2xvbmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2xvbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9jbG9uZS5qc1wiKTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZV8xLmRlZmF1bHQ7XG52YXIgZGVib3VuY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGVib3VuY2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9kZWJvdW5jZS5qc1wiKTtcbmV4cG9ydHMuZGVib3VuY2UgPSBkZWJvdW5jZV8xLmRlZmF1bHQ7XG52YXIgbWVtb2l6ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tZW1vaXplICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbWVtb2l6ZS5qc1wiKTtcbmV4cG9ydHMubWVtb2l6ZSA9IG1lbW9pemVfMS5kZWZhdWx0O1xudmFyIGRlZXBfbWl4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RlZXAtbWl4ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZGVlcC1taXguanNcIik7XG5leHBvcnRzLmRlZXBNaXggPSBkZWVwX21peF8xLmRlZmF1bHQ7XG52YXIgZWFjaF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lYWNoICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZWFjaC5qc1wiKTtcbmV4cG9ydHMuZWFjaCA9IGVhY2hfMS5kZWZhdWx0O1xudmFyIGV4dGVuZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9leHRlbmQgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9leHRlbmQuanNcIik7XG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZF8xLmRlZmF1bHQ7XG52YXIgaW5kZXhfb2ZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW5kZXgtb2YgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC1vZi5qc1wiKTtcbmV4cG9ydHMuaW5kZXhPZiA9IGluZGV4X29mXzEuZGVmYXVsdDtcbnZhciBpc19lbXB0eV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1lbXB0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWVtcHR5LmpzXCIpO1xuZXhwb3J0cy5pc0VtcHR5ID0gaXNfZW1wdHlfMS5kZWZhdWx0O1xudmFyIGlzX2VxdWFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWVxdWFsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZXF1YWwuanNcIik7XG5leHBvcnRzLmlzRXF1YWwgPSBpc19lcXVhbF8xLmRlZmF1bHQ7XG52YXIgaXNfZXF1YWxfd2l0aF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1lcXVhbC13aXRoICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZXF1YWwtd2l0aC5qc1wiKTtcbmV4cG9ydHMuaXNFcXVhbFdpdGggPSBpc19lcXVhbF93aXRoXzEuZGVmYXVsdDtcbnZhciBtYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWFwICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbWFwLmpzXCIpO1xuZXhwb3J0cy5tYXAgPSBtYXBfMS5kZWZhdWx0O1xudmFyIG1hcF92YWx1ZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWFwLXZhbHVlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL21hcC12YWx1ZXMuanNcIik7XG5leHBvcnRzLm1hcFZhbHVlcyA9IG1hcF92YWx1ZXNfMS5kZWZhdWx0O1xudmFyIG1peF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9taXggKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9taXguanNcIik7XG5leHBvcnRzLm1peCA9IG1peF8xLmRlZmF1bHQ7XG5leHBvcnRzLmFzc2lnbiA9IG1peF8xLmRlZmF1bHQ7XG52YXIgZ2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2dldC5qc1wiKTtcbmV4cG9ydHMuZ2V0ID0gZ2V0XzEuZGVmYXVsdDtcbnZhciBzZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2V0ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvc2V0LmpzXCIpO1xuZXhwb3J0cy5zZXQgPSBzZXRfMS5kZWZhdWx0O1xudmFyIHBpY2tfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGljayAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3BpY2suanNcIik7XG5leHBvcnRzLnBpY2sgPSBwaWNrXzEuZGVmYXVsdDtcbnZhciB0aHJvdHRsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90aHJvdHRsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3Rocm90dGxlLmpzXCIpO1xuZXhwb3J0cy50aHJvdHRsZSA9IHRocm90dGxlXzEuZGVmYXVsdDtcbnZhciB0b19hcnJheV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90by1hcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3RvLWFycmF5LmpzXCIpO1xuZXhwb3J0cy50b0FycmF5ID0gdG9fYXJyYXlfMS5kZWZhdWx0O1xudmFyIHRvX3N0cmluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90by1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi90by1zdHJpbmcuanNcIik7XG5leHBvcnRzLnRvU3RyaW5nID0gdG9fc3RyaW5nXzEuZGVmYXVsdDtcbnZhciB1bmlxdWVfaWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdW5pcXVlLWlkICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdW5pcXVlLWlkLmpzXCIpO1xuZXhwb3J0cy51bmlxdWVJZCA9IHVuaXF1ZV9pZF8xLmRlZmF1bHQ7XG52YXIgbm9vcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ub29wICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbm9vcC5qc1wiKTtcbmV4cG9ydHMubm9vcCA9IG5vb3BfMS5kZWZhdWx0O1xudmFyIGlkZW50aXR5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lkZW50aXR5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaWRlbnRpdHkuanNcIik7XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHlfMS5kZWZhdWx0O1xudmFyIHNpemVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2l6ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3NpemUuanNcIik7XG5leHBvcnRzLnNpemUgPSBzaXplXzEuZGVmYXVsdDtcbi8vIOS4jeefpemBk+S4uuS7gOS5iO+8jOmcgOimgeaKiui/meS4qiBleHBvcnTvvIzkuI3nhLYgdHMg5Lya5oql57G75Z6L6ZSZ6K+vXG52YXIgY2FjaGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2FjaGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9jYWNoZS5qc1wiKTtcbmV4cG9ydHMuQ2FjaGUgPSBjYWNoZV8xLmRlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJndW1lbnRzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcmd1bWVudHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIOaYr+WQpuaYr+WPguaVsOexu+Wei1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSDmtYvor5XnmoTlgLxcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc190eXBlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXR5cGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy10eXBlLmpzXCIpO1xudmFyIGlzQXJndW1lbnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzX3R5cGVfMS5kZWZhdWx0KHZhbHVlLCAnQXJndW1lbnRzJyk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNBcmd1bWVudHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1hcmd1bWVudHMuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LWxpa2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS1saWtlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc0FycmF5TGlrZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8qKlxuICAgICAqIGlzQXJyYXlMaWtlKFsxLCAyLCAzXSkgPT4gdHJ1ZVxuICAgICAqIGlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pID0+IHRydWVcbiAgICAgKiBpc0FycmF5TGlrZSgnYWJjJykgPT4gdHJ1ZVxuICAgICAqIGlzQXJyYXlMaWtlKEZ1bmN0aW9uKSA9PiBmYWxzZVxuICAgICAqL1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgaXNGaW5pdGUodmFsdWUubGVuZ3RoKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpc0FycmF5TGlrZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWFycmF5LWxpa2UuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfdHlwZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy10eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtdHlwZS5qc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSA/XG4gICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpIDpcbiAgICAgICAgaXNfdHlwZV8xLmRlZmF1bHQodmFsdWUsICdBcnJheScpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1hcnJheS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYm9vbGVhbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWJvb2xlYW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiDmmK/lkKbmmK/luIPlsJTnsbvlnotcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUg5rWL6K+V55qE5YC8XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNfdHlwZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy10eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtdHlwZS5qc1wiKTtcbnZhciBpc0Jvb2xlYW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gaXNfdHlwZV8xLmRlZmF1bHQodmFsdWUsICdCb29sZWFuJyk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNCb29sZWFuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtYm9vbGVhbi5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZGF0ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWRhdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX3R5cGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtdHlwZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXR5cGUuanNcIik7XG52YXIgaXNEYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzX3R5cGVfMS5kZWZhdWx0KHZhbHVlLCAnRGF0ZScpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWRhdGUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWRlY2ltYWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1kZWNpbWFsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19udW1iZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtbnVtYmVyICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbnVtYmVyLmpzXCIpO1xudmFyIGlzRGVjaW1hbCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gaXNfbnVtYmVyXzEuZGVmYXVsdChudW0pICYmIG51bSAlIDEgIT09IDA7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNEZWNpbWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZGVjaW1hbC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZWxlbWVudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWVsZW1lbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiDliKTmlq3mmK/lkKZIVE1M5YWD57SgXG4gKiBAcmV0dXJuIHtCb29sZWFufSDmmK/lkKZIVE1M5YWD57SgXG4gKi9cbnZhciBpc0VsZW1lbnQgPSBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvIGluc3RhbmNlb2YgRWxlbWVudCB8fCBvIGluc3RhbmNlb2YgSFRNTERvY3VtZW50O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRWxlbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWVsZW1lbnQuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWVtcHR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWVtcHR5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfbmlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW5pbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW5pbC5qc1wiKTtcbnZhciBpc19hcnJheV9saWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5LWxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS1saWtlLmpzXCIpO1xudmFyIGdldF90eXBlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldC10eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ2V0LXR5cGUuanNcIik7XG52YXIgaXNfcHJvdG90eXBlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXByb3RvdHlwZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXByb3RvdHlwZS5qc1wiKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgLyoqXG4gICAgICogaXNFbXB0eShudWxsKSA9PiB0cnVlXG4gICAgICogaXNFbXB0eSgpID0+IHRydWVcbiAgICAgKiBpc0VtcHR5KHRydWUpID0+IHRydWVcbiAgICAgKiBpc0VtcHR5KDEpID0+IHRydWVcbiAgICAgKiBpc0VtcHR5KFsxLCAyLCAzXSkgPT4gZmFsc2VcbiAgICAgKiBpc0VtcHR5KCdhYmMnKSA9PiBmYWxzZVxuICAgICAqIGlzRW1wdHkoeyBhOiAxIH0pID0+IGZhbHNlXG4gICAgICovXG4gICAgaWYgKGlzX25pbF8xLmRlZmF1bHQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNfYXJyYXlfbGlrZV8xLmRlZmF1bHQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgdHlwZSA9IGdldF90eXBlXzEuZGVmYXVsdCh2YWx1ZSk7XG4gICAgaWYgKHR5cGUgPT09ICdNYXAnIHx8IHR5cGUgPT09ICdTZXQnKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgICB9XG4gICAgaWYgKGlzX3Byb3RvdHlwZV8xLmRlZmF1bHQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAhT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBpc0VtcHR5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZW1wdHkuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWVxdWFsLXdpdGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1lcXVhbC13aXRoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19mdW5jdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1mdW5jdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWZ1bmN0aW9uLmpzXCIpO1xudmFyIGlzX2VxdWFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWVxdWFsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZXF1YWwuanNcIik7XG4vKipcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICogfVxuICpcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlKSB7XG4gKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKG90aFZhbHVlKSkge1xuICogICAgIHJldHVybiB0cnVlO1xuICogICB9XG4gKiB9XG4gKlxuICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XG4gKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAqXG4gKiBpc0VxdWFsV2l0aChhcnJheSwgb3RoZXIsIGN1c3RvbWl6ZXIpOyAgLy8gPT4gdHJ1ZVxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKHZhbHVlLCBvdGhlciwgZm4pIHtcbiAgICBpZiAoIWlzX2Z1bmN0aW9uXzEuZGVmYXVsdChmbikpIHtcbiAgICAgICAgcmV0dXJuIGlzX2VxdWFsXzEuZGVmYXVsdCh2YWx1ZSwgb3RoZXIpO1xuICAgIH1cbiAgICByZXR1cm4gISFmbih2YWx1ZSwgb3RoZXIpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1lcXVhbC13aXRoLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1lcXVhbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1lcXVhbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX29iamVjdF9saWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW9iamVjdC1saWtlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtb2JqZWN0LWxpa2UuanNcIik7XG52YXIgaXNfYXJyYXlfbGlrZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheS1saWtlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXktbGlrZS5qc1wiKTtcbnZhciBpc19zdHJpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtc3RyaW5nLmpzXCIpO1xudmFyIGlzRXF1YWwgPSBmdW5jdGlvbiAodmFsdWUsIG90aGVyKSB7XG4gICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZSB8fCAhb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNfc3RyaW5nXzEuZGVmYXVsdCh2YWx1ZSkgfHwgaXNfc3RyaW5nXzEuZGVmYXVsdChvdGhlcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNfYXJyYXlfbGlrZV8xLmRlZmF1bHQodmFsdWUpIHx8IGlzX2FycmF5X2xpa2VfMS5kZWZhdWx0KG90aGVyKSkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnN0ID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcnN0ID0gaXNFcXVhbCh2YWx1ZVtpXSwgb3RoZXJbaV0pO1xuICAgICAgICAgICAgaWYgKCFyc3QpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnN0O1xuICAgIH1cbiAgICBpZiAoaXNfb2JqZWN0X2xpa2VfMS5kZWZhdWx0KHZhbHVlKSB8fCBpc19vYmplY3RfbGlrZV8xLmRlZmF1bHQob3RoZXIpKSB7XG4gICAgICAgIHZhciB2YWx1ZUtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgIHZhciBvdGhlcktleXMgPSBPYmplY3Qua2V5cyhvdGhlcik7XG4gICAgICAgIGlmICh2YWx1ZUtleXMubGVuZ3RoICE9PSBvdGhlcktleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJzdCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByc3QgPSBpc0VxdWFsKHZhbHVlW3ZhbHVlS2V5c1tpXV0sIG90aGVyW3ZhbHVlS2V5c1tpXV0pO1xuICAgICAgICAgICAgaWYgKCFyc3QpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnN0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNFcXVhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWVxdWFsLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1lcnJvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1lcnJvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiDmmK/lkKbmmK/lj4LmlbDnsbvlnotcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUg5rWL6K+V55qE5YC8XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNfdHlwZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy10eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtdHlwZS5qc1wiKTtcbnZhciBpc0Vycm9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzX3R5cGVfMS5kZWZhdWx0KHZhbHVlLCAnRXJyb3InKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpc0Vycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZXJyb3IuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWV2ZW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1ldmVuLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19udW1iZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtbnVtYmVyICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbnVtYmVyLmpzXCIpO1xudmFyIGlzRXZlbiA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gaXNfbnVtYmVyXzEuZGVmYXVsdChudW0pICYmIG51bSAlIDIgPT09IDA7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNFdmVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZXZlbi5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZmluaXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1maW5pdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIOWIpOaWreaYr+WQpuS4uuaciemZkOaVsFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzX251bWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1udW1iZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1udW1iZXIuanNcIik7XG5mdW5jdGlvbiBkZWZhdWx0XzEodmFsdWUpIHtcbiAgICByZXR1cm4gaXNfbnVtYmVyXzEuZGVmYXVsdCh2YWx1ZSkgJiYgaXNGaW5pdGUodmFsdWUpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdF8xO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZmluaXRlLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1mdW5jdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1mdW5jdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiDmmK/lkKbkuLrlh73mlbBcbiAqIEBwYXJhbSAgeyp9IGZuIOWvueixoVxuICogQHJldHVybiB7Qm9vbGVhbn0gIOaYr+WQpuWHveaVsFxuICovXG52YXIgaXNfdHlwZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy10eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtdHlwZS5qc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gaXNfdHlwZV8xLmRlZmF1bHQodmFsdWUsICdGdW5jdGlvbicpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1mdW5jdGlvbi5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtaW50ZWdlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWludGVnZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX251bWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1udW1iZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1udW1iZXIuanNcIik7XG52YXIgaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciA/IE51bWJlci5pc0ludGVnZXIgOiBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIGlzX251bWJlcl8xLmRlZmF1bHQobnVtKSAmJiBudW0gJSAxID09PSAwO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSW50ZWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWludGVnZXIuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW1hdGNoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW1hdGNoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfbmlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW5pbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW5pbC5qc1wiKTtcbnZhciBrZXlzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2tleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9rZXlzLmpzXCIpO1xuZnVuY3Rpb24gaXNNYXRjaChvYmosIGF0dHJzKSB7XG4gICAgdmFyIF9rZXlzID0ga2V5c18xLmRlZmF1bHQoYXR0cnMpO1xuICAgIHZhciBsZW5ndGggPSBfa2V5cy5sZW5ndGg7XG4gICAgaWYgKGlzX25pbF8xLmRlZmF1bHQob2JqKSlcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIga2V5ID0gX2tleXNbaV07XG4gICAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBpc01hdGNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtbWF0Y2guanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW5lZ2F0aXZlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW5lZ2F0aXZlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfbnVtYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW51bWJlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW51bWJlci5qc1wiKTtcbnZhciBpc05lZ2F0aXZlID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBpc19udW1iZXJfMS5kZWZhdWx0KG51bSkgJiYgbnVtIDwgMDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpc05lZ2F0aXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtbmVnYXRpdmUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW5pbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbmlsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gaXNGaW5pdGUsXG52YXIgaXNOaWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvKipcbiAgICAgKiBpc05pbChudWxsKSA9PiB0cnVlXG4gICAgICogaXNOaWwoKSA9PiB0cnVlXG4gICAgICovXG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNOaWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1uaWwuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW51bGwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1udWxsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc051bGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNOdWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtbnVsbC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbnVtYmVyLWVxdWFsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1udW1iZXItZXF1YWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUFJFQ0lTSU9OID0gMC4wMDAwMTsgLy8gbnVtYmVycyBsZXNzIHRoYW4gdGhpcyBpcyBjb25zaWRlcmVkIGFzIDBcbmZ1bmN0aW9uIGlzTnVtYmVyRXF1YWwoYSwgYiwgcHJlY2lzaW9uKSB7XG4gICAgaWYgKHByZWNpc2lvbiA9PT0gdm9pZCAwKSB7IHByZWNpc2lvbiA9IFBSRUNJU0lPTjsgfVxuICAgIHJldHVybiBNYXRoLmFicygoYSAtIGIpKSA8IHByZWNpc2lvbjtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGlzTnVtYmVyRXF1YWw7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1udW1iZXItZXF1YWwuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW51bWJlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbnVtYmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiDliKTmlq3mmK/lkKbmlbDlrZdcbiAqIEByZXR1cm4ge0Jvb2xlYW59IOaYr+WQpuaVsOWtl1xuICovXG52YXIgaXNfdHlwZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy10eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtdHlwZS5qc1wiKTtcbnZhciBpc051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBpc190eXBlXzEuZGVmYXVsdCh2YWx1ZSwgJ051bWJlcicpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTnVtYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtbnVtYmVyLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1vYmplY3QtbGlrZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1vYmplY3QtbGlrZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzT2JqZWN0TGlrZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8qKlxuICAgICAqIGlzT2JqZWN0TGlrZSh7fSkgPT4gdHJ1ZVxuICAgICAqIGlzT2JqZWN0TGlrZShbMSwgMiwgM10pID0+IHRydWVcbiAgICAgKiBpc09iamVjdExpa2UoRnVuY3Rpb24pID0+IGZhbHNlXG4gICAgICogaXNPYmplY3RMaWtlKG51bGwpID0+IGZhbHNlXG4gICAgICovXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGw7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNPYmplY3RMaWtlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtb2JqZWN0LWxpa2UuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtb2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8qKlxuICAgICAqIGlzT2JqZWN0KHt9KSA9PiB0cnVlXG4gICAgICogaXNPYmplY3QoWzEsIDIsIDNdKSA9PiB0cnVlXG4gICAgICogaXNPYmplY3QoRnVuY3Rpb24pID0+IHRydWVcbiAgICAgKiBpc09iamVjdChudWxsKSA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1vYmplY3QuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW9kZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtb2RkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX251bWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1udW1iZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1udW1iZXIuanNcIik7XG52YXIgaXNPZGQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIGlzX251bWJlcl8xLmRlZmF1bHQobnVtKSAmJiBudW0gJSAyICE9PSAwO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzT2RkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtb2RkLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1wbGFpbi1vYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXBsYWluLW9iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19vYmplY3RfbGlrZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1vYmplY3QtbGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW9iamVjdC1saWtlLmpzXCIpO1xudmFyIGlzX3R5cGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtdHlwZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXR5cGUuanNcIik7XG52YXIgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8qKlxuICAgICAqIGlzT2JqZWN0TGlrZShuZXcgRm9vKSA9PiBmYWxzZVxuICAgICAqIGlzT2JqZWN0TGlrZShbMSwgMiwgM10pID0+IGZhbHNlXG4gICAgICogaXNPYmplY3RMaWtlKHsgeDogMCwgeTogMCB9KSA9PiB0cnVlXG4gICAgICogaXNPYmplY3RMaWtlKE9iamVjdC5jcmVhdGUobnVsbCkpID0+IHRydWVcbiAgICAgKi9cbiAgICBpZiAoIWlzX29iamVjdF9saWtlXzEuZGVmYXVsdCh2YWx1ZSkgfHwgIWlzX3R5cGVfMS5kZWZhdWx0KHZhbHVlLCAnT2JqZWN0JykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHByb3RvID0gdmFsdWU7XG4gICAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gcHJvdG87XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNQbGFpbk9iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLXBsYWluLW9iamVjdC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtcG9zaXRpdmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtcG9zaXRpdmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19udW1iZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtbnVtYmVyICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbnVtYmVyLmpzXCIpO1xudmFyIGlzUG9zaXRpdmUgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIGlzX251bWJlcl8xLmRlZmF1bHQobnVtKSAmJiBudW0gPiAwO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzUG9zaXRpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1wb3NpdGl2ZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtcHJvdG90eXBlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1wcm90b3R5cGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xudmFyIGlzUHJvdG90eXBlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNQcm90b3R5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1wcm90b3R5cGUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXJlZy1leHAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1yZWctZXhwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc190eXBlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXR5cGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy10eXBlLmpzXCIpO1xudmFyIGlzUmVnRXhwID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBpc190eXBlXzEuZGVmYXVsdChzdHIsICdSZWdFeHAnKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpc1JlZ0V4cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLXJlZy1leHAuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXN0cmluZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtc3RyaW5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX3R5cGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtdHlwZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXR5cGUuanNcIik7XG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBpc190eXBlXzEuZGVmYXVsdChzdHIsICdTdHJpbmcnKTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtc3RyaW5nLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy10eXBlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtdHlwZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcbnZhciBpc1R5cGUgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGUpIHsgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCAnICsgdHlwZSArICddJzsgfTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLXR5cGUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXVuZGVmaW5lZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtdW5kZWZpbmVkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzVW5kZWZpbmVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNVbmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy11bmRlZmluZWQuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2tleXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9rZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlYWNoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9lYWNoLmpzXCIpO1xudmFyIGlzX2Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWZ1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZnVuY3Rpb24uanNcIik7XG52YXIga2V5cyA9IE9iamVjdC5rZXlzID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gT2JqZWN0LmtleXMob2JqKTsgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZWFjaF8xLmRlZmF1bHQob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoIShpc19mdW5jdGlvbl8xLmRlZmF1bHQob2JqKSAmJiBrZXkgPT09ICdwcm90b3R5cGUnKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0ga2V5cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXMuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2xhc3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9sYXN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19hcnJheV9saWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5LWxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS1saWtlLmpzXCIpO1xuZnVuY3Rpb24gbGFzdChvKSB7XG4gICAgaWYgKGlzX2FycmF5X2xpa2VfMS5kZWZhdWx0KG8pKSB7XG4gICAgICAgIHZhciBhcnIgPSBvO1xuICAgICAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGxhc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXN0LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9sb3dlci1jYXNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbG93ZXItY2FzZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdG9fc3RyaW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3RvLXN0cmluZy5qc1wiKTtcbnZhciBsb3dlckNhc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHRvX3N0cmluZ18xLmRlZmF1bHQoc3RyKS50b0xvd2VyQ2FzZSgpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGxvd2VyQ2FzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvd2VyLWNhc2UuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2xvd2VyLWZpcnN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2xvd2VyLWZpcnN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdG9fc3RyaW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3RvLXN0cmluZy5qc1wiKTtcbnZhciBsb3dlckZpcnN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHN0ciA9IHRvX3N0cmluZ18xLmRlZmF1bHQodmFsdWUpO1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGxvd2VyRmlyc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb3dlci1maXJzdC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbWFwLXZhbHVlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL21hcC12YWx1ZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX25pbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1uaWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1uaWwuanNcIik7XG52YXIgaXNfb2JqZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW9iamVjdC5qc1wiKTtcbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2OyB9O1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChvYmplY3QsIGZ1bmMpIHtcbiAgICBpZiAoZnVuYyA9PT0gdm9pZCAwKSB7IGZ1bmMgPSBpZGVudGl0eTsgfVxuICAgIHZhciByID0ge307XG4gICAgaWYgKGlzX29iamVjdF8xLmRlZmF1bHQob2JqZWN0KSAmJiAhaXNfbmlsXzEuZGVmYXVsdChvYmplY3QpKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByW2tleV0gPSBmdW5jKG9iamVjdFtrZXldLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcC12YWx1ZXMuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL21hcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbWFwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVhY2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2VhY2guanNcIik7XG52YXIgaXNfYXJyYXlfbGlrZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheS1saWtlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXktbGlrZS5qc1wiKTtcbnZhciBtYXAgPSBmdW5jdGlvbiAoYXJyLCBmdW5jKSB7XG4gICAgaWYgKCFpc19hcnJheV9saWtlXzEuZGVmYXVsdChhcnIpKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGVhY2hfMS5kZWZhdWx0KGFyciwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICByZXN1bHQucHVzaChmdW5jKHZhbHVlLCBpbmRleCkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gbWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9tYXgtYnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL21heC1ieS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlYWNoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9lYWNoLmpzXCIpO1xudmFyIGlzX2FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXkuanNcIik7XG52YXIgaXNfZnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtZnVuY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1mdW5jdGlvbi5qc1wiKTtcbi8qKlxuICogQHBhcmFtIHtBcnJheX0gYXJyIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybiB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gKlxuICogbWF4Qnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAqIC8vID0+IHsgJ24nOiAyIH1cbiAqXG4gKiBtYXhCeShvYmplY3RzLCAnbicpO1xuICogLy8gPT4geyAnbic6IDIgfVxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGFyciwgZm4pIHtcbiAgICBpZiAoIWlzX2FycmF5XzEuZGVmYXVsdChhcnIpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciBtYXggPSBhcnJbMF07XG4gICAgdmFyIG1heERhdGE7XG4gICAgaWYgKGlzX2Z1bmN0aW9uXzEuZGVmYXVsdChmbikpIHtcbiAgICAgICAgbWF4RGF0YSA9IGZuKGFyclswXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXhEYXRhID0gYXJyWzBdW2ZuXTtcbiAgICB9XG4gICAgdmFyIGRhdGE7XG4gICAgZWFjaF8xLmRlZmF1bHQoYXJyLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIGlmIChpc19mdW5jdGlvbl8xLmRlZmF1bHQoZm4pKSB7XG4gICAgICAgICAgICBkYXRhID0gZm4odmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB2YWxbZm5dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhID4gbWF4RGF0YSkge1xuICAgICAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICAgICAgbWF4RGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWF4O1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXgtYnkuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL21lbW9pemUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9tZW1vaXplLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19mdW5jdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1mdW5jdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWZ1bmN0aW9uLmpzXCIpO1xuLyoqXG4gKiBfLm1lbW9pemUoY2FsQ29sb3IpO1xuICogXy5tZW1vaXplKGNhbENvbG9yLCAoLi4uYXJncykgPT4gYXJnc1swXSk7XG4gKiBAcGFyYW0gZlxuICogQHBhcmFtIHJlc29sdmVyXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoZiwgcmVzb2x2ZXIpIHtcbiAgICBpZiAoIWlzX2Z1bmN0aW9uXzEuZGVmYXVsdChmKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAvLyDkvb/nlKjmlrnms5XmnoTpgKAga2V577yM5aaC5p6c5LiN5a2Y5ZyoIHJlc29sdmVy77yM5YiZ55u05o6l5Y+W56ys5LiA5Liq5Y+C5pWw5L2c5Li6IGtleVxuICAgICAgICB2YXIga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF07XG4gICAgICAgIHZhciBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuICAgICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgLy8g57yT5a2Y6LW35p2lXG4gICAgICAgIGNhY2hlLnNldChrZXksIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4gbWVtb2l6ZWQ7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbW9pemUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL21pbi1ieS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbWluLWJ5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVhY2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2VhY2guanNcIik7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbnZhciBpc19mdW5jdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1mdW5jdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWZ1bmN0aW9uLmpzXCIpO1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAqXG4gKiBtaW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICogLy8gPT4geyAnbic6IDEgfVxuICpcbiAqIG1pbkJ5KG9iamVjdHMsICduJyk7XG4gKiAvLyA9PiB7ICduJzogMSB9XG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoYXJyLCBmbikge1xuICAgIGlmICghaXNfYXJyYXlfMS5kZWZhdWx0KGFycikpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIG1pbiA9IGFyclswXTtcbiAgICB2YXIgbWluRGF0YTtcbiAgICBpZiAoaXNfZnVuY3Rpb25fMS5kZWZhdWx0KGZuKSkge1xuICAgICAgICBtaW5EYXRhID0gZm4oYXJyWzBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1pbkRhdGEgPSBhcnJbMF1bZm5dO1xuICAgIH1cbiAgICB2YXIgZGF0YTtcbiAgICBlYWNoXzEuZGVmYXVsdChhcnIsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgaWYgKGlzX2Z1bmN0aW9uXzEuZGVmYXVsdChmbikpIHtcbiAgICAgICAgICAgIGRhdGEgPSBmbih2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHZhbFtmbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEgPCBtaW5EYXRhKSB7XG4gICAgICAgICAgICBtaW4gPSB2YWw7XG4gICAgICAgICAgICBtaW5EYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtaW47XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pbi1ieS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbWl4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9taXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBGSVhNRTogTXV0YWJsZSBwYXJhbSBzaG91bGQgYmUgZm9yYmlkZGVuIGluIHN0YXRpYyBsYW5nLlxuZnVuY3Rpb24gX21peChkaXN0LCBvYmopIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkgIT09ICdjb25zdHJ1Y3RvcicgJiYgb2JqW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGlzdFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtaXgoZGlzdCwgc3JjMSwgc3JjMiwgc3JjMykge1xuICAgIGlmIChzcmMxKVxuICAgICAgICBfbWl4KGRpc3QsIHNyYzEpO1xuICAgIGlmIChzcmMyKVxuICAgICAgICBfbWl4KGRpc3QsIHNyYzIpO1xuICAgIGlmIChzcmMzKVxuICAgICAgICBfbWl4KGRpc3QsIHNyYzMpO1xuICAgIHJldHVybiBkaXN0O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gbWl4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWl4LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9tb2QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL21vZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtb2QgPSBmdW5jdGlvbiAobiwgbSkge1xuICAgIHJldHVybiAoKG4gJSBtKSArIG0pICUgbTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBtb2Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2QuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL25vb3AuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9ub29wLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoKSB7IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9vcC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbnVtYmVyMmNvbG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9udW1iZXIyY29sb3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbnVtQ29sb3JDYWNoZSA9IHt9O1xuZnVuY3Rpb24gbnVtYmVyVG9Db2xvcihudW0pIHtcbiAgICAvLyDlop7liqDnvJPlrZhcbiAgICB2YXIgY29sb3IgPSBudW1Db2xvckNhY2hlW251bV07XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgICB2YXIgc3RyID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0ci5sZW5ndGg7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIHN0ciA9ICcwJyArIHN0cjtcbiAgICAgICAgfVxuICAgICAgICBjb2xvciA9ICcjJyArIHN0cjtcbiAgICAgICAgbnVtQ29sb3JDYWNoZVtudW1dID0gY29sb3I7XG4gICAgfVxuICAgIHJldHVybiBjb2xvcjtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IG51bWJlclRvQ29sb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIyY29sb3IuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3BhcnNlLXJhZGl1cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcGFyc2UtcmFkaXVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX2FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXkuanNcIik7XG5mdW5jdGlvbiBwYXJzZVJhZGl1cyhyYWRpdXMpIHtcbiAgICB2YXIgcjEgPSAwLCByMiA9IDAsIHIzID0gMCwgcjQgPSAwO1xuICAgIGlmIChpc19hcnJheV8xLmRlZmF1bHQocmFkaXVzKSkge1xuICAgICAgICBpZiAocmFkaXVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSByYWRpdXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmFkaXVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgcjEgPSByMyA9IHJhZGl1c1swXTtcbiAgICAgICAgICAgIHIyID0gcjQgPSByYWRpdXNbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmFkaXVzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgcjEgPSByYWRpdXNbMF07XG4gICAgICAgICAgICByMiA9IHI0ID0gcmFkaXVzWzFdO1xuICAgICAgICAgICAgcjMgPSByYWRpdXNbMl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByMSA9IHJhZGl1c1swXTtcbiAgICAgICAgICAgIHIyID0gcmFkaXVzWzFdO1xuICAgICAgICAgICAgcjMgPSByYWRpdXNbMl07XG4gICAgICAgICAgICByNCA9IHJhZGl1c1szXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSByYWRpdXM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHIxOiByMSxcbiAgICAgICAgcjI6IHIyLFxuICAgICAgICByMzogcjMsXG4gICAgICAgIHI0OiByNFxuICAgIH07XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZVJhZGl1cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLXJhZGl1cy5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcGljay5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3BpY2suanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVhY2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2VhY2guanNcIik7XG52YXIgaXNfcGxhaW5fb2JqZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXBsYWluLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXBsYWluLW9iamVjdC5qc1wiKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKG9iamVjdCwga2V5cykge1xuICAgIGlmIChvYmplY3QgPT09IG51bGwgfHwgIWlzX3BsYWluX29iamVjdF8xLmRlZmF1bHQob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBlYWNoXzEuZGVmYXVsdChrZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBpY2suanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3B1bGwtYXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9wdWxsLWF0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19hcnJheV9saWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5LWxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS1saWtlLmpzXCIpO1xudmFyIHNwbGljZSA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2U7XG52YXIgcHVsbEF0ID0gZnVuY3Rpb24gcHVsbEF0KGFyciwgaW5kZXhlcykge1xuICAgIGlmICghaXNfYXJyYXlfbGlrZV8xLmRlZmF1bHQoYXJyKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBhcnIgPyBpbmRleGVzLmxlbmd0aCA6IDA7XG4gICAgdmFyIGxhc3QgPSBsZW5ndGggLSAxO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgcHJldmlvdXMgPSB2b2lkIDA7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gbGFzdCB8fCBpbmRleCAhPT0gcHJldmlvdXMpIHtcbiAgICAgICAgICAgIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChhcnIsIGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHB1bGxBdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1bGwtYXQuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3B1bGwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9wdWxsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhcnJQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG52YXIgc3BsaWNlID0gYXJyUHJvdG90eXBlLnNwbGljZTtcbnZhciBpbmRleE9mID0gYXJyUHJvdG90eXBlLmluZGV4T2Y7XG52YXIgcHVsbCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFsdWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKChmcm9tSW5kZXggPSBpbmRleE9mLmNhbGwoYXJyLCB2YWx1ZSkpID4gLTEpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFyciwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHB1bGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdWxsLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9yZWR1Y2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3JlZHVjZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlYWNoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9lYWNoLmpzXCIpO1xudmFyIGlzX2FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXkuanNcIik7XG52YXIgaXNfcGxhaW5fb2JqZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXBsYWluLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXBsYWluLW9iamVjdC5qc1wiKTtcbnZhciByZWR1Y2UgPSBmdW5jdGlvbiAoYXJyLCBmbiwgaW5pdCkge1xuICAgIGlmICghaXNfYXJyYXlfMS5kZWZhdWx0KGFycikgJiYgIWlzX3BsYWluX29iamVjdF8xLmRlZmF1bHQoYXJyKSkge1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gaW5pdDtcbiAgICBlYWNoXzEuZGVmYXVsdChhcnIsIGZ1bmN0aW9uIChkYXRhLCBpKSB7XG4gICAgICAgIHJlc3VsdCA9IGZuKHJlc3VsdCwgZGF0YSwgaSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSByZWR1Y2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1Y2UuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3JlbW92ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcmVtb3ZlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX2FycmF5X2xpa2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXktbGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LWxpa2UuanNcIik7XG52YXIgcHVsbF9hdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wdWxsLWF0ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcHVsbC1hdC5qc1wiKTtcbnZhciByZW1vdmUgPSBmdW5jdGlvbiAoYXJyLCBwcmVkaWNhdGUpIHtcbiAgICAvKipcbiAgICAgKiBjb25zdCBhcnIgPSBbMSwgMiwgMywgNF1cbiAgICAgKiBjb25zdCBldmVucyA9IHJlbW92ZShhcnIsIG4gPT4gbiAlIDIgPT0gMClcbiAgICAgKiBjb25zb2xlLmxvZyhhcnIpIC8vID0+IFsxLCAzXVxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKSAvLyA9PiBbMiwgNF1cbiAgICAgKi9cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgaWYgKCFpc19hcnJheV9saWtlXzEuZGVmYXVsdChhcnIpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciBpID0gLTE7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycltpXTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaSwgYXJyKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1bGxfYXRfMS5kZWZhdWx0KGFyciwgaW5kZXhlcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSByZW1vdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3JlcXVlc3QtYW5pbWF0aW9uLWZyYW1lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3JlcXVlc3QtYW5pbWF0aW9uLWZyYW1lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pIHtcbiAgICB2YXIgbWV0aG9kID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZiwgMTYpO1xuICAgICAgICB9O1xuICAgIHJldHVybiBtZXRob2QoZm4pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC1hbmltYXRpb24tZnJhbWUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3NldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvc2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX29iamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1vYmplY3QuanNcIik7XG52YXIgaXNfc3RyaW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXN0cmluZy5qc1wiKTtcbnZhciBpc19udW1iZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtbnVtYmVyICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbnVtYmVyLmpzXCIpO1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L2Rsdi9ibG9iL21hc3Rlci9pbmRleC5qc1xuICogQHBhcmFtIG9ialxuICogQHBhcmFtIHBhdGhcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKG9iaiwgcGF0aCwgdmFsdWUpIHtcbiAgICB2YXIgbyA9IG9iajtcbiAgICB2YXIga2V5QXJyID0gaXNfc3RyaW5nXzEuZGVmYXVsdChwYXRoKSA/IHBhdGguc3BsaXQoJy4nKSA6IHBhdGg7XG4gICAga2V5QXJyLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaWR4KSB7XG4gICAgICAgIC8vIOS4jeaYr+acgOWQjuS4gOS4qlxuICAgICAgICBpZiAoaWR4IDwga2V5QXJyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGlmICghaXNfb2JqZWN0XzEuZGVmYXVsdChvW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgb1trZXldID0gaXNfbnVtYmVyXzEuZGVmYXVsdChrZXlBcnJbaWR4ICsgMV0pID8gW10gOiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG8gPSBvW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvc2l6ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3NpemUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX25pbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1uaWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1uaWwuanNcIik7XG52YXIgaXNfYXJyYXlfbGlrZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheS1saWtlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXktbGlrZS5qc1wiKTtcbmZ1bmN0aW9uIHNpemUobykge1xuICAgIGlmIChpc19uaWxfMS5kZWZhdWx0KG8pKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoaXNfYXJyYXlfbGlrZV8xLmRlZmF1bHQobykpIHtcbiAgICAgICAgcmV0dXJuIG8ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMobykubGVuZ3RoO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gc2l6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpemUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3NvbWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9zb21lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICog5Y+q6KaB5pyJ5LiA5Liq5ruh6Laz5p2h5Lu25bCx6L+U5ZueIHRydWVcbiAqIEBwYXJhbSBhcnJcbiAqIEBwYXJhbSBmdW5jXG4gKi9cbnZhciBzb21lID0gZnVuY3Rpb24gKGFyciwgZnVuYykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmdW5jKGFycltpXSwgaSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHNvbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb21lLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9zb3J0LWJ5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvc29ydC1ieS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbnZhciBpc19zdHJpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtc3RyaW5nLmpzXCIpO1xudmFyIGlzX2Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWZ1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZnVuY3Rpb24uanNcIik7XG5mdW5jdGlvbiBzb3J0QnkoYXJyLCBrZXkpIHtcbiAgICB2YXIgY29tcGFyZXI7XG4gICAgaWYgKGlzX2Z1bmN0aW9uXzEuZGVmYXVsdChrZXkpKSB7XG4gICAgICAgIGNvbXBhcmVyID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGtleShhKSAtIGtleShiKTsgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBrZXlzXzEgPSBbXTtcbiAgICAgICAgaWYgKGlzX3N0cmluZ18xLmRlZmF1bHQoa2V5KSkge1xuICAgICAgICAgICAga2V5c18xLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc19hcnJheV8xLmRlZmF1bHQoa2V5KSkge1xuICAgICAgICAgICAga2V5c18xID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIGNvbXBhcmVyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c18xLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBrZXlzXzFbaV07XG4gICAgICAgICAgICAgICAgaWYgKGFbcHJvcF0gPiBiW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYVtwcm9wXSA8IGJbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhcnIuc29ydChjb21wYXJlcik7XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHNvcnRCeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnQtYnkuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3N0YXJ0cy13aXRoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3N0YXJ0cy13aXRoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbnZhciBpc19zdHJpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtc3RyaW5nLmpzXCIpO1xuZnVuY3Rpb24gc3RhcnRzV2l0aChhcnIsIGUpIHtcbiAgICByZXR1cm4gKGlzX2FycmF5XzEuZGVmYXVsdChhcnIpIHx8IGlzX3N0cmluZ18xLmRlZmF1bHQoYXJyKSkgPyBhcnJbMF0gPT09IGUgOiBmYWxzZTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHN0YXJ0c1dpdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGFydHMtd2l0aC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvc3Vic3RpdHV0ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3N1YnN0aXR1dGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gc3Vic3RpdHV0ZShzdHIsIG8pIHtcbiAgICBpZiAoIXN0ciB8fCAhbykge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFw/XFx7KFtee31dKylcXH0vZywgZnVuY3Rpb24gKG1hdGNoLCBuYW1lKSB7XG4gICAgICAgIGlmIChtYXRjaC5jaGFyQXQoMCkgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAob1tuYW1lXSA9PT0gdW5kZWZpbmVkKSA/ICcnIDogb1tuYW1lXTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHN1YnN0aXR1dGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzdGl0dXRlLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi90aHJvdHRsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi90aHJvdHRsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIHRpbWVvdXQsIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IERhdGUubm93KCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpXG4gICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgdGhyb3R0bGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIGlmICghdGltZW91dClcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICB0aHJvdHRsZWQuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHByZXZpb3VzID0gMDtcbiAgICAgICAgdGltZW91dCA9IGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiB0aHJvdHRsZWQ7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRocm90dGxlLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi90by1hcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi90by1hcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX2FycmF5X2xpa2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXktbGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LWxpa2UuanNcIik7XG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzX2FycmF5X2xpa2VfMS5kZWZhdWx0KHZhbHVlKSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHZhbHVlKSA6IFtdO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10by1hcnJheS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdG8tZGVncmVlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi90by1kZWdyZWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgREVHUkVFID0gMTgwIC8gTWF0aC5QSTtcbnZhciB0b0RlZ3JlZSA9IGZ1bmN0aW9uIChyYWRpYW4pIHtcbiAgICByZXR1cm4gREVHUkVFICogcmFkaWFuO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvRGVncmVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG8tZGVncmVlLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi90by1pbnRlZ2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdG8taW50ZWdlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZUludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvLWludGVnZXIuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3RvLXJhZGlhbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdG8tcmFkaWFuLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJBRElBTiA9IE1hdGguUEkgLyAxODA7XG52YXIgdG9SYWRpYW4gPSBmdW5jdGlvbiAoZGVncmVlKSB7XG4gICAgcmV0dXJuIFJBRElBTiAqIGRlZ3JlZTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSB0b1JhZGlhbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvLXJhZGlhbi5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdG8tc3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi90by1zdHJpbmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfbmlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW5pbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW5pbC5qc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoaXNfbmlsXzEuZGVmYXVsdCh2YWx1ZSkpXG4gICAgICAgIHJldHVybiAnJztcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG8tc3RyaW5nLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi91bmlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi91bmlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHVuaXFfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdW5pcSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3VuaXEuanNcIik7XG52YXIgdW5pb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBzb3VyY2VzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiB1bmlxXzEuZGVmYXVsdChbXS5jb25jYXQuYXBwbHkoW10sIHNvdXJjZXMpKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSB1bmlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaW9uLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi91bmlxLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdW5pcS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGFpbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udGFpbnMgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9jb250YWlucy5qc1wiKTtcbnZhciBlYWNoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9lYWNoLmpzXCIpO1xudmFyIHVuaXEgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIHJlc3VsdEFyciA9IFtdO1xuICAgIGVhY2hfMS5kZWZhdWx0KGFyciwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFjb250YWluc18xLmRlZmF1bHQocmVzdWx0QXJyLCBpdGVtKSkge1xuICAgICAgICAgICAgcmVzdWx0QXJyLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0QXJyO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHVuaXE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmlxLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi91bmlxdWUtaWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3VuaXF1ZS1pZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtYXAgPSB7fTtcbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgcHJlZml4ID0gcHJlZml4IHx8ICdnJztcbiAgICBpZiAoIW1hcFtwcmVmaXhdKSB7XG4gICAgICAgIG1hcFtwcmVmaXhdID0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1hcFtwcmVmaXhdICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBwcmVmaXggKyBtYXBbcHJlZml4XTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pcXVlLWlkLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi91cHBlci1jYXNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdXBwZXItY2FzZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdG9fc3RyaW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3RvLXN0cmluZy5qc1wiKTtcbnZhciB1cHBlckNhc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHRvX3N0cmluZ18xLmRlZmF1bHQoc3RyKS50b1VwcGVyQ2FzZSgpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHVwcGVyQ2FzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVwcGVyLWNhc2UuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3VwcGVyLWZpcnN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3VwcGVyLWZpcnN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdG9fc3RyaW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3RvLXN0cmluZy5qc1wiKTtcbnZhciB1cHBlckZpcnN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHN0ciA9IHRvX3N0cmluZ18xLmRlZmF1bHQodmFsdWUpO1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHVwcGVyRmlyc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cHBlci1maXJzdC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdmFsdWVzLW9mLWtleS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3ZhbHVlcy1vZi1rZXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVhY2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2VhY2guanNcIik7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbnZhciBpc19uaWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtbmlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbmlsLmpzXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChkYXRhLCBuYW1lKSB7XG4gICAgdmFyIHJzdCA9IFtdO1xuICAgIHZhciB0bXBNYXAgPSB7fTtcbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpbbmFtZV07XG4gICAgICAgIGlmICghaXNfbmlsXzEuZGVmYXVsdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIGZsYXR0ZW5cbiAgICAgICAgICAgIGlmICghaXNfYXJyYXlfMS5kZWZhdWx0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVhY2hfMS5kZWZhdWx0KHZhbHVlLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gdW5pcXVlXG4gICAgICAgICAgICAgICAgaWYgKCF0bXBNYXBbdmFsXSkge1xuICAgICAgICAgICAgICAgICAgICByc3QucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB0bXBNYXBbdmFsXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcnN0O1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWx1ZXMtb2Yta2V5LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi92YWx1ZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3ZhbHVlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlYWNoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9lYWNoLmpzXCIpO1xudmFyIGlzX2Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWZ1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZnVuY3Rpb24uanNcIik7XG4vLyBAdHMtaWdub3JlXG52YXIgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIE9iamVjdC52YWx1ZXMob2JqKTsgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZWFjaF8xLmRlZmF1bHQob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoIShpc19mdW5jdGlvbl8xLmRlZmF1bHQob2JqKSAmJiBrZXkgPT09ICdwcm90b3R5cGUnKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSB2YWx1ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWx1ZXMuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3dyYXAtYmVoYXZpb3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi93cmFwLWJlaGF2aW9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICog5bCB6KOF5LqL5Lu277yM5L6/5LqO5L2/55So5LiK5LiL5paHdGhpcyzlkozkvr/kuo7op6PpmaTkuovku7bml7bkvb/nlKhcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqICAg5a+56LGhXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGFjdGlvbiDkuovku7blkI3np7BcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAgICAgICAg6L+U5Zue5LqL5Lu25aSE55CG5Ye95pWwXG4gKi9cbmZ1bmN0aW9uIHdyYXBCZWhhdmlvcihvYmosIGFjdGlvbikge1xuICAgIGlmIChvYmpbJ193cmFwXycgKyBhY3Rpb25dKSB7XG4gICAgICAgIHJldHVybiBvYmpbJ193cmFwXycgKyBhY3Rpb25dO1xuICAgIH1cbiAgICB2YXIgbWV0aG9kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgb2JqW2FjdGlvbl0oZSk7XG4gICAgfTtcbiAgICBvYmpbJ193cmFwXycgKyBhY3Rpb25dID0gbWV0aG9kO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB3cmFwQmVoYXZpb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13cmFwLWJlaGF2aW9yLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fYWJzLXN2Zy1wYXRoQDAuMS4xQGFicy1zdmctcGF0aC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fYWJzLXN2Zy1wYXRoQDAuMS4xQGFicy1zdmctcGF0aC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cbm1vZHVsZS5leHBvcnRzID0gYWJzb2x1dGl6ZVxuXG4vKipcbiAqIHJlZGVmaW5lIGBwYXRoYCB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGF0aFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gYWJzb2x1dGl6ZShwYXRoKXtcblx0dmFyIHN0YXJ0WCA9IDBcblx0dmFyIHN0YXJ0WSA9IDBcblx0dmFyIHggPSAwXG5cdHZhciB5ID0gMFxuXG5cdHJldHVybiBwYXRoLm1hcChmdW5jdGlvbihzZWcpe1xuXHRcdHNlZyA9IHNlZy5zbGljZSgpXG5cdFx0dmFyIHR5cGUgPSBzZWdbMF1cblx0XHR2YXIgY29tbWFuZCA9IHR5cGUudG9VcHBlckNhc2UoKVxuXG5cdFx0Ly8gaXMgcmVsYXRpdmVcblx0XHRpZiAodHlwZSAhPSBjb21tYW5kKSB7XG5cdFx0XHRzZWdbMF0gPSBjb21tYW5kXG5cdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0Y2FzZSAnYSc6XG5cdFx0XHRcdFx0c2VnWzZdICs9IHhcblx0XHRcdFx0XHRzZWdbN10gKz0geVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgJ3YnOlxuXHRcdFx0XHRcdHNlZ1sxXSArPSB5XG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSAnaCc6XG5cdFx0XHRcdFx0c2VnWzFdICs9IHhcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgc2VnLmxlbmd0aDspIHtcblx0XHRcdFx0XHRcdHNlZ1tpKytdICs9IHhcblx0XHRcdFx0XHRcdHNlZ1tpKytdICs9IHlcblx0XHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIGN1cnNvciBzdGF0ZVxuXHRcdHN3aXRjaCAoY29tbWFuZCkge1xuXHRcdFx0Y2FzZSAnWic6XG5cdFx0XHRcdHggPSBzdGFydFhcblx0XHRcdFx0eSA9IHN0YXJ0WVxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAnSCc6XG5cdFx0XHRcdHggPSBzZWdbMV1cblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgJ1YnOlxuXHRcdFx0XHR5ID0gc2VnWzFdXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICdNJzpcblx0XHRcdFx0eCA9IHN0YXJ0WCA9IHNlZ1sxXVxuXHRcdFx0XHR5ID0gc3RhcnRZID0gc2VnWzJdXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR4ID0gc2VnW3NlZy5sZW5ndGggLSAyXVxuXHRcdFx0XHR5ID0gc2VnW3NlZy5sZW5ndGggLSAxXVxuXHRcdH1cblxuXHRcdHJldHVybiBzZWdcblx0fSlcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtYXJyYXlAMS4yLjRAZDMtYXJyYXkvZGlzdC9kMy1hcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZDMtYXJyYXlAMS4yLjRAZDMtYXJyYXkvZGlzdC9kMy1hcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBodHRwczovL2QzanMub3JnL2QzLWFycmF5LyB2MS4yLjQgQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgICB0cnVlID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmlzZWN0b3IoY29tcGFyZSkge1xuICAgICAgICBpZiAoY29tcGFyZS5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICBjb21wYXJlID0gYXNjZW5kaW5nQ29tcGFyYXRvcihjb21wYXJlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGZ1bmN0aW9uIChhLCB4LCBsbywgaGkpIHtcbiAgICAgICAgICAgICAgICBpZiAobG8gPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICAgICAgICAgIGlmIChoaSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBoaSA9IGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsbztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByaWdodDogZnVuY3Rpb24gKGEsIHgsIGxvLCBoaSkge1xuICAgICAgICAgICAgICAgIGlmIChsbyA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBsbyA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhpID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGhpID0gYS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc2NlbmRpbmdDb21wYXJhdG9yKGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCB4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXNjZW5kaW5nKGYoZCksIHgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgYXNjZW5kaW5nQmlzZWN0ID0gYmlzZWN0b3IoYXNjZW5kaW5nKTtcbiAgICB2YXIgYmlzZWN0UmlnaHQgPSBhc2NlbmRpbmdCaXNlY3QucmlnaHQ7XG4gICAgdmFyIGJpc2VjdExlZnQgPSBhc2NlbmRpbmdCaXNlY3QubGVmdDtcbiAgICBmdW5jdGlvbiBwYWlycyhhcnJheSwgZikge1xuICAgICAgICBpZiAoZiA9PSBudWxsKVxuICAgICAgICAgICAgZiA9IHBhaXI7XG4gICAgICAgIHZhciBpID0gMCwgbiA9IGFycmF5Lmxlbmd0aCAtIDEsIHAgPSBhcnJheVswXSwgcGFpcnMgPSBuZXcgQXJyYXkobiA8IDAgPyAwIDogbik7XG4gICAgICAgIHdoaWxlIChpIDwgbilcbiAgICAgICAgICAgIHBhaXJzW2ldID0gZihwLCBwID0gYXJyYXlbKytpXSk7XG4gICAgICAgIHJldHVybiBwYWlycztcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFpcihhLCBiKSB7XG4gICAgICAgIHJldHVybiBbYSwgYl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyb3NzKHZhbHVlczAsIHZhbHVlczEsIHJlZHVjZSkge1xuICAgICAgICB2YXIgbjAgPSB2YWx1ZXMwLmxlbmd0aCwgbjEgPSB2YWx1ZXMxLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KG4wICogbjEpLCBpMCwgaTEsIGksIHZhbHVlMDtcbiAgICAgICAgaWYgKHJlZHVjZSA9PSBudWxsKVxuICAgICAgICAgICAgcmVkdWNlID0gcGFpcjtcbiAgICAgICAgZm9yIChpMCA9IGkgPSAwOyBpMCA8IG4wOyArK2kwKSB7XG4gICAgICAgICAgICBmb3IgKHZhbHVlMCA9IHZhbHVlczBbaTBdLCBpMSA9IDA7IGkxIDwgbjE7ICsraTEsICsraSkge1xuICAgICAgICAgICAgICAgIHZhbHVlc1tpXSA9IHJlZHVjZSh2YWx1ZTAsIHZhbHVlczFbaTFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xuICAgIH1cbiAgICBmdW5jdGlvbiBudW1iZXIoeCkge1xuICAgICAgICByZXR1cm4geCA9PT0gbnVsbCA/IE5hTiA6ICt4O1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YXJpYW5jZSh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgICAgICAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLCBtID0gMCwgaSA9IC0xLCBtZWFuID0gMCwgdmFsdWUsIGRlbHRhLCBzdW0gPSAwO1xuICAgICAgICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSB2YWx1ZSAtIG1lYW47XG4gICAgICAgICAgICAgICAgICAgIG1lYW4gKz0gZGVsdGEgLyArK207XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBkZWx0YSAqICh2YWx1ZSAtIG1lYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gdmFsdWUgLSBtZWFuO1xuICAgICAgICAgICAgICAgICAgICBtZWFuICs9IGRlbHRhIC8gKyttO1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gZGVsdGEgKiAodmFsdWUgLSBtZWFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0gPiAxKVxuICAgICAgICAgICAgcmV0dXJuIHN1bSAvIChtIC0gMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRldmlhdGlvbihhcnJheSwgZikge1xuICAgICAgICB2YXIgdiA9IHZhcmlhbmNlKGFycmF5LCBmKTtcbiAgICAgICAgcmV0dXJuIHYgPyBNYXRoLnNxcnQodikgOiB2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBleHRlbnQodmFsdWVzLCB2YWx1ZW9mKSB7XG4gICAgICAgIHZhciBuID0gdmFsdWVzLmxlbmd0aCwgaSA9IC0xLCB2YWx1ZSwgbWluLCBtYXg7XG4gICAgICAgIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluID4gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXggPCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW4gPiB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heCA8IHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9XG4gICAgdmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xuICAgIHZhciBzbGljZSA9IGFycmF5LnNsaWNlO1xuICAgIHZhciBtYXAgPSBhcnJheS5tYXA7XG4gICAgZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICAgIHN0YXJ0ID0gK3N0YXJ0LCBzdG9wID0gK3N0b3AsIHN0ZXAgPSAobiA9IGFyZ3VtZW50cy5sZW5ndGgpIDwgMiA/IChzdG9wID0gc3RhcnQsIHN0YXJ0ID0gMCwgMSkgOiBuIDwgMyA/IDEgOiArc3RlcDtcbiAgICAgICAgdmFyIGkgPSAtMSwgbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApKSB8IDAsIHJhbmdlID0gbmV3IEFycmF5KG4pO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgcmFuZ2VbaV0gPSBzdGFydCArIGkgKiBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gICAgdmFyIGUxMCA9IE1hdGguc3FydCg1MCksIGU1ID0gTWF0aC5zcXJ0KDEwKSwgZTIgPSBNYXRoLnNxcnQoMik7XG4gICAgZnVuY3Rpb24gdGlja3Moc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gICAgICAgIHZhciByZXZlcnNlLCBpID0gLTEsIG4sIHRpY2tzLCBzdGVwO1xuICAgICAgICBzdG9wID0gK3N0b3AsIHN0YXJ0ID0gK3N0YXJ0LCBjb3VudCA9ICtjb3VudDtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBzdG9wICYmIGNvdW50ID4gMClcbiAgICAgICAgICAgIHJldHVybiBbc3RhcnRdO1xuICAgICAgICBpZiAocmV2ZXJzZSA9IHN0b3AgPCBzdGFydClcbiAgICAgICAgICAgIG4gPSBzdGFydCwgc3RhcnQgPSBzdG9wLCBzdG9wID0gbjtcbiAgICAgICAgaWYgKChzdGVwID0gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpKSA9PT0gMCB8fCAhaXNGaW5pdGUoc3RlcCkpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLmNlaWwoc3RhcnQgLyBzdGVwKTtcbiAgICAgICAgICAgIHN0b3AgPSBNYXRoLmZsb29yKHN0b3AgLyBzdGVwKTtcbiAgICAgICAgICAgIHRpY2tzID0gbmV3IEFycmF5KG4gPSBNYXRoLmNlaWwoc3RvcCAtIHN0YXJ0ICsgMSkpO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgdGlja3NbaV0gPSAoc3RhcnQgKyBpKSAqIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQgKiBzdGVwKTtcbiAgICAgICAgICAgIHN0b3AgPSBNYXRoLmNlaWwoc3RvcCAqIHN0ZXApO1xuICAgICAgICAgICAgdGlja3MgPSBuZXcgQXJyYXkobiA9IE1hdGguY2VpbChzdGFydCAtIHN0b3AgKyAxKSk7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICB0aWNrc1tpXSA9IChzdGFydCAtIGkpIC8gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV2ZXJzZSlcbiAgICAgICAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIHRpY2tzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICAgICAgICB2YXIgc3RlcCA9IChzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoMCwgY291bnQpLCBwb3dlciA9IE1hdGguZmxvb3IoTWF0aC5sb2coc3RlcCkgLyBNYXRoLkxOMTApLCBlcnJvciA9IHN0ZXAgLyBNYXRoLnBvdygxMCwgcG93ZXIpO1xuICAgICAgICByZXR1cm4gcG93ZXIgPj0gMFxuICAgICAgICAgICAgPyAoZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxKSAqIE1hdGgucG93KDEwLCBwb3dlcilcbiAgICAgICAgICAgIDogLU1hdGgucG93KDEwLCAtcG93ZXIpIC8gKGVycm9yID49IGUxMCA/IDEwIDogZXJyb3IgPj0gZTUgPyA1IDogZXJyb3IgPj0gZTIgPyAyIDogMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICAgICAgICB2YXIgc3RlcDAgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoMCwgY291bnQpLCBzdGVwMSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKHN0ZXAwKSAvIE1hdGguTE4xMCkpLCBlcnJvciA9IHN0ZXAwIC8gc3RlcDE7XG4gICAgICAgIGlmIChlcnJvciA+PSBlMTApXG4gICAgICAgICAgICBzdGVwMSAqPSAxMDtcbiAgICAgICAgZWxzZSBpZiAoZXJyb3IgPj0gZTUpXG4gICAgICAgICAgICBzdGVwMSAqPSA1O1xuICAgICAgICBlbHNlIGlmIChlcnJvciA+PSBlMilcbiAgICAgICAgICAgIHN0ZXAxICo9IDI7XG4gICAgICAgIHJldHVybiBzdG9wIDwgc3RhcnQgPyAtc3RlcDEgOiBzdGVwMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3R1cmdlcyh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChNYXRoLmxvZyh2YWx1ZXMubGVuZ3RoKSAvIE1hdGguTE4yKSArIDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhpc3RvZ3JhbSgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaWRlbnRpdHksIGRvbWFpbiA9IGV4dGVudCwgdGhyZXNob2xkID0gc3R1cmdlcztcbiAgICAgICAgZnVuY3Rpb24gaGlzdG9ncmFtKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBpLCBuID0gZGF0YS5sZW5ndGgsIHgsIHZhbHVlcyA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaV0gPSB2YWx1ZShkYXRhW2ldLCBpLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB4eiA9IGRvbWFpbih2YWx1ZXMpLCB4MCA9IHh6WzBdLCB4MSA9IHh6WzFdLCB0eiA9IHRocmVzaG9sZCh2YWx1ZXMsIHgwLCB4MSk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IG51bWJlciBvZiB0aHJlc2hvbGRzIGludG8gdW5pZm9ybSB0aHJlc2hvbGRzLlxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHR6KSkge1xuICAgICAgICAgICAgICAgIHR6ID0gdGlja1N0ZXAoeDAsIHgxLCB0eik7XG4gICAgICAgICAgICAgICAgdHogPSByYW5nZShNYXRoLmNlaWwoeDAgLyB0eikgKiB0eiwgeDEsIHR6KTsgLy8gZXhjbHVzaXZlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgYW55IHRocmVzaG9sZHMgb3V0c2lkZSB0aGUgZG9tYWluLlxuICAgICAgICAgICAgdmFyIG0gPSB0ei5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAodHpbMF0gPD0geDApXG4gICAgICAgICAgICAgICAgdHouc2hpZnQoKSwgLS1tO1xuICAgICAgICAgICAgd2hpbGUgKHR6W20gLSAxXSA+IHgxKVxuICAgICAgICAgICAgICAgIHR6LnBvcCgpLCAtLW07XG4gICAgICAgICAgICB2YXIgYmlucyA9IG5ldyBBcnJheShtICsgMSksIGJpbjtcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgYmlucy5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gbTsgKytpKSB7XG4gICAgICAgICAgICAgICAgYmluID0gYmluc1tpXSA9IFtdO1xuICAgICAgICAgICAgICAgIGJpbi54MCA9IGkgPiAwID8gdHpbaSAtIDFdIDogeDA7XG4gICAgICAgICAgICAgICAgYmluLngxID0gaSA8IG0gPyB0eltpXSA6IHgxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXNzaWduIGRhdGEgdG8gYmlucyBieSB2YWx1ZSwgaWdub3JpbmcgYW55IG91dHNpZGUgdGhlIGRvbWFpbi5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB4ID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh4MCA8PSB4ICYmIHggPD0geDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYmluc1tiaXNlY3RSaWdodCh0eiwgeCwgMCwgbSldLnB1c2goZGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJpbnM7XG4gICAgICAgIH1cbiAgICAgICAgaGlzdG9ncmFtLnZhbHVlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgaGlzdG9ncmFtKSA6IHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBoaXN0b2dyYW0uZG9tYWluID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoW19bMF0sIF9bMV1dKSwgaGlzdG9ncmFtKSA6IGRvbWFpbjtcbiAgICAgICAgfTtcbiAgICAgICAgaGlzdG9ncmFtLnRocmVzaG9sZHMgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhyZXNob2xkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBBcnJheS5pc0FycmF5KF8pID8gY29uc3RhbnQoc2xpY2UuY2FsbChfKSkgOiBjb25zdGFudChfKSwgaGlzdG9ncmFtKSA6IHRocmVzaG9sZDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGhpc3RvZ3JhbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcXVhbnRpbGUodmFsdWVzLCBwLCB2YWx1ZW9mKSB7XG4gICAgICAgIGlmICh2YWx1ZW9mID09IG51bGwpXG4gICAgICAgICAgICB2YWx1ZW9mID0gbnVtYmVyO1xuICAgICAgICBpZiAoIShuID0gdmFsdWVzLmxlbmd0aCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICgocCA9ICtwKSA8PSAwIHx8IG4gPCAyKVxuICAgICAgICAgICAgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1swXSwgMCwgdmFsdWVzKTtcbiAgICAgICAgaWYgKHAgPj0gMSlcbiAgICAgICAgICAgIHJldHVybiArdmFsdWVvZih2YWx1ZXNbbiAtIDFdLCBuIC0gMSwgdmFsdWVzKTtcbiAgICAgICAgdmFyIG4sIGkgPSAobiAtIDEpICogcCwgaTAgPSBNYXRoLmZsb29yKGkpLCB2YWx1ZTAgPSArdmFsdWVvZih2YWx1ZXNbaTBdLCBpMCwgdmFsdWVzKSwgdmFsdWUxID0gK3ZhbHVlb2YodmFsdWVzW2kwICsgMV0sIGkwICsgMSwgdmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlMCArICh2YWx1ZTEgLSB2YWx1ZTApICogKGkgLSBpMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZyZWVkbWFuRGlhY29uaXModmFsdWVzLCBtaW4sIG1heCkge1xuICAgICAgICB2YWx1ZXMgPSBtYXAuY2FsbCh2YWx1ZXMsIG51bWJlcikuc29ydChhc2NlbmRpbmcpO1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKDIgKiAocXVhbnRpbGUodmFsdWVzLCAwLjc1KSAtIHF1YW50aWxlKHZhbHVlcywgMC4yNSkpICogTWF0aC5wb3codmFsdWVzLmxlbmd0aCwgLTEgLyAzKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY290dCh2YWx1ZXMsIG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoMy41ICogZGV2aWF0aW9uKHZhbHVlcykgKiBNYXRoLnBvdyh2YWx1ZXMubGVuZ3RoLCAtMSAvIDMpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1heCh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgICAgICAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLCBpID0gLTEsIHZhbHVlLCBtYXg7XG4gICAgICAgIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgdmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVhbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgICAgICAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLCBtID0gbiwgaSA9IC0xLCB2YWx1ZSwgc3VtID0gMDtcbiAgICAgICAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlc1tpXSkpKVxuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAtLW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpKSlcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgLS1tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtKVxuICAgICAgICAgICAgcmV0dXJuIHN1bSAvIG07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lZGlhbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgICAgICAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLCBpID0gLTEsIHZhbHVlLCBudW1iZXJzID0gW107XG4gICAgICAgIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZXNbaV0pKSkge1xuICAgICAgICAgICAgICAgICAgICBudW1iZXJzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlcnMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWFudGlsZShudW1iZXJzLnNvcnQoYXNjZW5kaW5nKSwgMC41KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVyZ2UoYXJyYXlzKSB7XG4gICAgICAgIHZhciBuID0gYXJyYXlzLmxlbmd0aCwgbSwgaSA9IC0xLCBqID0gMCwgbWVyZ2VkLCBhcnJheTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICBqICs9IGFycmF5c1tpXS5sZW5ndGg7XG4gICAgICAgIG1lcmdlZCA9IG5ldyBBcnJheShqKTtcbiAgICAgICAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgICAgICAgICBhcnJheSA9IGFycmF5c1tuXTtcbiAgICAgICAgICAgIG0gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoLS1tID49IDApIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRbLS1qXSA9IGFycmF5W21dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1pbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgICAgICAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLCBpID0gLTEsIHZhbHVlLCBtaW47XG4gICAgICAgIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgbWluID4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIG1pbiA+IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVybXV0ZShhcnJheSwgaW5kZXhlcykge1xuICAgICAgICB2YXIgaSA9IGluZGV4ZXMubGVuZ3RoLCBwZXJtdXRlcyA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgIHBlcm11dGVzW2ldID0gYXJyYXlbaW5kZXhlc1tpXV07XG4gICAgICAgIHJldHVybiBwZXJtdXRlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gc2Nhbih2YWx1ZXMsIGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbiwgaSA9IDAsIGogPSAwLCB4aSwgeGogPSB2YWx1ZXNbal07XG4gICAgICAgIGlmIChjb21wYXJlID09IG51bGwpXG4gICAgICAgICAgICBjb21wYXJlID0gYXNjZW5kaW5nO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmUoeGkgPSB2YWx1ZXNbaV0sIHhqKSA8IDAgfHwgY29tcGFyZSh4aiwgeGopICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgeGogPSB4aSwgaiA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBhcmUoeGosIHhqKSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBqO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGFycmF5LCBpMCwgaTEpIHtcbiAgICAgICAgdmFyIG0gPSAoaTEgPT0gbnVsbCA/IGFycmF5Lmxlbmd0aCA6IGkxKSAtIChpMCA9IGkwID09IG51bGwgPyAwIDogK2kwKSwgdCwgaTtcbiAgICAgICAgd2hpbGUgKG0pIHtcbiAgICAgICAgICAgIGkgPSBNYXRoLnJhbmRvbSgpICogbS0tIHwgMDtcbiAgICAgICAgICAgIHQgPSBhcnJheVttICsgaTBdO1xuICAgICAgICAgICAgYXJyYXlbbSArIGkwXSA9IGFycmF5W2kgKyBpMF07XG4gICAgICAgICAgICBhcnJheVtpICsgaTBdID0gdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1bSh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgICAgICAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLCBpID0gLTEsIHZhbHVlLCBzdW0gPSAwO1xuICAgICAgICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSB2YWx1ZTsgLy8gTm90ZTogemVybyBhbmQgbnVsbCBhcmUgZXF1aXZhbGVudC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKVxuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNwb3NlKG1hdHJpeCkge1xuICAgICAgICBpZiAoIShuID0gbWF0cml4Lmxlbmd0aCkpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAtMSwgbSA9IG1pbihtYXRyaXgsIGxlbmd0aCksIHRyYW5zcG9zZSA9IG5ldyBBcnJheShtKTsgKytpIDwgbTspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAtMSwgbiwgcm93ID0gdHJhbnNwb3NlW2ldID0gbmV3IEFycmF5KG4pOyArK2ogPCBuOykge1xuICAgICAgICAgICAgICAgIHJvd1tqXSA9IG1hdHJpeFtqXVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNwb3NlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZW5ndGgoZCkge1xuICAgICAgICByZXR1cm4gZC5sZW5ndGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHppcCgpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zcG9zZShhcmd1bWVudHMpO1xuICAgIH1cbiAgICBleHBvcnRzLmJpc2VjdCA9IGJpc2VjdFJpZ2h0O1xuICAgIGV4cG9ydHMuYmlzZWN0UmlnaHQgPSBiaXNlY3RSaWdodDtcbiAgICBleHBvcnRzLmJpc2VjdExlZnQgPSBiaXNlY3RMZWZ0O1xuICAgIGV4cG9ydHMuYXNjZW5kaW5nID0gYXNjZW5kaW5nO1xuICAgIGV4cG9ydHMuYmlzZWN0b3IgPSBiaXNlY3RvcjtcbiAgICBleHBvcnRzLmNyb3NzID0gY3Jvc3M7XG4gICAgZXhwb3J0cy5kZXNjZW5kaW5nID0gZGVzY2VuZGluZztcbiAgICBleHBvcnRzLmRldmlhdGlvbiA9IGRldmlhdGlvbjtcbiAgICBleHBvcnRzLmV4dGVudCA9IGV4dGVudDtcbiAgICBleHBvcnRzLmhpc3RvZ3JhbSA9IGhpc3RvZ3JhbTtcbiAgICBleHBvcnRzLnRocmVzaG9sZEZyZWVkbWFuRGlhY29uaXMgPSBmcmVlZG1hbkRpYWNvbmlzO1xuICAgIGV4cG9ydHMudGhyZXNob2xkU2NvdHQgPSBzY290dDtcbiAgICBleHBvcnRzLnRocmVzaG9sZFN0dXJnZXMgPSBzdHVyZ2VzO1xuICAgIGV4cG9ydHMubWF4ID0gbWF4O1xuICAgIGV4cG9ydHMubWVhbiA9IG1lYW47XG4gICAgZXhwb3J0cy5tZWRpYW4gPSBtZWRpYW47XG4gICAgZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuICAgIGV4cG9ydHMubWluID0gbWluO1xuICAgIGV4cG9ydHMucGFpcnMgPSBwYWlycztcbiAgICBleHBvcnRzLnBlcm11dGUgPSBwZXJtdXRlO1xuICAgIGV4cG9ydHMucXVhbnRpbGUgPSBxdWFudGlsZTtcbiAgICBleHBvcnRzLnJhbmdlID0gcmFuZ2U7XG4gICAgZXhwb3J0cy5zY2FuID0gc2NhbjtcbiAgICBleHBvcnRzLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGV4cG9ydHMuc3VtID0gc3VtO1xuICAgIGV4cG9ydHMudGlja3MgPSB0aWNrcztcbiAgICBleHBvcnRzLnRpY2tJbmNyZW1lbnQgPSB0aWNrSW5jcmVtZW50O1xuICAgIGV4cG9ydHMudGlja1N0ZXAgPSB0aWNrU3RlcDtcbiAgICBleHBvcnRzLnRyYW5zcG9zZSA9IHRyYW5zcG9zZTtcbiAgICBleHBvcnRzLnZhcmlhbmNlID0gdmFyaWFuY2U7XG4gICAgZXhwb3J0cy56aXAgPSB6aXA7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn0pKSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWNvbGxlY3Rpb25AMS4wLjdAZDMtY29sbGVjdGlvbi9kaXN0L2QzLWNvbGxlY3Rpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2QzLWNvbGxlY3Rpb25AMS4wLjdAZDMtY29sbGVjdGlvbi9kaXN0L2QzLWNvbGxlY3Rpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1jb2xsZWN0aW9uLyB2MS4wLjcgQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgICB0cnVlID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBwcmVmaXggPSBcIiRcIjtcbiAgICBmdW5jdGlvbiBNYXAoKSB7IH1cbiAgICBNYXAucHJvdG90eXBlID0gbWFwLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IE1hcCxcbiAgICAgICAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gKHByZWZpeCArIGtleSkgaW4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1twcmVmaXggKyBrZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzW3ByZWZpeCArIGtleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHByZWZpeCArIGtleTtcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmIGRlbGV0ZSB0aGlzW3Byb3BlcnR5XTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzW3Byb3BlcnR5XTtcbiAgICAgICAgfSxcbiAgICAgICAga2V5czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpXG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChwcm9wZXJ0eS5zbGljZSgxKSk7XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKVxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzW3Byb3BlcnR5XSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnRyaWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcylcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeClcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKHsga2V5OiBwcm9wZXJ0eS5zbGljZSgxKSwgdmFsdWU6IHRoaXNbcHJvcGVydHldIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpXG4gICAgICAgICAgICAgICAgICAgICsrc2l6ZTtcbiAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9LFxuICAgICAgICBlbXB0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcylcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKVxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KVxuICAgICAgICAgICAgICAgICAgICBmKHRoaXNbcHJvcGVydHldLCBwcm9wZXJ0eS5zbGljZSgxKSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIG1hcChvYmplY3QsIGYpIHtcbiAgICAgICAgdmFyIG1hcCA9IG5ldyBNYXA7XG4gICAgICAgIC8vIENvcHkgY29uc3RydWN0b3IuXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBNYXApXG4gICAgICAgICAgICBvYmplY3QuZWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkgeyBtYXAuc2V0KGtleSwgdmFsdWUpOyB9KTtcbiAgICAgICAgLy8gSW5kZXggYXJyYXkgYnkgbnVtZXJpYyBpbmRleCBvciBzcGVjaWZpZWQga2V5IGZ1bmN0aW9uLlxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgIHZhciBpID0gLTEsIG4gPSBvYmplY3QubGVuZ3RoLCBvO1xuICAgICAgICAgICAgaWYgKGYgPT0gbnVsbClcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICAgICAgbWFwLnNldChpLCBvYmplY3RbaV0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgICAgICBtYXAuc2V0KGYobyA9IG9iamVjdFtpXSwgaSwgb2JqZWN0KSwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydCBvYmplY3QgdG8gbWFwLlxuICAgICAgICBlbHNlIGlmIChvYmplY3QpXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KVxuICAgICAgICAgICAgICAgIG1hcC5zZXQoa2V5LCBvYmplY3Rba2V5XSk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5lc3QoKSB7XG4gICAgICAgIHZhciBrZXlzID0gW10sIHNvcnRLZXlzID0gW10sIHNvcnRWYWx1ZXMsIHJvbGx1cCwgbmVzdDtcbiAgICAgICAgZnVuY3Rpb24gYXBwbHkoYXJyYXksIGRlcHRoLCBjcmVhdGVSZXN1bHQsIHNldFJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlcHRoID49IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRWYWx1ZXMgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkuc29ydChzb3J0VmFsdWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9sbHVwICE9IG51bGwgPyByb2xsdXAoYXJyYXkpIDogYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaSA9IC0xLCBuID0gYXJyYXkubGVuZ3RoLCBrZXkgPSBrZXlzW2RlcHRoKytdLCBrZXlWYWx1ZSwgdmFsdWUsIHZhbHVlc0J5S2V5ID0gbWFwKCksIHZhbHVlcywgcmVzdWx0ID0gY3JlYXRlUmVzdWx0KCk7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMgPSB2YWx1ZXNCeUtleS5nZXQoa2V5VmFsdWUgPSBrZXkodmFsdWUgPSBhcnJheVtpXSkgKyBcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNCeUtleS5zZXQoa2V5VmFsdWUsIFt2YWx1ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlc0J5S2V5LmVhY2goZnVuY3Rpb24gKHZhbHVlcywga2V5KSB7XG4gICAgICAgICAgICAgICAgc2V0UmVzdWx0KHJlc3VsdCwga2V5LCBhcHBseSh2YWx1ZXMsIGRlcHRoLCBjcmVhdGVSZXN1bHQsIHNldFJlc3VsdCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVudHJpZXMobWFwJCQxLCBkZXB0aCkge1xuICAgICAgICAgICAgaWYgKCsrZGVwdGggPiBrZXlzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwJCQxO1xuICAgICAgICAgICAgdmFyIGFycmF5LCBzb3J0S2V5ID0gc29ydEtleXNbZGVwdGggLSAxXTtcbiAgICAgICAgICAgIGlmIChyb2xsdXAgIT0gbnVsbCAmJiBkZXB0aCA+PSBrZXlzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBhcnJheSA9IG1hcCQkMS5lbnRyaWVzKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYXJyYXkgPSBbXSwgbWFwJCQxLmVhY2goZnVuY3Rpb24gKHYsIGspIHsgYXJyYXkucHVzaCh7IGtleTogaywgdmFsdWVzOiBlbnRyaWVzKHYsIGRlcHRoKSB9KTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gc29ydEtleSAhPSBudWxsID8gYXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gc29ydEtleShhLmtleSwgYi5rZXkpOyB9KSA6IGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXN0ID0ge1xuICAgICAgICAgICAgb2JqZWN0OiBmdW5jdGlvbiAoYXJyYXkpIHsgcmV0dXJuIGFwcGx5KGFycmF5LCAwLCBjcmVhdGVPYmplY3QsIHNldE9iamVjdCk7IH0sXG4gICAgICAgICAgICBtYXA6IGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gYXBwbHkoYXJyYXksIDAsIGNyZWF0ZU1hcCwgc2V0TWFwKTsgfSxcbiAgICAgICAgICAgIGVudHJpZXM6IGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gZW50cmllcyhhcHBseShhcnJheSwgMCwgY3JlYXRlTWFwLCBzZXRNYXApLCAwKTsgfSxcbiAgICAgICAgICAgIGtleTogZnVuY3Rpb24gKGQpIHsga2V5cy5wdXNoKGQpOyByZXR1cm4gbmVzdDsgfSxcbiAgICAgICAgICAgIHNvcnRLZXlzOiBmdW5jdGlvbiAob3JkZXIpIHsgc29ydEtleXNba2V5cy5sZW5ndGggLSAxXSA9IG9yZGVyOyByZXR1cm4gbmVzdDsgfSxcbiAgICAgICAgICAgIHNvcnRWYWx1ZXM6IGZ1bmN0aW9uIChvcmRlcikgeyBzb3J0VmFsdWVzID0gb3JkZXI7IHJldHVybiBuZXN0OyB9LFxuICAgICAgICAgICAgcm9sbHVwOiBmdW5jdGlvbiAoZikgeyByb2xsdXAgPSBmOyByZXR1cm4gbmVzdDsgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0T2JqZWN0KG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVNYXAoKSB7XG4gICAgICAgIHJldHVybiBtYXAoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0TWFwKG1hcCQkMSwga2V5LCB2YWx1ZSkge1xuICAgICAgICBtYXAkJDEuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTZXQoKSB7IH1cbiAgICB2YXIgcHJvdG8gPSBtYXAucHJvdG90eXBlO1xuICAgIFNldC5wcm90b3R5cGUgPSBzZXQucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogU2V0LFxuICAgICAgICBoYXM6IHByb3RvLmhhcyxcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IFwiXCI7XG4gICAgICAgICAgICB0aGlzW3ByZWZpeCArIHZhbHVlXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogcHJvdG8ucmVtb3ZlLFxuICAgICAgICBjbGVhcjogcHJvdG8uY2xlYXIsXG4gICAgICAgIHZhbHVlczogcHJvdG8ua2V5cyxcbiAgICAgICAgc2l6ZTogcHJvdG8uc2l6ZSxcbiAgICAgICAgZW1wdHk6IHByb3RvLmVtcHR5LFxuICAgICAgICBlYWNoOiBwcm90by5lYWNoXG4gICAgfTtcbiAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBmKSB7XG4gICAgICAgIHZhciBzZXQgPSBuZXcgU2V0O1xuICAgICAgICAvLyBDb3B5IGNvbnN0cnVjdG9yLlxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgU2V0KVxuICAgICAgICAgICAgb2JqZWN0LmVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHNldC5hZGQodmFsdWUpOyB9KTtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgaXTigJlzIGFuIGFycmF5LlxuICAgICAgICBlbHNlIGlmIChvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBpID0gLTEsIG4gPSBvYmplY3QubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGYgPT0gbnVsbClcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICAgICAgc2V0LmFkZChvYmplY3RbaV0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgICAgICBzZXQuYWRkKGYob2JqZWN0W2ldLCBpLCBvYmplY3QpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBrZXlzKG1hcCkge1xuICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbWFwKVxuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWx1ZXMobWFwKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG1hcClcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG1hcFtrZXldKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50cmllcyhtYXApIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG1hcClcbiAgICAgICAgICAgIGVudHJpZXMucHVzaCh7IGtleToga2V5LCB2YWx1ZTogbWFwW2tleV0gfSk7XG4gICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgIH1cbiAgICBleHBvcnRzLm5lc3QgPSBuZXN0O1xuICAgIGV4cG9ydHMuc2V0ID0gc2V0O1xuICAgIGV4cG9ydHMubWFwID0gbWFwO1xuICAgIGV4cG9ydHMua2V5cyA9IGtleXM7XG4gICAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgZXhwb3J0cy5lbnRyaWVzID0gZW50cmllcztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufSkpKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtY29tcG9zaXRlLXByb2plY3Rpb25zQDEuMy4yQGQzLWNvbXBvc2l0ZS1wcm9qZWN0aW9ucy9kMy1jb21wb3NpdGUtcHJvamVjdGlvbnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kMy1jb21wb3NpdGUtcHJvamVjdGlvbnNAMS4zLjJAZDMtY29tcG9zaXRlLXByb2plY3Rpb25zL2QzLWNvbXBvc2l0ZS1wcm9qZWN0aW9ucy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gaHR0cDovL2dlb2V4YW1wbGVzLmNvbS9kMy1jb21wb3NpdGUtcHJvamVjdGlvbnMvIHYxLjMuMiBDb3B5cmlnaHQgMjAxOSBSb2dlciBWZWNpYW5hIGkgUm92aXJhXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgICB0cnVlID8gZmFjdG9yeShleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1nZW8gKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtZ2VvQDEuMTEuOUBkMy1nZW8vZGlzdC9kMy1nZW8uanNcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLXBhdGggKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtcGF0aEAxLjAuOUBkMy1wYXRoL2Rpc3QvZDMtcGF0aC5qc1wiKSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cywgZDNHZW8sIGQzUGF0aCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgZXBzaWxvbiA9IDFlLTY7XG4gICAgZnVuY3Rpb24gbm9vcCgpIHsgfVxuICAgIHZhciB4MCA9IEluZmluaXR5LCB5MCA9IHgwLCB4MSA9IC14MCwgeTEgPSB4MTtcbiAgICB2YXIgYm91bmRzU3RyZWFtID0ge1xuICAgICAgICBwb2ludDogYm91bmRzUG9pbnQsXG4gICAgICAgIGxpbmVTdGFydDogbm9vcCxcbiAgICAgICAgbGluZUVuZDogbm9vcCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBub29wLFxuICAgICAgICBwb2x5Z29uRW5kOiBub29wLFxuICAgICAgICByZXN1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICAgICAgICAgIHgxID0geTEgPSAtKHkwID0geDAgPSBJbmZpbml0eSk7XG4gICAgICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBib3VuZHNQb2ludCh4LCB5KSB7XG4gICAgICAgIGlmICh4IDwgeDApXG4gICAgICAgICAgICB4MCA9IHg7XG4gICAgICAgIGlmICh4ID4geDEpXG4gICAgICAgICAgICB4MSA9IHg7XG4gICAgICAgIGlmICh5IDwgeTApXG4gICAgICAgICAgICB5MCA9IHk7XG4gICAgICAgIGlmICh5ID4geTEpXG4gICAgICAgICAgICB5MSA9IHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpdEV4dGVudChwcm9qZWN0aW9uLCBleHRlbnQsIG9iamVjdCkge1xuICAgICAgICB2YXIgdyA9IGV4dGVudFsxXVswXSAtIGV4dGVudFswXVswXSwgaCA9IGV4dGVudFsxXVsxXSAtIGV4dGVudFswXVsxXSwgY2xpcCA9IHByb2plY3Rpb24uY2xpcEV4dGVudCAmJiBwcm9qZWN0aW9uLmNsaXBFeHRlbnQoKTtcbiAgICAgICAgcHJvamVjdGlvblxuICAgICAgICAgICAgLnNjYWxlKDE1MClcbiAgICAgICAgICAgIC50cmFuc2xhdGUoWzAsIDBdKTtcbiAgICAgICAgaWYgKGNsaXAgIT0gbnVsbClcbiAgICAgICAgICAgIHByb2plY3Rpb24uY2xpcEV4dGVudChudWxsKTtcbiAgICAgICAgZDNHZW8uZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvbi5zdHJlYW0oYm91bmRzU3RyZWFtKSk7XG4gICAgICAgIHZhciBiID0gYm91bmRzU3RyZWFtLnJlc3VsdCgpLCBrID0gTWF0aC5taW4odyAvIChiWzFdWzBdIC0gYlswXVswXSksIGggLyAoYlsxXVsxXSAtIGJbMF1bMV0pKSwgeCA9ICtleHRlbnRbMF1bMF0gKyAodyAtIGsgKiAoYlsxXVswXSArIGJbMF1bMF0pKSAvIDIsIHkgPSArZXh0ZW50WzBdWzFdICsgKGggLSBrICogKGJbMV1bMV0gKyBiWzBdWzFdKSkgLyAyO1xuICAgICAgICBpZiAoY2xpcCAhPSBudWxsKVxuICAgICAgICAgICAgcHJvamVjdGlvbi5jbGlwRXh0ZW50KGNsaXApO1xuICAgICAgICByZXR1cm4gcHJvamVjdGlvblxuICAgICAgICAgICAgLnNjYWxlKGsgKiAxNTApXG4gICAgICAgICAgICAudHJhbnNsYXRlKFt4LCB5XSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgW1swLCAwXSwgc2l6ZV0sIG9iamVjdCk7XG4gICAgfVxuICAgIC8vIFRoZSBwcm9qZWN0aW9ucyBtdXN0IGhhdmUgbXV0dWFsbHkgZXhjbHVzaXZlIGNsaXAgcmVnaW9ucyBvbiB0aGUgc3BoZXJlLFxuICAgIC8vIGFzIHRoaXMgd2lsbCBhdm9pZCBlbWl0dGluZyBpbnRlcmxlYXZpbmcgbGluZXMgYW5kIHBvbHlnb25zLlxuICAgIGZ1bmN0aW9uIG11bHRpcGxleChzdHJlYW1zKSB7XG4gICAgICAgIHZhciBuID0gc3RyZWFtcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2ludCh4LCB5KTsgfSxcbiAgICAgICAgICAgIHNwaGVyZTogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnNwaGVyZSgpOyB9LFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZVN0YXJ0KCk7IH0sXG4gICAgICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZUVuZCgpOyB9LFxuICAgICAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvblN0YXJ0KCk7IH0sXG4gICAgICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvbkVuZCgpOyB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEEgY29tcG9zaXRlIHByb2plY3Rpb24gZm9yIHRoZSBVbml0ZWQgU3RhdGVzLCBjb25maWd1cmVkIGJ5IGRlZmF1bHQgZm9yXG4gICAgLy8gOTYww5c1MDAuIFRoZSBwcm9qZWN0aW9uIGFsc28gd29ya3MgcXVpdGUgd2VsbCBhdCA5NjDDlzYwMCBpZiB5b3UgY2hhbmdlIHRoZVxuICAgIC8vIHNjYWxlIHRvIDEyODUgYW5kIGFkanVzdCB0aGUgdHJhbnNsYXRlIGFjY29yZGluZ2x5LiBUaGUgc2V0IG9mIHN0YW5kYXJkXG4gICAgLy8gcGFyYWxsZWxzIGZvciBlYWNoIHJlZ2lvbiBjb21lcyBmcm9tIFVTR1MsIHdoaWNoIGlzIHB1Ymxpc2hlZCBoZXJlOlxuICAgIC8vIGh0dHA6Ly9lZ3NjLnVzZ3MuZ292L2lzYi9wdWJzL01hcFByb2plY3Rpb25zL3Byb2plY3Rpb25zLmh0bWwjYWxiZXJzXG4gICAgZnVuY3Rpb24gYWxiZXJzVXNhKCkge1xuICAgICAgICB2YXIgY2FjaGUsIGNhY2hlU3RyZWFtLCBsb3dlcjQ4ID0gZDNHZW8uZ2VvQWxiZXJzKCksIGxvd2VyNDhQb2ludCwgYWxhc2thID0gZDNHZW8uZ2VvQ29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWzE1NCwgMF0pLmNlbnRlcihbLTIsIDU4LjVdKS5wYXJhbGxlbHMoWzU1LCA2NV0pLCBhbGFza2FQb2ludCwgLy8gRVBTRzozMzM4XG4gICAgICAgIGhhd2FpaSA9IGQzR2VvLmdlb0NvbmljRXF1YWxBcmVhKCkucm90YXRlKFsxNTcsIDBdKS5jZW50ZXIoWy0zLCAxOS45XSkucGFyYWxsZWxzKFs4LCAxOF0pLCBoYXdhaWlQb2ludCwgLy8gRVNSSToxMDIwMDdcbiAgICAgICAgcG9pbnQsIHBvaW50U3RyZWFtID0geyBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgcG9pbnQgPSBbeCwgeV07IH0gfTtcbiAgICAgICAgZnVuY3Rpb24gYWxiZXJzVXNhKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGNvb3JkaW5hdGVzWzBdLCB5ID0gY29vcmRpbmF0ZXNbMV07XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQgPSBudWxsLFxuICAgICAgICAgICAgICAgIChsb3dlcjQ4UG9pbnQucG9pbnQoeCwgeSksIHBvaW50KVxuICAgICAgICAgICAgICAgICAgICB8fCAoYWxhc2thUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KVxuICAgICAgICAgICAgICAgICAgICB8fCAoaGF3YWlpUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBhbGJlcnNVc2EuaW52ZXJ0ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgayA9IGxvd2VyNDguc2NhbGUoKSwgdCA9IGxvd2VyNDgudHJhbnNsYXRlKCksIHggPSAoY29vcmRpbmF0ZXNbMF0gLSB0WzBdKSAvIGssIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgICAgICAgICByZXR1cm4gKHkgPj0gMC4xMjAgJiYgeSA8IDAuMjM0ICYmIHggPj0gLTAuNDI1ICYmIHggPCAtMC4yMTQgPyBhbGFza2FcbiAgICAgICAgICAgICAgICA6IHkgPj0gMC4xNjYgJiYgeSA8IDAuMjM0ICYmIHggPj0gLTAuMjE0ICYmIHggPCAtMC4xMTUgPyBoYXdhaWlcbiAgICAgICAgICAgICAgICAgICAgOiBsb3dlcjQ4KS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2Euc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gbXVsdGlwbGV4KFtsb3dlcjQ4LnN0cmVhbShjYWNoZVN0cmVhbSA9IHN0cmVhbSksIGFsYXNrYS5zdHJlYW0oc3RyZWFtKSwgaGF3YWlpLnN0cmVhbShzdHJlYW0pXSk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5wcmVjaXNpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBsb3dlcjQ4LnByZWNpc2lvbigpO1xuICAgICAgICAgICAgbG93ZXI0OC5wcmVjaXNpb24oXyksIGFsYXNrYS5wcmVjaXNpb24oXyksIGhhd2FpaS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLnNjYWxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbG93ZXI0OC5zY2FsZSgpO1xuICAgICAgICAgICAgbG93ZXI0OC5zY2FsZShfKSwgYWxhc2thLnNjYWxlKF8gKiAwLjM1KSwgaGF3YWlpLnNjYWxlKF8pO1xuICAgICAgICAgICAgcmV0dXJuIGFsYmVyc1VzYS50cmFuc2xhdGUobG93ZXI0OC50cmFuc2xhdGUoKSk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBsb3dlcjQ4LnRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgdmFyIGsgPSBsb3dlcjQ4LnNjYWxlKCksIHggPSArX1swXSwgeSA9ICtfWzFdO1xuICAgICAgICAgICAgbG93ZXI0OFBvaW50ID0gbG93ZXI0OFxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoXylcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjQ1NSAqIGssIHkgLSAwLjIzOCAqIGtdLCBbeCArIDAuNDU1ICogaywgeSArIDAuMjM4ICoga11dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgYWxhc2thUG9pbnQgPSBhbGFza2FcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4zMDcgKiBrLCB5ICsgMC4yMDEgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjQyNSAqIGsgKyBlcHNpbG9uLCB5ICsgMC4xMjAgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4yMTQgKiBrIC0gZXBzaWxvbiwgeSArIDAuMjM0ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIGhhd2FpaVBvaW50ID0gaGF3YWlpXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMjA1ICogaywgeSArIDAuMjEyICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4yMTQgKiBrICsgZXBzaWxvbiwgeSArIDAuMTY2ICogayArIGVwc2lsb25dLCBbeCAtIDAuMTE1ICogayAtIGVwc2lsb24sIHkgKyAwLjIzNCAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLmZpdEV4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdEV4dGVudChhbGJlcnNVc2EsIGV4dGVudCwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLmZpdFNpemUgPSBmdW5jdGlvbiAoc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0U2l6ZShhbGJlcnNVc2EsIHNpemUsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gYWxiZXJzVXNhO1xuICAgICAgICB9XG4gICAgICAgIGFsYmVyc1VzYS5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBoYXdhaWkxID0gbG93ZXI0OChbLTEwMi45MSwgMjYuM10pO1xuICAgICAgICAgICAgdmFyIGhhd2FpaTIgPSBsb3dlcjQ4KFstMTA0LjAsIDI3LjVdKTtcbiAgICAgICAgICAgIHZhciBoYXdhaWkzID0gbG93ZXI0OChbLTEwOC4wLCAyOS4xXSk7XG4gICAgICAgICAgICB2YXIgaGF3YWlpNCA9IGxvd2VyNDgoWy0xMTAuMCwgMjkuMV0pO1xuICAgICAgICAgICAgdmFyIGFsYXNrYTEgPSBsb3dlcjQ4KFstMTEwLjAsIDI2LjddKTtcbiAgICAgICAgICAgIHZhciBhbGFza2EyID0gbG93ZXI0OChbLTExMi44LCAyNy42XSk7XG4gICAgICAgICAgICB2YXIgYWxhc2thMyA9IGxvd2VyNDgoWy0xMTQuMywgMzAuNl0pO1xuICAgICAgICAgICAgdmFyIGFsYXNrYTQgPSBsb3dlcjQ4KFstMTE5LjMsIDMwLjFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGhhd2FpaTFbMF0sIGhhd2FpaTFbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oaGF3YWlpMlswXSwgaGF3YWlpMlsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhoYXdhaWkzWzBdLCBoYXdhaWkzWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGhhd2FpaTRbMF0sIGhhd2FpaTRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oYWxhc2thMVswXSwgYWxhc2thMVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhhbGFza2EyWzBdLCBhbGFza2EyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGFsYXNrYTNbMF0sIGFsYXNrYTNbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYWxhc2thNFswXSwgYWxhc2thNFsxXSk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5nZXRDb21wb3NpdGlvbkJvcmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGQzUGF0aC5wYXRoKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDb21wb3NpdGlvbkJvcmRlcnMoY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC50b1N0cmluZygpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYWxiZXJzVXNhLnNjYWxlKDEwNzApO1xuICAgIH1cbiAgICAvLyBUaGUgcHJvamVjdGlvbnMgbXVzdCBoYXZlIG11dHVhbGx5IGV4Y2x1c2l2ZSBjbGlwIHJlZ2lvbnMgb24gdGhlIHNwaGVyZSxcbiAgICAvLyBhcyB0aGlzIHdpbGwgYXZvaWQgZW1pdHRpbmcgaW50ZXJsZWF2aW5nIGxpbmVzIGFuZCBwb2x5Z29ucy5cbiAgICBmdW5jdGlvbiBtdWx0aXBsZXgkMShzdHJlYW1zKSB7XG4gICAgICAgIHZhciBuID0gc3RyZWFtcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2ludCh4LCB5KTsgfSxcbiAgICAgICAgICAgIHNwaGVyZTogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnNwaGVyZSgpOyB9LFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZVN0YXJ0KCk7IH0sXG4gICAgICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZUVuZCgpOyB9LFxuICAgICAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvblN0YXJ0KCk7IH0sXG4gICAgICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvbkVuZCgpOyB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEEgY29tcG9zaXRlIHByb2plY3Rpb24gZm9yIHRoZSBVbml0ZWQgU3RhdGVzLCBjb25maWd1cmVkIGJ5IGRlZmF1bHQgZm9yXG4gICAgLy8gOTYww5c1MDAuIEFsc28gd29ya3MgcXVpdGUgd2VsbCBhdCA5NjDDlzYwMCB3aXRoIHNjYWxlIDEyODUuIFRoZSBzZXQgb2ZcbiAgICAvLyBzdGFuZGFyZCBwYXJhbGxlbHMgZm9yIGVhY2ggcmVnaW9uIGNvbWVzIGZyb20gVVNHUywgd2hpY2ggaXMgcHVibGlzaGVkIGhlcmU6XG4gICAgLy8gaHR0cDovL2Vnc2MudXNncy5nb3YvaXNiL3B1YnMvTWFwUHJvamVjdGlvbnMvcHJvamVjdGlvbnMuaHRtbCNhbGJlcnNcbiAgICBmdW5jdGlvbiBhbGJlcnNVc2FUZXJyaXRvcmllcygpIHtcbiAgICAgICAgdmFyIGNhY2hlLCBjYWNoZVN0cmVhbSwgbG93ZXI0OCA9IGQzR2VvLmdlb0FsYmVycygpLCBsb3dlcjQ4UG9pbnQsIGFsYXNrYSA9IGQzR2VvLmdlb0NvbmljRXF1YWxBcmVhKCkucm90YXRlKFsxNTQsIDBdKS5jZW50ZXIoWy0yLCA1OC41XSkucGFyYWxsZWxzKFs1NSwgNjVdKSwgYWxhc2thUG9pbnQsIC8vIEVQU0c6MzMzOFxuICAgICAgICBoYXdhaWkgPSBkM0dlby5nZW9Db25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbMTU3LCAwXSkuY2VudGVyKFstMywgMTkuOV0pLnBhcmFsbGVscyhbOCwgMThdKSwgaGF3YWlpUG9pbnQsIC8vIEVTUkk6MTAyMDA3XG4gICAgICAgIHB1ZXJ0b1JpY28gPSBkM0dlby5nZW9Db25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbNjYsIDBdKS5jZW50ZXIoWzAsIDE4XSkucGFyYWxsZWxzKFs4LCAxOF0pLCBwdWVydG9SaWNvUG9pbnQsIC8vVGFrZW4gZnJvbSBodHRwczovL2JsLm9ja3Mub3JnL21ib3N0b2NrLzU2MjkxMjBcbiAgICAgICAgc2Ftb2EgPSBkM0dlby5nZW9FcXVpcmVjdGFuZ3VsYXIoKS5yb3RhdGUoWzE3MywgMTRdKSwgc2Ftb2FQb2ludCwgLy8gRVBTRzo0MTY5XG4gICAgICAgIGd1YW0gPSBkM0dlby5nZW9FcXVpcmVjdGFuZ3VsYXIoKS5yb3RhdGUoWy0xNDUsIC0xNi44XSksIGd1YW1Qb2ludCwgcG9pbnQsIHBvaW50U3RyZWFtID0geyBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgcG9pbnQgPSBbeCwgeV07IH0gfTtcbiAgICAgICAgLypcbiAgICAgICAgdmFyIHB1ZXJ0b1JpY29CYm94ID0gW1stNjguMywgMTldLCBbLTYzLjksIDE3XV07XG4gICAgICAgIHZhciBzYW1vYUJib3ggPSBbWy0xNzEsIC0xNF0sIFstMTY4LCAtMTQuOF1dO1xuICAgICAgICB2YXIgZ3VhbUJib3ggPSBbWzE0NCwgMjAuOF0sIFsxNDYuNSwgMTIuN11dO1xuICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBhbGJlcnNVc2EoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciB4ID0gY29vcmRpbmF0ZXNbMF0sIHkgPSBjb29yZGluYXRlc1sxXTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludCA9IG51bGwsXG4gICAgICAgICAgICAgICAgKGxvd2VyNDhQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChhbGFza2FQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChoYXdhaWlQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChwdWVydG9SaWNvUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoc2Ftb2FQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChndWFtUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBhbGJlcnNVc2EuaW52ZXJ0ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgayA9IGxvd2VyNDguc2NhbGUoKSwgdCA9IGxvd2VyNDgudHJhbnNsYXRlKCksIHggPSAoY29vcmRpbmF0ZXNbMF0gLSB0WzBdKSAvIGssIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgLy9Ib3cgYXJlIHRoZSByZXR1cm4gdmFsdWVzIGNhbGN1bGF0ZWQ6XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCIqKioqKipcIik7XG4gICAgICAgICAgICB2YXIgYzAgPSBwdWVydG9SaWNvKHB1ZXJ0b1JpY29CYm94WzBdKTtcbiAgICAgICAgICAgIHZhciB4MCA9IChjMFswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHZhciB5MCA9IChjMFsxXSAtIHRbMV0pIC8gaztcbiAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInAwIHB1ZXJ0b1JpY29cIiwgeDAgKyAnIC0gJyArIHkwKTtcbiAgICBcbiAgICAgICAgICAgIHZhciBjMSA9IHB1ZXJ0b1JpY28ocHVlcnRvUmljb0Jib3hbMV0pO1xuICAgICAgICAgICAgdmFyIHgxID0gKGMxWzBdIC0gdFswXSkgLyBrO1xuICAgICAgICAgICAgdmFyIHkxID0gKGMxWzFdIC0gdFsxXSkgLyBrO1xuICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicDEgcHVlcnRvUmljb1wiLCB4MSArICcgLSAnICsgeTEpO1xuICAgIFxuICAgICAgICAgICAgYzAgPSBzYW1vYShzYW1vYUJib3hbMF0pO1xuICAgICAgICAgICAgeDAgPSAoYzBbMF0gLSB0WzBdKSAvIGs7XG4gICAgICAgICAgICB5MCA9IChjMFsxXSAtIHRbMV0pIC8gaztcbiAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInAwIHNhbW9hXCIsIHgwICsgJyAtICcgKyB5MCk7XG4gICAgXG4gICAgICAgICAgICBjMSA9IHNhbW9hKHNhbW9hQmJveFsxXSk7XG4gICAgICAgICAgICB4MSA9IChjMVswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHkxID0gKGMxWzFdIC0gdFsxXSkgLyBrO1xuICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicDEgc2Ftb2FcIiwgeDEgKyAnIC0gJyArIHkxKTtcbiAgICBcbiAgICAgICAgICAgIGMwID0gZ3VhbShndWFtQmJveFswXSk7XG4gICAgICAgICAgICB4MCA9IChjMFswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHkwID0gKGMwWzFdIC0gdFsxXSkgLyBrO1xuICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicDAgZ3VhbVwiLCB4MCArICcgLSAnICsgeTApO1xuICAgIFxuICAgICAgICAgICAgYzEgPSBndWFtKGd1YW1CYm94WzFdKTtcbiAgICAgICAgICAgIHgxID0gKGMxWzBdIC0gdFswXSkgLyBrO1xuICAgICAgICAgICAgeTEgPSAoYzFbMV0gLSB0WzFdKSAvIGs7XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJwMSBndWFtXCIsIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuICh5ID49IDAuMTIwICYmIHkgPCAwLjIzNCAmJiB4ID49IC0wLjQyNSAmJiB4IDwgLTAuMjE0ID8gYWxhc2thXG4gICAgICAgICAgICAgICAgOiB5ID49IDAuMTY2ICYmIHkgPCAwLjIzNCAmJiB4ID49IC0wLjIxNCAmJiB4IDwgLTAuMTE1ID8gaGF3YWlpXG4gICAgICAgICAgICAgICAgICAgIDogeSA+PSAwLjIwNjQgJiYgeSA8IDAuMjQxMyAmJiB4ID49IDAuMzEyICYmIHggPCAwLjM4NSA/IHB1ZXJ0b1JpY29cbiAgICAgICAgICAgICAgICAgICAgICAgIDogeSA+PSAwLjA5ICYmIHkgPCAwLjExOTcgJiYgeCA+PSAtMC40MjQzICYmIHggPCAtMC4zMjMyID8gc2Ftb2FcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHkgPj0gLTAuMDUxOCAmJiB5IDwgMC4wODk1ICYmIHggPj0gLTAuNDI0MyAmJiB4IDwgLTAuMzgyNCA/IGd1YW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBsb3dlcjQ4KS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2Euc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gbXVsdGlwbGV4JDEoW2xvd2VyNDguc3RyZWFtKGNhY2hlU3RyZWFtID0gc3RyZWFtKSwgYWxhc2thLnN0cmVhbShzdHJlYW0pLCBoYXdhaWkuc3RyZWFtKHN0cmVhbSksIHB1ZXJ0b1JpY28uc3RyZWFtKHN0cmVhbSksIHNhbW9hLnN0cmVhbShzdHJlYW0pLCBndWFtLnN0cmVhbShzdHJlYW0pXSk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5wcmVjaXNpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvd2VyNDgucHJlY2lzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb3dlcjQ4LnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIGFsYXNrYS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBoYXdhaWkucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgcHVlcnRvUmljby5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBzYW1vYS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBndWFtLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2Euc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvd2VyNDguc2NhbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvd2VyNDguc2NhbGUoXyk7XG4gICAgICAgICAgICBhbGFza2Euc2NhbGUoXyAqIDAuMzUpO1xuICAgICAgICAgICAgaGF3YWlpLnNjYWxlKF8pO1xuICAgICAgICAgICAgcHVlcnRvUmljby5zY2FsZShfKTtcbiAgICAgICAgICAgIHNhbW9hLnNjYWxlKF8gKiAyKTtcbiAgICAgICAgICAgIGd1YW0uc2NhbGUoXyk7XG4gICAgICAgICAgICByZXR1cm4gYWxiZXJzVXNhLnRyYW5zbGF0ZShsb3dlcjQ4LnRyYW5zbGF0ZSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG93ZXI0OC50cmFuc2xhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLCB4ID0gK19bMF0sIHkgPSArX1sxXTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICB2YXIgYzAgPSBwdWVydG9SaWNvLnRyYW5zbGF0ZShbeCArIDAuMzUwICogaywgeSArIDAuMjI0ICoga10pKHB1ZXJ0b1JpY29CYm94WzBdKTtcbiAgICAgICAgICAgIHZhciB4MCA9ICh4IC0gYzBbMF0pIC8gaztcbiAgICAgICAgICAgIHZhciB5MCA9ICh5IC0gYzBbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgYzEgPSBwdWVydG9SaWNvLnRyYW5zbGF0ZShbeCArIDAuMzUwICogaywgeSArIDAuMjI0ICoga10pKHB1ZXJ0b1JpY29CYm94WzFdKTtcbiAgICAgICAgICAgIHZhciB4MSA9ICh4IC0gYzFbMF0pIC8gaztcbiAgICAgICAgICAgIHZhciB5MSA9ICh5IC0gYzFbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ3B1ZXJ0b1JpY286IHAwOiAnICsgeDAgKyAnLCAnICsgeTAgKyAnICwgcDE6ICcgKyB4MSArICcgLSAnICsgeTEpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCcuY2xpcEV4dGVudChbW3ggJytcbiAgICAgICAgICAgICAoeDA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uLCB5ICcrXG4gICAgICAgICAgICAgKHkwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgICcgKiBrICsgZXBzaWxvbl0sW3ggJytcbiAgICAgICAgICAgICAoeDE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uLCB5ICcrXG4gICAgICAgICAgICAgKHkxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgICcgKiBrIC0gZXBzaWxvbl1dKScpO1xuICAgICAgICBcbiAgICAgICAgICAgICAgYzAgPSBzYW1vYS50cmFuc2xhdGUoW3ggLSAwLjQ5MiAqIGssIHkgKyAwLjA5ICoga10pKHNhbW9hQmJveFswXSk7XG4gICAgICAgICAgICAgIHgwID0gKHggLSBjMFswXSkgLyBrO1xuICAgICAgICAgICAgICB5MCA9ICh5IC0gYzBbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgICAgIGMxID0gc2Ftb2EudHJhbnNsYXRlKFt4IC0gMC40OTIgKiBrLCB5ICsgMC4wOSAqIGtdKShzYW1vYUJib3hbMV0pO1xuICAgICAgICAgICAgICB4MSA9ICh4IC0gYzFbMF0pIC8gaztcbiAgICAgICAgICAgICAgeTEgPSAoeSAtIGMxWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnc2Ftb2E6IHAwOiAnICsgeDAgKyAnLCAnICsgeTAgKyAnICwgcDE6ICcgKyB4MSArICcgLSAnICsgeTEpO1xuICAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnLmNsaXBFeHRlbnQoW1t4ICcrXG4gICAgICAgICAgICAgICh4MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uLCB5ICcrXG4gICAgICAgICAgICAgICh5MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uXSxbeCAnK1xuICAgICAgICAgICAgICAoeDE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgICcgKiBrIC0gZXBzaWxvbiwgeSAnK1xuICAgICAgICAgICAgICAoeTE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgICcgKiBrIC0gZXBzaWxvbl1dKScpO1xuICAgICAgICBcbiAgICAgICAgICAgICAgYzAgPSBndWFtLnRyYW5zbGF0ZShbeCAtIDAuNDA4ICogaywgeSArIDAuMDE4ICoga10pKGd1YW1CYm94WzBdKTtcbiAgICAgICAgICAgICAgeDAgPSAoeCAtIGMwWzBdKSAvIGs7XG4gICAgICAgICAgICAgIHkwID0gKHkgLSBjMFsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgICAgYzEgPSBndWFtLnRyYW5zbGF0ZShbeCAtIDAuNDA4ICogaywgeSArIDAuMDE4ICoga10pKGd1YW1CYm94WzFdKTtcbiAgICAgICAgICAgICAgeDEgPSAoeCAtIGMxWzBdKSAvIGs7XG4gICAgICAgICAgICAgIHkxID0gKHkgLSBjMVsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ2d1YW06IHAwOiAnICsgeDAgKyAnLCAnICsgeTAgKyAnICwgcDE6ICcgKyB4MSArICcgLSAnICsgeTEpO1xuICAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnLmNsaXBFeHRlbnQoW1t4ICcrXG4gICAgICAgICAgICAgICh4MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uLCB5ICcrXG4gICAgICAgICAgICAgICh5MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uXSxbeCAnK1xuICAgICAgICAgICAgICAoeDE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgICcgKiBrIC0gZXBzaWxvbiwgeSAnK1xuICAgICAgICAgICAgICAoeTE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgICcgKiBrIC0gZXBzaWxvbl1dKScpO1xuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbG93ZXI0OFBvaW50ID0gbG93ZXI0OFxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoXylcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjQ1NSAqIGssIHkgLSAwLjIzOCAqIGtdLCBbeCArIDAuNDU1ICogaywgeSArIDAuMjM4ICoga11dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgYWxhc2thUG9pbnQgPSBhbGFza2FcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4zMDcgKiBrLCB5ICsgMC4yMDEgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjQyNSAqIGsgKyBlcHNpbG9uLCB5ICsgMC4xMjAgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4yMTQgKiBrIC0gZXBzaWxvbiwgeSArIDAuMjMzICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIGhhd2FpaVBvaW50ID0gaGF3YWlpXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMjA1ICogaywgeSArIDAuMjEyICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4yMTQgKiBrICsgZXBzaWxvbiwgeSArIDAuMTY2ICogayArIGVwc2lsb25dLCBbeCAtIDAuMTE1ICogayAtIGVwc2lsb24sIHkgKyAwLjIzMyAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBwdWVydG9SaWNvUG9pbnQgPSBwdWVydG9SaWNvXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMzUwICogaywgeSArIDAuMjI0ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4ICsgMC4zMTIgKiBrICsgZXBzaWxvbiwgeSArIDAuMjA2NCAqIGsgKyBlcHNpbG9uXSwgW3ggKyAwLjM4NSAqIGsgLSBlcHNpbG9uLCB5ICsgMC4yMzMgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgc2Ftb2FQb2ludCA9IHNhbW9hXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuNDkyICogaywgeSArIDAuMDkgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjQyNDMgKiBrICsgZXBzaWxvbiwgeSArIDAuMDkwMyAqIGsgKyBlcHNpbG9uXSwgW3ggLSAwLjMyMzMgKiBrIC0gZXBzaWxvbiwgeSArIDAuMTE5NyAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBndWFtUG9pbnQgPSBndWFtXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuNDA4ICogaywgeSArIDAuMDE4ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC40MjQ0ICogayArIGVwc2lsb24sIHkgLSAwLjA1MTkgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4zODI0ICogayAtIGVwc2lsb24sIHkgKyAwLjA4OTUgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5maXRFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRFeHRlbnQoYWxiZXJzVXNhLCBleHRlbnQsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5maXRTaXplID0gZnVuY3Rpb24gKHNpemUsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdFNpemUoYWxiZXJzVXNhLCBzaXplLCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGFsYmVyc1VzYTtcbiAgICAgICAgfVxuICAgICAgICBhbGJlcnNVc2EuZHJhd0NvbXBvc2l0aW9uQm9yZGVycyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiQ0xJUCBFWFRFTlQgaGF3YWlpOiBcIiwgaGF3YWlpLmNsaXBFeHRlbnQoKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJVTCBCQk9YOlwiLCBsb3dlcjQ4LmludmVydChbaGF3YWlpLmNsaXBFeHRlbnQoKVswXVswXSwgaGF3YWlpLmNsaXBFeHRlbnQoKVswXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVSIEJCT1g6XCIsIGxvd2VyNDguaW52ZXJ0KFtoYXdhaWkuY2xpcEV4dGVudCgpWzFdWzBdLCBoYXdhaWkuY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEQgQkJPWDpcIiwgbG93ZXI0OC5pbnZlcnQoW2hhd2FpaS5jbGlwRXh0ZW50KClbMV1bMF0sIGhhd2FpaS5jbGlwRXh0ZW50KClbMV1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJMTCBCQk9YOlwiLCBsb3dlcjQ4LmludmVydChbaGF3YWlpLmNsaXBFeHRlbnQoKVswXVswXSwgaGF3YWlpLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJDTElQIEVYVEVOVCBhbGFza2E6IFwiLCBhbGFza2EuY2xpcEV4dGVudCgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVMIEJCT1g6XCIsIGxvd2VyNDguaW52ZXJ0KFthbGFza2EuY2xpcEV4dGVudCgpWzBdWzBdLCBhbGFza2EuY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVVIgQkJPWDpcIiwgbG93ZXI0OC5pbnZlcnQoW2FsYXNrYS5jbGlwRXh0ZW50KClbMV1bMF0sIGFsYXNrYS5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJMRCBCQk9YOlwiLCBsb3dlcjQ4LmludmVydChbYWxhc2thLmNsaXBFeHRlbnQoKVsxXVswXSwgYWxhc2thLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxMIEJCT1g6XCIsIGxvd2VyNDguaW52ZXJ0KFthbGFza2EuY2xpcEV4dGVudCgpWzBdWzBdLCBhbGFza2EuY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkNMSVAgRVhURU5UIHB1ZXJ0b1JpY286IFwiLCBwdWVydG9SaWNvLmNsaXBFeHRlbnQoKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJVTCBCQk9YOlwiLCBsb3dlcjQ4LmludmVydChbcHVlcnRvUmljby5jbGlwRXh0ZW50KClbMF1bMF0sIHB1ZXJ0b1JpY28uY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVVIgQkJPWDpcIiwgbG93ZXI0OC5pbnZlcnQoW3B1ZXJ0b1JpY28uY2xpcEV4dGVudCgpWzFdWzBdLCBwdWVydG9SaWNvLmNsaXBFeHRlbnQoKVswXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxEIEJCT1g6XCIsIGxvd2VyNDguaW52ZXJ0KFtwdWVydG9SaWNvLmNsaXBFeHRlbnQoKVsxXVswXSwgcHVlcnRvUmljby5jbGlwRXh0ZW50KClbMV1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJMTCBCQk9YOlwiLCBsb3dlcjQ4LmludmVydChbcHVlcnRvUmljby5jbGlwRXh0ZW50KClbMF1bMF0sIHB1ZXJ0b1JpY28uY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkNMSVAgRVhURU5UIHNhbW9hOiBcIiwgc2Ftb2EuY2xpcEV4dGVudCgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVMIEJCT1g6XCIsIGxvd2VyNDguaW52ZXJ0KFtzYW1vYS5jbGlwRXh0ZW50KClbMF1bMF0sIHNhbW9hLmNsaXBFeHRlbnQoKVswXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVSIEJCT1g6XCIsIGxvd2VyNDguaW52ZXJ0KFtzYW1vYS5jbGlwRXh0ZW50KClbMV1bMF0sIHNhbW9hLmNsaXBFeHRlbnQoKVswXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxEIEJCT1g6XCIsIGxvd2VyNDguaW52ZXJ0KFtzYW1vYS5jbGlwRXh0ZW50KClbMV1bMF0sIHNhbW9hLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxMIEJCT1g6XCIsIGxvd2VyNDguaW52ZXJ0KFtzYW1vYS5jbGlwRXh0ZW50KClbMF1bMF0sIHNhbW9hLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiQ0xJUCBFWFRFTlQgZ3VhbTogXCIsIGd1YW0uY2xpcEV4dGVudCgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVMIEJCT1g6XCIsIGxvd2VyNDguaW52ZXJ0KFtndWFtLmNsaXBFeHRlbnQoKVswXVswXSwgZ3VhbS5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJVUiBCQk9YOlwiLCBsb3dlcjQ4LmludmVydChbZ3VhbS5jbGlwRXh0ZW50KClbMV1bMF0sIGd1YW0uY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEQgQkJPWDpcIiwgbG93ZXI0OC5pbnZlcnQoW2d1YW0uY2xpcEV4dGVudCgpWzFdWzBdLCBndWFtLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxMIEJCT1g6XCIsIGxvd2VyNDguaW52ZXJ0KFtndWFtLmNsaXBFeHRlbnQoKVswXVswXSwgZ3VhbS5jbGlwRXh0ZW50KClbMV1bMV1dKSk7XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHVsaGF3YWlpID0gbG93ZXI0OChbLTExMC40NjQxLCAyOC4yODA1XSk7XG4gICAgICAgICAgICB2YXIgdXJoYXdhaWkgPSBsb3dlcjQ4KFstMTA0LjA1OTcsIDI4Ljk1MjhdKTtcbiAgICAgICAgICAgIHZhciBsZGhhd2FpaSA9IGxvd2VyNDgoWy0xMDMuNzA0OSwgMjUuMTAzMV0pO1xuICAgICAgICAgICAgdmFyIGxsaGF3YWlpID0gbG93ZXI0OChbLTEwOS44MzM3LCAyNC40NTMxXSk7XG4gICAgICAgICAgICB2YXIgdWxhbGFza2EgPSBsb3dlcjQ4KFstMTI0LjQ3NDUsIDI4LjE0MDddKTtcbiAgICAgICAgICAgIHZhciB1cmFsYXNrYSA9IGxvd2VyNDgoWy0xMTAuOTMxLCAzMC44ODQ0XSk7XG4gICAgICAgICAgICB2YXIgbGRhbGFza2EgPSBsb3dlcjQ4KFstMTA5LjgzMzcsIDI0LjQ1MzFdKTtcbiAgICAgICAgICAgIHZhciBsbGFsYXNrYSA9IGxvd2VyNDgoWy0xMjIuNDYyOCwgMjEuODU2Ml0pO1xuICAgICAgICAgICAgdmFyIHVscHVlcnRvUmljbyA9IGxvd2VyNDgoWy03Ni44NTc5LCAyNS4xNTQ0XSk7XG4gICAgICAgICAgICB2YXIgdXJwdWVydG9SaWNvID0gbG93ZXI0OChbLTcyLjQyOSwgMjQuMjA5N10pO1xuICAgICAgICAgICAgdmFyIGxkcHVlcnRvUmljbyA9IGxvd2VyNDgoWy03Mi44MjY1LCAyMi43MDU2XSk7XG4gICAgICAgICAgICB2YXIgbGxwdWVydG9SaWNvID0gbG93ZXI0OChbLTc3LjE4NTIsIDIzLjYzOTJdKTtcbiAgICAgICAgICAgIHZhciB1bHNhbW9hID0gbG93ZXI0OChbLTEyNS4wMDkzLCAyOS43NzkxXSk7XG4gICAgICAgICAgICB2YXIgdXJzYW1vYSA9IGxvd2VyNDgoWy0xMTguNTE5MywgMzEuMzI2Ml0pO1xuICAgICAgICAgICAgdmFyIGxkc2Ftb2EgPSBsb3dlcjQ4KFstMTE4LjA2NCwgMjkuNjkxMl0pO1xuICAgICAgICAgICAgdmFyIGxsc2Ftb2EgPSBsb3dlcjQ4KFstMTI0LjQzNjksIDI4LjE2OV0pO1xuICAgICAgICAgICAgdmFyIHVsZ3VhbSA9IGxvd2VyNDgoWy0xMjguMTMxNCwgMzcuNDU4Ml0pO1xuICAgICAgICAgICAgdmFyIHVyZ3VhbSA9IGxvd2VyNDgoWy0xMjUuMjEzMiwgMzguMjE0XSk7XG4gICAgICAgICAgICB2YXIgbGRndWFtID0gbG93ZXI0OChbLTEyMi4zNjE2LCAzMC41MTE1XSk7XG4gICAgICAgICAgICB2YXIgbGxndWFtID0gbG93ZXI0OChbLTEyNS4wMzE1LCAyOS44MjExXSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bGhhd2FpaVswXSwgdWxoYXdhaWlbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJoYXdhaWlbMF0sIHVyaGF3YWlpWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkaGF3YWlpWzBdLCBsZGhhd2FpaVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZGhhd2FpaVswXSwgbGRoYXdhaWlbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxoYXdhaWlbMF0sIGxsaGF3YWlpWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bGFsYXNrYVswXSwgdWxhbGFza2FbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJhbGFza2FbMF0sIHVyYWxhc2thWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkYWxhc2thWzBdLCBsZGFsYXNrYVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZGFsYXNrYVswXSwgbGRhbGFza2FbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxhbGFza2FbMF0sIGxsYWxhc2thWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bHB1ZXJ0b1JpY29bMF0sIHVscHVlcnRvUmljb1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1cnB1ZXJ0b1JpY29bMF0sIHVycHVlcnRvUmljb1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZHB1ZXJ0b1JpY29bMF0sIGxkcHVlcnRvUmljb1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZHB1ZXJ0b1JpY29bMF0sIGxkcHVlcnRvUmljb1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbHB1ZXJ0b1JpY29bMF0sIGxscHVlcnRvUmljb1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxzYW1vYVswXSwgdWxzYW1vYVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1cnNhbW9hWzBdLCB1cnNhbW9hWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkc2Ftb2FbMF0sIGxkc2Ftb2FbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRzYW1vYVswXSwgbGRzYW1vYVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbHNhbW9hWzBdLCBsbHNhbW9hWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bGd1YW1bMF0sIHVsZ3VhbVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1cmd1YW1bMF0sIHVyZ3VhbVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZGd1YW1bMF0sIGxkZ3VhbVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZGd1YW1bMF0sIGxkZ3VhbVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbGd1YW1bMF0sIGxsZ3VhbVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2EuZ2V0Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBkM1BhdGgucGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzKGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGFsYmVyc1VzYS5zY2FsZSgxMDcwKTtcbiAgICB9XG4gICAgLy8gVGhlIHByb2plY3Rpb25zIG11c3QgaGF2ZSBtdXR1YWxseSBleGNsdXNpdmUgY2xpcCByZWdpb25zIG9uIHRoZSBzcGhlcmUsXG4gICAgLy8gYXMgdGhpcyB3aWxsIGF2b2lkIGVtaXR0aW5nIGludGVybGVhdmluZyBsaW5lcyBhbmQgcG9seWdvbnMuXG4gICAgZnVuY3Rpb24gbXVsdGlwbGV4JDIoc3RyZWFtcykge1xuICAgICAgICB2YXIgbiA9IHN0cmVhbXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIHNwaGVyZTogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0uc3BoZXJlKCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZUVuZCgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICAgIH0gfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBIGNvbXBvc2l0ZSBwcm9qZWN0aW9uIGZvciBTcGFpbiwgY29uZmlndXJlZCBieSBkZWZhdWx0IGZvciA5NjDDlzUwMC5cbiAgICBmdW5jdGlvbiBjb25pY0NvbmZvcm1hbFNwYWluKCkge1xuICAgICAgICB2YXIgY2FjaGUsIGNhY2hlU3RyZWFtLCBpYmVyaWFuUGVuaW5zdWxlID0gZDNHZW8uZ2VvQ29uaWNDb25mb3JtYWwoKS5yb3RhdGUoWzUsIC0zOC42XSkucGFyYWxsZWxzKFswLCA2MF0pLCBpYmVyaWFuUGVuaW5zdWxlUG9pbnQsIGNhbmFyeUlzbGFuZHMgPSBkM0dlby5nZW9Db25pY0NvbmZvcm1hbCgpLnJvdGF0ZShbNSwgLTM4LjZdKS5wYXJhbGxlbHMoWzAsIDYwXSksIGNhbmFyeUlzbGFuZHNQb2ludCwgcG9pbnQsIHBvaW50U3RyZWFtID0geyBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgcG9pbnQgPSBbeCwgeV07IH0gfTtcbiAgICAgICAgLypcbiAgICAgICAgdmFyIGliZXJpYW5QZW5pbnN1bGVCYm94ID0gW1stMTEsIDQ2XSwgWzQsIDM1XV07XG4gICAgICAgIHZhciBjYW5hcnlJc2xhbmRzQmJveCA9IFtbLTE5LjAsIDI4Ljg1XSwgWy0xMi43LCAyOC4xXV07XG4gICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNvbmljQ29uZm9ybWFsU3BhaW4oY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciB4ID0gY29vcmRpbmF0ZXNbMF0sIHkgPSBjb29yZGluYXRlc1sxXTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludCA9IG51bGwsXG4gICAgICAgICAgICAgICAgKGliZXJpYW5QZW5pbnN1bGVQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChjYW5hcnlJc2xhbmRzUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25pY0NvbmZvcm1hbFNwYWluLmludmVydCA9IGZ1bmN0aW9uIChjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIGsgPSBpYmVyaWFuUGVuaW5zdWxlLnNjYWxlKCksIHQgPSBpYmVyaWFuUGVuaW5zdWxlLnRyYW5zbGF0ZSgpLCB4ID0gKGNvb3JkaW5hdGVzWzBdIC0gdFswXSkgLyBrLCB5ID0gKGNvb3JkaW5hdGVzWzFdIC0gdFsxXSkgLyBrO1xuICAgICAgICAgICAgcmV0dXJuICh5ID49IDAuMDUzNDYgJiYgeSA8IDAuMDg5NyAmJiB4ID49IC0wLjEzMzg4ICYmIHggPCAtMC4wMzIyID8gY2FuYXJ5SXNsYW5kc1xuICAgICAgICAgICAgICAgIDogaWJlcmlhblBlbmluc3VsZSkuaW52ZXJ0KGNvb3JkaW5hdGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxTcGFpbi5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBtdWx0aXBsZXgkMihbaWJlcmlhblBlbmluc3VsZS5zdHJlYW0oY2FjaGVTdHJlYW0gPSBzdHJlYW0pLCBjYW5hcnlJc2xhbmRzLnN0cmVhbShzdHJlYW0pXSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljQ29uZm9ybWFsU3BhaW4ucHJlY2lzaW9uID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpYmVyaWFuUGVuaW5zdWxlLnByZWNpc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWJlcmlhblBlbmluc3VsZS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBjYW5hcnlJc2xhbmRzLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbFNwYWluLnNjYWxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpYmVyaWFuUGVuaW5zdWxlLnNjYWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpYmVyaWFuUGVuaW5zdWxlLnNjYWxlKF8pO1xuICAgICAgICAgICAgY2FuYXJ5SXNsYW5kcy5zY2FsZShfKTtcbiAgICAgICAgICAgIHJldHVybiBjb25pY0NvbmZvcm1hbFNwYWluLnRyYW5zbGF0ZShpYmVyaWFuUGVuaW5zdWxlLnRyYW5zbGF0ZSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxTcGFpbi50cmFuc2xhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGliZXJpYW5QZW5pbnN1bGUudHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgayA9IGliZXJpYW5QZW5pbnN1bGUuc2NhbGUoKSwgeCA9ICtfWzBdLCB5ID0gK19bMV07XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgdmFyIGMwID0gaWJlcmlhblBlbmluc3VsZShpYmVyaWFuUGVuaW5zdWxlQmJveFswXSk7XG4gICAgICAgICAgIHZhciB4MCA9ICh4IC0gYzBbMF0pIC8gaztcbiAgICAgICAgICAgdmFyIHkwID0gKHkgLSBjMFsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgdmFyIGMxID0gaWJlcmlhblBlbmluc3VsZShpYmVyaWFuUGVuaW5zdWxlQmJveFsxXSk7XG4gICAgICAgICAgIHZhciB4MSA9ICh4IC0gYzFbMF0pIC8gaztcbiAgICAgICAgICAgdmFyIHkxID0gKHkgLSBjMVsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgY29uc29sZS5pbmZvKCdJYmVyaWFuIFBlbmluc3VsYTogcDA6ICcgKyB4MCArICcsICcgKyB5MCArICcgLCBwMTogJyArIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgIFxuICAgICAgICAgICBjMCA9IGNhbmFyeUlzbGFuZHMudHJhbnNsYXRlKFt4ICsgMC4xICogaywgeSAtIDAuMDk0ICoga10pKGNhbmFyeUlzbGFuZHNCYm94WzBdKTtcbiAgICAgICAgICAgeDAgPSAoeCAtIGMwWzBdKSAvIGs7XG4gICAgICAgICAgIHkwID0gKHkgLSBjMFsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgYzEgPSBjYW5hcnlJc2xhbmRzLnRyYW5zbGF0ZShbeCArIDAuMSAqIGssIHkgLSAwLjA5NCAqIGtdKShjYW5hcnlJc2xhbmRzQmJveFsxXSk7XG4gICAgICAgICAgIHgxID0gKHggLSBjMVswXSkgLyBrO1xuICAgICAgICAgICB5MSA9ICh5IC0gYzFbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgIGNvbnNvbGUuaW5mbygnQ2FucnkgSXNsYW5kczogcDA6ICcgKyB4MCArICcsICcgKyB5MCArICcgLCBwMTogJyArIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgICovXG4gICAgICAgICAgICBpYmVyaWFuUGVuaW5zdWxlUG9pbnQgPSBpYmVyaWFuUGVuaW5zdWxlXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShfKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMDY4NTcgKiBrLCB5IC0gMC4xMjg4ICoga10sIFt4ICsgMC4xMzI0OSAqIGssIHkgKyAwLjA2ICoga11dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgY2FuYXJ5SXNsYW5kc1BvaW50ID0gY2FuYXJ5SXNsYW5kc1xuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggKyAwLjEgKiBrLCB5IC0gMC4wOTQgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjEzMzEgKiBrICsgZXBzaWxvbiwgeSArIDAuMDUzNDU3ICogayArIGVwc2lsb25dLCBbeCAtIDAuMDM1NCAqIGsgLSBlcHNpbG9uLCB5ICsgMC4wODk2OSAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxTcGFpbi5maXRFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRFeHRlbnQoY29uaWNDb25mb3JtYWxTcGFpbiwgZXh0ZW50LCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbFNwYWluLmZpdFNpemUgPSBmdW5jdGlvbiAoc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0U2l6ZShjb25pY0NvbmZvcm1hbFNwYWluLCBzaXplLCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmljQ29uZm9ybWFsU3BhaW47XG4gICAgICAgIH1cbiAgICAgICAgY29uaWNDb25mb3JtYWxTcGFpbi5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJDTElQIEVYVEVOVDogXCIsIGNhbmFyeUlzbGFuZHMuY2xpcEV4dGVudCgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVMIEJCT1g6XCIsIGliZXJpYW5QZW5pbnN1bGUuaW52ZXJ0KFtjYW5hcnlJc2xhbmRzLmNsaXBFeHRlbnQoKVswXVswXSwgY2FuYXJ5SXNsYW5kcy5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJVUiBCQk9YOlwiLCBpYmVyaWFuUGVuaW5zdWxlLmludmVydChbY2FuYXJ5SXNsYW5kcy5jbGlwRXh0ZW50KClbMV1bMF0sIGNhbmFyeUlzbGFuZHMuY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEQgQkJPWDpcIiwgaWJlcmlhblBlbmluc3VsZS5pbnZlcnQoW2NhbmFyeUlzbGFuZHMuY2xpcEV4dGVudCgpWzFdWzBdLCBjYW5hcnlJc2xhbmRzLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgdWxDYW5hcnlJc2xhbmRzID0gaWJlcmlhblBlbmluc3VsZShbLTE0LjAzNDY3NTAsIDM0Ljk2NTAwN10pO1xuICAgICAgICAgICAgdmFyIHVyQ2FuYXJ5SXNsYW5kcyA9IGliZXJpYW5QZW5pbnN1bGUoWy03LjQyMDg4OTksIDM1LjUzNjk4OF0pO1xuICAgICAgICAgICAgdmFyIGxkQ2FuYXJ5SXNsYW5kcyA9IGliZXJpYW5QZW5pbnN1bGUoWy03LjMxNDgyNzUsIDMzLjU0MzU5XSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bENhbmFyeUlzbGFuZHNbMF0sIHVsQ2FuYXJ5SXNsYW5kc1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1ckNhbmFyeUlzbGFuZHNbMF0sIHVyQ2FuYXJ5SXNsYW5kc1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZENhbmFyeUlzbGFuZHNbMF0sIGxkQ2FuYXJ5SXNsYW5kc1sxXSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljQ29uZm9ybWFsU3BhaW4uZ2V0Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBkM1BhdGgucGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzKGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbmljQ29uZm9ybWFsU3BhaW4uc2NhbGUoMjcwMCk7XG4gICAgfVxuICAgIC8vIFRoZSBwcm9qZWN0aW9ucyBtdXN0IGhhdmUgbXV0dWFsbHkgZXhjbHVzaXZlIGNsaXAgcmVnaW9ucyBvbiB0aGUgc3BoZXJlLFxuICAgIC8vIGFzIHRoaXMgd2lsbCBhdm9pZCBlbWl0dGluZyBpbnRlcmxlYXZpbmcgbGluZXMgYW5kIHBvbHlnb25zLlxuICAgIGZ1bmN0aW9uIG11bHRpcGxleCQzKHN0cmVhbXMpIHtcbiAgICAgICAgdmFyIG4gPSBzdHJlYW1zLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnNwaGVyZSgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgICB9IH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQSBjb21wb3NpdGUgcHJvamVjdGlvbiBmb3IgUG9ydHVnYWwsIGNvbmZpZ3VyZWQgYnkgZGVmYXVsdCBmb3IgOTYww5c1MDAuXG4gICAgZnVuY3Rpb24gY29uaWNDb25mb3JtYWxQb3J0dWdhbCgpIHtcbiAgICAgICAgdmFyIGNhY2hlLCBjYWNoZVN0cmVhbSwgaWJlcmlhblBlbmluc3VsZSA9IGQzR2VvLmdlb0NvbmljQ29uZm9ybWFsKCkucm90YXRlKFsxMCwgLTM5LjNdKS5wYXJhbGxlbHMoWzAsIDYwXSksIGliZXJpYW5QZW5pbnN1bGVQb2ludCwgbWFkZWlyYSA9IGQzR2VvLmdlb0NvbmljQ29uZm9ybWFsKCkucm90YXRlKFsxNywgLTMyLjddKS5wYXJhbGxlbHMoWzAsIDYwXSksIG1hZGVpcmFQb2ludCwgYXpvcmVzID0gZDNHZW8uZ2VvQ29uaWNDb25mb3JtYWwoKS5yb3RhdGUoWzI3LjgsIC0zOC42XSkucGFyYWxsZWxzKFswLCA2MF0pLCBhem9yZXNQb2ludCwgcG9pbnQsIHBvaW50U3RyZWFtID0geyBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgcG9pbnQgPSBbeCwgeV07IH0gfTtcbiAgICAgICAgLypcbiAgICAgICAgdmFyIGliZXJpYW5QZW5pbnN1bGVCYm94ID0gW1stMTEsIDQ2XSwgWzQsIDM0XV07XG4gICAgICAgIHZhciBtYWRlaXJhQmJveCA9IFtbLTE3Ljg1LCAzMy42XSwgWy0xNiwgMzIuMDJdXTtcbiAgICAgICAgdmFyIGF6b3Jlc0Jib3ggPSBbWy0zMiwgNDAuNTI5XSwgWy0yMy45OCwgMzUuNzVdXTtcbiAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY29uaWNDb25mb3JtYWxQb3J0dWdhbChjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIHggPSBjb29yZGluYXRlc1swXSwgeSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50ID0gbnVsbCxcbiAgICAgICAgICAgICAgICAoaWJlcmlhblBlbmluc3VsZVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG1hZGVpcmFQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChhem9yZXNQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbmljQ29uZm9ybWFsUG9ydHVnYWwuaW52ZXJ0ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgayA9IGliZXJpYW5QZW5pbnN1bGUuc2NhbGUoKSwgdCA9IGliZXJpYW5QZW5pbnN1bGUudHJhbnNsYXRlKCksIHggPSAoY29vcmRpbmF0ZXNbMF0gLSB0WzBdKSAvIGssIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgLy9Ib3cgYXJlIHRoZSByZXR1cm4gdmFsdWVzIGNhbGN1bGF0ZWQ6XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCIqKioqKipcIik7XG4gICAgICAgICAgICB2YXIgYzAgPSBtYWRlaXJhKG1hZGVpcmFCYm94WzBdKTtcbiAgICAgICAgICAgIHZhciB4MCA9IChjMFswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHZhciB5MCA9IChjMFsxXSAtIHRbMV0pIC8gaztcbiAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInAwIG1hZGVpcmFcIiwgeDAgKyAnIC0gJyArIHkwKTtcbiAgICBcbiAgICAgICAgICAgIHZhciBjMSA9IG1hZGVpcmEobWFkZWlyYUJib3hbMV0pO1xuICAgICAgICAgICAgdmFyIHgxID0gKGMxWzBdIC0gdFswXSkgLyBrO1xuICAgICAgICAgICAgdmFyIHkxID0gKGMxWzFdIC0gdFsxXSkgLyBrO1xuICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicDEgbWFkZWlyYVwiLCB4MSArICcgLSAnICsgeTEpO1xuICAgIFxuICAgICAgICAgICAgYzAgPSBhem9yZXMoYXpvcmVzQmJveFswXSk7XG4gICAgICAgICAgICB4MCA9IChjMFswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHkwID0gKGMwWzFdIC0gdFsxXSkgLyBrO1xuICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicDAgYXpvcmVzXCIsIHgwICsgJyAtICcgKyB5MCk7XG4gICAgXG4gICAgICAgICAgICBjMSA9IGF6b3Jlcyhhem9yZXNCYm94WzFdKTtcbiAgICAgICAgICAgIHgxID0gKGMxWzBdIC0gdFswXSkgLyBrO1xuICAgICAgICAgICAgeTEgPSAoYzFbMV0gLSB0WzFdKSAvIGs7XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJwMSBhem9yZXNcIiwgeDEgKyAnIC0gJyArIHkxKTtcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gKHkgPj0gMC4wMDkzICYmIHkgPCAwLjAzNjc4ICYmIHggPj0gLTAuMDM4NzUgJiYgeCA8IC0wLjAxMTYgPyBtYWRlaXJhXG4gICAgICAgICAgICAgICAgOiB5ID49IC0wLjA0MTIgJiYgeSA8IDAuMDA5MSAmJiB4ID49IC0wLjA3NzgyICYmIHggPCAtMC4wMTE2NiA/IGF6b3Jlc1xuICAgICAgICAgICAgICAgICAgICA6IGliZXJpYW5QZW5pbnN1bGUpLmludmVydChjb29yZGluYXRlcyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljQ29uZm9ybWFsUG9ydHVnYWwuc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gbXVsdGlwbGV4JDMoW2liZXJpYW5QZW5pbnN1bGUuc3RyZWFtKGNhY2hlU3RyZWFtID0gc3RyZWFtKSwgbWFkZWlyYS5zdHJlYW0oc3RyZWFtKSwgYXpvcmVzLnN0cmVhbShzdHJlYW0pXSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljQ29uZm9ybWFsUG9ydHVnYWwucHJlY2lzaW9uID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpYmVyaWFuUGVuaW5zdWxlLnByZWNpc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWJlcmlhblBlbmluc3VsZS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBtYWRlaXJhLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIGF6b3Jlcy5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxQb3J0dWdhbC5zY2FsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWJlcmlhblBlbmluc3VsZS5zY2FsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWJlcmlhblBlbmluc3VsZS5zY2FsZShfKTtcbiAgICAgICAgICAgIG1hZGVpcmEuc2NhbGUoXyk7XG4gICAgICAgICAgICBhem9yZXMuc2NhbGUoXyAqIDAuNik7XG4gICAgICAgICAgICByZXR1cm4gY29uaWNDb25mb3JtYWxQb3J0dWdhbC50cmFuc2xhdGUoaWJlcmlhblBlbmluc3VsZS50cmFuc2xhdGUoKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljQ29uZm9ybWFsUG9ydHVnYWwudHJhbnNsYXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpYmVyaWFuUGVuaW5zdWxlLnRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGsgPSBpYmVyaWFuUGVuaW5zdWxlLnNjYWxlKCksIHggPSArX1swXSwgeSA9ICtfWzFdO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIHZhciBjMCA9IGliZXJpYW5QZW5pbnN1bGUoaWJlcmlhblBlbmluc3VsZUJib3hbMF0pO1xuICAgICAgICAgICB2YXIgeDAgPSAoeCAtIGMwWzBdKSAvIGs7XG4gICAgICAgICAgIHZhciB5MCA9ICh5IC0gYzBbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgIHZhciBjMSA9IGliZXJpYW5QZW5pbnN1bGUoaWJlcmlhblBlbmluc3VsZUJib3hbMV0pO1xuICAgICAgICAgICB2YXIgeDEgPSAoeCAtIGMxWzBdKSAvIGs7XG4gICAgICAgICAgIHZhciB5MSA9ICh5IC0gYzFbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgIGNvbnNvbGUuaW5mbygnSWJlcmlhbiBQZW5pbnN1bGE6IHAwOiAnICsgeDAgKyAnLCAnICsgeTAgKyAnICwgcDE6ICcgKyB4MSArICcgLSAnICsgeTEpO1xuICAgICAgICAgICBjb25zb2xlLmluZm8oJy5jbGlwRXh0ZW50KFtbeCAnK1xuICAgICAgICAgICAgKHgwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHgwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGssIHkgJytcbiAgICAgICAgICAgICh5MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrXSxbeCAnK1xuICAgICAgICAgICAgKHgxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHgxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGssIHkgJytcbiAgICAgICAgICAgICh5MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrXV0pJyk7XG4gICAgICAgIFxuICAgICAgICAgICBjMCA9IG1hZGVpcmEudHJhbnNsYXRlKFt4IC0gMC4wMjY1ICogaywgeSArIDAuMDI1ICoga10pKG1hZGVpcmFCYm94WzBdKTtcbiAgICAgICAgICAgeDAgPSAoeCAtIGMwWzBdKSAvIGs7XG4gICAgICAgICAgIHkwID0gKHkgLSBjMFsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgYzEgPSBtYWRlaXJhLnRyYW5zbGF0ZShbeCAtIDAuMDI2NSAqIGssIHkgKyAwLjAyNSAqIGtdKShtYWRlaXJhQmJveFsxXSk7XG4gICAgICAgICAgIHgxID0gKHggLSBjMVswXSkgLyBrO1xuICAgICAgICAgICB5MSA9ICh5IC0gYzFbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgIGNvbnNvbGUuaW5mbygnTWFkZWlyYTogcDA6ICcgKyB4MCArICcsICcgKyB5MCArICcgLCBwMTogJyArIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgIGNvbnNvbGUuaW5mbygnLmNsaXBFeHRlbnQoW1t4ICcrXG4gICAgICAgICAgICAoeDA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICogayArIGVwc2lsb24sIHkgJytcbiAgICAgICAgICAgICh5MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrICsgZXBzaWxvbl0sW3ggJytcbiAgICAgICAgICAgICh4MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrIC0gZXBzaWxvbiwgeSAnK1xuICAgICAgICAgICAgKHkxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uXV0pJyk7XG4gICAgICAgIFxuICAgICAgICAgICAgYzAgPSBhem9yZXMudHJhbnNsYXRlKFt4IC0gMC4wNDUgKiBrLCB5ICsgLTAuMDIgKiBrXSkoYXpvcmVzQmJveFswXSk7XG4gICAgICAgICAgICB4MCA9ICh4IC0gYzBbMF0pIC8gaztcbiAgICAgICAgICAgIHkwID0gKHkgLSBjMFsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgIGMxID0gYXpvcmVzLnRyYW5zbGF0ZShbeCAtIDAuMDQ1ICogaywgeSArIC0wLjAyICoga10pKGF6b3Jlc0Jib3hbMV0pO1xuICAgICAgICAgICAgeDEgPSAoeCAtIGMxWzBdKSAvIGs7XG4gICAgICAgICAgICB5MSA9ICh5IC0gYzFbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ0F6b3JlczogcDA6ICcgKyB4MCArICcsICcgKyB5MCArICcgLCBwMTogJyArIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJy5jbGlwRXh0ZW50KFtbeCAnK1xuICAgICAgICAgICAgICh4MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAnICogayArIGVwc2lsb24sIHkgJytcbiAgICAgICAgICAgICAoeTA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uXSxbeCAnK1xuICAgICAgICAgICAgICh4MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAnICogayAtIGVwc2lsb24sIHkgJytcbiAgICAgICAgICAgICAoeTE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uXV0pJyk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGliZXJpYW5QZW5pbnN1bGVQb2ludCA9IGliZXJpYW5QZW5pbnN1bGVcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKF8pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4wMTE1ICogaywgeSAtIDAuMTEzOCAqIGtdLCBbeCArIDAuMjEwNSAqIGssIHkgKyAwLjA2NzMgKiBrXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBtYWRlaXJhUG9pbnQgPSBtYWRlaXJhXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMDI2NSAqIGssIHkgKyAwLjAyNSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMDM4OCAqIGsgKyBlcHNpbG9uLCB5ICsgMC4wMDkzICogayArIGVwc2lsb25dLCBbeCAtIDAuMDExNiAqIGsgLSBlcHNpbG9uLCB5ICsgMC4wMzY4ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIGF6b3Jlc1BvaW50ID0gYXpvcmVzXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMDQ1ICogaywgeSArIC0wLjAyICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4wNzc4ICogayArIGVwc2lsb24sIHkgLSAwLjA0MTMgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4wMTE3ICogayAtIGVwc2lsb24sIHkgKyAwLjAwOTEgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljQ29uZm9ybWFsUG9ydHVnYWwuZml0RXh0ZW50ID0gZnVuY3Rpb24gKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0RXh0ZW50KGNvbmljQ29uZm9ybWFsUG9ydHVnYWwsIGV4dGVudCwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxQb3J0dWdhbC5maXRTaXplID0gZnVuY3Rpb24gKHNpemUsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdFNpemUoY29uaWNDb25mb3JtYWxQb3J0dWdhbCwgc2l6ZSwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBjb25pY0NvbmZvcm1hbFBvcnR1Z2FsO1xuICAgICAgICB9XG4gICAgICAgIGNvbmljQ29uZm9ybWFsUG9ydHVnYWwuZHJhd0NvbXBvc2l0aW9uQm9yZGVycyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiQ0xJUCBFWFRFTlQgTUFERUlSQTogXCIsIG1hZGVpcmEuY2xpcEV4dGVudCgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVMIEJCT1g6XCIsIGliZXJpYW5QZW5pbnN1bGUuaW52ZXJ0KFttYWRlaXJhLmNsaXBFeHRlbnQoKVswXVswXSwgbWFkZWlyYS5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJVUiBCQk9YOlwiLCBpYmVyaWFuUGVuaW5zdWxlLmludmVydChbbWFkZWlyYS5jbGlwRXh0ZW50KClbMV1bMF0sIG1hZGVpcmEuY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEQgQkJPWDpcIiwgaWJlcmlhblBlbmluc3VsZS5pbnZlcnQoW21hZGVpcmEuY2xpcEV4dGVudCgpWzFdWzBdLCBtYWRlaXJhLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxMIEJCT1g6XCIsIGliZXJpYW5QZW5pbnN1bGUuaW52ZXJ0KFttYWRlaXJhLmNsaXBFeHRlbnQoKVswXVswXSwgbWFkZWlyYS5jbGlwRXh0ZW50KClbMV1bMV1dKSk7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiQ0xJUCBFWFRFTlQgQVpPUkVTOiBcIiwgYXpvcmVzLmNsaXBFeHRlbnQoKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJVTCBCQk9YOlwiLCBpYmVyaWFuUGVuaW5zdWxlLmludmVydChbYXpvcmVzLmNsaXBFeHRlbnQoKVswXVswXSwgYXpvcmVzLmNsaXBFeHRlbnQoKVswXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVSIEJCT1g6XCIsIGliZXJpYW5QZW5pbnN1bGUuaW52ZXJ0KFthem9yZXMuY2xpcEV4dGVudCgpWzFdWzBdLCBhem9yZXMuY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEQgQkJPWDpcIiwgaWJlcmlhblBlbmluc3VsZS5pbnZlcnQoW2F6b3Jlcy5jbGlwRXh0ZW50KClbMV1bMF0sIGF6b3Jlcy5jbGlwRXh0ZW50KClbMV1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJMTCBCQk9YOlwiLCBpYmVyaWFuUGVuaW5zdWxlLmludmVydChbYXpvcmVzLmNsaXBFeHRlbnQoKVswXVswXSwgYXpvcmVzLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgdWxtYWRlaXJhID0gaWJlcmlhblBlbmluc3VsZShbLTEyLjgzNTEsIDM4LjcxMTNdKTtcbiAgICAgICAgICAgIHZhciB1cm1hZGVpcmEgPSBpYmVyaWFuUGVuaW5zdWxlKFstMTAuODQ4MiwgMzguNzYzM10pO1xuICAgICAgICAgICAgdmFyIGxkbWFkZWlyYSA9IGliZXJpYW5QZW5pbnN1bGUoWy0xMC44MTgxLCAzNy4yMDcyXSk7XG4gICAgICAgICAgICB2YXIgbGxtYWRlaXJhID0gaWJlcmlhblBlbmluc3VsZShbLTEyLjczNDUsIDM3LjE1NzNdKTtcbiAgICAgICAgICAgIHZhciB1bGF6b3JlcyA9IGliZXJpYW5QZW5pbnN1bGUoWy0xNi4wNzUzLCA0MS40NDM2XSk7XG4gICAgICAgICAgICB2YXIgdXJhem9yZXMgPSBpYmVyaWFuUGVuaW5zdWxlKFstMTAuOTE2OCwgNDEuNjg2MV0pO1xuICAgICAgICAgICAgdmFyIGxkYXpvcmVzID0gaWJlcmlhblBlbmluc3VsZShbLTEwLjg1NTcsIDM4Ljc3NDddKTtcbiAgICAgICAgICAgIHZhciBsbGF6b3JlcyA9IGliZXJpYW5QZW5pbnN1bGUoWy0xNS42NzI4LCAzOC41NTA1XSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bG1hZGVpcmFbMF0sIHVsbWFkZWlyYVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1cm1hZGVpcmFbMF0sIHVybWFkZWlyYVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZG1hZGVpcmFbMF0sIGxkbWFkZWlyYVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZG1hZGVpcmFbMF0sIGxkbWFkZWlyYVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbG1hZGVpcmFbMF0sIGxsbWFkZWlyYVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxhem9yZXNbMF0sIHVsYXpvcmVzWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyYXpvcmVzWzBdLCB1cmF6b3Jlc1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZGF6b3Jlc1swXSwgbGRhem9yZXNbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRhem9yZXNbMF0sIGxkYXpvcmVzWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsYXpvcmVzWzBdLCBsbGF6b3Jlc1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbFBvcnR1Z2FsLmdldENvbXBvc2l0aW9uQm9yZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gZDNQYXRoLnBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NvbXBvc2l0aW9uQm9yZGVycyhjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb25pY0NvbmZvcm1hbFBvcnR1Z2FsLnNjYWxlKDQyMDApO1xuICAgIH1cbiAgICAvLyBUaGUgcHJvamVjdGlvbnMgbXVzdCBoYXZlIG11dHVhbGx5IGV4Y2x1c2l2ZSBjbGlwIHJlZ2lvbnMgb24gdGhlIHNwaGVyZSxcbiAgICAvLyBhcyB0aGlzIHdpbGwgYXZvaWQgZW1pdHRpbmcgaW50ZXJsZWF2aW5nIGxpbmVzIGFuZCBwb2x5Z29ucy5cbiAgICBmdW5jdGlvbiBtdWx0aXBsZXgkNChzdHJlYW1zKSB7XG4gICAgICAgIHZhciBuID0gc3RyZWFtcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgc3BoZXJlOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5zcGhlcmUoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgfSB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEEgY29tcG9zaXRlIHByb2plY3Rpb24gZm9yIEVjdWFkb3IsIGNvbmZpZ3VyZWQgYnkgZGVmYXVsdCBmb3IgOTYww5c1MDAuXG4gICAgZnVuY3Rpb24gbWVyY2F0b3JFY3VhZG9yKCkge1xuICAgICAgICB2YXIgY2FjaGUsIGNhY2hlU3RyZWFtLCBtYWlubGFuZCA9IGQzR2VvLmdlb01lcmNhdG9yKCkucm90YXRlKFs4MCwgMS41XSksIG1haW5sYW5kUG9pbnQsIGdhbGFwYWdvcyA9IGQzR2VvLmdlb01lcmNhdG9yKCkucm90YXRlKFs5MC43MywgMV0pLCBnYWxhcGFnb3NQb2ludCwgcG9pbnQsIHBvaW50U3RyZWFtID0geyBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgcG9pbnQgPSBbeCwgeV07IH0gfTtcbiAgICAgICAgLypcbiAgICAgICAgdmFyIG1haW5sYW5kQmJveCA9IFtbLTgxLjUsIDIuN10sIFstNzAuMCwgLTYuMF1dO1xuICAgICAgICB2YXIgZ2FsYXBhZ29zQmJveCA9IFtbLTkyLjIsIDAuNThdLCBbLTg4LjgsIC0xLjhdXTtcbiAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gbWVyY2F0b3JFY3VhZG9yKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGNvb3JkaW5hdGVzWzBdLCB5ID0gY29vcmRpbmF0ZXNbMV07XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQgPSBudWxsLFxuICAgICAgICAgICAgICAgIChtYWlubGFuZFBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGdhbGFwYWdvc1BvaW50LnBvaW50KHgsIHkpLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgbWVyY2F0b3JFY3VhZG9yLmludmVydCA9IGZ1bmN0aW9uIChjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIGsgPSBtYWlubGFuZC5zY2FsZSgpLCB0ID0gbWFpbmxhbmQudHJhbnNsYXRlKCksIHggPSAoY29vcmRpbmF0ZXNbMF0gLSB0WzBdKSAvIGssIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgLy9Ib3cgYXJlIHRoZSByZXR1cm4gdmFsdWVzIGNhbGN1bGF0ZWQ6XG4gICAgICAgICAgICB2YXIgYzAgPSBnYWxhcGFnb3MoZ2FsYXBhZ29zQmJveFswXSk7XG4gICAgICAgICAgICB2YXIgeDAgPSAoYzBbMF0gLSB0WzBdKSAvIGs7XG4gICAgICAgICAgICB2YXIgeTAgPSAoYzBbMV0gLSB0WzFdKSAvIGs7XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJwMCBnYWxhcGFnb3NcIiwgeDAgKyAnIC0gJyArIHkwKTtcbiAgICBcbiAgICBcbiAgICAgICAgICAgIHZhciBjMSA9IGdhbGFwYWdvcyhnYWxhcGFnb3NCYm94WzFdKTtcbiAgICAgICAgICAgIHZhciB4MSA9IChjMVswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHZhciB5MSA9IChjMVsxXSAtIHRbMV0pIC8gaztcbiAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInAxIGdhbGFwYWdvc1wiLCB4MSArICcgLSAnICsgeTEpO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiAoeSA+PSAtMC4wNjc2ICYmIHkgPCAtMC4wMjYgJiYgeCA+PSAtMC4wODU3ICYmIHggPCAtMC4wMjYzID8gZ2FsYXBhZ29zXG4gICAgICAgICAgICAgICAgOiBtYWlubGFuZCkuaW52ZXJ0KGNvb3JkaW5hdGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgbWVyY2F0b3JFY3VhZG9yLnN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IG11bHRpcGxleCQ0KFttYWlubGFuZC5zdHJlYW0oY2FjaGVTdHJlYW0gPSBzdHJlYW0pLCBnYWxhcGFnb3Muc3RyZWFtKHN0cmVhbSldKTtcbiAgICAgICAgfTtcbiAgICAgICAgbWVyY2F0b3JFY3VhZG9yLnByZWNpc2lvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbmxhbmQucHJlY2lzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYWlubGFuZC5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBnYWxhcGFnb3MucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yRWN1YWRvci5zY2FsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbmxhbmQuc2NhbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1haW5sYW5kLnNjYWxlKF8pO1xuICAgICAgICAgICAgZ2FsYXBhZ29zLnNjYWxlKF8pO1xuICAgICAgICAgICAgcmV0dXJuIG1lcmNhdG9yRWN1YWRvci50cmFuc2xhdGUobWFpbmxhbmQudHJhbnNsYXRlKCkpO1xuICAgICAgICB9O1xuICAgICAgICBtZXJjYXRvckVjdWFkb3IudHJhbnNsYXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWlubGFuZC50cmFuc2xhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrID0gbWFpbmxhbmQuc2NhbGUoKSwgeCA9ICtfWzBdLCB5ID0gK19bMV07XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgdmFyIGMwID0gbWFpbmxhbmQobWFpbmxhbmRCYm94WzBdKTtcbiAgICAgICAgICAgdmFyIHgwID0gKHggLSBjMFswXSkgLyBrO1xuICAgICAgICAgICB2YXIgeTAgPSAoeSAtIGMwWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICB2YXIgYzEgPSBtYWlubGFuZChtYWlubGFuZEJib3hbMV0pO1xuICAgICAgICAgICB2YXIgeDEgPSAoeCAtIGMxWzBdKSAvIGs7XG4gICAgICAgICAgIHZhciB5MSA9ICh5IC0gYzFbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgIGNvbnNvbGUuaW5mbygnbWFpbmxhbmQ6IHAwOiAnICsgeDAgKyAnLCAnICsgeTAgKyAnICwgcDE6ICcgKyB4MSArICcgLSAnICsgeTEpO1xuICAgICAgICAgICBjb25zb2xlLmluZm8oJy5jbGlwRXh0ZW50KFtbeCAnK1xuICAgICAgICAgICAgKHgwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHgwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGssIHkgJytcbiAgICAgICAgICAgICh5MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrXSxbeCAnK1xuICAgICAgICAgICAgKHgxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHgxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGssIHkgJytcbiAgICAgICAgICAgICh5MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrXV0pJyk7XG4gICAgICAgIFxuICAgICAgICAgICBjMCA9IGdhbGFwYWdvcy50cmFuc2xhdGUoW3ggLSAwLjA2ICogaywgeSAtIDAuMDQgKiBrXSkoZ2FsYXBhZ29zQmJveFswXSk7XG4gICAgICAgICAgIHgwID0gKHggLSBjMFswXSkgLyBrO1xuICAgICAgICAgICB5MCA9ICh5IC0gYzBbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgIGMxID0gZ2FsYXBhZ29zLnRyYW5zbGF0ZShbeCAtIDAuMDYgKiBrLCB5IC0gMC4wNCAqIGtdKShnYWxhcGFnb3NCYm94WzFdKTtcbiAgICAgICAgICAgeDEgPSAoeCAtIGMxWzBdKSAvIGs7XG4gICAgICAgICAgIHkxID0gKHkgLSBjMVsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgY29uc29sZS5pbmZvKCdnYWxhcGFnb3M6IHAwOiAnICsgeDAgKyAnLCAnICsgeTAgKyAnICwgcDE6ICcgKyB4MSArICcgLSAnICsgeTEpO1xuICAgICAgICAgICBjb25zb2xlLmluZm8oJy5jbGlwRXh0ZW50KFtbeCAnK1xuICAgICAgICAgICAgKHgwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHgwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uLCB5ICcrXG4gICAgICAgICAgICAoeTA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICogayArIGVwc2lsb25dLFt4ICcrXG4gICAgICAgICAgICAoeDE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICogayAtIGVwc2lsb24sIHkgJytcbiAgICAgICAgICAgICh5MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrIC0gZXBzaWxvbl1dKScpOyovXG4gICAgICAgICAgICBtYWlubGFuZFBvaW50ID0gbWFpbmxhbmRcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKF8pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4wMjYyICogaywgeSAtIDAuMDczNCAqIGtdLCBbeCArIDAuMTc0MSAqIGssIHkgKyAwLjA3OSAqIGtdXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIGdhbGFwYWdvc1BvaW50ID0gZ2FsYXBhZ29zXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMDYgKiBrLCB5IC0gMC4wNCAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMDg1NyAqIGsgKyBlcHNpbG9uLCB5IC0gMC4wNjc2ICogayArIGVwc2lsb25dLCBbeCAtIDAuMDI2MyAqIGsgLSBlcHNpbG9uLCB5IC0gMC4wMjYgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yRWN1YWRvci5maXRFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRFeHRlbnQobWVyY2F0b3JFY3VhZG9yLCBleHRlbnQsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yRWN1YWRvci5maXRTaXplID0gZnVuY3Rpb24gKHNpemUsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdFNpemUobWVyY2F0b3JFY3VhZG9yLCBzaXplLCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG1lcmNhdG9yRWN1YWRvcjtcbiAgICAgICAgfVxuICAgICAgICBtZXJjYXRvckVjdWFkb3IuZHJhd0NvbXBvc2l0aW9uQm9yZGVycyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiQ0xJUCBFWFRFTlQ6IFwiLCBnYWxhcGFnb3MuY2xpcEV4dGVudCgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVMIEJCT1g6XCIsIG1haW5sYW5kLmludmVydChbZ2FsYXBhZ29zLmNsaXBFeHRlbnQoKVswXVswXSwgZ2FsYXBhZ29zLmNsaXBFeHRlbnQoKVswXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVSIEJCT1g6XCIsIG1haW5sYW5kLmludmVydChbZ2FsYXBhZ29zLmNsaXBFeHRlbnQoKVsxXVswXSwgZ2FsYXBhZ29zLmNsaXBFeHRlbnQoKVswXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxEIEJCT1g6XCIsIG1haW5sYW5kLmludmVydChbZ2FsYXBhZ29zLmNsaXBFeHRlbnQoKVsxXVswXSwgZ2FsYXBhZ29zLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxMIEJCT1g6XCIsIG1haW5sYW5kLmludmVydChbZ2FsYXBhZ29zLmNsaXBFeHRlbnQoKVswXVswXSwgZ2FsYXBhZ29zLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgdWxnYWxhcGFnb3MgPSBtYWlubGFuZChbLTg0LjkwMzIsIDIuMzc1N10pO1xuICAgICAgICAgICAgdmFyIHVyZ2FsYXBhZ29zID0gbWFpbmxhbmQoWy04MS41MDQ3LCAyLjM3MDhdKTtcbiAgICAgICAgICAgIHZhciBsZGdhbGFwYWdvcyA9IG1haW5sYW5kKFstODEuNTA2MywgLTAuMDFdKTtcbiAgICAgICAgICAgIHZhciBsbGdhbGFwYWdvcyA9IG1haW5sYW5kKFstODQuOTA4NiwgLTAuMDA1XSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bGdhbGFwYWdvc1swXSwgdWxnYWxhcGFnb3NbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJnYWxhcGFnb3NbMF0sIHVyZ2FsYXBhZ29zWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkZ2FsYXBhZ29zWzBdLCBsZGdhbGFwYWdvc1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbGdhbGFwYWdvc1swXSwgbGxnYWxhcGFnb3NbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbWVyY2F0b3JFY3VhZG9yLmdldENvbXBvc2l0aW9uQm9yZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gZDNQYXRoLnBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NvbXBvc2l0aW9uQm9yZGVycyhjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtZXJjYXRvckVjdWFkb3Iuc2NhbGUoMzUwMCk7XG4gICAgfVxuICAgIC8vIFRoZSBwcm9qZWN0aW9ucyBtdXN0IGhhdmUgbXV0dWFsbHkgZXhjbHVzaXZlIGNsaXAgcmVnaW9ucyBvbiB0aGUgc3BoZXJlLFxuICAgIC8vIGFzIHRoaXMgd2lsbCBhdm9pZCBlbWl0dGluZyBpbnRlcmxlYXZpbmcgbGluZXMgYW5kIHBvbHlnb25zLlxuICAgIGZ1bmN0aW9uIG11bHRpcGxleCQ1KHN0cmVhbXMpIHtcbiAgICAgICAgdmFyIG4gPSBzdHJlYW1zLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnNwaGVyZSgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgICB9IH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQSBjb21wb3NpdGUgcHJvamVjdGlvbiBmb3IgQ2hpbGUsIGNvbmZpZ3VyZWQgYnkgZGVmYXVsdCBmb3IgOTYww5c1MDAuXG4gICAgZnVuY3Rpb24gdHJhbnN2ZXJzZU1lcmNhdG9yQ2hpbGUoKSB7XG4gICAgICAgIHZhciBjYWNoZSwgY2FjaGVTdHJlYW0sIG1haW5sYW5kID0gZDNHZW8uZ2VvVHJhbnN2ZXJzZU1lcmNhdG9yKCkucm90YXRlKFs3MiwgMzddKSwgbWFpbmxhbmRQb2ludCwgYW50YXJjdGljID0gZDNHZW8uZ2VvU3RlcmVvZ3JhcGhpYygpLnJvdGF0ZShbNzIsIDBdKSwgYW50YXJjdGljUG9pbnQsIGp1YW5GZXJuYW5kZXogPSBkM0dlby5nZW9NZXJjYXRvcigpLnJvdGF0ZShbODAsIDMzLjVdKSwganVhbkZlcm5hbmRlelBvaW50LCBwYXNjdWEgPSBkM0dlby5nZW9NZXJjYXRvcigpLnJvdGF0ZShbMTEwLCAyNV0pLCBwYXNjdWFQb2ludCwgcG9pbnQsIHBvaW50U3RyZWFtID0geyBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgcG9pbnQgPSBbeCwgeV07IH0gfTtcbiAgICAgICAgLypcbiAgICAgICAgdmFyIG1haW5sYW5kQmJveCA9IFtbLTc1LjUsIC0xNS4wXSwgWy0zMiwgLTQ5LjBdXTtcbiAgICAgICAgdmFyIGFudGFyY3RpY0Jib3ggPSBbWy05MS4wLCAtNjAuMF0sIFstNDMuMCwgLTkwLjBdXTtcbiAgICAgICAgdmFyIGp1YW5GZXJuYW5kZXpCYm94ID0gW1stODEuMCwgLTMzLjBdLCBbLTc4LjUsIC0zNC4wXV07XG4gICAgICAgIHZhciBwYXNjdWFCYm94ID0gW1stMTEwLCAtMjYuNl0sIFstMTA4LjcsIC0yNy41XV07XG4gICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHRyYW5zdmVyc2VNZXJjYXRvckNoaWxlKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGNvb3JkaW5hdGVzWzBdLCB5ID0gY29vcmRpbmF0ZXNbMV07XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQgPSBudWxsLFxuICAgICAgICAgICAgICAgIChtYWlubGFuZFBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGFudGFyY3RpY1BvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGp1YW5GZXJuYW5kZXpQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChwYXNjdWFQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zdmVyc2VNZXJjYXRvckNoaWxlLmludmVydCA9IGZ1bmN0aW9uIChjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIGsgPSBtYWlubGFuZC5zY2FsZSgpLCB0ID0gbWFpbmxhbmQudHJhbnNsYXRlKCksIHggPSAoY29vcmRpbmF0ZXNbMF0gLSB0WzBdKSAvIGssIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgLy9Ib3cgYXJlIHRoZSByZXR1cm4gdmFsdWVzIGNhbGN1bGF0ZWQ6XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCIqKioqKipcIik7XG4gICAgICAgICAgICB2YXIgYzAgPSBhbnRhcmN0aWMoYW50YXJjdGljQmJveFswXSk7XG4gICAgICAgICAgICB2YXIgeDAgPSAoYzBbMF0gLSB0WzBdKSAvIGs7XG4gICAgICAgICAgICB2YXIgeTAgPSAoYzBbMV0gLSB0WzFdKSAvIGs7XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJwMCBhbnRhcmN0aWNcIiwgeDAgKyAnIC0gJyArIHkwKTtcbiAgICBcbiAgICAgICAgICAgIHZhciBjMSA9IGFudGFyY3RpYyhhbnRhcmN0aWNCYm94WzFdKTtcbiAgICAgICAgICAgIHZhciB4MSA9IChjMVswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHZhciB5MSA9IChjMVsxXSAtIHRbMV0pIC8gaztcbiAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInAxIGFudGFyY3RpY1wiLCB4MSArICcgLSAnICsgeTEpO1xuICAgIFxuICAgICAgICAgICAgYzAgPSBqdWFuRmVybmFuZGV6KGp1YW5GZXJuYW5kZXpCYm94WzBdKTtcbiAgICAgICAgICAgIHgwID0gKGMwWzBdIC0gdFswXSkgLyBrO1xuICAgICAgICAgICAgeTAgPSAoYzBbMV0gLSB0WzFdKSAvIGs7XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJwMCBqdWFuRmVybmFuZGV6XCIsIHgwICsgJyAtICcgKyB5MCk7XG4gICAgXG4gICAgICAgICAgICBjMSA9IGp1YW5GZXJuYW5kZXooanVhbkZlcm5hbmRlekJib3hbMV0pO1xuICAgICAgICAgICAgeDEgPSAoYzFbMF0gLSB0WzBdKSAvIGs7XG4gICAgICAgICAgICB5MSA9IChjMVsxXSAtIHRbMV0pIC8gaztcbiAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInAxIGp1YW5GZXJuYW5kZXpcIiwgeDEgKyAnIC0gJyArIHkxKTtcbiAgICBcbiAgICAgICAgICAgIGMwID0gcGFzY3VhKHBhc2N1YUJib3hbMF0pO1xuICAgICAgICAgICAgeDAgPSAoYzBbMF0gLSB0WzBdKSAvIGs7XG4gICAgICAgICAgICB5MCA9IChjMFsxXSAtIHRbMV0pIC8gaztcbiAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInAwIHBhc2N1YVwiLCB4MCArICcgLSAnICsgeTApO1xuICAgIFxuICAgICAgICAgICAgYzEgPSBwYXNjdWEocGFzY3VhQmJveFsxXSk7XG4gICAgICAgICAgICB4MSA9IChjMVswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHkxID0gKGMxWzFdIC0gdFsxXSkgLyBrO1xuICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicDEgcGFzY3VhXCIsIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuICh5ID49IDAuMjU4MiAmJiB5IDwgMC4zMiAmJiB4ID49IC0wLjEwMzYgJiYgeCA8IC0wLjA4NyA/IGFudGFyY3RpY1xuICAgICAgICAgICAgICAgIDogeSA+PSAtMC4wMTI5OCAmJiB5IDwgMC4wMTMzICYmIHggPj0gLTAuMTEzOTYgJiYgeCA8IC0wLjA1OTQ0ID8ganVhbkZlcm5hbmRlelxuICAgICAgICAgICAgICAgICAgICA6IHkgPj0gMC4wMTUzOSAmJiB5IDwgMC4wMzkxMSAmJiB4ID49IC0wLjA4OSAmJiB4IDwgLTAuMDU4OCA/IHBhc2N1YVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBtYWlubGFuZCkuaW52ZXJ0KGNvb3JkaW5hdGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnN2ZXJzZU1lcmNhdG9yQ2hpbGUuc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gbXVsdGlwbGV4JDUoW21haW5sYW5kLnN0cmVhbShjYWNoZVN0cmVhbSA9IHN0cmVhbSksIGFudGFyY3RpYy5zdHJlYW0oc3RyZWFtKSwganVhbkZlcm5hbmRlei5zdHJlYW0oc3RyZWFtKSwgcGFzY3VhLnN0cmVhbShzdHJlYW0pXSk7XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zdmVyc2VNZXJjYXRvckNoaWxlLnByZWNpc2lvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbmxhbmQucHJlY2lzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYWlubGFuZC5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBhbnRhcmN0aWMucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAganVhbkZlcm5hbmRlei5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBwYXNjdWEucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zdmVyc2VNZXJjYXRvckNoaWxlLnNjYWxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWlubGFuZC5zY2FsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFpbmxhbmQuc2NhbGUoXyk7XG4gICAgICAgICAgICBhbnRhcmN0aWMuc2NhbGUoXyAqIDAuMTUpO1xuICAgICAgICAgICAganVhbkZlcm5hbmRlei5zY2FsZShfICogMS41KTtcbiAgICAgICAgICAgIHBhc2N1YS5zY2FsZShfICogMS41KTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc3ZlcnNlTWVyY2F0b3JDaGlsZS50cmFuc2xhdGUobWFpbmxhbmQudHJhbnNsYXRlKCkpO1xuICAgICAgICB9O1xuICAgICAgICB0cmFuc3ZlcnNlTWVyY2F0b3JDaGlsZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW5sYW5kLnRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGsgPSBtYWlubGFuZC5zY2FsZSgpLCB4ID0gK19bMF0sIHkgPSArX1sxXTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICB2YXIgYzAgPSBtYWlubGFuZChtYWlubGFuZEJib3hbMF0pO1xuICAgICAgICAgICB2YXIgeDAgPSAoeCAtIGMwWzBdKSAvIGs7XG4gICAgICAgICAgIHZhciB5MCA9ICh5IC0gYzBbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgIHZhciBjMSA9IG1haW5sYW5kKG1haW5sYW5kQmJveFsxXSk7XG4gICAgICAgICAgIHZhciB4MSA9ICh4IC0gYzFbMF0pIC8gaztcbiAgICAgICAgICAgdmFyIHkxID0gKHkgLSBjMVsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgY29uc29sZS5pbmZvKCdNYWlubGFuZDogcDA6ICcgKyB4MCArICcsICcgKyB5MCArICcgLCBwMTogJyArIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgIGNvbnNvbGUuaW5mbygnLmNsaXBFeHRlbnQoW1t4ICcrXG4gICAgICAgICAgICAoeDA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICogaywgeSAnK1xuICAgICAgICAgICAgKHkwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGtdLFt4ICcrXG4gICAgICAgICAgICAoeDE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICogaywgeSAnK1xuICAgICAgICAgICAgKHkxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGtdXSknKTtcbiAgICAgICAgXG4gICAgICAgICAgIGMwID0gYW50YXJjdGljLnRyYW5zbGF0ZShbeCAtIDAuMSAqIGssIHkgKyAwLjE3ICoga10pKGFudGFyY3RpY0Jib3hbMF0pO1xuICAgICAgICAgICB4MCA9ICh4IC0gYzBbMF0pIC8gaztcbiAgICAgICAgICAgeTAgPSAoeSAtIGMwWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICBjMSA9IGFudGFyY3RpYy50cmFuc2xhdGUoW3ggLSAwLjEgKiBrLCB5ICsgMC4xNyAqIGtdKShhbnRhcmN0aWNCYm94WzFdKTtcbiAgICAgICAgICAgeDEgPSAoeCAtIGMxWzBdKSAvIGs7XG4gICAgICAgICAgIHkxID0gKHkgLSBjMVsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgY29uc29sZS5pbmZvKCdhbnRhcmN0aWM6IHAwOiAnICsgeDAgKyAnLCAnICsgeTAgKyAnICwgcDE6ICcgKyB4MSArICcgLSAnICsgeTEpO1xuICAgICAgICAgICBjb25zb2xlLmluZm8oJ0RvZXNuIHQgd29yayBkdWUgdG8gLTkwIGxhdGl0dWRlIScgKyAnLmNsaXBFeHRlbnQoW1t4ICcrXG4gICAgICAgICAgICAoeDA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICogayArIGVwc2lsb24sIHkgJytcbiAgICAgICAgICAgICh5MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrICsgZXBzaWxvbl0sW3ggJytcbiAgICAgICAgICAgICh4MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrIC0gZXBzaWxvbiwgeSAnK1xuICAgICAgICAgICAgKHkxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uXV0pJyk7XG4gICAgICAgIFxuICAgICAgICAgICAgYzAgPSBqdWFuRmVybmFuZGV6LnRyYW5zbGF0ZShbeCAtIDAuMDkyICogaywgeSAtMCAqIGtdKShqdWFuRmVybmFuZGV6QmJveFswXSk7XG4gICAgICAgICAgICB4MCA9ICh4IC0gYzBbMF0pIC8gaztcbiAgICAgICAgICAgIHkwID0gKHkgLSBjMFsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgIGMxID0ganVhbkZlcm5hbmRlei50cmFuc2xhdGUoW3ggLSAwLjA5MiAqIGssIHkgLTAgKiBrXSkoanVhbkZlcm5hbmRlekJib3hbMV0pO1xuICAgICAgICAgICAgeDEgPSAoeCAtIGMxWzBdKSAvIGs7XG4gICAgICAgICAgICB5MSA9ICh5IC0gYzFbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ2p1YW5GZXJuYW5kZXo6IHAwOiAnICsgeDAgKyAnLCAnICsgeTAgKyAnICwgcDE6ICcgKyB4MSArICcgLSAnICsgeTEpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCcuY2xpcEV4dGVudChbW3ggJytcbiAgICAgICAgICAgICAoeDA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uLCB5ICcrXG4gICAgICAgICAgICAgKHkwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgICcgKiBrICsgZXBzaWxvbl0sW3ggJytcbiAgICAgICAgICAgICAoeDE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uLCB5ICcrXG4gICAgICAgICAgICAgKHkxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgICcgKiBrIC0gZXBzaWxvbl1dKScpO1xuICAgICAgICBcbiAgICAgICAgICAgICBjMCA9IHBhc2N1YS50cmFuc2xhdGUoW3ggLSAwLjA4OSAqIGssIHkgLTAuMDI2NSAqIGtdKShwYXNjdWFCYm94WzBdKTtcbiAgICAgICAgICAgICB4MCA9ICh4IC0gYzBbMF0pIC8gaztcbiAgICAgICAgICAgICB5MCA9ICh5IC0gYzBbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgICAgYzEgPSBwYXNjdWEudHJhbnNsYXRlKFt4IC0gMC4wODkgKiBrLCB5IC0wLjAyNjUgKiBrXSkocGFzY3VhQmJveFsxXSk7XG4gICAgICAgICAgICAgeDEgPSAoeCAtIGMxWzBdKSAvIGs7XG4gICAgICAgICAgICAgeTEgPSAoeSAtIGMxWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICAgIGNvbnNvbGUuaW5mbygncGFzY3VhOiBwMDogJyArIHgwICsgJywgJyArIHkwICsgJyAsIHAxOiAnICsgeDEgKyAnIC0gJyArIHkxKTtcbiAgICAgICAgICAgICBjb25zb2xlLmluZm8oJy5jbGlwRXh0ZW50KFtbeCAnK1xuICAgICAgICAgICAgICAoeDA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgICcgKiBrICsgZXBzaWxvbiwgeSAnK1xuICAgICAgICAgICAgICAoeTA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgICcgKiBrICsgZXBzaWxvbl0sW3ggJytcbiAgICAgICAgICAgICAgKHgxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHgxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgICAnICogayAtIGVwc2lsb24sIHkgJytcbiAgICAgICAgICAgICAgKHkxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgICAnICogayAtIGVwc2lsb25dXSknKTtcbiAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1haW5sYW5kUG9pbnQgPSBtYWlubGFuZFxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoXylcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjA1OSAqIGssIHkgLSAwLjM4MzUgKiBrXSwgW3ggKyAwLjQ0OTggKiBrLCB5ICsgMC4zMzc1ICoga11dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgYW50YXJjdGljUG9pbnQgPSBhbnRhcmN0aWNcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4wODcgKiBrLCB5ICsgMC4xNyAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMTE2NiAqIGsgKyBlcHNpbG9uLCB5ICsgMC4yNTgyICogayArIGVwc2lsb25dLCBbeCAtIDAuMDYgKiBrIC0gZXBzaWxvbiwgeSArIDAuMzIgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAganVhbkZlcm5hbmRlelBvaW50ID0ganVhbkZlcm5hbmRlelxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjA5MiAqIGssIHkgLSAwICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4xMTQgKiBrICsgZXBzaWxvbiwgeSAtIDAuMDEzICogayArIGVwc2lsb25dLCBbeCAtIDAuMDU5NCAqIGsgLSBlcHNpbG9uLCB5ICsgMC4wMTMzICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIHBhc2N1YVBvaW50ID0gcGFzY3VhXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMDg5ICogaywgeSAtIDAuMDI2NSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMDg5ICogayArIGVwc2lsb24sIHkgKyAwLjAxNTQgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4wNTg4ICogayAtIGVwc2lsb24sIHkgKyAwLjAzOTEgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zdmVyc2VNZXJjYXRvckNoaWxlLmZpdEV4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdEV4dGVudCh0cmFuc3ZlcnNlTWVyY2F0b3JDaGlsZSwgZXh0ZW50LCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICB0cmFuc3ZlcnNlTWVyY2F0b3JDaGlsZS5maXRTaXplID0gZnVuY3Rpb24gKHNpemUsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdFNpemUodHJhbnN2ZXJzZU1lcmNhdG9yQ2hpbGUsIHNpemUsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnN2ZXJzZU1lcmNhdG9yQ2hpbGU7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnN2ZXJzZU1lcmNhdG9yQ2hpbGUuZHJhd0NvbXBvc2l0aW9uQm9yZGVycyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiQ0xJUCBFWFRFTlQgYW50YXJjdGljOiBcIiwgYW50YXJjdGljLmNsaXBFeHRlbnQoKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJVTCBCQk9YOlwiLCBtYWlubGFuZC5pbnZlcnQoW2FudGFyY3RpYy5jbGlwRXh0ZW50KClbMF1bMF0sIGFudGFyY3RpYy5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJVUiBCQk9YOlwiLCBtYWlubGFuZC5pbnZlcnQoW2FudGFyY3RpYy5jbGlwRXh0ZW50KClbMV1bMF0sIGFudGFyY3RpYy5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJMRCBCQk9YOlwiLCBtYWlubGFuZC5pbnZlcnQoW2FudGFyY3RpYy5jbGlwRXh0ZW50KClbMV1bMF0sIGFudGFyY3RpYy5jbGlwRXh0ZW50KClbMV1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJMTCBCQk9YOlwiLCBtYWlubGFuZC5pbnZlcnQoW2FudGFyY3RpYy5jbGlwRXh0ZW50KClbMF1bMF0sIGFudGFyY3RpYy5jbGlwRXh0ZW50KClbMV1bMV1dKSk7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiQ0xJUCBFWFRFTlQganVhbkZlcm5hbmRlejogXCIsIGp1YW5GZXJuYW5kZXouY2xpcEV4dGVudCgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVMIEJCT1g6XCIsIG1haW5sYW5kLmludmVydChbanVhbkZlcm5hbmRlei5jbGlwRXh0ZW50KClbMF1bMF0sIGp1YW5GZXJuYW5kZXouY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVVIgQkJPWDpcIiwgbWFpbmxhbmQuaW52ZXJ0KFtqdWFuRmVybmFuZGV6LmNsaXBFeHRlbnQoKVsxXVswXSwganVhbkZlcm5hbmRlei5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJMRCBCQk9YOlwiLCBtYWlubGFuZC5pbnZlcnQoW2p1YW5GZXJuYW5kZXouY2xpcEV4dGVudCgpWzFdWzBdLCBqdWFuRmVybmFuZGV6LmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxMIEJCT1g6XCIsIG1haW5sYW5kLmludmVydChbanVhbkZlcm5hbmRlei5jbGlwRXh0ZW50KClbMF1bMF0sIGp1YW5GZXJuYW5kZXouY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkNMSVAgRVhURU5UIHBhc2N1YTogXCIsIHBhc2N1YS5jbGlwRXh0ZW50KCkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVUwgQkJPWDpcIiwgbWFpbmxhbmQuaW52ZXJ0KFtwYXNjdWEuY2xpcEV4dGVudCgpWzBdWzBdLCBwYXNjdWEuY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVVIgQkJPWDpcIiwgbWFpbmxhbmQuaW52ZXJ0KFtwYXNjdWEuY2xpcEV4dGVudCgpWzFdWzBdLCBwYXNjdWEuY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEQgQkJPWDpcIiwgbWFpbmxhbmQuaW52ZXJ0KFtwYXNjdWEuY2xpcEV4dGVudCgpWzFdWzBdLCBwYXNjdWEuY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEwgQkJPWDpcIiwgbWFpbmxhbmQuaW52ZXJ0KFtwYXNjdWEuY2xpcEV4dGVudCgpWzBdWzBdLCBwYXNjdWEuY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciB1bGFudGFyY3RpYyA9IG1haW5sYW5kKFstODIuNjk5OSwgLTUxLjMwNDNdKTtcbiAgICAgICAgICAgIHZhciB1cmFudGFyY3RpYyA9IG1haW5sYW5kKFstNzcuNTQ0MiwgLTUxLjY2MzFdKTtcbiAgICAgICAgICAgIHZhciBsZGFudGFyY3RpYyA9IG1haW5sYW5kKFstNzguMDI1NCwgLTU1LjE4NjBdKTtcbiAgICAgICAgICAgIHZhciBsbGFudGFyY3RpYyA9IG1haW5sYW5kKFstODMuNjEwNiwgLTU0Ljc3ODVdKTtcbiAgICAgICAgICAgIHZhciB1bGp1YW5GZXJuYW5kZXogPSBtYWlubGFuZChbLTgwLjA2MzgsIC0zNS45ODQwXSk7XG4gICAgICAgICAgICB2YXIgdXJqdWFuRmVybmFuZGV6ID0gbWFpbmxhbmQoWy03Ni4yMTUzLCAtMzYuMTgxMV0pO1xuICAgICAgICAgICAgdmFyIGxkanVhbkZlcm5hbmRleiA9IG1haW5sYW5kKFstNzYuMjk5NCwgLTM3LjY4MzldKTtcbiAgICAgICAgICAgIHZhciBsbGp1YW5GZXJuYW5kZXogPSBtYWlubGFuZChbLTgwLjIyMzEsIC0zNy40NzU3XSk7XG4gICAgICAgICAgICB2YXIgdWxwYXNjdWEgPSBtYWlubGFuZChbLTc4LjQ0MiwgLTM3LjcwNl0pO1xuICAgICAgICAgICAgdmFyIHVycGFzY3VhID0gbWFpbmxhbmQoWy03Ni4yNjMsIC0zNy44MDU0XSk7XG4gICAgICAgICAgICB2YXIgbGRwYXNjdWEgPSBtYWlubGFuZChbLTc2LjM0NCwgLTM5LjE1OTVdKTtcbiAgICAgICAgICAgIHZhciBsbHBhc2N1YSA9IG1haW5sYW5kKFstNzguNTYzOCwgLTM5LjA1NTldKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsYW50YXJjdGljWzBdLCB1bGFudGFyY3RpY1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1cmFudGFyY3RpY1swXSwgdXJhbnRhcmN0aWNbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRhbnRhcmN0aWNbMF0sIGxkYW50YXJjdGljWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkYW50YXJjdGljWzBdLCBsZGFudGFyY3RpY1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbGFudGFyY3RpY1swXSwgbGxhbnRhcmN0aWNbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsanVhbkZlcm5hbmRlelswXSwgdWxqdWFuRmVybmFuZGV6WzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyanVhbkZlcm5hbmRlelswXSwgdXJqdWFuRmVybmFuZGV6WzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkanVhbkZlcm5hbmRlelswXSwgbGRqdWFuRmVybmFuZGV6WzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkanVhbkZlcm5hbmRlelswXSwgbGRqdWFuRmVybmFuZGV6WzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsanVhbkZlcm5hbmRlelswXSwgbGxqdWFuRmVybmFuZGV6WzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bHBhc2N1YVswXSwgdWxwYXNjdWFbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJwYXNjdWFbMF0sIHVycGFzY3VhWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkcGFzY3VhWzBdLCBsZHBhc2N1YVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZHBhc2N1YVswXSwgbGRwYXNjdWFbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxwYXNjdWFbMF0sIGxscGFzY3VhWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zdmVyc2VNZXJjYXRvckNoaWxlLmdldENvbXBvc2l0aW9uQm9yZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gZDNQYXRoLnBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NvbXBvc2l0aW9uQm9yZGVycyhjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cmFuc3ZlcnNlTWVyY2F0b3JDaGlsZS5zY2FsZSg3MDApO1xuICAgIH1cbiAgICAvLyBUaGUgcHJvamVjdGlvbnMgbXVzdCBoYXZlIG11dHVhbGx5IGV4Y2x1c2l2ZSBjbGlwIHJlZ2lvbnMgb24gdGhlIHNwaGVyZSxcbiAgICAvLyBhcyB0aGlzIHdpbGwgYXZvaWQgZW1pdHRpbmcgaW50ZXJsZWF2aW5nIGxpbmVzIGFuZCBwb2x5Z29ucy5cbiAgICBmdW5jdGlvbiBtdWx0aXBsZXgkNihzdHJlYW1zKSB7XG4gICAgICAgIHZhciBuID0gc3RyZWFtcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgc3BoZXJlOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5zcGhlcmUoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgfSB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEEgY29tcG9zaXRlIHByb2plY3Rpb24gZm9yIFBvcnR1Z2FsLCBjb25maWd1cmVkIGJ5IGRlZmF1bHQgZm9yIDk2MMOXNTAwLlxuICAgIGZ1bmN0aW9uIGNvbmljRXF1aWRpc3RhbnRKYXBhbigpIHtcbiAgICAgICAgdmFyIGNhY2hlLCBjYWNoZVN0cmVhbSwgbWFpbmxhbmQgPSBkM0dlby5nZW9Db25pY0VxdWlkaXN0YW50KCkucm90YXRlKFstMTM2LCAtMjJdKS5wYXJhbGxlbHMoWzQwLCAzNF0pLCBtYWlubGFuZFBvaW50LCAvL2dpcy5zdGFja2V4Y2hhbmdlLmNvbS9hLzczMTM1XG4gICAgICAgIGhva2thaWRvID0gZDNHZW8uZ2VvQ29uaWNFcXVpZGlzdGFudCgpLnJvdGF0ZShbLTE0NiwgLTI2XSkucGFyYWxsZWxzKFs0MCwgMzRdKSwgaG9ra2FpZG9Qb2ludCwgb2tpbmF3YSA9IGQzR2VvLmdlb0NvbmljRXF1aWRpc3RhbnQoKS5yb3RhdGUoWy0xMjYsIC0xOV0pLnBhcmFsbGVscyhbNDAsIDM0XSksIG9raW5hd2FQb2ludCwgcG9pbnQsIHBvaW50U3RyZWFtID0geyBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgcG9pbnQgPSBbeCwgeV07IH0gfTtcbiAgICAgICAgLypcbiAgICAgICAgdmFyIG1haW5sYW5kQmJveCA9IFtbMTI2LjAsIDQxLjYwNl0sIFsxNDIuOTcsIDI5Ljk3XV07XG4gICAgICAgIHZhciBob2trYWlkb0Jib3ggPSBbWzEzOC43LCA0NS42MV0sIFsxNDYuMiwgNDEuMl1dO1xuICAgICAgICB2YXIgb2tpbmF3YUJib3ggPSBbWzEyMi42LCAyOS4wXSwgWzEzMCwgMjMuN11dO1xuICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjb25pY0VxdWlkaXN0YW50SmFwYW4oY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciB4ID0gY29vcmRpbmF0ZXNbMF0sIHkgPSBjb29yZGluYXRlc1sxXTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludCA9IG51bGwsXG4gICAgICAgICAgICAgICAgKG1haW5sYW5kUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoaG9ra2FpZG9Qb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChva2luYXdhUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25pY0VxdWlkaXN0YW50SmFwYW4uaW52ZXJ0ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgayA9IG1haW5sYW5kLnNjYWxlKCksIHQgPSBtYWlubGFuZC50cmFuc2xhdGUoKSwgeCA9IChjb29yZGluYXRlc1swXSAtIHRbMF0pIC8gaywgeSA9IChjb29yZGluYXRlc1sxXSAtIHRbMV0pIC8gaztcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAvL0hvdyBhcmUgdGhlIHJldHVybiB2YWx1ZXMgY2FsY3VsYXRlZDpcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKlwiKTtcbiAgICAgICAgICAgIHZhciBjMCA9IGhva2thaWRvKGhva2thaWRvQmJveFswXSk7XG4gICAgICAgICAgICB2YXIgeDAgPSAoYzBbMF0gLSB0WzBdKSAvIGs7XG4gICAgICAgICAgICB2YXIgeTAgPSAoYzBbMV0gLSB0WzFdKSAvIGs7XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJwMCBob2trYWlkb1wiLCB4MCArICcgLSAnICsgeTApO1xuICAgIFxuICAgICAgICAgICAgdmFyIGMxID0gaG9ra2FpZG8oaG9ra2FpZG9CYm94WzFdKTtcbiAgICAgICAgICAgIHZhciB4MSA9IChjMVswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHZhciB5MSA9IChjMVsxXSAtIHRbMV0pIC8gaztcbiAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInAxIGhva2thaWRvXCIsIHgxICsgJyAtICcgKyB5MSk7XG4gICAgXG4gICAgICAgICAgICBjMCA9IG9raW5hd2Eob2tpbmF3YUJib3hbMF0pO1xuICAgICAgICAgICAgeDAgPSAoYzBbMF0gLSB0WzBdKSAvIGs7XG4gICAgICAgICAgICB5MCA9IChjMFsxXSAtIHRbMV0pIC8gaztcbiAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInAwIG9raW5hd2FcIiwgeDAgKyAnIC0gJyArIHkwKTtcbiAgICBcbiAgICAgICAgICAgIGMxID0gb2tpbmF3YShva2luYXdhQmJveFsxXSk7XG4gICAgICAgICAgICB4MSA9IChjMVswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHkxID0gKGMxWzFdIC0gdFsxXSkgLyBrO1xuICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicDEgb2tpbmF3YVwiLCB4MSArICcgLSAnICsgeTEpO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiAoeSA+PSAtMC4xMDkyNSAmJiB5IDwgLTAuMDI3MDEgJiYgeCA+PSAtMC4xMzUgJiYgeCA8IC0wLjAzOTcgPyBob2trYWlkb1xuICAgICAgICAgICAgICAgIDogeSA+PSAwLjA0NzEzICYmIHkgPCAwLjExMTM4ICYmIHggPj0gLTAuMDM5ODYgJiYgeCA8IDAuMDUxID8gb2tpbmF3YVxuICAgICAgICAgICAgICAgICAgICA6IG1haW5sYW5kKS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0VxdWlkaXN0YW50SmFwYW4uc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gbXVsdGlwbGV4JDYoW21haW5sYW5kLnN0cmVhbShjYWNoZVN0cmVhbSA9IHN0cmVhbSksIGhva2thaWRvLnN0cmVhbShzdHJlYW0pLCBva2luYXdhLnN0cmVhbShzdHJlYW0pXSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljRXF1aWRpc3RhbnRKYXBhbi5wcmVjaXNpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW5sYW5kLnByZWNpc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFpbmxhbmQucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgaG9ra2FpZG8ucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgb2tpbmF3YS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNFcXVpZGlzdGFudEphcGFuLnNjYWxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWlubGFuZC5zY2FsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFpbmxhbmQuc2NhbGUoXyk7XG4gICAgICAgICAgICBob2trYWlkby5zY2FsZShfKTtcbiAgICAgICAgICAgIG9raW5hd2Euc2NhbGUoXyAqIDAuNyk7XG4gICAgICAgICAgICByZXR1cm4gY29uaWNFcXVpZGlzdGFudEphcGFuLnRyYW5zbGF0ZShtYWlubGFuZC50cmFuc2xhdGUoKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljRXF1aWRpc3RhbnRKYXBhbi50cmFuc2xhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW5sYW5kLnRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGsgPSBtYWlubGFuZC5zY2FsZSgpLCB4ID0gK19bMF0sIHkgPSArX1sxXTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICB2YXIgYzAgPSBtYWlubGFuZChtYWlubGFuZEJib3hbMF0pO1xuICAgICAgICAgICB2YXIgeDAgPSAoeCAtIGMwWzBdKSAvIGs7XG4gICAgICAgICAgIHZhciB5MCA9ICh5IC0gYzBbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgIHZhciBjMSA9IG1haW5sYW5kKG1haW5sYW5kQmJveFsxXSk7XG4gICAgICAgICAgIHZhciB4MSA9ICh4IC0gYzFbMF0pIC8gaztcbiAgICAgICAgICAgdmFyIHkxID0gKHkgLSBjMVsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgY29uc29sZS5pbmZvKCdNYWluOiBwMDogJyArIHgwICsgJywgJyArIHkwICsgJyAsIHAxOiAnICsgeDEgKyAnIC0gJyArIHkxKTtcbiAgICAgICAgICAgY29uc29sZS5pbmZvKCcuY2xpcEV4dGVudChbW3ggJytcbiAgICAgICAgICAgICh4MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrLCB5ICcrXG4gICAgICAgICAgICAoeTA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICoga10sW3ggJytcbiAgICAgICAgICAgICh4MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrLCB5ICcrXG4gICAgICAgICAgICAoeTE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICoga11dKScpO1xuICAgICAgICBcbiAgICAgICAgICAgYzAgPSBob2trYWlkby50cmFuc2xhdGUoW3ggLSAwLjA0MjUgKiBrLCB5IC0gMC4wMDUgKiBrXSkoaG9ra2FpZG9CYm94WzBdKTtcbiAgICAgICAgICAgeDAgPSAoeCAtIGMwWzBdKSAvIGs7XG4gICAgICAgICAgIHkwID0gKHkgLSBjMFsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgYzEgPSBob2trYWlkby50cmFuc2xhdGUoW3ggLSAwLjA0MjUgKiBrLCB5IC0gMC4wMDUgKiBrXSkoaG9ra2FpZG9CYm94WzFdKTtcbiAgICAgICAgICAgeDEgPSAoeCAtIGMxWzBdKSAvIGs7XG4gICAgICAgICAgIHkxID0gKHkgLSBjMVsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgY29uc29sZS5pbmZvKCdob2trYWlkbzogcDA6ICcgKyB4MCArICcsICcgKyB5MCArICcgLCBwMTogJyArIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgIGNvbnNvbGUuaW5mbygnLmNsaXBFeHRlbnQoW1t4ICcrXG4gICAgICAgICAgICAoeDA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICogayArIGVwc2lsb24sIHkgJytcbiAgICAgICAgICAgICh5MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrICsgZXBzaWxvbl0sW3ggJytcbiAgICAgICAgICAgICh4MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrIC0gZXBzaWxvbiwgeSAnK1xuICAgICAgICAgICAgKHkxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uXV0pJyk7XG4gICAgICAgIFxuICAgICAgICAgICAgYzAgPSBva2luYXdhLnRyYW5zbGF0ZShbeCAtIDAgKiBrLCB5ICsgMCAqIGtdKShva2luYXdhQmJveFswXSk7XG4gICAgICAgICAgICB4MCA9ICh4IC0gYzBbMF0pIC8gaztcbiAgICAgICAgICAgIHkwID0gKHkgLSBjMFsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgIGMxID0gb2tpbmF3YS50cmFuc2xhdGUoW3ggLSAwICogaywgeSArIDAgKiBrXSkob2tpbmF3YUJib3hbMV0pO1xuICAgICAgICAgICAgeDEgPSAoeCAtIGMxWzBdKSAvIGs7XG4gICAgICAgICAgICB5MSA9ICh5IC0gYzFbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ29raW5hd2E6IHAwOiAnICsgeDAgKyAnLCAnICsgeTAgKyAnICwgcDE6ICcgKyB4MSArICcgLSAnICsgeTEpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCcuY2xpcEV4dGVudChbW3ggJytcbiAgICAgICAgICAgICAoeDA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uLCB5ICcrXG4gICAgICAgICAgICAgKHkwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgICcgKiBrICsgZXBzaWxvbl0sW3ggJytcbiAgICAgICAgICAgICAoeDE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uLCB5ICcrXG4gICAgICAgICAgICAgKHkxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgICcgKiBrIC0gZXBzaWxvbl1dKScpO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtYWlubGFuZFBvaW50ID0gbWFpbmxhbmRcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKF8pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4xMzUyICogaywgeSAtIDAuMTA5MSAqIGtdLCBbeCArIDAuMTE3ICogaywgeSArIDAuMDk4ICoga11dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgaG9ra2FpZG9Qb2ludCA9IGhva2thaWRvXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMDQyNSAqIGssIHkgLSAwLjAwNSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMTM1ICogayArIGVwc2lsb24sIHkgLSAwLjEwOTMgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4wMzk3ICogayAtIGVwc2lsb24sIHkgLSAwLjAyNyAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBva2luYXdhUG9pbnQgPSBva2luYXdhXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShfKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMDM5OSAqIGsgKyBlcHNpbG9uLCB5ICsgMC4wNDcxICogayArIGVwc2lsb25dLCBbeCArIDAuMDUxICogayAtIGVwc2lsb24sIHkgKyAwLjExMTQgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljRXF1aWRpc3RhbnRKYXBhbi5maXRFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRFeHRlbnQoY29uaWNFcXVpZGlzdGFudEphcGFuLCBleHRlbnQsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljRXF1aWRpc3RhbnRKYXBhbi5maXRTaXplID0gZnVuY3Rpb24gKHNpemUsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdFNpemUoY29uaWNFcXVpZGlzdGFudEphcGFuLCBzaXplLCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmljRXF1aWRpc3RhbnRKYXBhbjtcbiAgICAgICAgfVxuICAgICAgICBjb25pY0VxdWlkaXN0YW50SmFwYW4uZHJhd0NvbXBvc2l0aW9uQm9yZGVycyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiQ0xJUCBFWFRFTlQgaG9ra2FpZG86IFwiLCBob2trYWlkby5jbGlwRXh0ZW50KCkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVUwgQkJPWDpcIiwgbWFpbmxhbmQuaW52ZXJ0KFtob2trYWlkby5jbGlwRXh0ZW50KClbMF1bMF0sIGhva2thaWRvLmNsaXBFeHRlbnQoKVswXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVSIEJCT1g6XCIsIG1haW5sYW5kLmludmVydChbaG9ra2FpZG8uY2xpcEV4dGVudCgpWzFdWzBdLCBob2trYWlkby5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJMRCBCQk9YOlwiLCBtYWlubGFuZC5pbnZlcnQoW2hva2thaWRvLmNsaXBFeHRlbnQoKVsxXVswXSwgaG9ra2FpZG8uY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEwgQkJPWDpcIiwgbWFpbmxhbmQuaW52ZXJ0KFtob2trYWlkby5jbGlwRXh0ZW50KClbMF1bMF0sIGhva2thaWRvLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgdWxob2trYWlkbyA9IG1haW5sYW5kKFsxMjYuMDEzMjA0ODM2ODkxNDMsIDQxLjYyMTA5MDMxMDIxNTU4NV0pO1xuICAgICAgICAgICAgdmFyIHVyaG9ra2FpZG8gPSBtYWlubGFuZChbMTMzLjA0MzA0Mzg3MDI1OTAzLCA0Mi4xNTA4NzUyMzcwNzE4Nl0pO1xuICAgICAgICAgICAgdmFyIGxkaG9ra2FpZG8gPSBtYWlubGFuZChbMTMzLjMwMjE3NjYwODA2ODgsIDM3LjQzOTc1NDQ0NzI1MDk4XSk7XG4gICAgICAgICAgICB2YXIgbGxob2trYWlkbyA9IG1haW5sYW5kKFsxMjYuODc4ODkxNjg2MjgyMjQsIDM2Ljk1NDg4OTQ1MTU5Nzc5XSk7XG4gICAgICAgICAgICB2YXIgbGxva2luYXdhID0gbWFpbmxhbmQoWzEzMi45LCAyOS44XSk7XG4gICAgICAgICAgICB2YXIgbG1va2luYXdhID0gbWFpbmxhbmQoWzEzNCwgMzNdKTtcbiAgICAgICAgICAgIHZhciBscm9raW5hd2EgPSBtYWlubGFuZChbMTM5LjMsIDMzLjJdKTtcbiAgICAgICAgICAgIHZhciBsbHJva2luYXdhID0gbWFpbmxhbmQoWzEzOS4xNiwgMzAuNV0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxob2trYWlkb1swXSwgdWxob2trYWlkb1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1cmhva2thaWRvWzBdLCB1cmhva2thaWRvWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkaG9ra2FpZG9bMF0sIGxkaG9ra2FpZG9bMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxob2trYWlkb1swXSwgbGxob2trYWlkb1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8obGxva2luYXdhWzBdLCBsbG9raW5hd2FbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obG1va2luYXdhWzBdLCBsbW9raW5hd2FbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obHJva2luYXdhWzBdLCBscm9raW5hd2FbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxyb2tpbmF3YVswXSwgbGxyb2tpbmF3YVsxXSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljRXF1aWRpc3RhbnRKYXBhbi5nZXRDb21wb3NpdGlvbkJvcmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGQzUGF0aC5wYXRoKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDb21wb3NpdGlvbkJvcmRlcnMoY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC50b1N0cmluZygpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY29uaWNFcXVpZGlzdGFudEphcGFuLnNjYWxlKDIyMDApO1xuICAgIH1cbiAgICAvLyBUaGUgcHJvamVjdGlvbnMgbXVzdCBoYXZlIG11dHVhbGx5IGV4Y2x1c2l2ZSBjbGlwIHJlZ2lvbnMgb24gdGhlIHNwaGVyZSxcbiAgICAvLyBhcyB0aGlzIHdpbGwgYXZvaWQgZW1pdHRpbmcgaW50ZXJsZWF2aW5nIGxpbmVzIGFuZCBwb2x5Z29ucy5cbiAgICBmdW5jdGlvbiBtdWx0aXBsZXgkNyhzdHJlYW1zKSB7XG4gICAgICAgIHZhciBuID0gc3RyZWFtcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgc3BoZXJlOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5zcGhlcmUoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgfSB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEEgY29tcG9zaXRlIHByb2plY3Rpb24gZm9yIEZyYW5jZSwgY29uZmlndXJlZCBieSBkZWZhdWx0IGZvciA5NjDDlzUwMC5cbiAgICBmdW5jdGlvbiBjb25pY0NvbmZvcm1hbEZyYW5jZSgpIHtcbiAgICAgICAgdmFyIGNhY2hlLCBjYWNoZVN0cmVhbSwgZXVyb3BlID0gZDNHZW8uZ2VvQ29uaWNDb25mb3JtYWwoKS5yb3RhdGUoWy0zLCAtNDYuMl0pLnBhcmFsbGVscyhbMCwgNjBdKSwgZXVyb3BlUG9pbnQsIGd1eWFuZSA9IGQzR2VvLmdlb01lcmNhdG9yKCkuY2VudGVyKFstNTMuMiwgMy45XSksIGd1eWFuZVBvaW50LCBtYXJ0aW5pcXVlID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5jZW50ZXIoWy02MS4wMywgMTQuNjddKSwgbWFydGluaXF1ZVBvaW50LCBndWFkZWxvdXBlID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5jZW50ZXIoWy02MS40NiwgMTYuMTRdKSwgZ3VhZGVsb3VwZVBvaW50LCBzYWludEJhcnRoZWxlbXkgPSBkM0dlby5nZW9NZXJjYXRvcigpLmNlbnRlcihbLTYyLjg1LCAxNy45Ml0pLCBzYWludEJhcnRoZWxlbXlQb2ludCwgc3RQaWVycmVNaXF1ZWxvbiA9IGQzR2VvLmdlb01lcmNhdG9yKCkuY2VudGVyKFstNTYuMjMsIDQ2LjkzXSksIHN0UGllcnJlTWlxdWVsb25Qb2ludCwgbWF5b3R0ZSA9IGQzR2VvLmdlb01lcmNhdG9yKCkuY2VudGVyKFs0NS4xNiwgLTEyLjhdKSwgbWF5b3R0ZVBvaW50LCByZXVuaW9uID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5jZW50ZXIoWzU1LjUyLCAtMjEuMTNdKSwgcmV1bmlvblBvaW50LCBub3V2ZWxsZUNhbGVkb25pZSA9IGQzR2VvLmdlb01lcmNhdG9yKCkuY2VudGVyKFsxNjUuOCwgLTIxLjA3XSksIG5vdXZlbGxlQ2FsZWRvbmllUG9pbnQsIHdhbGxpc0Z1dHVuYSA9IGQzR2VvLmdlb01lcmNhdG9yKCkuY2VudGVyKFstMTc4LjEsIC0xNC4zXSksIHdhbGxpc0Z1dHVuYVBvaW50LCBwb2x5bmVzaWUgPSBkM0dlby5nZW9NZXJjYXRvcigpLmNlbnRlcihbLTE1MC41NSwgLTE3LjExXSksIHBvbHluZXNpZVBvaW50LCBwb2x5bmVzaWUyID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5jZW50ZXIoWy0xNTAuNTUsIC0xNy4xMV0pLCBwb2x5bmVzaWUyUG9pbnQsIHBvaW50LCBwb2ludFN0cmVhbSA9IHsgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7IHBvaW50ID0gW3gsIHldOyB9IH07XG4gICAgICAgIC8qXG4gICAgICAgIHZhciBldXJvcGVCYm94ID0gW1stNi41LCA1MV0sIFsxMCwgNDFdXTtcbiAgICAgICAgdmFyIGd1eWFuZUJib3ggPSBbWy01NC41LCA2LjI5XSwgWy01MC45LCAxLjQ4XV07XG4gICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNvbmljQ29uZm9ybWFsRnJhbmNlKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGNvb3JkaW5hdGVzWzBdLCB5ID0gY29vcmRpbmF0ZXNbMV07XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQgPSBudWxsLFxuICAgICAgICAgICAgICAgIChldXJvcGVQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChndXlhbmVQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChtYXJ0aW5pcXVlUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoZ3VhZGVsb3VwZVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHNhaW50QmFydGhlbGVteVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHN0UGllcnJlTWlxdWVsb25Qb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChtYXlvdHRlUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAocmV1bmlvblBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG5vdXZlbGxlQ2FsZWRvbmllUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAod2FsbGlzRnV0dW5hUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAocG9seW5lc2llUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAocG9seW5lc2llMlBvaW50LnBvaW50KHgsIHkpLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uaWNDb25mb3JtYWxGcmFuY2UuaW52ZXJ0ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgayA9IGV1cm9wZS5zY2FsZSgpLCB0ID0gZXVyb3BlLnRyYW5zbGF0ZSgpLCB4ID0gKGNvb3JkaW5hdGVzWzBdIC0gdFswXSkgLyBrLCB5ID0gKGNvb3JkaW5hdGVzWzFdIC0gdFsxXSkgLyBrO1xuICAgICAgICAgICAgcmV0dXJuICh5ID49IDAuMDI5ICYmIHkgPCAwLjA4NjQgJiYgeCA+PSAtMC4xNCAmJiB4IDwgLTAuMDk5NiA/IGd1eWFuZVxuICAgICAgICAgICAgICAgIDogeSA+PSAwICYmIHkgPCAwLjAyOSAmJiB4ID49IC0wLjE0ICYmIHggPCAtMC4wOTk2ID8gbWFydGluaXF1ZVxuICAgICAgICAgICAgICAgICAgICA6IHkgPj0gLTAuMDMyICYmIHkgPCAwICYmIHggPj0gLTAuMTQgJiYgeCA8IC0wLjA5OTYgPyBndWFkZWxvdXBlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHkgPj0gLTAuMDUyICYmIHkgPCAtMC4wMzIgJiYgeCA+PSAtMC4xNCAmJiB4IDwgLTAuMDk5NiA/IHNhaW50QmFydGhlbGVteVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeSA+PSAtMC4wNzYgJiYgeSA8IDAuMDUyICYmIHggPj0gLTAuMTQgJiYgeCA8IC0wLjA5OTYgPyBzdFBpZXJyZU1pcXVlbG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeSA+PSAtMC4wNzYgJiYgeSA8IC0wLjA1MiAmJiB4ID49IDAuMDk2NyAmJiB4IDwgMC4xMzcxID8gbWF5b3R0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB5ID49IC0wLjA1MiAmJiB5IDwgLTAuMDIgJiYgeCA+PSAwLjA5NjcgJiYgeCA8IDAuMTM3MSA/IHJldW5pb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHkgPj0gLTAuMDIgJiYgeSA8IDAuMDEyICYmIHggPj0gMC4wOTY3ICYmIHggPCAwLjEzNzEgPyBub3V2ZWxsZUNhbGVkb25pZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHkgPj0gMC4wMTIgJiYgeSA8IDAuMDMzICYmIHggPj0gMC4wOTY3ICYmIHggPCAwLjEzNzEgPyB3YWxsaXNGdXR1bmFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeSA+PSAwLjAzMyAmJiB5IDwgMC4wODY0ICYmIHggPj0gMC4wOTY3ICYmIHggPCAwLjEzNzEgPyBwb2x5bmVzaWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGV1cm9wZSkuaW52ZXJ0KGNvb3JkaW5hdGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxGcmFuY2Uuc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gbXVsdGlwbGV4JDcoW2V1cm9wZS5zdHJlYW0oY2FjaGVTdHJlYW0gPSBzdHJlYW0pLCBndXlhbmUuc3RyZWFtKHN0cmVhbSksIG1hcnRpbmlxdWUuc3RyZWFtKHN0cmVhbSksIGd1YWRlbG91cGUuc3RyZWFtKHN0cmVhbSksIHNhaW50QmFydGhlbGVteS5zdHJlYW0oc3RyZWFtKSwgc3RQaWVycmVNaXF1ZWxvbi5zdHJlYW0oc3RyZWFtKSwgbWF5b3R0ZS5zdHJlYW0oc3RyZWFtKSwgcmV1bmlvbi5zdHJlYW0oc3RyZWFtKSwgbm91dmVsbGVDYWxlZG9uaWUuc3RyZWFtKHN0cmVhbSksIHdhbGxpc0Z1dHVuYS5zdHJlYW0oc3RyZWFtKSwgcG9seW5lc2llLnN0cmVhbShzdHJlYW0pLCBwb2x5bmVzaWUyLnN0cmVhbShzdHJlYW0pXSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljQ29uZm9ybWFsRnJhbmNlLnByZWNpc2lvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXVyb3BlLnByZWNpc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXVyb3BlLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIGd1eWFuZS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBtYXJ0aW5pcXVlLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIGd1YWRlbG91cGUucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgc2FpbnRCYXJ0aGVsZW15LnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHN0UGllcnJlTWlxdWVsb24ucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgbWF5b3R0ZS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICByZXVuaW9uLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIG5vdXZlbGxlQ2FsZWRvbmllLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHdhbGxpc0Z1dHVuYS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBwb2x5bmVzaWUucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgcG9seW5lc2llMi5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxGcmFuY2Uuc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV1cm9wZS5zY2FsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXVyb3BlLnNjYWxlKF8pO1xuICAgICAgICAgICAgZ3V5YW5lLnNjYWxlKF8gKiAwLjYpO1xuICAgICAgICAgICAgbWFydGluaXF1ZS5zY2FsZShfICogMS42KTtcbiAgICAgICAgICAgIGd1YWRlbG91cGUuc2NhbGUoXyAqIDEuNCk7XG4gICAgICAgICAgICBzYWludEJhcnRoZWxlbXkuc2NhbGUoXyAqIDUpO1xuICAgICAgICAgICAgc3RQaWVycmVNaXF1ZWxvbi5zY2FsZShfICogMS4zKTtcbiAgICAgICAgICAgIG1heW90dGUuc2NhbGUoXyAqIDEuNik7XG4gICAgICAgICAgICByZXVuaW9uLnNjYWxlKF8gKiAxLjIpO1xuICAgICAgICAgICAgbm91dmVsbGVDYWxlZG9uaWUuc2NhbGUoXyAqIDAuMyk7XG4gICAgICAgICAgICB3YWxsaXNGdXR1bmEuc2NhbGUoXyAqIDIuNyk7XG4gICAgICAgICAgICBwb2x5bmVzaWUuc2NhbGUoXyAqIDAuNSk7XG4gICAgICAgICAgICBwb2x5bmVzaWUyLnNjYWxlKF8gKiAwLjA2KTtcbiAgICAgICAgICAgIHJldHVybiBjb25pY0NvbmZvcm1hbEZyYW5jZS50cmFuc2xhdGUoZXVyb3BlLnRyYW5zbGF0ZSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxGcmFuY2UudHJhbnNsYXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldXJvcGUudHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgayA9IGV1cm9wZS5zY2FsZSgpLCB4ID0gK19bMF0sIHkgPSArX1sxXTtcbiAgICAgICAgICAgIGV1cm9wZVBvaW50ID0gZXVyb3BlXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShfKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMDk5NiAqIGssIHkgLSAwLjA5MDggKiBrXSwgW3ggKyAwLjA5NjcgKiBrLCB5ICsgMC4wODY0ICoga11dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgZ3V5YW5lUG9pbnQgPSBndXlhbmVcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4xMiAqIGssIHkgKyAwLjA1NzUgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjE0ICogayArIGVwc2lsb24sIHkgKyAwLjAyOSAqIGsgKyBlcHNpbG9uXSwgW3ggLSAwLjA5OTYgKiBrIC0gZXBzaWxvbiwgeSArIDAuMDg2NCAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBtYXJ0aW5pcXVlUG9pbnQgPSBtYXJ0aW5pcXVlXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMTIgKiBrLCB5ICsgMC4wMTMgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjE0ICogayArIGVwc2lsb24sIHkgKyAwICogayArIGVwc2lsb25dLCBbeCAtIDAuMDk5NiAqIGsgLSBlcHNpbG9uLCB5ICsgMC4wMjkgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgZ3VhZGVsb3VwZVBvaW50ID0gZ3VhZGVsb3VwZVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjEyICogaywgeSAtIDAuMDE0ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4xNCAqIGsgKyBlcHNpbG9uLCB5IC0gMC4wMzIgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4wOTk2ICogayAtIGVwc2lsb24sIHkgKyAwICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIHNhaW50QmFydGhlbGVteVBvaW50ID0gc2FpbnRCYXJ0aGVsZW15XG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMTIgKiBrLCB5IC0gMC4wNDQgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjE0ICogayArIGVwc2lsb24sIHkgLSAwLjA1MiAqIGsgKyBlcHNpbG9uXSwgW3ggLSAwLjA5OTYgKiBrIC0gZXBzaWxvbiwgeSAtIDAuMDMyICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIHN0UGllcnJlTWlxdWVsb25Qb2ludCA9IHN0UGllcnJlTWlxdWVsb25cbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4xMiAqIGssIHkgLSAwLjA2NSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMTQgKiBrICsgZXBzaWxvbiwgeSAtIDAuMDc2ICogayArIGVwc2lsb25dLCBbeCAtIDAuMDk5NiAqIGsgLSBlcHNpbG9uLCB5IC0gMC4wNTIgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgbWF5b3R0ZVBvaW50ID0gbWF5b3R0ZVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggKyAwLjExNyAqIGssIHkgLSAwLjA2NCAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCArIDAuMDk2NyAqIGsgKyBlcHNpbG9uLCB5IC0gMC4wNzYgKiBrICsgZXBzaWxvbl0sIFt4ICsgMC4xMzcxICogayAtIGVwc2lsb24sIHkgLSAwLjA1MiAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICByZXVuaW9uUG9pbnQgPSByZXVuaW9uXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMTE2ICogaywgeSAtIDAuMDM1NSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCArIDAuMDk2NyAqIGsgKyBlcHNpbG9uLCB5IC0gMC4wNTIgKiBrICsgZXBzaWxvbl0sIFt4ICsgMC4xMzcxICogayAtIGVwc2lsb24sIHkgLSAwLjAyICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIG5vdXZlbGxlQ2FsZWRvbmllUG9pbnQgPSBub3V2ZWxsZUNhbGVkb25pZVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggKyAwLjExNiAqIGssIHkgLSAwLjAwNDggKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggKyAwLjA5NjcgKiBrICsgZXBzaWxvbiwgeSAtIDAuMDIgKiBrICsgZXBzaWxvbl0sIFt4ICsgMC4xMzcxICogayAtIGVwc2lsb24sIHkgKyAwLjAxMiAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICB3YWxsaXNGdXR1bmFQb2ludCA9IHdhbGxpc0Z1dHVuYVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggKyAwLjExNiAqIGssIHkgKyAwLjAyMiAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCArIDAuMDk2NyAqIGsgKyBlcHNpbG9uLCB5ICsgMC4wMTIgKiBrICsgZXBzaWxvbl0sIFt4ICsgMC4xMzcxICogayAtIGVwc2lsb24sIHkgKyAwLjAzMyAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBwb2x5bmVzaWUyUG9pbnQgPSBwb2x5bmVzaWUyXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMTEgKiBrLCB5ICsgMC4wNDUgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggKyAwLjA5NjcgKiBrICsgZXBzaWxvbiwgeSArIDAuMDMzICogayArIGVwc2lsb25dLCBbeCArIDAuMTM3MSAqIGsgLSBlcHNpbG9uLCB5ICsgMC4wNiAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBwb2x5bmVzaWVQb2ludCA9IHBvbHluZXNpZVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggKyAwLjExNSAqIGssIHkgKyAwLjA3NSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCArIDAuMDk2NyAqIGsgKyBlcHNpbG9uLCB5ICsgMC4wNiAqIGsgKyBlcHNpbG9uXSwgW3ggKyAwLjEzNzEgKiBrIC0gZXBzaWxvbiwgeSArIDAuMDg2NCAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxGcmFuY2UuZml0RXh0ZW50ID0gZnVuY3Rpb24gKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0RXh0ZW50KGNvbmljQ29uZm9ybWFsRnJhbmNlLCBleHRlbnQsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljQ29uZm9ybWFsRnJhbmNlLmZpdFNpemUgPSBmdW5jdGlvbiAoc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0U2l6ZShjb25pY0NvbmZvcm1hbEZyYW5jZSwgc2l6ZSwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBjb25pY0NvbmZvcm1hbEZyYW5jZTtcbiAgICAgICAgfVxuICAgICAgICBjb25pY0NvbmZvcm1hbEZyYW5jZS5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInZhciB1bCwgdXIsIGxkLCBsbDtcIik7XG4gICAgICAgICAgICB2YXIgcHJvanMgPSBbZ3V5YW5lLCBtYXJ0aW5pcXVlLCBndWFkZWxvdXBlLCBzYWludEJhcnRoZWxlbXksIHN0UGllcnJlTWlxdWVsb24sIG1heW90dGUsIHJldW5pb24sIG5vdXZlbGxlQ2FsZWRvbmllLCB3YWxsaXNGdXR1bmEsIHBvbHluZXNpZSwgcG9seW5lc2llMl07XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHByb2pzKXtcbiAgICAgICAgICAgICAgdmFyIHVsID0gZXVyb3BlLmludmVydChbcHJvanNbaV0uY2xpcEV4dGVudCgpWzBdWzBdLCBwcm9qc1tpXS5jbGlwRXh0ZW50KClbMF1bMV1dKTtcbiAgICAgICAgICAgICAgdmFyIHVyID0gZXVyb3BlLmludmVydChbcHJvanNbaV0uY2xpcEV4dGVudCgpWzFdWzBdLCBwcm9qc1tpXS5jbGlwRXh0ZW50KClbMF1bMV1dKTtcbiAgICAgICAgICAgICAgdmFyIGxkID0gZXVyb3BlLmludmVydChbcHJvanNbaV0uY2xpcEV4dGVudCgpWzFdWzBdLCBwcm9qc1tpXS5jbGlwRXh0ZW50KClbMV1bMV1dKTtcbiAgICAgICAgICAgICAgdmFyIGxsID0gZXVyb3BlLmludmVydChbcHJvanNbaV0uY2xpcEV4dGVudCgpWzBdWzBdLCBwcm9qc1tpXS5jbGlwRXh0ZW50KClbMV1bMV1dKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidWwgPSBldXJvcGUoW1wiK3VsK1wiXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInVyID0gZXVyb3BlKFtcIit1citcIl0pO1wiKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJsZCA9IGV1cm9wZShbXCIrbGQrXCJdKTtcIik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibGwgPSBldXJvcGUoW1wiK2xsK1wiXSk7XCIpO1xuICAgICAgICBcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1wiKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb250ZXh0LmxpbmVUbyh1clswXSwgdXJbMV0pO1wiKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1wiKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1wiKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb250ZXh0LmNsb3NlUGF0aCgpO1wiKTtcbiAgICAgICAgXG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgIHZhciB1bCwgdXIsIGxkLCBsbDtcbiAgICAgICAgICAgIHVsID0gZXVyb3BlKFstNy45Mzg4ODY3MjUxMTEwMzYsIDQzLjcyMTk0NjA5MTg4MzVdKTtcbiAgICAgICAgICAgIHVyID0gZXVyb3BlKFstNC44MzIwODA4OTY0NTgyOTUsIDQ0LjEyOTMwMjY4NTQ5MzcyXSk7XG4gICAgICAgICAgICBsZCA9IGV1cm9wZShbLTQuMjA1Mjk5NzQzNzkzMjYzLCA0MC45ODA5NjM0Njk2NzM2NV0pO1xuICAgICAgICAgICAgbGwgPSBldXJvcGUoWy03LjA3MTc5NjQ1MzEyNjE1MiwgNDAuNjEwMDM3MzE5MTgxNDQ0XSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHVsID0gZXVyb3BlKFstOC40Mjc1MTM3MzYxNzY5MiwgNDUuMzI4ODk0NTI1NTMwMzFdKTtcbiAgICAgICAgICAgIHVyID0gZXVyb3BlKFstNS4xODU5OTMwNTc3NzEwNywgNDUuNzU2NjQ0MjA2Mjk3Nl0pO1xuICAgICAgICAgICAgbGQgPSBldXJvcGUoWy00LjgzMjA4MDkwNTE1NDQzMSwgNDQuMTI5MzAyNzI2NzUxNDI2XSk7XG4gICAgICAgICAgICBsbCA9IGV1cm9wZShbLTcuOTM4ODg2NzM3MTI2MTkyLCA0My43MjE5NDYxMzI2Mzg1NF0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbLTkuMDEyNjU2ODk5NjU3MDQ2LCA0Ny4xMjc3MzM4MjEwMzAxNzZdKTtcbiAgICAgICAgICAgIHVyID0gZXVyb3BlKFstNS42MTA1MjQ0NzcyNzkzMTU1LCA0Ny41Nzk3Nzc4NjE0MTA2MjZdKTtcbiAgICAgICAgICAgIGxkID0gZXVyb3BlKFstNS4xODU5OTMwNjcxNjg1ODUsIDQ1Ljc1NjY0NDI0ODE3MDM0Nl0pO1xuICAgICAgICAgICAgbGwgPSBldXJvcGUoWy04LjQyNzUxMzc0OTE0MTgxMSwgNDUuMzI4ODk0NTY2ODYzMjZdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1clswXSwgdXJbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRbMF0sIGxkWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdWwgPSBldXJvcGUoWy05LjQwNTc0NzU1ODk4NTU1MywgNDguMjY1MDYzNzU1NTc0NTddKTtcbiAgICAgICAgICAgIHVyID0gZXVyb3BlKFstNS44OTYxNzUwMTg0Mzk1NzUsIDQ4LjczMzM1Mjg1MDg1MTYyNF0pO1xuICAgICAgICAgICAgbGQgPSBldXJvcGUoWy01LjYxMDUyNDQ4NzU1NjA0MywgNDcuNTc5Nzc3OTAzOTM3NjFdKTtcbiAgICAgICAgICAgIGxsID0gZXVyb3BlKFstOS4wMTI2NTY5MTM4MDgzNTEsIDQ3LjEyNzczMzg2Mjk3MTI1NV0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbLTkuOTA4NDM2MDYxMzQ2OTc0LCA0OS42NDI0NDg3ODk1MDU4NTZdKTtcbiAgICAgICAgICAgIHVyID0gZXVyb3BlKFstNi4yNjIwMjY3MTYyMzMxMjQsIDUwLjEzMTQyNjg0MTc4NzE3NF0pO1xuICAgICAgICAgICAgbGQgPSBldXJvcGUoWy01Ljg5NjE3NTAyOTMzMTIzMiwgNDguNzMzMzUyODkzNzcyNThdKTtcbiAgICAgICAgICAgIGxsID0gZXVyb3BlKFstOS40MDU3NDc1NzM5NjM5MywgNDguMjY1MDYzNzk3ODc3NjddKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1clswXSwgdXJbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRbMF0sIGxkWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdWwgPSBldXJvcGUoWzExLjk5NjkwNzcwNjUwNDQ2MiwgNTAuMTYwMzkwMjgxNjM1NzldKTtcbiAgICAgICAgICAgIHVyID0gZXVyb3BlKFsxNS42NDk5MDc4Nzk3NzMzNDMsIDQ5LjY4Mjc5MjQ2NzY1MjUzXSk7XG4gICAgICAgICAgICBsZCA9IGV1cm9wZShbMTUuMTU2NzEyODQwNTI2NjMyLCA0OC4zMDM3MTU1NzYyNTgzMV0pO1xuICAgICAgICAgICAgbGwgPSBldXJvcGUoWzExLjY0MTIyNjYxNzU0NDExLCA0OC43NjEwNzgyNDA1NDY4MTZdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1clswXSwgdXJbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRbMF0sIGxkWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdWwgPSBldXJvcGUoWzExLjY0MTIyNjYwNjk1NTc4OCwgNDguNzYxMDc4MTk3NTg4OV0pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWzE1LjE1NjcxMjgyNTgzMjE2NCwgNDguMzAzNzE1NTMzOTA0NjVdKTtcbiAgICAgICAgICAgIGxkID0gZXVyb3BlKFsxNC41NDk5MzIxNjYyNDExNzIsIDQ2LjQ4NjY1MzI0ODYxOTldKTtcbiAgICAgICAgICAgIGxsID0gZXVyb3BlKFsxMS4yMDQ0NDM3ODc5NTIxODMsIDQ2LjkxODk5MjMzOTE0MjQ4XSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHVsID0gZXVyb3BlKFsxMS4yMDQ0NDM3NzgyOTcxNjEsIDQ2LjkxODk5MjI5NjgyMzY0Nl0pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWzE0LjU0OTkzMjE1MjgxNTAzOSwgNDYuNDg2NjUzMjA2ODU2Mzk2XSk7XG4gICAgICAgICAgICBsZCA9IGV1cm9wZShbMTMuOTk0NDA5Nzk2NzY0MDA5LCA0NC42OTU4MzM0NDQzMjMyNTZdKTtcbiAgICAgICAgICAgIGxsID0gZXVyb3BlKFsxMC44MDUzMDY1OTkyNTM4NDgsIDQ1LjEwNTEzMzg3MDY4NDkyNF0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbMTAuODA1MzA2NTkwNDEyMDg1LCA0NS4xMDUxMzM4MjkwMzMwOF0pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWzEzLjk5NDQwOTc4NDQ0NzMzLCA0NC42OTU4MzM0MDMxODM2MDZdKTtcbiAgICAgICAgICAgIGxkID0gZXVyb3BlKFsxMy42NTQ2MzM3OTkwMjQzOTIsIDQzLjUzNTUyNDY4NTU4MTUyXSk7XG4gICAgICAgICAgICBsbCA9IGV1cm9wZShbMTAuNTYxNTE2ODAzOTgwOTU2LCA0My45MzA2NzE0NTk3OTg2MjRdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1clswXSwgdXJbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRbMF0sIGxkWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdWwgPSBldXJvcGUoWzEwLjU2MTUxNjc5NTYxNzM4MywgNDMuOTMwNjcxNDE4NTk3NTddKTtcbiAgICAgICAgICAgIHVyID0gZXVyb3BlKFsxMy42NTQ2MzM3ODczNjE5NTIsIDQzLjUzNTUyNDY0NDg2NzFdKTtcbiAgICAgICAgICAgIGxkID0gZXVyb3BlKFsxMi44Njc2OTE2MDQyMzk5MDEsIDQwLjY0MDcwMTk4NTAxOTQwNV0pO1xuICAgICAgICAgICAgbGwgPSBldXJvcGUoWzkuOTk3ODA5NTE1OTg3Njg4LCA0MS4wMDI4ODM0MzI1NDQ3MV0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbMTAuOCwgNDIuNF0pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWzEyLjgsIDQyLjEzXSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxGcmFuY2UuZ2V0Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBkM1BhdGgucGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzKGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbmljQ29uZm9ybWFsRnJhbmNlLnNjYWxlKDI3MDApO1xuICAgIH1cbiAgICAvLyBUaGUgcHJvamVjdGlvbnMgbXVzdCBoYXZlIG11dHVhbGx5IGV4Y2x1c2l2ZSBjbGlwIHJlZ2lvbnMgb24gdGhlIHNwaGVyZSxcbiAgICAvLyBhcyB0aGlzIHdpbGwgYXZvaWQgZW1pdHRpbmcgaW50ZXJsZWF2aW5nIGxpbmVzIGFuZCBwb2x5Z29ucy5cbiAgICBmdW5jdGlvbiBtdWx0aXBsZXgkOChzdHJlYW1zKSB7XG4gICAgICAgIHZhciBuID0gc3RyZWFtcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgc3BoZXJlOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5zcGhlcmUoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgfSB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEEgY29tcG9zaXRlIHByb2plY3Rpb24gZm9yIFBvcnR1Z2FsLCBjb25maWd1cmVkIGJ5IGRlZmF1bHQgZm9yIDk2MMOXNTAwLlxuICAgIGZ1bmN0aW9uIGNvbmljQ29uZm9ybWFsRXVyb3BlKCkge1xuICAgICAgICB2YXIgY2FjaGUsIGNhY2hlU3RyZWFtLCBldXJvcGUgPSBkM0dlby5nZW9Db25pY0NvbmZvcm1hbCgpLnJvdGF0ZShbLTEwLCAtNTNdKS5wYXJhbGxlbHMoWzAsIDYwXSksIGV1cm9wZVBvaW50LCBndWFkZWxvdXBlID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5jZW50ZXIoWy02MS40NiwgMTYuMTRdKSwgZ3VhZGVsb3VwZVBvaW50LCBndXlhbmUgPSBkM0dlby5nZW9NZXJjYXRvcigpLmNlbnRlcihbLTUzLjIsIDMuOV0pLCBndXlhbmVQb2ludCwgYXpvcmVzID0gZDNHZW8uZ2VvQ29uaWNDb25mb3JtYWwoKS5yb3RhdGUoWzI3LjgsIC0zOC45XSkucGFyYWxsZWxzKFswLCA2MF0pLCBhem9yZXNQb2ludCwgYXpvcmVzMiA9IGQzR2VvLmdlb0NvbmljQ29uZm9ybWFsKCkucm90YXRlKFsyNS40MywgLTM3LjM5OF0pLnBhcmFsbGVscyhbMCwgNjBdKSwgYXpvcmVzMlBvaW50LCBhem9yZXMzID0gZDNHZW8uZ2VvQ29uaWNDb25mb3JtYWwoKS5yb3RhdGUoWzMxLjE3LCAtMzkuNTM5XSkucGFyYWxsZWxzKFswLCA2MF0pLCBhem9yZXMzUG9pbnQsIG1hZGVpcmEgPSBkM0dlby5nZW9Db25pY0NvbmZvcm1hbCgpLnJvdGF0ZShbMTcsIC0zMi43XSkucGFyYWxsZWxzKFswLCA2MF0pLCBtYWRlaXJhUG9pbnQsIGNhbmFyeUlzbGFuZHMgPSBkM0dlby5nZW9Db25pY0NvbmZvcm1hbCgpLnJvdGF0ZShbMTYsIC0yOC41XSkucGFyYWxsZWxzKFswLCA2MF0pLCBjYW5hcnlJc2xhbmRzUG9pbnQsIG1hcnRpbmlxdWUgPSBkM0dlby5nZW9NZXJjYXRvcigpLmNlbnRlcihbLTYxLjAzLCAxNC42N10pLCBtYXJ0aW5pcXVlUG9pbnQsIG1heW90dGUgPSBkM0dlby5nZW9NZXJjYXRvcigpLmNlbnRlcihbNDUuMTYsIC0xMi44XSksIG1heW90dGVQb2ludCwgcmV1bmlvbiA9IGQzR2VvLmdlb01lcmNhdG9yKCkuY2VudGVyKFs1NS41MiwgLTIxLjEzXSksIHJldW5pb25Qb2ludCwgbWFsdGEgPSBkM0dlby5nZW9Db25pY0NvbmZvcm1hbCgpLnJvdGF0ZShbLTE0LjQsIC0zNS45NV0pLnBhcmFsbGVscyhbMCwgNjBdKSwgbWFsdGFQb2ludCwgcG9pbnQsIHBvaW50U3RyZWFtID0geyBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgcG9pbnQgPSBbeCwgeV07IH0gfTtcbiAgICAgICAgLypcbiAgICAgICAgdmFyIGV1cm9wZUJib3ggPSBbWy02LjUsIDUxXSwgWzEwLCA0MV1dO1xuICAgICAgICB2YXIgZ3V5YW5lQmJveCA9IFtbLTU0LjUsIDYuMjldLCBbLTUwLjksIDEuNDhdXTtcbiAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY29uaWNDb25mb3JtYWxFdXJvcGUoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciB4ID0gY29vcmRpbmF0ZXNbMF0sIHkgPSBjb29yZGluYXRlc1sxXTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludCA9IG51bGwsXG4gICAgICAgICAgICAgICAgKGV1cm9wZVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGd1eWFuZVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG1hcnRpbmlxdWVQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChndWFkZWxvdXBlUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoY2FuYXJ5SXNsYW5kc1BvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG1hZGVpcmFQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChtYXlvdHRlUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAocmV1bmlvblBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG1hbHRhUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoYXpvcmVzUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoYXpvcmVzMlBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGF6b3JlczNQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbmljQ29uZm9ybWFsRXVyb3BlLmludmVydCA9IGZ1bmN0aW9uIChjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIGsgPSBldXJvcGUuc2NhbGUoKSwgdCA9IGV1cm9wZS50cmFuc2xhdGUoKSwgeCA9IChjb29yZGluYXRlc1swXSAtICh0WzBdICsgMC4wOCAqIGspKSAvIGssIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgICAgICAgICByZXR1cm4gKHkgPj0gLTAuMzEgJiYgeSA8IC0wLjI0ICYmIHggPj0gMC4xNCAmJiB4IDwgMC4yNCA/IGd1YWRlbG91cGVcbiAgICAgICAgICAgICAgICA6IHkgPj0gLTAuMjQgJiYgeSA8IC0wLjE3ICYmIHggPj0gMC4xNCAmJiB4IDwgMC4yNCA/IGd1eWFuZVxuICAgICAgICAgICAgICAgICAgICA6IHkgPj0gLTAuMTcgJiYgeSA8IC0wLjEyICYmIHggPj0gMC4yMSAmJiB4IDwgMC4yNCA/IGF6b3JlczJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogeSA+PSAtMC4xNyAmJiB5IDwgLTAuMTQgJiYgeCA+PSAwLjE0ICYmIHggPCAwLjE2NSA/IGF6b3JlczNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHkgPj0gLTAuMTcgJiYgeSA8IC0wLjEgJiYgeCA+PSAwLjE0ICYmIHggPCAwLjI0ID8gYXpvcmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeSA+PSAtMC4xICYmIHkgPCAtMC4wMyAmJiB4ID49IDAuMTQgJiYgeCA8IDAuMjQgPyBtYWRlaXJhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHkgPj0gLTAuMDMgJiYgeSA8IDAuMDQgJiYgeCA+PSAwLjE0ICYmIHggPCAwLjI0ID8gY2FuYXJ5SXNsYW5kc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeSA+PSAtMC4zMSAmJiB5IDwgLTAuMjQgJiYgeCA+PSAwLjI0ICYmIHggPCAwLjM0ID8gbWFydGluaXF1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHkgPj0gLTAuMjQgJiYgeSA8IC0wLjE3ICYmIHggPj0gMC4yNCAmJiB4IDwgMC4zNCA/IG1heW90dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeSA+PSAtMC4xNyAmJiB5IDwgLTAuMSAmJiB4ID49IDAuMjQgJiYgeCA8IDAuMzQgPyByZXVuaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB5ID49IC0wLjEgJiYgeSA8IC0wLjAzICYmIHggPj0gMC4yNCAmJiB4IDwgMC4zNCA/IG1hbHRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZXVyb3BlKS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbEV1cm9wZS5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBtdWx0aXBsZXgkOChbZXVyb3BlLnN0cmVhbShjYWNoZVN0cmVhbSA9IHN0cmVhbSksIGd1eWFuZS5zdHJlYW0oc3RyZWFtKSwgbWFydGluaXF1ZS5zdHJlYW0oc3RyZWFtKSwgZ3VhZGVsb3VwZS5zdHJlYW0oc3RyZWFtKSwgY2FuYXJ5SXNsYW5kcy5zdHJlYW0oc3RyZWFtKSwgbWFkZWlyYS5zdHJlYW0oc3RyZWFtKSwgbWF5b3R0ZS5zdHJlYW0oc3RyZWFtKSwgcmV1bmlvbi5zdHJlYW0oc3RyZWFtKSwgbWFsdGEuc3RyZWFtKHN0cmVhbSksIGF6b3Jlcy5zdHJlYW0oc3RyZWFtKSwgYXpvcmVzMi5zdHJlYW0oc3RyZWFtKSwgYXpvcmVzMy5zdHJlYW0oc3RyZWFtKV0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbEV1cm9wZS5wcmVjaXNpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV1cm9wZS5wcmVjaXNpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV1cm9wZS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBndXlhbmUucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgbWFydGluaXF1ZS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBndWFkZWxvdXBlLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIGNhbmFyeUlzbGFuZHMucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgbWFkZWlyYS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBtYXlvdHRlLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHJldW5pb24ucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgbWFsdGEucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgYXpvcmVzLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIGF6b3JlczIucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgYXpvcmVzMy5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxFdXJvcGUuc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV1cm9wZS5zY2FsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXVyb3BlLnNjYWxlKF8pO1xuICAgICAgICAgICAgZ3VhZGVsb3VwZS5zY2FsZShfICogMyk7XG4gICAgICAgICAgICBndXlhbmUuc2NhbGUoXyAqIDAuOCk7XG4gICAgICAgICAgICBtYXJ0aW5pcXVlLnNjYWxlKF8gKiAzLjUpO1xuICAgICAgICAgICAgcmV1bmlvbi5zY2FsZShfICogMi43KTtcbiAgICAgICAgICAgIGF6b3Jlcy5zY2FsZShfICogMik7XG4gICAgICAgICAgICBhem9yZXMyLnNjYWxlKF8gKiAyKTtcbiAgICAgICAgICAgIGF6b3JlczMuc2NhbGUoXyAqIDIpO1xuICAgICAgICAgICAgbWFkZWlyYS5zY2FsZShfICogMyk7XG4gICAgICAgICAgICBjYW5hcnlJc2xhbmRzLnNjYWxlKF8pO1xuICAgICAgICAgICAgbWF5b3R0ZS5zY2FsZShfICogNS41KTtcbiAgICAgICAgICAgIG1hbHRhLnNjYWxlKF8gKiA2KTtcbiAgICAgICAgICAgIHJldHVybiBjb25pY0NvbmZvcm1hbEV1cm9wZS50cmFuc2xhdGUoZXVyb3BlLnRyYW5zbGF0ZSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxFdXJvcGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldXJvcGUudHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgayA9IGV1cm9wZS5zY2FsZSgpLCB4ID0gK19bMF0sIHkgPSArX1sxXTtcbiAgICAgICAgICAgIGV1cm9wZVBvaW50ID0gZXVyb3BlXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMDggKiBrLCB5XSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjUxICogaywgeSAtIDAuMzMgKiBrXSwgW3ggKyAwLjUgKiBrLCB5ICsgMC4zMyAqIGtdXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIGd1YWRlbG91cGVQb2ludCA9IGd1YWRlbG91cGVcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4ICsgMC4xOSAqIGssIHkgLSAwLjI3NSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCArIDAuMTQgKiBrICsgZXBzaWxvbiwgeSAtIDAuMzEgKiBrICsgZXBzaWxvbl0sIFt4ICsgMC4yNCAqIGsgLSBlcHNpbG9uLCB5IC0gMC4yNCAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBndXlhbmVQb2ludCA9IGd1eWFuZVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggKyAwLjE5ICogaywgeSAtIDAuMjA1ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4ICsgMC4xNCAqIGsgKyBlcHNpbG9uLCB5IC0gMC4yNCAqIGsgKyBlcHNpbG9uXSwgW3ggKyAwLjI0ICogayAtIGVwc2lsb24sIHkgLSAwLjE3ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIGF6b3Jlc1BvaW50ID0gYXpvcmVzXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMTkgKiBrLCB5IC0gMC4xMzUgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggKyAwLjE0ICogayArIGVwc2lsb24sIHkgLSAwLjE3ICogayArIGVwc2lsb25dLCBbeCArIDAuMjQgKiBrIC0gZXBzaWxvbiwgeSAtIDAuMSAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBhem9yZXMyUG9pbnQgPSBhem9yZXMyXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMjI1ICogaywgeSAtIDAuMTQ3ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4ICsgMC4yMSAqIGsgKyBlcHNpbG9uLCB5IC0gMC4xNyAqIGsgKyBlcHNpbG9uXSwgW3ggKyAwLjI0ICogayAtIGVwc2lsb24sIHkgLSAwLjEyICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIGF6b3JlczNQb2ludCA9IGF6b3JlczNcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4ICsgMC4xNTMgKiBrLCB5IC0gMC4xNSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCArIDAuMTQgKiBrICsgZXBzaWxvbiwgeSAtIDAuMTcgKiBrICsgZXBzaWxvbl0sIFt4ICsgMC4xNjUgKiBrIC0gZXBzaWxvbiwgeSAtIDAuMTQgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgbWFkZWlyYVBvaW50ID0gbWFkZWlyYVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggKyAwLjE5ICogaywgeSAtIDAuMDY1ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4ICsgMC4xNCAqIGsgKyBlcHNpbG9uLCB5IC0gMC4xICogayArIGVwc2lsb25dLCBbeCArIDAuMjQgKiBrIC0gZXBzaWxvbiwgeSAtIDAuMDMgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgY2FuYXJ5SXNsYW5kc1BvaW50ID0gY2FuYXJ5SXNsYW5kc1xuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggKyAwLjE5ICogaywgeSArIDAuMDA1ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4ICsgMC4xNCAqIGsgKyBlcHNpbG9uLCB5IC0gMC4wMyAqIGsgKyBlcHNpbG9uXSwgW3ggKyAwLjI0ICogayAtIGVwc2lsb24sIHkgKyAwLjA0ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIG1hcnRpbmlxdWVQb2ludCA9IG1hcnRpbmlxdWVcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4ICsgMC4yOSAqIGssIHkgLSAwLjI3NSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCArIDAuMjQgKiBrICsgZXBzaWxvbiwgeSAtIDAuMzEgKiBrICsgZXBzaWxvbl0sIFt4ICsgMC4zNCAqIGsgLSBlcHNpbG9uLCB5IC0gMC4yNCAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBtYXlvdHRlUG9pbnQgPSBtYXlvdHRlXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMjkgKiBrLCB5IC0gMC4yMDUgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggKyAwLjI0ICogayArIGVwc2lsb24sIHkgLSAwLjI0ICogayArIGVwc2lsb25dLCBbeCArIDAuMzQgKiBrIC0gZXBzaWxvbiwgeSAtIDAuMTcgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgcmV1bmlvblBvaW50ID0gcmV1bmlvblxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggKyAwLjI5ICogaywgeSAtIDAuMTM1ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4ICsgMC4yNCAqIGsgKyBlcHNpbG9uLCB5IC0gMC4xNyAqIGsgKyBlcHNpbG9uXSwgW3ggKyAwLjM0ICogayAtIGVwc2lsb24sIHkgLSAwLjEgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgbWFsdGFQb2ludCA9IG1hbHRhXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMjkgKiBrLCB5IC0gMC4wNjUgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggKyAwLjI0ICogayArIGVwc2lsb24sIHkgLSAwLjEgKiBrICsgZXBzaWxvbl0sIFt4ICsgMC4zNCAqIGsgLSBlcHNpbG9uLCB5IC0gMC4wMyAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxFdXJvcGUuZml0RXh0ZW50ID0gZnVuY3Rpb24gKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0RXh0ZW50KGNvbmljQ29uZm9ybWFsRXVyb3BlLCBleHRlbnQsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljQ29uZm9ybWFsRXVyb3BlLmZpdFNpemUgPSBmdW5jdGlvbiAoc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0U2l6ZShjb25pY0NvbmZvcm1hbEV1cm9wZSwgc2l6ZSwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBjb25pY0NvbmZvcm1hbEV1cm9wZTtcbiAgICAgICAgfVxuICAgICAgICBjb25pY0NvbmZvcm1hbEV1cm9wZS5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInZhciB1bCwgdXIsIGxkLCBsbDtcIik7XG4gICAgICAgICAgICB2YXIgcHJvanMgPSBbZ3V5YW5lLCBtYXJ0aW5pcXVlLCBndWFkZWxvdXBlLCBjYW5hcnlJc2xhbmRzLCBtYWRlaXJhLCBtYXlvdHRlLCByZXVuaW9uLCBtYWx0YSwgYXpvcmVzLCBhem9yZXMyLCBhem9yZXMzXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gcHJvanMpe1xuICAgICAgICAgICAgICB2YXIgdWwgPSBldXJvcGUuaW52ZXJ0KFtwcm9qc1tpXS5jbGlwRXh0ZW50KClbMF1bMF0sIHByb2pzW2ldLmNsaXBFeHRlbnQoKVswXVsxXV0pO1xuICAgICAgICAgICAgICB2YXIgdXIgPSBldXJvcGUuaW52ZXJ0KFtwcm9qc1tpXS5jbGlwRXh0ZW50KClbMV1bMF0sIHByb2pzW2ldLmNsaXBFeHRlbnQoKVswXVsxXV0pO1xuICAgICAgICAgICAgICB2YXIgbGQgPSBldXJvcGUuaW52ZXJ0KFtwcm9qc1tpXS5jbGlwRXh0ZW50KClbMV1bMF0sIHByb2pzW2ldLmNsaXBFeHRlbnQoKVsxXVsxXV0pO1xuICAgICAgICAgICAgICB2YXIgbGwgPSBldXJvcGUuaW52ZXJ0KFtwcm9qc1tpXS5jbGlwRXh0ZW50KClbMF1bMF0sIHByb2pzW2ldLmNsaXBFeHRlbnQoKVsxXVsxXV0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bCA9IGV1cm9wZShbXCIrdWwrXCJdKTtcIik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidXIgPSBldXJvcGUoW1wiK3VyK1wiXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImxkID0gZXVyb3BlKFtcIitsZCtcIl0pO1wiKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJsbCA9IGV1cm9wZShbXCIrbGwrXCJdKTtcIik7XG4gICAgICAgIFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQuY2xvc2VQYXRoKCk7XCIpO1xuICAgICAgICBcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgdmFyIHVsLCB1ciwgbGQsIGxsO1xuICAgICAgICAgICAgdWwgPSBldXJvcGUoWzQyLjQ1NzU1NjEwODI4NjQ4LCA2My4zNDM2NTg1NDc5MTQ5MzRdKTtcbiAgICAgICAgICAgIHVyID0gZXVyb3BlKFs1Mi42NTgzNzI2NjY2NzAyOSwgNTkuMzUwNDUwODAyOTA5MjldKTtcbiAgICAgICAgICAgIGxkID0gZXVyb3BlKFs0Ny4xOTc1NDUwMjI0Nzc4NSwgNTYuMTI2NTM0OTY1NDgxMTddKTtcbiAgICAgICAgICAgIGxsID0gZXVyb3BlKFszNy42NzMwMzQyNzMzNjMwNDQsIDU5LjYxNjM4MjY4NTA2MTExXSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHVsID0gZXVyb3BlKFs1OS40MTExMDc1NDAwMzQwMywgNjIuMzUwNjk3MjczOTkzMzZdKTtcbiAgICAgICAgICAgIHVyID0gZXVyb3BlKFs2Ni43NTA1MDIyODY0MDc5NCwgNTcuMTE3OTczMDM2MzYwMzhdKTtcbiAgICAgICAgICAgIGxkID0gZXVyb3BlKFs2MC4yMzYwNjU3MjUxMTA0MzYsIDU0LjYzMzMxNDMzODE4OTkyXSk7XG4gICAgICAgICAgICBsbCA9IGV1cm9wZShbNTIuNjU4MzczMTMxNTMzMTEsIDU5LjM1MDQ1MDgwNDU5OTM1NV0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbNDguODEwOTExMzAwODAyNDMsIDY2LjkzMzUzNDAyNjM0NjQxXSk7XG4gICAgICAgICAgICB1ciA9IGV1cm9wZShbNTkuNDExMTA3MzA2NTQ2NzksIDYyLjM1MDY5NzQwNjUzMDg2XSk7XG4gICAgICAgICAgICBsZCA9IGV1cm9wZShbNTIuNjU4MzcyODk3NDQ0MSwgNTkuMzUwNDUwOTIyMjQ0NV0pO1xuICAgICAgICAgICAgbGwgPSBldXJvcGUoWzQyLjQ1NzU1NjMxNjc1NzUxLCA2My4zNDM2NTg2ODgwNTgyMV0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbMzEuMDU0MTk4NDE4NDQ2NDc1LCA1Mi4xMDgwNjczNzY2MTg0XSk7XG4gICAgICAgICAgICB1ciA9IGV1cm9wZShbMzkuMDk4NjkyODQ4ODQxMTcsIDQ5LjQwMDcwMDA0NzE5MDU1NF0pO1xuICAgICAgICAgICAgbGQgPSBldXJvcGUoWzM2LjA1ODA4MTE0OTkxNzUsIDQ2LjAyOTQ0MTc0OTA4NDk4XSk7XG4gICAgICAgICAgICBsbCA9IGV1cm9wZShbMjguNjkwNTA4NTg4ODM1NzI2LCA0OC40MzMxMjY5NzkzODY0MTVdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1clswXSwgdXJbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRbMF0sIGxkWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdWwgPSBldXJvcGUoWzMzLjk3Nzg3Nzc0NTkxMjAyNSwgNTUuODQ5OTQ1NTAxMzMxXSk7XG4gICAgICAgICAgICB1ciA9IGV1cm9wZShbNDIuNzUzMjg0MzIxNjc3MjYsIDUyLjc4NDU1MTIyNDYyMzUzXSk7XG4gICAgICAgICAgICBsZCA9IGV1cm9wZShbMzkuMDk4NjkyOTc1NDAyMjQsIDQ5LjQwMDcwMDE3NjE0ODYyNV0pO1xuICAgICAgICAgICAgbGwgPSBldXJvcGUoWzMxLjA1NDE5ODUxODA3MDA4LCA1Mi4xMDgwNjc1MTgxMDkyM10pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbNTIuNjU4MzcyOTAwNzU5Mjk2LCA1OS4zNTA0NTA2ODUyNjQxNV0pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWzYwLjIzNjA2NTQ5NTgzMzA0LCA1NC42MzMzMTQyMzgwMDI2NF0pO1xuICAgICAgICAgICAgbGQgPSBldXJvcGUoWzU0LjY3NTYzNzA5NTMxMjIsIDUxLjg5MjI5ODc4OTM5OTQ1NV0pO1xuICAgICAgICAgICAgbGwgPSBldXJvcGUoWzQ3LjE5NzU0NTI0Nzg4MTg5LCA1Ni4xMjY1MzQ4NjEyMjI3OTRdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1clswXSwgdXJbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRbMF0sIGxkWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdWwgPSBldXJvcGUoWzQ3LjE5NzU0NTA2MDgyNDU1LCA1Ni4xMjY1MzQ3MzU1OTE0NTZdKTtcbiAgICAgICAgICAgIHVyID0gZXVyb3BlKFs1NC42NzU2MzY5MDAxMjM1MTQsIDUxLjg5MjI5ODY4MTMzNzA5NV0pO1xuICAgICAgICAgICAgbGQgPSBldXJvcGUoWzQ5Ljk0NDQ4NjQ4OTUxNDg2LCA0OC45ODc3NTQ4NDk4MzI4NV0pO1xuICAgICAgICAgICAgbGwgPSBldXJvcGUoWzQyLjc1MzI4NDY4NzE2MTA4LCA1Mi43ODQ1NTEyNjA2MDgxOF0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbNDIuNzUzMjg0NTM0MTY3NjksIDUyLjc4NDU1MTEzMjA5MTAxXSk7XG4gICAgICAgICAgICB1ciA9IGV1cm9wZShbNDkuOTQ0NDg2MzIzMzk3NTgsIDQ4Ljk4Nzc1NDczNzA2NDU3XSk7XG4gICAgICAgICAgICBsZCA9IGV1cm9wZShbNDUuOTEyMzM5OTkwMzk0MzE1LCA0NS45OTM2MTc4NDk4NzAwM10pO1xuICAgICAgICAgICAgbGwgPSBldXJvcGUoWzM5LjA5ODY5MzE3MzU2NjA3LCA0OS40MDA3MDAwOTM3ODcxMV0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbMzcuNjczMDM0MTE0Mjk2NjM0LCA1OS42MTYzODI1NDE4MzExOV0pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWzQ3LjE5NzU0NDgzNTQyMDU0NCwgNTYuMTI2NTM0ODM5ODQ5ODQ2XSk7XG4gICAgICAgICAgICBsZCA9IGV1cm9wZShbNDIuNzUzMjg0NDc0NjcwNjQsIDUyLjc4NDU1MTM1MzE0MDY4XSk7XG4gICAgICAgICAgICBsbCA9IGV1cm9wZShbMzMuOTc3ODc3ODcwMzYzOTA1LCA1NS44NDk5NDU2NDQ2NzExNDVdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1clswXSwgdXJbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRbMF0sIGxkWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdWwgPSBldXJvcGUoWzQ0LjU2NzQ4NDg2NDQ2MDMyLCA1Ny4yNjQ4OTM2Nzg0NTgxOF0pO1xuICAgICAgICAgICAgbGQgPSBldXJvcGUoWzQzLjkzMzU3OTExOTM1ODgsIDUzLjc0NjU0MDk0MjYwMTcyNl0pO1xuICAgICAgICAgICAgbGwgPSBldXJvcGUoWzQzLCA1Nl0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbMzcuNjczMDM0MTE0Mjk2NjM0LCA1OS42MTYzODI1NDE4MzExOV0pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWzQwLjI1OTAyNjkxOTUzNDY2LCA1OC44MzAwMjA0NDIyMjYzOV0pO1xuICAgICAgICAgICAgbGQgPSBldXJvcGUoWzM4LjQ1ODI3MDQ5Mjc0MjAyNCwgNTcuMjYyMzIxNzgwMjgwMDJdKTtcbiAgICAgICAgICAgIGxsID0gZXVyb3BlKFszNS45Nzc1NDk0ODAzMDE1NiwgNTguMDAyNjY2Mzc5OTIzODZdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1clswXSwgdXJbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRbMF0sIGxkWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbEV1cm9wZS5nZXRDb21wb3NpdGlvbkJvcmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGQzUGF0aC5wYXRoKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDb21wb3NpdGlvbkJvcmRlcnMoY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC50b1N0cmluZygpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY29uaWNDb25mb3JtYWxFdXJvcGUuc2NhbGUoNzUwKTtcbiAgICB9XG4gICAgLy8gVGhlIHByb2plY3Rpb25zIG11c3QgaGF2ZSBtdXR1YWxseSBleGNsdXNpdmUgY2xpcCByZWdpb25zIG9uIHRoZSBzcGhlcmUsXG4gICAgLy8gYXMgdGhpcyB3aWxsIGF2b2lkIGVtaXR0aW5nIGludGVybGVhdmluZyBsaW5lcyBhbmQgcG9seWdvbnMuXG4gICAgZnVuY3Rpb24gbXVsdGlwbGV4JDkoc3RyZWFtcykge1xuICAgICAgICB2YXIgbiA9IHN0cmVhbXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIHNwaGVyZTogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0uc3BoZXJlKCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZUVuZCgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICAgIH0gfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBIGNvbXBvc2l0ZSBwcm9qZWN0aW9uIGZvciBNYWxheXNpYSwgY29uZmlndXJlZCBieSBkZWZhdWx0IGZvciA5NjDDlzUwMC5cbiAgICBmdW5jdGlvbiBtZXJjYXRvck1hbGF5c2lhKCkge1xuICAgICAgICB2YXIgY2FjaGUsIGNhY2hlU3RyZWFtLCBwZW5pbnN1bGFyID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5jZW50ZXIoWzEwNS4yNSwgNC4wMF0pLCBwZW5pbnN1bGFyUG9pbnQsIGJvcm5lbyA9IGQzR2VvLmdlb01lcmNhdG9yKCkuY2VudGVyKFsxMTguNjUsIDIuODZdKSwgYm9ybmVvUG9pbnQsIHBvaW50LCBwb2ludFN0cmVhbSA9IHsgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7IHBvaW50ID0gW3gsIHldOyB9IH07XG4gICAgICAgIGZ1bmN0aW9uIG1lcmNhdG9yTWFsYXlzaWEoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciB4ID0gY29vcmRpbmF0ZXNbMF0sIHkgPSBjb29yZGluYXRlc1sxXTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludCA9IG51bGwsXG4gICAgICAgICAgICAgICAgKHBlbmluc3VsYXJQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChib3JuZW9Qb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIG1lcmNhdG9yTWFsYXlzaWEuaW52ZXJ0ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgayA9IHBlbmluc3VsYXIuc2NhbGUoKSwgdCA9IHBlbmluc3VsYXIudHJhbnNsYXRlKCksIHggPSAoY29vcmRpbmF0ZXNbMF0gLSB0WzBdKSAvIGssIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgICAgICAgICByZXR1cm4gKHkgPj0gLTAuMDUyMSAmJiB5IDwgMC4wMjI5ICYmIHggPj0gLTAuMDExMSAmJiB4IDwgMC4xMDAwID8gYm9ybmVvXG4gICAgICAgICAgICAgICAgOiBwZW5pbnN1bGFyKS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBtZXJjYXRvck1hbGF5c2lhLnN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IG11bHRpcGxleCQ5KFtwZW5pbnN1bGFyLnN0cmVhbShjYWNoZVN0cmVhbSA9IHN0cmVhbSksIGJvcm5lby5zdHJlYW0oc3RyZWFtKV0pO1xuICAgICAgICB9O1xuICAgICAgICBtZXJjYXRvck1hbGF5c2lhLnByZWNpc2lvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGVuaW5zdWxhci5wcmVjaXNpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlbmluc3VsYXIucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgYm9ybmVvLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBtZXJjYXRvck1hbGF5c2lhLnNjYWxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwZW5pbnN1bGFyLnNjYWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZW5pbnN1bGFyLnNjYWxlKF8pO1xuICAgICAgICAgICAgYm9ybmVvLnNjYWxlKF8gKiAwLjYxNSk7XG4gICAgICAgICAgICByZXR1cm4gbWVyY2F0b3JNYWxheXNpYS50cmFuc2xhdGUocGVuaW5zdWxhci50cmFuc2xhdGUoKSk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yTWFsYXlzaWEudHJhbnNsYXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwZW5pbnN1bGFyLnRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGsgPSBwZW5pbnN1bGFyLnNjYWxlKCksIHggPSArX1swXSwgeSA9ICtfWzFdO1xuICAgICAgICAgICAgcGVuaW5zdWxhclBvaW50ID0gcGVuaW5zdWxhclxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoXylcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjExMDAgKiBrLCB5IC0gMC4wNTIxICoga10sIFt4IC0gMC4wMTExICogaywgeSArIDAuMDUyMSAqIGtdXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIGJvcm5lb1BvaW50ID0gYm9ybmVvXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMDkwMDAgKiBrLCB5IC0gMC4wMCAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMDExMSAqIGsgKyBlcHNpbG9uLCB5IC0gMC4wNTIxICogayArIGVwc2lsb25dLCBbeCArIDAuMTAwMCAqIGsgLSBlcHNpbG9uLCB5ICsgMC4wMjQgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yTWFsYXlzaWEuZml0RXh0ZW50ID0gZnVuY3Rpb24gKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0RXh0ZW50KG1lcmNhdG9yTWFsYXlzaWEsIGV4dGVudCwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgbWVyY2F0b3JNYWxheXNpYS5maXRTaXplID0gZnVuY3Rpb24gKHNpemUsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdFNpemUobWVyY2F0b3JNYWxheXNpYSwgc2l6ZSwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBtZXJjYXRvck1hbGF5c2lhO1xuICAgICAgICB9XG4gICAgICAgIG1lcmNhdG9yTWFsYXlzaWEuZHJhd0NvbXBvc2l0aW9uQm9yZGVycyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbGxib3IgPSBwZW5pbnN1bGFyKFsxMDYuMzIxNCwgMi4wMjI4XSk7XG4gICAgICAgICAgICB2YXIgbG1ib3IgPSBwZW5pbnN1bGFyKFsxMDUuMTg0MywgMi4zNzYxXSk7XG4gICAgICAgICAgICB2YXIgbHJib3IgPSBwZW5pbnN1bGFyKFsxMDQuMjE1MSwgMy4zNjE4XSk7XG4gICAgICAgICAgICB2YXIgbGxyYm9yID0gcGVuaW5zdWxhcihbMTA0LjIxNTAsIDQuNTY1MV0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8obGxib3JbMF0sIGxsYm9yWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxtYm9yWzBdLCBsbWJvclsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhscmJvclswXSwgbHJib3JbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxyYm9yWzBdLCBsbHJib3JbMV0pO1xuICAgICAgICB9O1xuICAgICAgICBtZXJjYXRvck1hbGF5c2lhLmdldENvbXBvc2l0aW9uQm9yZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gZDNQYXRoLnBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NvbXBvc2l0aW9uQm9yZGVycyhjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtZXJjYXRvck1hbGF5c2lhLnNjYWxlKDQ4MDApO1xuICAgIH1cbiAgICAvLyBUaGUgcHJvamVjdGlvbnMgbXVzdCBoYXZlIG11dHVhbGx5IGV4Y2x1c2l2ZSBjbGlwIHJlZ2lvbnMgb24gdGhlIHNwaGVyZSxcbiAgICAvLyBhcyB0aGlzIHdpbGwgYXZvaWQgZW1pdHRpbmcgaW50ZXJsZWF2aW5nIGxpbmVzIGFuZCBwb2x5Z29ucy5cbiAgICBmdW5jdGlvbiBtdWx0aXBsZXgkYShzdHJlYW1zKSB7XG4gICAgICAgIHZhciBuID0gc3RyZWFtcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgc3BoZXJlOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5zcGhlcmUoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgfSB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEEgY29tcG9zaXRlIHByb2plY3Rpb24gZm9yIEVxdWF0b3JpYWwgR3VpbmVhLCBjb25maWd1cmVkIGJ5IGRlZmF1bHQgZm9yIDk2MMOXNTAwLlxuICAgIGZ1bmN0aW9uIG1lcmNhdG9yRXF1YXRvcmlhbEd1aW5lYSgpIHtcbiAgICAgICAgdmFyIGNhY2hlLCBjYWNoZVN0cmVhbSwgY29udGluZW50ID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5yb3RhdGUoWy05LjUsIC0xLjVdKSwgY29udGluZW50UG9pbnQsIGJpb2tvID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5yb3RhdGUoWy04LjYsIC0zLjVdKSwgYmlva29Qb2ludCwgYW5ub2JvbiA9IGQzR2VvLmdlb01lcmNhdG9yKCkucm90YXRlKFstNS42LCAxLjQ1XSksIGFubm9ib25Qb2ludCwgcG9pbnQsIHBvaW50U3RyZWFtID0geyBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgcG9pbnQgPSBbeCwgeV07IH0gfTtcbiAgICAgICAgZnVuY3Rpb24gbWVyY2F0b3JFcXVhdG9yaWFsR3VpbmVhKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGNvb3JkaW5hdGVzWzBdLCB5ID0gY29vcmRpbmF0ZXNbMV07XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQgPSBudWxsLFxuICAgICAgICAgICAgICAgIChjb250aW5lbnRQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChiaW9rb1BvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGFubm9ib25Qb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIG1lcmNhdG9yRXF1YXRvcmlhbEd1aW5lYS5pbnZlcnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciBrID0gY29udGluZW50LnNjYWxlKCksIHQgPSBjb250aW5lbnQudHJhbnNsYXRlKCksIHggPSAoY29vcmRpbmF0ZXNbMF0gLSB0WzBdKSAvIGssIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgICAgICAgICByZXR1cm4gKHkgPj0gLTAuMDIgJiYgeSA8IDAgJiYgeCA+PSAtMC4wMzggJiYgeCA8IC0wLjAwNSA/IGJpb2tvXG4gICAgICAgICAgICAgICAgOiB5ID49IDAgJiYgeSA8IDAuMDIgJiYgeCA+PSAtMC4wMzggJiYgeCA8IC0wLjAwNSA/IGFubm9ib25cbiAgICAgICAgICAgICAgICAgICAgOiBjb250aW5lbnQpLmludmVydChjb29yZGluYXRlcyk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yRXF1YXRvcmlhbEd1aW5lYS5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBtdWx0aXBsZXgkYShbY29udGluZW50LnN0cmVhbShjYWNoZVN0cmVhbSA9IHN0cmVhbSksIGJpb2tvLnN0cmVhbShzdHJlYW0pLCBhbm5vYm9uLnN0cmVhbShzdHJlYW0pXSk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yRXF1YXRvcmlhbEd1aW5lYS5wcmVjaXNpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRpbmVudC5wcmVjaXNpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbmVudC5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBiaW9rby5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBhbm5vYm9uLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBtZXJjYXRvckVxdWF0b3JpYWxHdWluZWEuc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRpbmVudC5zY2FsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGluZW50LnNjYWxlKF8pO1xuICAgICAgICAgICAgYmlva28uc2NhbGUoXyAqIDEuNSk7XG4gICAgICAgICAgICBhbm5vYm9uLnNjYWxlKF8gKiA0KTtcbiAgICAgICAgICAgIHJldHVybiBtZXJjYXRvckVxdWF0b3JpYWxHdWluZWEudHJhbnNsYXRlKGNvbnRpbmVudC50cmFuc2xhdGUoKSk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yRXF1YXRvcmlhbEd1aW5lYS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRpbmVudC50cmFuc2xhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrID0gY29udGluZW50LnNjYWxlKCksIHggPSArX1swXSwgeSA9ICtfWzFdO1xuICAgICAgICAgICAgY29udGluZW50UG9pbnQgPSBjb250aW5lbnRcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKF8pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4wMDUgKiBrLCB5IC0gMC4wMiAqIGtdLCBbeCArIDAuMDM4ICogaywgeSArIDAuMDIgKiBrXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBiaW9rb1BvaW50ID0gYmlva29cbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4wMjUgKiBrLCB5IC0gMC4wMSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMDM4ICogayArIGVwc2lsb24sIHkgLSAwLjAyICogayArIGVwc2lsb25dLCBbeCAtIDAuMDA1ICogayAtIGVwc2lsb24sIHkgKyAwICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIGFubm9ib25Qb2ludCA9IGFubm9ib25cbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4wMjUgKiBrLCB5ICsgMC4wMSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMDM4ICogayArIGVwc2lsb24sIHkgLSAwICogayArIGVwc2lsb25dLCBbeCAtIDAuMDA1ICogayAtIGVwc2lsb24sIHkgKyAwLjAyICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBtZXJjYXRvckVxdWF0b3JpYWxHdWluZWEuZml0RXh0ZW50ID0gZnVuY3Rpb24gKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0RXh0ZW50KG1lcmNhdG9yRXF1YXRvcmlhbEd1aW5lYSwgZXh0ZW50LCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBtZXJjYXRvckVxdWF0b3JpYWxHdWluZWEuZml0U2l6ZSA9IGZ1bmN0aW9uIChzaXplLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRTaXplKG1lcmNhdG9yRXF1YXRvcmlhbEd1aW5lYSwgc2l6ZSwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBtZXJjYXRvckVxdWF0b3JpYWxHdWluZWE7XG4gICAgICAgIH1cbiAgICAgICAgbWVyY2F0b3JFcXVhdG9yaWFsR3VpbmVhLmRyYXdDb21wb3NpdGlvbkJvcmRlcnMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidmFyIHVsLCB1ciwgbGQsIGxsO1wiKTtcbiAgICAgICAgICAgIHZhciBwcm9qcyA9IFtjb250aW5lbnQsIGJpb2tvLCBhbm5vYm9uXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gcHJvanMpe1xuICAgICAgICAgICAgICB2YXIgdWwgPSBjb250aW5lbnQuaW52ZXJ0KFtwcm9qc1tpXS5jbGlwRXh0ZW50KClbMF1bMF0sIHByb2pzW2ldLmNsaXBFeHRlbnQoKVswXVsxXV0pO1xuICAgICAgICAgICAgICB2YXIgdXIgPSBjb250aW5lbnQuaW52ZXJ0KFtwcm9qc1tpXS5jbGlwRXh0ZW50KClbMV1bMF0sIHByb2pzW2ldLmNsaXBFeHRlbnQoKVswXVsxXV0pO1xuICAgICAgICAgICAgICB2YXIgbGQgPSBjb250aW5lbnQuaW52ZXJ0KFtwcm9qc1tpXS5jbGlwRXh0ZW50KClbMV1bMF0sIHByb2pzW2ldLmNsaXBFeHRlbnQoKVsxXVsxXV0pO1xuICAgICAgICAgICAgICB2YXIgbGwgPSBjb250aW5lbnQuaW52ZXJ0KFtwcm9qc1tpXS5jbGlwRXh0ZW50KClbMF1bMF0sIHByb2pzW2ldLmNsaXBFeHRlbnQoKVsxXVsxXV0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bCA9IGNvbnRpbmVudChbXCIrdWwrXCJdKTtcIik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidXIgPSBjb250aW5lbnQoW1wiK3VyK1wiXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImxkID0gY29udGluZW50KFtcIitsZCtcIl0pO1wiKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJsbCA9IGNvbnRpbmVudChbXCIrbGwrXCJdKTtcIik7XG4gICAgICAgIFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQuY2xvc2VQYXRoKCk7XCIpO1xuICAgICAgICBcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgdmFyIHVsLCB1ciwgbGQsIGxsO1xuICAgICAgICAgICAgdWwgPSBjb250aW5lbnQoWzkuMjEzMjcyNzI3NTE2ODIsIDIuNjQ1ODIwNDM5NDU0MTIzXSk7XG4gICAgICAgICAgICB1ciA9IGNvbnRpbmVudChbMTEuNjc5MTI2MjkzMjM5ODcyLCAyLjY0NDc1NTUxOTI2ODY4OV0pO1xuICAgICAgICAgICAgbGQgPSBjb250aW5lbnQoWzExLjY3Njg0NTM4OTAyOTIyNywgMC4zNTMwNzgyNDYzNzYwNjQzM10pO1xuICAgICAgICAgICAgbGwgPSBjb250aW5lbnQoWzkuMjEzNTcyOTE3Nzc0MDE0LCAwLjM1NDE0MjA1MjA0NDE3NzU0XSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHVsID0gY29udGluZW50KFs3LjMyMDg3MzcxMTU0MzY2OSwgMi42NDQ3NTU1MTQ0OTk3NV0pO1xuICAgICAgICAgICAgdXIgPSBjb250aW5lbnQoWzkuMjEzMjcyNzIyNzM4NjU4LCAyLjY0NTgyMDQzNDY3OTgwM10pO1xuICAgICAgICAgICAgbGQgPSBjb250aW5lbnQoWzkuMjEzNDIyODk2NDgwMzQ5LCAxLjQ5OTk4MTI1MDUyODMwNTRdKTtcbiAgICAgICAgICAgIGxsID0gY29udGluZW50KFs3LjMyMjAxNDc2MDUyMDc4NywgMS40OTg5MTY4ODc4OTg1NTY2XSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHVsID0gY29udGluZW50KFs3LjMyMjAxNDc2MDUzMDI5MDUsIDEuNDk4OTE2ODc4MzQ5Mjc2Nl0pO1xuICAgICAgICAgICAgdXIgPSBjb250aW5lbnQoWzkuMjEzNDIyODk2NDgxNTk4LCAxLjQ5OTk4MTI0MDk3OTAyMV0pO1xuICAgICAgICAgICAgbGQgPSBjb250aW5lbnQoWzkuMjEzNTcyOTEyOTk5NjA0LCAwLjM1NDE0MjA1NjgxNzI0N10pO1xuICAgICAgICAgICAgbGwgPSBjb250aW5lbnQoWzcuMzIzMTU0NjE1NzM5ODA5LCAwLjM1MzA3ODI1MTE1NDUwNF0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yRXF1YXRvcmlhbEd1aW5lYS5nZXRDb21wb3NpdGlvbkJvcmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGQzUGF0aC5wYXRoKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDb21wb3NpdGlvbkJvcmRlcnMoY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC50b1N0cmluZygpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWVyY2F0b3JFcXVhdG9yaWFsR3VpbmVhLnNjYWxlKDEyMDAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbXVsdGlwbGV4JGIoc3RyZWFtcykge1xuICAgICAgICB2YXIgbiA9IHN0cmVhbXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnNwaGVyZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZUVuZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhbGJlcnNVaygpIHtcbiAgICAgICAgdmFyIGNhY2hlLCBjYWNoZVN0cmVhbSwgbWFpbiA9IGQzR2VvLmdlb0FsYmVycygpXG4gICAgICAgICAgICAucm90YXRlKFs0LjQsIDAuOF0pXG4gICAgICAgICAgICAuY2VudGVyKFswLCA1NS40XSlcbiAgICAgICAgICAgIC5wYXJhbGxlbHMoWzUwLCA2MF0pLCBtYWluUG9pbnQsIHNoZXRsYW5kID0gZDNHZW8uZ2VvQWxiZXJzKClcbiAgICAgICAgICAgIC5yb3RhdGUoWzQuNCwgMC44XSlcbiAgICAgICAgICAgIC5jZW50ZXIoWzAsIDU1LjRdKVxuICAgICAgICAgICAgLnBhcmFsbGVscyhbNTAsIDYwXSksIHNoZXRsYW5kUG9pbnQsIHBvaW50LCBwb2ludFN0cmVhbSA9IHtcbiAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHBvaW50ID0gW3gsIHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBhbGJlcnNVayhjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIHggPSBjb29yZGluYXRlc1swXSwgeSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgICAgICAgICAgcmV0dXJuICgocG9pbnQgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAobWFpblBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHwgKHNoZXRsYW5kUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgYWxiZXJzVWsuaW52ZXJ0ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgayA9IG1haW4uc2NhbGUoKSwgdCA9IG1haW4udHJhbnNsYXRlKCksIHggPSAoY29vcmRpbmF0ZXNbMF0gLSB0WzBdKSAvIGssIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgICAgICAgICByZXR1cm4gKHkgPj0gLTAuMDg5ICYmIHkgPCAwLjA2ICYmIHggPj0gMC4wMjkgJiYgeCA8IDAuMDQ2XG4gICAgICAgICAgICAgICAgPyBzaGV0bGFuZFxuICAgICAgICAgICAgICAgIDogbWFpbikuaW52ZXJ0KGNvb3JkaW5hdGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVWsuc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW1cbiAgICAgICAgICAgICAgICA/IGNhY2hlXG4gICAgICAgICAgICAgICAgOiAoY2FjaGUgPSBtdWx0aXBsZXgkYihbXG4gICAgICAgICAgICAgICAgICAgIG1haW4uc3RyZWFtKChjYWNoZVN0cmVhbSA9IHN0cmVhbSkpLFxuICAgICAgICAgICAgICAgICAgICBzaGV0bGFuZC5zdHJlYW0oc3RyZWFtKVxuICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVWsucHJlY2lzaW9uID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi5wcmVjaXNpb24oKTtcbiAgICAgICAgICAgIG1haW4ucHJlY2lzaW9uKF8pLCBzaGV0bGFuZC5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVWsuc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYWluLnNjYWxlKCk7XG4gICAgICAgICAgICBtYWluLnNjYWxlKF8pLCBzaGV0bGFuZC5zY2FsZShfKTtcbiAgICAgICAgICAgIHJldHVybiBhbGJlcnNVay50cmFuc2xhdGUobWFpbi50cmFuc2xhdGUoKSk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VrLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW4udHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB2YXIgayA9IG1haW4uc2NhbGUoKSwgeCA9ICtfWzBdLCB5ID0gK19bMV07XG4gICAgICAgICAgICBtYWluUG9pbnQgPSBtYWluXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShfKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtcbiAgICAgICAgICAgICAgICBbeCAtIDAuMDY1ICogaywgeSAtIDAuMDg5ICoga10sXG4gICAgICAgICAgICAgICAgW3ggKyAwLjA3NSAqIGssIHkgKyAwLjA4OSAqIGtdXG4gICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgc2hldGxhbmRQb2ludCA9IHNoZXRsYW5kXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMDEgKiBrLCB5ICsgMC4wMjUgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbXG4gICAgICAgICAgICAgICAgW3ggKyAwLjAyOSAqIGsgKyBlcHNpbG9uLCB5IC0gMC4wODkgKiBrICsgZXBzaWxvbl0sXG4gICAgICAgICAgICAgICAgW3ggKyAwLjA0NiAqIGsgLSBlcHNpbG9uLCB5IC0gMC4wNiAqIGsgLSBlcHNpbG9uXVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVay5maXRFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRFeHRlbnQoYWxiZXJzVWssIGV4dGVudCwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVWsuZml0U2l6ZSA9IGZ1bmN0aW9uIChzaXplLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRTaXplKGFsYmVyc1VrLCBzaXplLCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGFsYmVyc1VrO1xuICAgICAgICB9XG4gICAgICAgIGFsYmVyc1VrLmRyYXdDb21wb3NpdGlvbkJvcmRlcnMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgLyp2YXIgdWwgPSBtYWluLmludmVydChbXG4gICAgICAgICAgICAgIHNoZXRsYW5kLmNsaXBFeHRlbnQoKVswXVswXSxcbiAgICAgICAgICAgICAgc2hldGxhbmQuY2xpcEV4dGVudCgpWzBdWzFdXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHZhciB1ciA9IG1haW4uaW52ZXJ0KFtcbiAgICAgICAgICAgICAgc2hldGxhbmQuY2xpcEV4dGVudCgpWzFdWzBdLFxuICAgICAgICAgICAgICBzaGV0bGFuZC5jbGlwRXh0ZW50KClbMF1bMV1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdmFyIGxkID0gbWFpbi5pbnZlcnQoW1xuICAgICAgICAgICAgICBzaGV0bGFuZC5jbGlwRXh0ZW50KClbMV1bMF0sXG4gICAgICAgICAgICAgIHNoZXRsYW5kLmNsaXBFeHRlbnQoKVsxXVsxXVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB2YXIgbGwgPSBtYWluLmludmVydChbXG4gICAgICAgICAgICAgIHNoZXRsYW5kLmNsaXBFeHRlbnQoKVswXVswXSxcbiAgICAgICAgICAgICAgc2hldGxhbmQuY2xpcEV4dGVudCgpWzFdWzFdXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInVsID0gbWFpbihbXCIgKyB1bCArIFwiXSk7XCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1ciA9IG1haW4oW1wiICsgdXIgKyBcIl0pO1wiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibGQgPSBtYWluKFtcIiArIGxkICsgXCJdKTtcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImxsID0gbWFpbihbXCIgKyBsbCArIFwiXSk7XCIpO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1wiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQuY2xvc2VQYXRoKCk7XCIpOyovXG4gICAgICAgICAgICB2YXIgdWwsIHVyLCBsZCwgbGw7XG4gICAgICAgICAgICB1bCA9IG1haW4oWy0xLjExMzIwNTg3MDI0MjM2NSwgNTkuNjQ5MjAwNTA3NzMzNTddKTtcbiAgICAgICAgICAgIHVyID0gbWFpbihbMC44MDc4OTkwOTIzOTk2MDYsIDU5LjU5MDg1ODM2NDcyMjY5XSk7XG4gICAgICAgICAgICBsZCA9IG1haW4oWzAuNTc3ODYxMTk2MTQyMDM4NiwgNTcuOTM0Njc4MjI4MzI1NzddKTtcbiAgICAgICAgICAgIGxsID0gbWFpbihbLTEuMjU4Njc3ODIwNzg0NDgsIDU3Ljk5MDI5NDUwMDg1MTQyXSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVWsuZ2V0Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBkM1BhdGgucGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzKGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGFsYmVyc1VrLnNjYWxlKDI4MDApO1xuICAgIH1cbiAgICBleHBvcnRzLmdlb0FsYmVyc1VrID0gYWxiZXJzVWs7XG4gICAgZXhwb3J0cy5nZW9BbGJlcnNVc2EgPSBhbGJlcnNVc2E7XG4gICAgZXhwb3J0cy5nZW9BbGJlcnNVc2FUZXJyaXRvcmllcyA9IGFsYmVyc1VzYVRlcnJpdG9yaWVzO1xuICAgIGV4cG9ydHMuZ2VvQ29uaWNDb25mb3JtYWxFdXJvcGUgPSBjb25pY0NvbmZvcm1hbEV1cm9wZTtcbiAgICBleHBvcnRzLmdlb0NvbmljQ29uZm9ybWFsRnJhbmNlID0gY29uaWNDb25mb3JtYWxGcmFuY2U7XG4gICAgZXhwb3J0cy5nZW9Db25pY0NvbmZvcm1hbFBvcnR1Z2FsID0gY29uaWNDb25mb3JtYWxQb3J0dWdhbDtcbiAgICBleHBvcnRzLmdlb0NvbmljQ29uZm9ybWFsU3BhaW4gPSBjb25pY0NvbmZvcm1hbFNwYWluO1xuICAgIGV4cG9ydHMuZ2VvQ29uaWNFcXVpZGlzdGFudEphcGFuID0gY29uaWNFcXVpZGlzdGFudEphcGFuO1xuICAgIGV4cG9ydHMuZ2VvTWVyY2F0b3JFY3VhZG9yID0gbWVyY2F0b3JFY3VhZG9yO1xuICAgIGV4cG9ydHMuZ2VvTWVyY2F0b3JFcXVhdG9yaWFsR3VpbmVhID0gbWVyY2F0b3JFcXVhdG9yaWFsR3VpbmVhO1xuICAgIGV4cG9ydHMuZ2VvTWVyY2F0b3JNYWxheXNpYSA9IG1lcmNhdG9yTWFsYXlzaWE7XG4gICAgZXhwb3J0cy5nZW9UcmFuc3ZlcnNlTWVyY2F0b3JDaGlsZSA9IHRyYW5zdmVyc2VNZXJjYXRvckNoaWxlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59KSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1kc3ZAMS4yLjBAZDMtZHN2L2Rpc3QvZDMtZHN2LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kMy1kc3ZAMS4yLjBAZDMtZHN2L2Rpc3QvZDMtZHN2LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtZHN2LyB2MS4yLjAgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgICB0cnVlID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIEVPTCA9IHt9LCBFT0YgPSB7fSwgUVVPVEUgPSAzNCwgTkVXTElORSA9IDEwLCBSRVRVUk4gPSAxMztcbiAgICBmdW5jdGlvbiBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucykge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiZFwiLCBcInJldHVybiB7XCIgKyBjb2x1bW5zLm1hcChmdW5jdGlvbiAobmFtZSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgXCI6IGRbXCIgKyBpICsgXCJdIHx8IFxcXCJcXFwiXCI7XG4gICAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjdXN0b21Db252ZXJ0ZXIoY29sdW1ucywgZikge1xuICAgICAgICB2YXIgb2JqZWN0ID0gb2JqZWN0Q29udmVydGVyKGNvbHVtbnMpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJvdywgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGYob2JqZWN0KHJvdyksIGksIGNvbHVtbnMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDb21wdXRlIHVuaXF1ZSBjb2x1bW5zIGluIG9yZGVyIG9mIGRpc2NvdmVyeS5cbiAgICBmdW5jdGlvbiBpbmZlckNvbHVtbnMocm93cykge1xuICAgICAgICB2YXIgY29sdW1uU2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgY29sdW1ucyA9IFtdO1xuICAgICAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgZm9yICh2YXIgY29sdW1uIGluIHJvdykge1xuICAgICAgICAgICAgICAgIGlmICghKGNvbHVtbiBpbiBjb2x1bW5TZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaChjb2x1bW5TZXRbY29sdW1uXSA9IGNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhZCh2YWx1ZSwgd2lkdGgpIHtcbiAgICAgICAgdmFyIHMgPSB2YWx1ZSArIFwiXCIsIGxlbmd0aCA9IHMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKDApICsgcyA6IHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4geWVhciA8IDAgPyBcIi1cIiArIHBhZCgteWVhciwgNilcbiAgICAgICAgICAgIDogeWVhciA+IDk5OTkgPyBcIitcIiArIHBhZCh5ZWFyLCA2KVxuICAgICAgICAgICAgICAgIDogcGFkKHllYXIsIDQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgICAgICAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpLCBtaW51dGVzID0gZGF0ZS5nZXRVVENNaW51dGVzKCksIHNlY29uZHMgPSBkYXRlLmdldFVUQ1NlY29uZHMoKSwgbWlsbGlzZWNvbmRzID0gZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgcmV0dXJuIGlzTmFOKGRhdGUpID8gXCJJbnZhbGlkIERhdGVcIlxuICAgICAgICAgICAgOiBmb3JtYXRZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkgKyBcIi1cIiArIHBhZChkYXRlLmdldFVUQ01vbnRoKCkgKyAxLCAyKSArIFwiLVwiICsgcGFkKGRhdGUuZ2V0VVRDRGF0ZSgpLCAyKVxuICAgICAgICAgICAgICAgICsgKG1pbGxpc2Vjb25kcyA/IFwiVFwiICsgcGFkKGhvdXJzLCAyKSArIFwiOlwiICsgcGFkKG1pbnV0ZXMsIDIpICsgXCI6XCIgKyBwYWQoc2Vjb25kcywgMikgKyBcIi5cIiArIHBhZChtaWxsaXNlY29uZHMsIDMpICsgXCJaXCJcbiAgICAgICAgICAgICAgICAgICAgOiBzZWNvbmRzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIjpcIiArIHBhZChzZWNvbmRzLCAyKSArIFwiWlwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG1pbnV0ZXMgfHwgaG91cnMgPyBcIlRcIiArIHBhZChob3VycywgMikgKyBcIjpcIiArIHBhZChtaW51dGVzLCAyKSArIFwiWlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZHN2KGRlbGltaXRlcikge1xuICAgICAgICB2YXIgcmVGb3JtYXQgPSBuZXcgUmVnRXhwKFwiW1xcXCJcIiArIGRlbGltaXRlciArIFwiXFxuXFxyXVwiKSwgREVMSU1JVEVSID0gZGVsaW1pdGVyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlKHRleHQsIGYpIHtcbiAgICAgICAgICAgIHZhciBjb252ZXJ0LCBjb2x1bW5zLCByb3dzID0gcGFyc2VSb3dzKHRleHQsIGZ1bmN0aW9uIChyb3csIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udmVydClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnQocm93LCBpIC0gMSk7XG4gICAgICAgICAgICAgICAgY29sdW1ucyA9IHJvdywgY29udmVydCA9IGYgPyBjdXN0b21Db252ZXJ0ZXIocm93LCBmKSA6IG9iamVjdENvbnZlcnRlcihyb3cpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByb3dzLmNvbHVtbnMgPSBjb2x1bW5zIHx8IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VSb3dzKHRleHQsIGYpIHtcbiAgICAgICAgICAgIHZhciByb3dzID0gW10sIC8vIG91dHB1dCByb3dzXG4gICAgICAgICAgICBOID0gdGV4dC5sZW5ndGgsIEkgPSAwLCAvLyBjdXJyZW50IGNoYXJhY3RlciBpbmRleFxuICAgICAgICAgICAgbiA9IDAsIC8vIGN1cnJlbnQgbGluZSBudW1iZXJcbiAgICAgICAgICAgIHQsIC8vIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgIGVvZiA9IE4gPD0gMCwgLy8gY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0Y/XG4gICAgICAgICAgICBlb2wgPSBmYWxzZTsgLy8gY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0w/XG4gICAgICAgICAgICAvLyBTdHJpcCB0aGUgdHJhaWxpbmcgbmV3bGluZS5cbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoTiAtIDEpID09PSBORVdMSU5FKVxuICAgICAgICAgICAgICAgIC0tTjtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoTiAtIDEpID09PSBSRVRVUk4pXG4gICAgICAgICAgICAgICAgLS1OO1xuICAgICAgICAgICAgZnVuY3Rpb24gdG9rZW4oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVvZilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVPRjtcbiAgICAgICAgICAgICAgICBpZiAoZW9sKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW9sID0gZmFsc2UsIEVPTDtcbiAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZSBxdW90ZXMuXG4gICAgICAgICAgICAgICAgdmFyIGksIGogPSBJLCBjO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaikgPT09IFFVT1RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChJKysgPCBOICYmIHRleHQuY2hhckNvZGVBdChJKSAhPT0gUVVPVEUgfHwgdGV4dC5jaGFyQ29kZUF0KCsrSSkgPT09IFFVT1RFKVxuICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGkgPSBJKSA+PSBOKVxuICAgICAgICAgICAgICAgICAgICAgICAgZW9mID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKGMgPSB0ZXh0LmNoYXJDb2RlQXQoSSsrKSkgPT09IE5FV0xJTkUpXG4gICAgICAgICAgICAgICAgICAgICAgICBlb2wgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBSRVRVUk4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSBORVdMSU5FKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrSTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqICsgMSwgaSAtIDEpLnJlcGxhY2UoL1wiXCIvZywgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaW5kIG5leHQgZGVsaW1pdGVyIG9yIG5ld2xpbmUuXG4gICAgICAgICAgICAgICAgd2hpbGUgKEkgPCBOKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoYyA9IHRleHQuY2hhckNvZGVBdChpID0gSSsrKSkgPT09IE5FV0xJTkUpXG4gICAgICAgICAgICAgICAgICAgICAgICBlb2wgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBSRVRVUk4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSBORVdMSU5FKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrSTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjICE9PSBERUxJTUlURVIpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJldHVybiBsYXN0IHRva2VuIGJlZm9yZSBFT0YuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVvZiA9IHRydWUsIHRleHQuc2xpY2UoaiwgTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoKHQgPSB0b2tlbigpKSAhPT0gRU9GKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0ICE9PSBFT0wgJiYgdCAhPT0gRU9GKVxuICAgICAgICAgICAgICAgICAgICByb3cucHVzaCh0KSwgdCA9IHRva2VuKCk7XG4gICAgICAgICAgICAgICAgaWYgKGYgJiYgKHJvdyA9IGYocm93LCBuKyspKSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3dzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykge1xuICAgICAgICAgICAgcmV0dXJuIHJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUocm93W2NvbHVtbl0pO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oZGVsaW1pdGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvcm1hdChyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgICAgICBpZiAoY29sdW1ucyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbHVtbnMgPSBpbmZlckNvbHVtbnMocm93cyk7XG4gICAgICAgICAgICByZXR1cm4gW2NvbHVtbnMubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcildLmNvbmNhdChwcmVmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpKS5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvcm1hdEJvZHkocm93cywgY29sdW1ucykge1xuICAgICAgICAgICAgaWYgKGNvbHVtbnMgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb2x1bW5zID0gaW5mZXJDb2x1bW5zKHJvd3MpO1xuICAgICAgICAgICAgcmV0dXJuIHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykuam9pbihcIlxcblwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb3JtYXRSb3dzKHJvd3MpIHtcbiAgICAgICAgICAgIHJldHVybiByb3dzLm1hcChmb3JtYXRSb3cpLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZm9ybWF0Um93KHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHJvdy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiXG4gICAgICAgICAgICAgICAgOiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyBmb3JtYXREYXRlKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA6IHJlRm9ybWF0LnRlc3QodmFsdWUgKz0gXCJcIikgPyBcIlxcXCJcIiArIHZhbHVlLnJlcGxhY2UoL1wiL2csIFwiXFxcIlxcXCJcIikgKyBcIlxcXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFyc2U6IHBhcnNlLFxuICAgICAgICAgICAgcGFyc2VSb3dzOiBwYXJzZVJvd3MsXG4gICAgICAgICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgICAgIGZvcm1hdEJvZHk6IGZvcm1hdEJvZHksXG4gICAgICAgICAgICBmb3JtYXRSb3dzOiBmb3JtYXRSb3dzLFxuICAgICAgICAgICAgZm9ybWF0Um93OiBmb3JtYXRSb3csXG4gICAgICAgICAgICBmb3JtYXRWYWx1ZTogZm9ybWF0VmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGNzdiA9IGRzdihcIixcIik7XG4gICAgdmFyIGNzdlBhcnNlID0gY3N2LnBhcnNlO1xuICAgIHZhciBjc3ZQYXJzZVJvd3MgPSBjc3YucGFyc2VSb3dzO1xuICAgIHZhciBjc3ZGb3JtYXQgPSBjc3YuZm9ybWF0O1xuICAgIHZhciBjc3ZGb3JtYXRCb2R5ID0gY3N2LmZvcm1hdEJvZHk7XG4gICAgdmFyIGNzdkZvcm1hdFJvd3MgPSBjc3YuZm9ybWF0Um93cztcbiAgICB2YXIgY3N2Rm9ybWF0Um93ID0gY3N2LmZvcm1hdFJvdztcbiAgICB2YXIgY3N2Rm9ybWF0VmFsdWUgPSBjc3YuZm9ybWF0VmFsdWU7XG4gICAgdmFyIHRzdiA9IGRzdihcIlxcdFwiKTtcbiAgICB2YXIgdHN2UGFyc2UgPSB0c3YucGFyc2U7XG4gICAgdmFyIHRzdlBhcnNlUm93cyA9IHRzdi5wYXJzZVJvd3M7XG4gICAgdmFyIHRzdkZvcm1hdCA9IHRzdi5mb3JtYXQ7XG4gICAgdmFyIHRzdkZvcm1hdEJvZHkgPSB0c3YuZm9ybWF0Qm9keTtcbiAgICB2YXIgdHN2Rm9ybWF0Um93cyA9IHRzdi5mb3JtYXRSb3dzO1xuICAgIHZhciB0c3ZGb3JtYXRSb3cgPSB0c3YuZm9ybWF0Um93O1xuICAgIHZhciB0c3ZGb3JtYXRWYWx1ZSA9IHRzdi5mb3JtYXRWYWx1ZTtcbiAgICBmdW5jdGlvbiBhdXRvVHlwZShvYmplY3QpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0udHJpbSgpLCBudW1iZXIsIG07XG4gICAgICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBcInRydWVcIilcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJOYU5cIilcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE5hTjtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc05hTihudW1iZXIgPSArdmFsdWUpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVtYmVyO1xuICAgICAgICAgICAgZWxzZSBpZiAobSA9IHZhbHVlLm1hdGNoKC9eKFstK11cXGR7Mn0pP1xcZHs0fSgtXFxkezJ9KC1cXGR7Mn0pPyk/KFRcXGR7Mn06XFxkezJ9KDpcXGR7Mn0oXFwuXFxkezN9KT8pPyhafFstK11cXGR7Mn06XFxkezJ9KT8pPyQvKSkge1xuICAgICAgICAgICAgICAgIGlmIChmaXh0eiAmJiAhIW1bNF0gJiYgIW1bN10pXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvLS9nLCBcIi9cIikucmVwbGFjZSgvVC8sIFwiIFwiKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWRzdi9pc3N1ZXMvNDVcbiAgICB2YXIgZml4dHogPSBuZXcgRGF0ZShcIjIwMTktMDEtMDFUMDA6MDBcIikuZ2V0SG91cnMoKSB8fCBuZXcgRGF0ZShcIjIwMTktMDctMDFUMDA6MDBcIikuZ2V0SG91cnMoKTtcbiAgICBleHBvcnRzLmF1dG9UeXBlID0gYXV0b1R5cGU7XG4gICAgZXhwb3J0cy5jc3ZGb3JtYXQgPSBjc3ZGb3JtYXQ7XG4gICAgZXhwb3J0cy5jc3ZGb3JtYXRCb2R5ID0gY3N2Rm9ybWF0Qm9keTtcbiAgICBleHBvcnRzLmNzdkZvcm1hdFJvdyA9IGNzdkZvcm1hdFJvdztcbiAgICBleHBvcnRzLmNzdkZvcm1hdFJvd3MgPSBjc3ZGb3JtYXRSb3dzO1xuICAgIGV4cG9ydHMuY3N2Rm9ybWF0VmFsdWUgPSBjc3ZGb3JtYXRWYWx1ZTtcbiAgICBleHBvcnRzLmNzdlBhcnNlID0gY3N2UGFyc2U7XG4gICAgZXhwb3J0cy5jc3ZQYXJzZVJvd3MgPSBjc3ZQYXJzZVJvd3M7XG4gICAgZXhwb3J0cy5kc3ZGb3JtYXQgPSBkc3Y7XG4gICAgZXhwb3J0cy50c3ZGb3JtYXQgPSB0c3ZGb3JtYXQ7XG4gICAgZXhwb3J0cy50c3ZGb3JtYXRCb2R5ID0gdHN2Rm9ybWF0Qm9keTtcbiAgICBleHBvcnRzLnRzdkZvcm1hdFJvdyA9IHRzdkZvcm1hdFJvdztcbiAgICBleHBvcnRzLnRzdkZvcm1hdFJvd3MgPSB0c3ZGb3JtYXRSb3dzO1xuICAgIGV4cG9ydHMudHN2Rm9ybWF0VmFsdWUgPSB0c3ZGb3JtYXRWYWx1ZTtcbiAgICBleHBvcnRzLnRzdlBhcnNlID0gdHN2UGFyc2U7XG4gICAgZXhwb3J0cy50c3ZQYXJzZVJvd3MgPSB0c3ZQYXJzZVJvd3M7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn0pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtZ2VvLXByb2plY3Rpb25AMi4xLjJAZDMtZ2VvLXByb2plY3Rpb24vYnVpbGQvZDMtZ2VvLXByb2plY3Rpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kMy1nZW8tcHJvamVjdGlvbkAyLjEuMkBkMy1nZW8tcHJvamVjdGlvbi9idWlsZC9kMy1nZW8tcHJvamVjdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1nZW8tcHJvamVjdGlvbi8gVmVyc2lvbiAyLjEuMi4gQ29weXJpZ2h0IDIwMTcgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICAgdHJ1ZSA/IGZhY3RvcnkoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtZ2VvICovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWdlb0AxLjExLjlAZDMtZ2VvL2Rpc3QvZDMtZ2VvLmpzXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1hcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1hcnJheUAxLjIuNEBkMy1hcnJheS9kaXN0L2QzLWFycmF5LmpzXCIpKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCBkM0dlbywgZDNBcnJheSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgYWJzID0gTWF0aC5hYnM7XG4gICAgdmFyIGF0YW4gPSBNYXRoLmF0YW47XG4gICAgdmFyIGF0YW4yID0gTWF0aC5hdGFuMjtcbiAgICB2YXIgY29zID0gTWF0aC5jb3M7XG4gICAgdmFyIGV4cCA9IE1hdGguZXhwO1xuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIGxvZyA9IE1hdGgubG9nO1xuICAgIHZhciBtYXggPSBNYXRoLm1heDtcbiAgICB2YXIgbWluID0gTWF0aC5taW47XG4gICAgdmFyIHBvdyA9IE1hdGgucG93O1xuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIHNpZ24gPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPiAwID8gMSA6IHggPCAwID8gLTEgOiAwOyB9O1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgdGFuID0gTWF0aC50YW47XG4gICAgdmFyIGVwc2lsb24gPSAxZS02O1xuICAgIHZhciBlcHNpbG9uMiA9IDFlLTEyO1xuICAgIHZhciBwaSA9IE1hdGguUEk7XG4gICAgdmFyIGhhbGZQaSA9IHBpIC8gMjtcbiAgICB2YXIgcXVhcnRlclBpID0gcGkgLyA0O1xuICAgIHZhciBzcXJ0MV8yID0gTWF0aC5TUVJUMV8yO1xuICAgIHZhciBzcXJ0MiA9IHNxcnQoMik7XG4gICAgdmFyIHNxcnRQaSA9IHNxcnQocGkpO1xuICAgIHZhciB0YXUgPSBwaSAqIDI7XG4gICAgdmFyIGRlZ3JlZXMgPSAxODAgLyBwaTtcbiAgICB2YXIgcmFkaWFucyA9IHBpIC8gMTgwO1xuICAgIGZ1bmN0aW9uIHNpbmNpKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPyB4IC8gTWF0aC5zaW4oeCkgOiAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc2luKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPiAxID8gaGFsZlBpIDogeCA8IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWNvcyh4KSB7XG4gICAgICAgIHJldHVybiB4ID4gMSA/IDAgOiB4IDwgLTEgPyBwaSA6IE1hdGguYWNvcyh4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3FydCh4KSB7XG4gICAgICAgIHJldHVybiB4ID4gMCA/IE1hdGguc3FydCh4KSA6IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRhbmgoeCkge1xuICAgICAgICB4ID0gZXhwKDIgKiB4KTtcbiAgICAgICAgcmV0dXJuICh4IC0gMSkgLyAoeCArIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaW5oKHgpIHtcbiAgICAgICAgcmV0dXJuIChleHAoeCkgLSBleHAoLXgpKSAvIDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvc2goeCkge1xuICAgICAgICByZXR1cm4gKGV4cCh4KSArIGV4cCgteCkpIC8gMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJzaW5oKHgpIHtcbiAgICAgICAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCArIDEpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJjb3NoKHgpIHtcbiAgICAgICAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCAtIDEpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWlyeVJhdyhiZXRhKSB7XG4gICAgICAgIHZhciB0YW5CZXRhXzIgPSB0YW4oYmV0YSAvIDIpLCBiID0gMiAqIGxvZyhjb3MoYmV0YSAvIDIpKSAvICh0YW5CZXRhXzIgKiB0YW5CZXRhXzIpO1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBjb3N4ID0gY29zKHgpLCBjb3N5ID0gY29zKHkpLCBzaW55ID0gc2luKHkpLCBjb3N6ID0gY29zeSAqIGNvc3gsIGsgPSAtKCgxIC0gY29zeiA/IGxvZygoMSArIGNvc3opIC8gMikgLyAoMSAtIGNvc3opIDogLTAuNSkgKyBiIC8gKDEgKyBjb3N6KSk7XG4gICAgICAgICAgICByZXR1cm4gW2sgKiBjb3N5ICogc2luKHgpLCBrICogc2lueV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHIgPSBzcXJ0KHggKiB4ICsgeSAqIHkpLCB6ID0gLWJldGEgLyAyLCBpID0gNTAsIGRlbHRhO1xuICAgICAgICAgICAgaWYgKCFyKVxuICAgICAgICAgICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIHpfMiA9IHogLyAyLCBjb3N6XzIgPSBjb3Moel8yKSwgc2luel8yID0gc2luKHpfMiksIHRhbnpfMiA9IHRhbih6XzIpLCBsbnNlY3pfMiA9IGxvZygxIC8gY29zel8yKTtcbiAgICAgICAgICAgICAgICB6IC09IGRlbHRhID0gKDIgLyB0YW56XzIgKiBsbnNlY3pfMiAtIGIgKiB0YW56XzIgLSByKSAvICgtbG5zZWN6XzIgLyAoc2luel8yICogc2luel8yKSArIDEgLSBiIC8gKDIgKiBjb3N6XzIgKiBjb3N6XzIpKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGFicyhkZWx0YSkgPiBlcHNpbG9uICYmIC0taSA+IDApO1xuICAgICAgICAgICAgdmFyIHNpbnogPSBzaW4oeik7XG4gICAgICAgICAgICByZXR1cm4gW2F0YW4yKHggKiBzaW56LCByICogY29zKHopKSwgYXNpbih5ICogc2lueiAvIHIpXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIHZhciBhaXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmV0YSA9IGhhbGZQaSwgbSA9IGQzR2VvLmdlb1Byb2plY3Rpb25NdXRhdG9yKGFpcnlSYXcpLCBwID0gbShiZXRhKTtcbiAgICAgICAgcC5yYWRpdXMgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBtKGJldGEgPSBfICogcmFkaWFucykgOiBiZXRhICogZGVncmVlcztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBcbiAgICAgICAgICAgIC5zY2FsZSgxNzkuOTc2KVxuICAgICAgICAgICAgLmNsaXBBbmdsZSgxNDcpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gYWl0b2ZmUmF3KHgsIHkpIHtcbiAgICAgICAgdmFyIGNvc3kgPSBjb3MoeSksIHNpbmNpYSA9IHNpbmNpKGFjb3MoY29zeSAqIGNvcyh4IC89IDIpKSk7XG4gICAgICAgIHJldHVybiBbMiAqIGNvc3kgKiBzaW4oeCkgKiBzaW5jaWEsIHNpbih5KSAqIHNpbmNpYV07XG4gICAgfVxuICAgIC8vIEFib3J0IGlmIFt4LCB5XSBpcyBub3Qgd2l0aGluIGFuIGVsbGlwc2UgY2VudGVyZWQgYXQgWzAsIDBdIHdpdGhcbiAgICAvLyBzZW1pLW1ham9yIGF4aXMgcGkgYW5kIHNlbWktbWlub3IgYXhpcyBwaS8yLlxuICAgIGFpdG9mZlJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoeCAqIHggKyA0ICogeSAqIHkgPiBwaSAqIHBpICsgZXBzaWxvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHgxID0geCwgeTEgPSB5LCBpID0gMjU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBzaW54ID0gc2luKHgxKSwgc2lueF8yID0gc2luKHgxIC8gMiksIGNvc3hfMiA9IGNvcyh4MSAvIDIpLCBzaW55ID0gc2luKHkxKSwgY29zeSA9IGNvcyh5MSksIHNpbl8yeSA9IHNpbigyICogeTEpLCBzaW4yeSA9IHNpbnkgKiBzaW55LCBjb3MyeSA9IGNvc3kgKiBjb3N5LCBzaW4yeF8yID0gc2lueF8yICogc2lueF8yLCBjID0gMSAtIGNvczJ5ICogY29zeF8yICogY29zeF8yLCBlID0gYyA/IGFjb3MoY29zeSAqIGNvc3hfMikgKiBzcXJ0KGYgPSAxIC8gYykgOiBmID0gMCwgZiwgZnggPSAyICogZSAqIGNvc3kgKiBzaW54XzIgLSB4LCBmeSA9IGUgKiBzaW55IC0geSwgZHhkeCA9IGYgKiAoY29zMnkgKiBzaW4yeF8yICsgZSAqIGNvc3kgKiBjb3N4XzIgKiBzaW4yeSksIGR4ZHkgPSBmICogKDAuNSAqIHNpbnggKiBzaW5fMnkgLSBlICogMiAqIHNpbnkgKiBzaW54XzIpLCBkeWR4ID0gZiAqIDAuMjUgKiAoc2luXzJ5ICogc2lueF8yIC0gZSAqIHNpbnkgKiBjb3MyeSAqIHNpbngpLCBkeWR5ID0gZiAqIChzaW4yeSAqIGNvc3hfMiArIGUgKiBzaW4yeF8yICogY29zeSksIHogPSBkeGR5ICogZHlkeCAtIGR5ZHkgKiBkeGR4O1xuICAgICAgICAgICAgaWYgKCF6KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFyIGR4ID0gKGZ5ICogZHhkeSAtIGZ4ICogZHlkeSkgLyB6LCBkeSA9IChmeCAqIGR5ZHggLSBmeSAqIGR4ZHgpIC8gejtcbiAgICAgICAgICAgIHgxIC09IGR4LCB5MSAtPSBkeTtcbiAgICAgICAgfSB3aGlsZSAoKGFicyhkeCkgPiBlcHNpbG9uIHx8IGFicyhkeSkgPiBlcHNpbG9uKSAmJiAtLWkgPiAwKTtcbiAgICAgICAgcmV0dXJuIFt4MSwgeTFdO1xuICAgIH07XG4gICAgdmFyIGFpdG9mZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oYWl0b2ZmUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE1Mi42Myk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBhcm1hZGlsbG9SYXcocGhpMCkge1xuICAgICAgICB2YXIgc2luUGhpMCA9IHNpbihwaGkwKSwgY29zUGhpMCA9IGNvcyhwaGkwKSwgc1BoaTAgPSBwaGkwID49IDAgPyAxIDogLTEsIHRhblBoaTAgPSB0YW4oc1BoaTAgKiBwaGkwKSwgayA9ICgxICsgc2luUGhpMCAtIGNvc1BoaTApIC8gMjtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLCBjb3NMYW1iZGEgPSBjb3MobGFtYmRhIC89IDIpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAoMSArIGNvc1BoaSkgKiBzaW4obGFtYmRhKSxcbiAgICAgICAgICAgICAgICAoc1BoaTAgKiBwaGkgPiAtYXRhbjIoY29zTGFtYmRhLCB0YW5QaGkwKSAtIDFlLTMgPyAwIDogLXNQaGkwICogMTApICsgayArIHNpbihwaGkpICogY29zUGhpMCAtICgxICsgY29zUGhpKSAqIHNpblBoaTAgKiBjb3NMYW1iZGEgLy8gVE9ETyBEMyBjb3JlIHNob3VsZCBhbGxvdyBudWxsIG9yIFtOYU4sIE5hTl0gdG8gYmUgcmV0dXJuZWQuXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBsYW1iZGEgPSAwLCBwaGkgPSAwLCBpID0gNTA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIGNvc0xhbWJkYSA9IGNvcyhsYW1iZGEpLCBzaW5MYW1iZGEgPSBzaW4obGFtYmRhKSwgY29zUGhpID0gY29zKHBoaSksIHNpblBoaSA9IHNpbihwaGkpLCBBID0gMSArIGNvc1BoaSwgZnggPSBBICogc2luTGFtYmRhIC0geCwgZnkgPSBrICsgc2luUGhpICogY29zUGhpMCAtIEEgKiBzaW5QaGkwICogY29zTGFtYmRhIC0geSwgZHhkTGFtYmRhID0gQSAqIGNvc0xhbWJkYSAvIDIsIGR4ZFBoaSA9IC1zaW5MYW1iZGEgKiBzaW5QaGksIGR5ZExhbWJkYSA9IHNpblBoaTAgKiBBICogc2luTGFtYmRhIC8gMiwgZHlkUGhpID0gY29zUGhpMCAqIGNvc1BoaSArIHNpblBoaTAgKiBjb3NMYW1iZGEgKiBzaW5QaGksIGRlbm9taW5hdG9yID0gZHhkUGhpICogZHlkTGFtYmRhIC0gZHlkUGhpICogZHhkTGFtYmRhLCBkTGFtYmRhID0gKGZ5ICogZHhkUGhpIC0gZnggKiBkeWRQaGkpIC8gZGVub21pbmF0b3IgLyAyLCBkUGhpID0gKGZ4ICogZHlkTGFtYmRhIC0gZnkgKiBkeGRMYW1iZGEpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICAgICAgbGFtYmRhIC09IGRMYW1iZGEsIHBoaSAtPSBkUGhpO1xuICAgICAgICAgICAgfSB3aGlsZSAoKGFicyhkTGFtYmRhKSA+IGVwc2lsb24gfHwgYWJzKGRQaGkpID4gZXBzaWxvbikgJiYgLS1pID4gMCk7XG4gICAgICAgICAgICByZXR1cm4gc1BoaTAgKiBwaGkgPiAtYXRhbjIoY29zKGxhbWJkYSksIHRhblBoaTApIC0gMWUtMyA/IFtsYW1iZGEgKiAyLCBwaGldIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIHZhciBhcm1hZGlsbG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwaGkwID0gMjAgKiByYWRpYW5zLCBzUGhpMCA9IHBoaTAgPj0gMCA/IDEgOiAtMSwgdGFuUGhpMCA9IHRhbihzUGhpMCAqIHBoaTApLCBtID0gZDNHZW8uZ2VvUHJvamVjdGlvbk11dGF0b3IoYXJtYWRpbGxvUmF3KSwgcCA9IG0ocGhpMCksIHN0cmVhbV8gPSBwLnN0cmVhbTtcbiAgICAgICAgcC5wYXJhbGxlbCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBoaTAgKiBkZWdyZWVzO1xuICAgICAgICAgICAgdGFuUGhpMCA9IHRhbigoc1BoaTAgPSAocGhpMCA9IF8gKiByYWRpYW5zKSA+PSAwID8gMSA6IC0xKSAqIHBoaTApO1xuICAgICAgICAgICAgcmV0dXJuIG0ocGhpMCk7XG4gICAgICAgIH07XG4gICAgICAgIHAuc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIHJvdGF0ZSA9IHAucm90YXRlKCksIHJvdGF0ZVN0cmVhbSA9IHN0cmVhbV8oc3RyZWFtKSwgc3BoZXJlU3RyZWFtID0gKHAucm90YXRlKFswLCAwXSksIHN0cmVhbV8oc3RyZWFtKSk7XG4gICAgICAgICAgICBwLnJvdGF0ZShyb3RhdGUpO1xuICAgICAgICAgICAgcm90YXRlU3RyZWFtLnNwaGVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ucG9seWdvblN0YXJ0KCksIHNwaGVyZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsYW1iZGEgPSBzUGhpMCAqIC0xODA7IHNQaGkwICogbGFtYmRhIDwgMTgwOyBsYW1iZGEgKz0gc1BoaTAgKiA5MClcbiAgICAgICAgICAgICAgICAgICAgc3BoZXJlU3RyZWFtLnBvaW50KGxhbWJkYSwgc1BoaTAgKiA5MCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNQaGkwICogKGxhbWJkYSAtPSBwaGkwKSA+PSAtMTgwKSB7IC8vIFRPRE8gcHJlY2lzaW9uP1xuICAgICAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ucG9pbnQobGFtYmRhLCBzUGhpMCAqIC1hdGFuMihjb3MobGFtYmRhICogcmFkaWFucyAvIDIpLCB0YW5QaGkwKSAqIGRlZ3JlZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ubGluZUVuZCgpLCBzcGhlcmVTdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByb3RhdGVTdHJlYW07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwXG4gICAgICAgICAgICAuc2NhbGUoMjE4LjY5NSlcbiAgICAgICAgICAgIC5jZW50ZXIoWzAsIDI4LjA5NzRdKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGF1Z3VzdFJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgdGFuUGhpID0gdGFuKHBoaSAvIDIpLCBrID0gc3FydCgxIC0gdGFuUGhpICogdGFuUGhpKSwgYyA9IDEgKyBrICogY29zKGxhbWJkYSAvPSAyKSwgeCA9IHNpbihsYW1iZGEpICogayAvIGMsIHkgPSB0YW5QaGkgLyBjLCB4MiA9IHggKiB4LCB5MiA9IHkgKiB5O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgNCAvIDMgKiB4ICogKDMgKyB4MiAtIDMgKiB5MiksXG4gICAgICAgICAgICA0IC8gMyAqIHkgKiAoMyArIDMgKiB4MiAtIHkyKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBhdWd1c3RSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgeCAqPSAzIC8gOCwgeSAqPSAzIC8gODtcbiAgICAgICAgaWYgKCF4ICYmIGFicyh5KSA+IDEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHgyID0geCAqIHgsIHkyID0geSAqIHksIHMgPSAxICsgeDIgKyB5Miwgc2luM0V0YSA9IHNxcnQoKHMgLSBzcXJ0KHMgKiBzIC0gNCAqIHkgKiB5KSkgLyAyKSwgZXRhID0gYXNpbihzaW4zRXRhKSAvIDMsIHhpID0gc2luM0V0YSA/IGFyY29zaChhYnMoeSAvIHNpbjNFdGEpKSAvIDMgOiBhcnNpbmgoYWJzKHgpKSAvIDMsIGNvc0V0YSA9IGNvcyhldGEpLCBjb3NoWGkgPSBjb3NoKHhpKSwgZCA9IGNvc2hYaSAqIGNvc2hYaSAtIGNvc0V0YSAqIGNvc0V0YTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHNpZ24oeCkgKiAyICogYXRhbjIoc2luaCh4aSkgKiBjb3NFdGEsIDAuMjUgLSBkKSxcbiAgICAgICAgICAgIHNpZ24oeSkgKiAyICogYXRhbjIoY29zaFhpICogc2luKGV0YSksIDAuMjUgKyBkKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIGF1Z3VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oYXVndXN0UmF3KVxuICAgICAgICAgICAgLnNjYWxlKDY2LjE2MDMpO1xuICAgIH07XG4gICAgdmFyIHNxcnQ4ID0gc3FydCg4KTtcbiAgICB2YXIgcGhpMCA9IGxvZygxICsgc3FydDIpO1xuICAgIGZ1bmN0aW9uIGJha2VyUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBwaGkwID0gYWJzKHBoaSk7XG4gICAgICAgIHJldHVybiBwaGkwIDwgcXVhcnRlclBpXG4gICAgICAgICAgICA/IFtsYW1iZGEsIGxvZyh0YW4ocXVhcnRlclBpICsgcGhpIC8gMikpXVxuICAgICAgICAgICAgOiBbbGFtYmRhICogY29zKHBoaTApICogKDIgKiBzcXJ0MiAtIDEgLyBzaW4ocGhpMCkpLCBzaWduKHBoaSkgKiAoMiAqIHNxcnQyICogKHBoaTAgLSBxdWFydGVyUGkpIC0gbG9nKHRhbihwaGkwIC8gMikpKV07XG4gICAgfVxuICAgIGJha2VyUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmICgoeTAgPSBhYnMoeSkpIDwgcGhpMClcbiAgICAgICAgICAgIHJldHVybiBbeCwgMiAqIGF0YW4oZXhwKHkpKSAtIGhhbGZQaV07XG4gICAgICAgIHZhciBwaGkgPSBxdWFydGVyUGksIGkgPSAyNSwgZGVsdGEsIHkwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgY29zUGhpXzIgPSBjb3MocGhpIC8gMiksIHRhblBoaV8yID0gdGFuKHBoaSAvIDIpO1xuICAgICAgICAgICAgcGhpIC09IGRlbHRhID0gKHNxcnQ4ICogKHBoaSAtIHF1YXJ0ZXJQaSkgLSBsb2codGFuUGhpXzIpIC0geTApIC8gKHNxcnQ4IC0gY29zUGhpXzIgKiBjb3NQaGlfMiAvICgyICogdGFuUGhpXzIpKTtcbiAgICAgICAgfSB3aGlsZSAoYWJzKGRlbHRhKSA+IGVwc2lsb24yICYmIC0taSA+IDApO1xuICAgICAgICByZXR1cm4gW3ggLyAoY29zKHBoaSkgKiAoc3FydDggLSAxIC8gc2luKHBoaSkpKSwgc2lnbih5KSAqIHBoaV07XG4gICAgfTtcbiAgICB2YXIgYmFrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGJha2VyUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDExMi4zMTQpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gYmVyZ2hhdXNSYXcobG9iZXMpIHtcbiAgICAgICAgdmFyIGsgPSAyICogcGkgLyBsb2JlcztcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIHAgPSBkM0dlby5nZW9BemltdXRoYWxFcXVpZGlzdGFudFJhdyhsYW1iZGEsIHBoaSk7XG4gICAgICAgICAgICBpZiAoYWJzKGxhbWJkYSkgPiBoYWxmUGkpIHsgLy8gYmFjayBoZW1pc3BoZXJlXG4gICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gYXRhbjIocFsxXSwgcFswXSksIHIgPSBzcXJ0KHBbMF0gKiBwWzBdICsgcFsxXSAqIHBbMV0pLCB0aGV0YTAgPSBrICogcm91bmQoKHRoZXRhIC0gaGFsZlBpKSAvIGspICsgaGFsZlBpLCBhbHBoYSA9IGF0YW4yKHNpbih0aGV0YSAtPSB0aGV0YTApLCAyIC0gY29zKHRoZXRhKSk7IC8vIGFuZ2xlIHJlbGF0aXZlIHRvIGxvYmUgZW5kXG4gICAgICAgICAgICAgICAgdGhldGEgPSB0aGV0YTAgKyBhc2luKHBpIC8gciAqIHNpbihhbHBoYSkpIC0gYWxwaGE7XG4gICAgICAgICAgICAgICAgcFswXSA9IHIgKiBjb3ModGhldGEpO1xuICAgICAgICAgICAgICAgIHBbMV0gPSByICogc2luKHRoZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciByID0gc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgICAgIGlmIChyID4gaGFsZlBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gYXRhbjIoeSwgeCksIHRoZXRhMCA9IGsgKiByb3VuZCgodGhldGEgLSBoYWxmUGkpIC8gaykgKyBoYWxmUGksIHMgPSB0aGV0YSA+IHRoZXRhMCA/IC0xIDogMSwgQSA9IHIgKiBjb3ModGhldGEwIC0gdGhldGEpLCBjb3RBbHBoYSA9IDEgLyB0YW4ocyAqIGFjb3MoKEEgLSBwaSkgLyBzcXJ0KHBpICogKHBpIC0gMiAqIEEpICsgciAqIHIpKSk7XG4gICAgICAgICAgICAgICAgdGhldGEgPSB0aGV0YTAgKyAyICogYXRhbigoY290QWxwaGEgKyBzICogc3FydChjb3RBbHBoYSAqIGNvdEFscGhhIC0gMykpIC8gMyk7XG4gICAgICAgICAgICAgICAgeCA9IHIgKiBjb3ModGhldGEpLCB5ID0gciAqIHNpbih0aGV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDNHZW8uZ2VvQXppbXV0aGFsRXF1aWRpc3RhbnRSYXcuaW52ZXJ0KHgsIHkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9XG4gICAgdmFyIGJlcmdoYXVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9iZXMgPSA1LCBtID0gZDNHZW8uZ2VvUHJvamVjdGlvbk11dGF0b3IoYmVyZ2hhdXNSYXcpLCBwID0gbShsb2JlcyksIHByb2plY3Rpb25TdHJlYW0gPSBwLnN0cmVhbSwgZXBzaWxvbiQkMSA9IDFlLTIsIGNyID0gLWNvcyhlcHNpbG9uJCQxICogcmFkaWFucyksIHNyID0gc2luKGVwc2lsb24kJDEgKiByYWRpYW5zKTtcbiAgICAgICAgcC5sb2JlcyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IG0obG9iZXMgPSArXykgOiBsb2JlcztcbiAgICAgICAgfTtcbiAgICAgICAgcC5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgcm90YXRlID0gcC5yb3RhdGUoKSwgcm90YXRlU3RyZWFtID0gcHJvamVjdGlvblN0cmVhbShzdHJlYW0pLCBzcGhlcmVTdHJlYW0gPSAocC5yb3RhdGUoWzAsIDBdKSwgcHJvamVjdGlvblN0cmVhbShzdHJlYW0pKTtcbiAgICAgICAgICAgIHAucm90YXRlKHJvdGF0ZSk7XG4gICAgICAgICAgICByb3RhdGVTdHJlYW0uc3BoZXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNwaGVyZVN0cmVhbS5wb2x5Z29uU3RhcnQoKSwgc3BoZXJlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBkZWx0YSA9IDM2MCAvIGxvYmVzLCBkZWx0YTAgPSAyICogcGkgLyBsb2JlcywgcGhpID0gOTAgLSAxODAgLyBsb2JlcywgcGhpMCA9IGhhbGZQaTsgaSA8IGxvYmVzOyArK2ksIHBoaSAtPSBkZWx0YSwgcGhpMCAtPSBkZWx0YTApIHtcbiAgICAgICAgICAgICAgICAgICAgc3BoZXJlU3RyZWFtLnBvaW50KGF0YW4yKHNyICogY29zKHBoaTApLCBjcikgKiBkZWdyZWVzLCBhc2luKHNyICogc2luKHBoaTApKSAqIGRlZ3JlZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGhpIDwgLTkwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ucG9pbnQoLTkwLCAtMTgwIC0gcGhpIC0gZXBzaWxvbiQkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ucG9pbnQoLTkwLCAtMTgwIC0gcGhpICsgZXBzaWxvbiQkMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ucG9pbnQoOTAsIHBoaSArIGVwc2lsb24kJDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BoZXJlU3RyZWFtLnBvaW50KDkwLCBwaGkgLSBlcHNpbG9uJCQxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ubGluZUVuZCgpLCBzcGhlcmVTdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByb3RhdGVTdHJlYW07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwXG4gICAgICAgICAgICAuc2NhbGUoODcuODA3NilcbiAgICAgICAgICAgIC5jZW50ZXIoWzAsIDE3LjE4NzVdKVxuICAgICAgICAgICAgLmNsaXBBbmdsZSgxODAgLSAxZS0zKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG1vbGx3ZWlkZUJyb21sZXlUaGV0YShjcCwgcGhpKSB7XG4gICAgICAgIHZhciBjcHNpblBoaSA9IGNwICogc2luKHBoaSksIGkgPSAzMCwgZGVsdGE7XG4gICAgICAgIGRvXG4gICAgICAgICAgICBwaGkgLT0gZGVsdGEgPSAocGhpICsgc2luKHBoaSkgLSBjcHNpblBoaSkgLyAoMSArIGNvcyhwaGkpKTtcbiAgICAgICAgd2hpbGUgKGFicyhkZWx0YSkgPiBlcHNpbG9uICYmIC0taSA+IDApO1xuICAgICAgICByZXR1cm4gcGhpIC8gMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9sbHdlaWRlQnJvbWxleVJhdyhjeCwgY3ksIGNwKSB7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHJldHVybiBbY3ggKiBsYW1iZGEgKiBjb3MocGhpID0gbW9sbHdlaWRlQnJvbWxleVRoZXRhKGNwLCBwaGkpKSwgY3kgKiBzaW4ocGhpKV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHkgPSBhc2luKHkgLyBjeSksIFt4IC8gKGN4ICogY29zKHkpKSwgYXNpbigoMiAqIHkgKyBzaW4oMiAqIHkpKSAvIGNwKV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICB2YXIgbW9sbHdlaWRlUmF3ID0gbW9sbHdlaWRlQnJvbWxleVJhdyhzcXJ0MiAvIGhhbGZQaSwgc3FydDIsIHBpKTtcbiAgICB2YXIgbW9sbHdlaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihtb2xsd2VpZGVSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTY5LjUyOSk7XG4gICAgfTtcbiAgICB2YXIgayA9IDIuMDAyNzY7XG4gICAgdmFyIHcgPSAxLjExMDcyO1xuICAgIGZ1bmN0aW9uIGJvZ2dzUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciB0aGV0YSA9IG1vbGx3ZWlkZUJyb21sZXlUaGV0YShwaSwgcGhpKTtcbiAgICAgICAgcmV0dXJuIFtrICogbGFtYmRhIC8gKDEgLyBjb3MocGhpKSArIHcgLyBjb3ModGhldGEpKSwgKHBoaSArIHNxcnQyICogc2luKHRoZXRhKSkgLyBrXTtcbiAgICB9XG4gICAgYm9nZ3NSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIGt5ID0gayAqIHksIHRoZXRhID0geSA8IDAgPyAtcXVhcnRlclBpIDogcXVhcnRlclBpLCBpID0gMjUsIGRlbHRhLCBwaGk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHBoaSA9IGt5IC0gc3FydDIgKiBzaW4odGhldGEpO1xuICAgICAgICAgICAgdGhldGEgLT0gZGVsdGEgPSAoc2luKDIgKiB0aGV0YSkgKyAyICogdGhldGEgLSBwaSAqIHNpbihwaGkpKSAvICgyICogY29zKDIgKiB0aGV0YSkgKyAyICsgcGkgKiBjb3MocGhpKSAqIHNxcnQyICogY29zKHRoZXRhKSk7XG4gICAgICAgIH0gd2hpbGUgKGFicyhkZWx0YSkgPiBlcHNpbG9uICYmIC0taSA+IDApO1xuICAgICAgICBwaGkgPSBreSAtIHNxcnQyICogc2luKHRoZXRhKTtcbiAgICAgICAgcmV0dXJuIFt4ICogKDEgLyBjb3MocGhpKSArIHcgLyBjb3ModGhldGEpKSAvIGssIHBoaV07XG4gICAgfTtcbiAgICB2YXIgYm9nZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGJvZ2dzUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE2MC44NTcpO1xuICAgIH07XG4gICAgdmFyIHBhcmFsbGVsMSA9IGZ1bmN0aW9uIChwcm9qZWN0QXQpIHtcbiAgICAgICAgdmFyIHBoaTAgPSAwLCBtID0gZDNHZW8uZ2VvUHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSwgcCA9IG0ocGhpMCk7XG4gICAgICAgIHAucGFyYWxsZWwgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBtKHBoaTAgPSBfICogcmFkaWFucykgOiBwaGkwICogZGVncmVlcztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBzaW51c29pZGFsUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJldHVybiBbbGFtYmRhICogY29zKHBoaSksIHBoaV07XG4gICAgfVxuICAgIHNpbnVzb2lkYWxSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIFt4IC8gY29zKHkpLCB5XTtcbiAgICB9O1xuICAgIHZhciBzaW51c29pZGFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihzaW51c29pZGFsUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE1Mi42Myk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBib25uZVJhdyhwaGkwKSB7XG4gICAgICAgIGlmICghcGhpMClcbiAgICAgICAgICAgIHJldHVybiBzaW51c29pZGFsUmF3O1xuICAgICAgICB2YXIgY290UGhpMCA9IDEgLyB0YW4ocGhpMCk7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciByaG8gPSBjb3RQaGkwICsgcGhpMCAtIHBoaSwgZSA9IHJobyA/IGxhbWJkYSAqIGNvcyhwaGkpIC8gcmhvIDogcmhvO1xuICAgICAgICAgICAgcmV0dXJuIFtyaG8gKiBzaW4oZSksIGNvdFBoaTAgLSByaG8gKiBjb3MoZSldO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciByaG8gPSBzcXJ0KHggKiB4ICsgKHkgPSBjb3RQaGkwIC0geSkgKiB5KSwgcGhpID0gY290UGhpMCArIHBoaTAgLSByaG87XG4gICAgICAgICAgICByZXR1cm4gW3JobyAvIGNvcyhwaGkpICogYXRhbjIoeCwgeSksIHBoaV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICB2YXIgYm9ubmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbGxlbDEoYm9ubmVSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTIzLjA4MilcbiAgICAgICAgICAgIC5jZW50ZXIoWzAsIDI2LjE0NDFdKVxuICAgICAgICAgICAgLnBhcmFsbGVsKDQ1KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGJvdHRvbWxleVJhdyhzaW5Qc2kpIHtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIHJobyA9IGhhbGZQaSAtIHBoaSwgZXRhID0gcmhvID8gbGFtYmRhICogc2luUHNpICogc2luKHJobykgLyByaG8gOiByaG87XG4gICAgICAgICAgICByZXR1cm4gW3JobyAqIHNpbihldGEpIC8gc2luUHNpLCBoYWxmUGkgLSByaG8gKiBjb3MoZXRhKV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHgxID0geCAqIHNpblBzaSwgeTEgPSBoYWxmUGkgLSB5LCByaG8gPSBzcXJ0KHgxICogeDEgKyB5MSAqIHkxKSwgZXRhID0gYXRhbjIoeDEsIHkxKTtcbiAgICAgICAgICAgIHJldHVybiBbKHJobyA/IHJobyAvIHNpbihyaG8pIDogMSkgKiBldGEgLyBzaW5Qc2ksIGhhbGZQaSAtIHJob107XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICB2YXIgYm90dG9tbGV5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2luUHNpID0gMC41LCBtID0gZDNHZW8uZ2VvUHJvamVjdGlvbk11dGF0b3IoYm90dG9tbGV5UmF3KSwgcCA9IG0oc2luUHNpKTtcbiAgICAgICAgcC5mcmFjdGlvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IG0oc2luUHNpID0gK18pIDogc2luUHNpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcFxuICAgICAgICAgICAgLnNjYWxlKDE1OC44MzcpO1xuICAgIH07XG4gICAgdmFyIGJyb21sZXlSYXcgPSBtb2xsd2VpZGVCcm9tbGV5UmF3KDEsIDQgLyBwaSwgcGkpO1xuICAgIHZhciBicm9tbGV5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihicm9tbGV5UmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE1Mi42Myk7XG4gICAgfTtcbiAgICAvLyBBemltdXRoYWwgZGlzdGFuY2UuXG4gICAgZnVuY3Rpb24gZGlzdGFuY2UoZFBoaSwgYzEsIHMxLCBjMiwgczIsIGRMYW1iZGEpIHtcbiAgICAgICAgdmFyIGNvc2RMYW1iZGEgPSBjb3MoZExhbWJkYSksIHI7XG4gICAgICAgIGlmIChhYnMoZFBoaSkgPiAxIHx8IGFicyhkTGFtYmRhKSA+IDEpIHtcbiAgICAgICAgICAgIHIgPSBhY29zKHMxICogczIgKyBjMSAqIGMyICogY29zZExhbWJkYSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2luZFBoaSA9IHNpbihkUGhpIC8gMiksIHNpbmRMYW1iZGEgPSBzaW4oZExhbWJkYSAvIDIpO1xuICAgICAgICAgICAgciA9IDIgKiBhc2luKHNxcnQoc2luZFBoaSAqIHNpbmRQaGkgKyBjMSAqIGMyICogc2luZExhbWJkYSAqIHNpbmRMYW1iZGEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWJzKHIpID4gZXBzaWxvbiA/IFtyLCBhdGFuMihjMiAqIHNpbihkTGFtYmRhKSwgYzEgKiBzMiAtIHMxICogYzIgKiBjb3NkTGFtYmRhKV0gOiBbMCwgMF07XG4gICAgfVxuICAgIC8vIEFuZ2xlIG9wcG9zaXRlIGEsIGFuZCBjb250YWluZWQgYmV0d2VlbiBzaWRlcyBvZiBsZW5ndGhzIGIgYW5kIGMuXG4gICAgZnVuY3Rpb24gYW5nbGUoYiwgYywgYSkge1xuICAgICAgICByZXR1cm4gYWNvcygoYiAqIGIgKyBjICogYyAtIGEgKiBhKSAvICgyICogYiAqIGMpKTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIGxvbmdpdHVkZS5cbiAgICBmdW5jdGlvbiBsb25naXR1ZGUobGFtYmRhKSB7XG4gICAgICAgIHJldHVybiBsYW1iZGEgLSAyICogcGkgKiBmbG9vcigobGFtYmRhICsgcGkpIC8gKDIgKiBwaSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGFtYmVybGluUmF3KHAwLCBwMSwgcDIpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IFtcbiAgICAgICAgICAgIFtwMFswXSwgcDBbMV0sIHNpbihwMFsxXSksIGNvcyhwMFsxXSldLFxuICAgICAgICAgICAgW3AxWzBdLCBwMVsxXSwgc2luKHAxWzFdKSwgY29zKHAxWzFdKV0sXG4gICAgICAgICAgICBbcDJbMF0sIHAyWzFdLCBzaW4ocDJbMV0pLCBjb3MocDJbMV0pXVxuICAgICAgICBdO1xuICAgICAgICBmb3IgKHZhciBhID0gcG9pbnRzWzJdLCBiLCBpID0gMDsgaSA8IDM7ICsraSwgYSA9IGIpIHtcbiAgICAgICAgICAgIGIgPSBwb2ludHNbaV07XG4gICAgICAgICAgICBhLnYgPSBkaXN0YW5jZShiWzFdIC0gYVsxXSwgYVszXSwgYVsyXSwgYlszXSwgYlsyXSwgYlswXSAtIGFbMF0pO1xuICAgICAgICAgICAgYS5wb2ludCA9IFswLCAwXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmV0YTAgPSBhbmdsZShwb2ludHNbMF0udlswXSwgcG9pbnRzWzJdLnZbMF0sIHBvaW50c1sxXS52WzBdKSwgYmV0YTEgPSBhbmdsZShwb2ludHNbMF0udlswXSwgcG9pbnRzWzFdLnZbMF0sIHBvaW50c1syXS52WzBdKSwgYmV0YTIgPSBwaSAtIGJldGEwO1xuICAgICAgICBwb2ludHNbMl0ucG9pbnRbMV0gPSAwO1xuICAgICAgICBwb2ludHNbMF0ucG9pbnRbMF0gPSAtKHBvaW50c1sxXS5wb2ludFswXSA9IHBvaW50c1swXS52WzBdIC8gMik7XG4gICAgICAgIHZhciBtZWFuID0gW1xuICAgICAgICAgICAgcG9pbnRzWzJdLnBvaW50WzBdID0gcG9pbnRzWzBdLnBvaW50WzBdICsgcG9pbnRzWzJdLnZbMF0gKiBjb3MoYmV0YTApLFxuICAgICAgICAgICAgMiAqIChwb2ludHNbMF0ucG9pbnRbMV0gPSBwb2ludHNbMV0ucG9pbnRbMV0gPSBwb2ludHNbMl0udlswXSAqIHNpbihiZXRhMCkpXG4gICAgICAgIF07XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciBzaW5QaGkgPSBzaW4ocGhpKSwgY29zUGhpID0gY29zKHBoaSksIHYgPSBuZXcgQXJyYXkoMyksIGk7XG4gICAgICAgICAgICAvLyBDb21wdXRlIGRpc3RhbmNlIGFuZCBhemltdXRoIGZyb20gY29udHJvbCBwb2ludHMuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgICAgICAgICAgICAgdltpXSA9IGRpc3RhbmNlKHBoaSAtIHBbMV0sIHBbM10sIHBbMl0sIGNvc1BoaSwgc2luUGhpLCBsYW1iZGEgLSBwWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZbaV1bMF0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwLnBvaW50O1xuICAgICAgICAgICAgICAgIHZbaV1bMV0gPSBsb25naXR1ZGUodltpXVsxXSAtIHAudlsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcml0aG1ldGljIG1lYW4gb2YgaW50ZXJjZXB0aW9uIHBvaW50cy5cbiAgICAgICAgICAgIHZhciBwb2ludCA9IG1lYW4uc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IGkgPT0gMiA/IDAgOiBpICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGFuZ2xlKHBvaW50c1tpXS52WzBdLCB2W2ldWzBdLCB2W2pdWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAodltpXVsxXSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGEgPSAtYTtcbiAgICAgICAgICAgICAgICBpZiAoIWkpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRbMF0gKz0gdltpXVswXSAqIGNvcyhhKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRbMV0gLT0gdltpXVswXSAqIHNpbihhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBiZXRhMSAtIGE7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50WzBdIC09IHZbaV1bMF0gKiBjb3MoYSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50WzFdIC09IHZbaV1bMF0gKiBzaW4oYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhID0gYmV0YTIgLSBhO1xuICAgICAgICAgICAgICAgICAgICBwb2ludFswXSArPSB2W2ldWzBdICogY29zKGEpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludFsxXSArPSB2W2ldWzBdICogc2luKGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50WzBdIC89IDMsIHBvaW50WzFdIC89IDM7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50UmFkaWFucyhwKSB7XG4gICAgICAgIHJldHVybiBwWzBdICo9IHJhZGlhbnMsIHBbMV0gKj0gcmFkaWFucywgcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hhbWJlcmxpbkFmcmljYSgpIHtcbiAgICAgICAgcmV0dXJuIGNoYW1iZXJsaW4oWzAsIDIyXSwgWzQ1LCAyMl0sIFsyMi41LCAtMjJdKVxuICAgICAgICAgICAgLnNjYWxlKDM4MClcbiAgICAgICAgICAgIC5jZW50ZXIoWzIyLjUsIDJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hhbWJlcmxpbihwMCwgcDEsIHAyKSB7XG4gICAgICAgIHZhciBjID0gZDNHZW8uZ2VvQ2VudHJvaWQoeyB0eXBlOiBcIk11bHRpUG9pbnRcIiwgY29vcmRpbmF0ZXM6IFtwMCwgcDEsIHAyXSB9KSwgUiA9IFstY1swXSwgLWNbMV1dLCByID0gZDNHZW8uZ2VvUm90YXRpb24oUiksIHAgPSBkM0dlby5nZW9Qcm9qZWN0aW9uKGNoYW1iZXJsaW5SYXcocG9pbnRSYWRpYW5zKHIocDApKSwgcG9pbnRSYWRpYW5zKHIocDEpKSwgcG9pbnRSYWRpYW5zKHIocDIpKSkpLnJvdGF0ZShSKSwgY2VudGVyID0gcC5jZW50ZXI7XG4gICAgICAgIGRlbGV0ZSBwLnJvdGF0ZTtcbiAgICAgICAgcC5jZW50ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjZW50ZXIocihfKSkgOiByLmludmVydChjZW50ZXIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDkwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29sbGlnbm9uUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBhbHBoYSA9IHNxcnQoMSAtIHNpbihwaGkpKTtcbiAgICAgICAgcmV0dXJuIFsoMiAvIHNxcnRQaSkgKiBsYW1iZGEgKiBhbHBoYSwgc3FydFBpICogKDEgLSBhbHBoYSldO1xuICAgIH1cbiAgICBjb2xsaWdub25SYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIGxhbWJkYSA9IChsYW1iZGEgPSB5IC8gc3FydFBpIC0gMSkgKiBsYW1iZGE7XG4gICAgICAgIHJldHVybiBbbGFtYmRhID4gMCA/IHggKiBzcXJ0KHBpIC8gbGFtYmRhKSAvIDIgOiAwLCBhc2luKDEgLSBsYW1iZGEpXTtcbiAgICB9O1xuICAgIHZhciBjb2xsaWdub24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGNvbGxpZ25vblJhdylcbiAgICAgICAgICAgIC5zY2FsZSg5NS42NDY0KVxuICAgICAgICAgICAgLmNlbnRlcihbMCwgMzBdKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNyYWlnUmF3KHBoaTApIHtcbiAgICAgICAgdmFyIHRhblBoaTAgPSB0YW4ocGhpMCk7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHJldHVybiBbbGFtYmRhLCAobGFtYmRhID8gbGFtYmRhIC8gc2luKGxhbWJkYSkgOiAxKSAqIChzaW4ocGhpKSAqIGNvcyhsYW1iZGEpIC0gdGFuUGhpMCAqIGNvcyhwaGkpKV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSB0YW5QaGkwID8gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIGlmICh4KVxuICAgICAgICAgICAgICAgIHkgKj0gc2luKHgpIC8geDtcbiAgICAgICAgICAgIHZhciBjb3NMYW1iZGEgPSBjb3MoeCk7XG4gICAgICAgICAgICByZXR1cm4gW3gsIDIgKiBhdGFuMihzcXJ0KGNvc0xhbWJkYSAqIGNvc0xhbWJkYSArIHRhblBoaTAgKiB0YW5QaGkwIC0geSAqIHkpIC0gY29zTGFtYmRhLCB0YW5QaGkwIC0geSldO1xuICAgICAgICB9IDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBbeCwgYXNpbih4ID8geSAqIHRhbih4KSAvIHggOiB5KV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICB2YXIgY3JhaWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbGxlbDEoY3JhaWdSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMjQ5LjgyOClcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoOTApO1xuICAgIH07XG4gICAgdmFyIHNxcnQzID0gc3FydCgzKTtcbiAgICBmdW5jdGlvbiBjcmFzdGVyUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJldHVybiBbc3FydDMgKiBsYW1iZGEgKiAoMiAqIGNvcygyICogcGhpIC8gMykgLSAxKSAvIHNxcnRQaSwgc3FydDMgKiBzcXJ0UGkgKiBzaW4ocGhpIC8gMyldO1xuICAgIH1cbiAgICBjcmFzdGVyUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBwaGkgPSAzICogYXNpbih5IC8gKHNxcnQzICogc3FydFBpKSk7XG4gICAgICAgIHJldHVybiBbc3FydFBpICogeCAvIChzcXJ0MyAqICgyICogY29zKDIgKiBwaGkgLyAzKSAtIDEpKSwgcGhpXTtcbiAgICB9O1xuICAgIHZhciBjcmFzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihjcmFzdGVyUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE1Ni4xOSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjeWxpbmRyaWNhbEVxdWFsQXJlYVJhdyhwaGkwKSB7XG4gICAgICAgIHZhciBjb3NQaGkwID0gY29zKHBoaTApO1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2xhbWJkYSAqIGNvc1BoaTAsIHNpbihwaGkpIC8gY29zUGhpMF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIFt4IC8gY29zUGhpMCwgYXNpbih5ICogY29zUGhpMCldO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9XG4gICAgdmFyIGN5bGluZHJpY2FsRXF1YWxBcmVhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGFyYWxsZWwxKGN5bGluZHJpY2FsRXF1YWxBcmVhUmF3KVxuICAgICAgICAgICAgLnBhcmFsbGVsKDM4LjU4KSAvLyBhY29zKHNxcnQod2lkdGggLyBoZWlnaHQgLyBwaSkpICogcmFkaWFuc1xuICAgICAgICAgICAgLnNjYWxlKDE5NS4wNDQpOyAvLyB3aWR0aCAvIChzcXJ0KHdpZHRoIC8gaGVpZ2h0IC8gcGkpICogMiAqIHBpKVxuICAgIH07XG4gICAgZnVuY3Rpb24gY3lsaW5kcmljYWxTdGVyZW9ncmFwaGljUmF3KHBoaTApIHtcbiAgICAgICAgdmFyIGNvc1BoaTAgPSBjb3MocGhpMCk7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHJldHVybiBbbGFtYmRhICogY29zUGhpMCwgKDEgKyBjb3NQaGkwKSAqIHRhbihwaGkgLyAyKV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIFt4IC8gY29zUGhpMCwgYXRhbih5IC8gKDEgKyBjb3NQaGkwKSkgKiAyXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIHZhciBjeWxpbmRyaWNhbFN0ZXJlb2dyYXBoaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbGxlbDEoY3lsaW5kcmljYWxTdGVyZW9ncmFwaGljUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDEyNC43NSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBlY2tlcnQxUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBhbHBoYSA9IHNxcnQoOCAvICgzICogcGkpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGFscGhhICogbGFtYmRhICogKDEgLSBhYnMocGhpKSAvIHBpKSxcbiAgICAgICAgICAgIGFscGhhICogcGhpXG4gICAgICAgIF07XG4gICAgfVxuICAgIGVja2VydDFSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIGFscGhhID0gc3FydCg4IC8gKDMgKiBwaSkpLCBwaGkgPSB5IC8gYWxwaGE7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB4IC8gKGFscGhhICogKDEgLSBhYnMocGhpKSAvIHBpKSksXG4gICAgICAgICAgICBwaGlcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIHZhciBlY2tlcnQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihlY2tlcnQxUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE2NS42NjQpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZWNrZXJ0MlJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgYWxwaGEgPSBzcXJ0KDQgLSAzICogc2luKGFicyhwaGkpKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAyIC8gc3FydCg2ICogcGkpICogbGFtYmRhICogYWxwaGEsXG4gICAgICAgICAgICBzaWduKHBoaSkgKiBzcXJ0KDIgKiBwaSAvIDMpICogKDIgLSBhbHBoYSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZWNrZXJ0MlJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgYWxwaGEgPSAyIC0gYWJzKHkpIC8gc3FydCgyICogcGkgLyAzKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHggKiBzcXJ0KDYgKiBwaSkgLyAoMiAqIGFscGhhKSxcbiAgICAgICAgICAgIHNpZ24oeSkgKiBhc2luKCg0IC0gYWxwaGEgKiBhbHBoYSkgLyAzKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIGVja2VydDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGVja2VydDJSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTY1LjY2NCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBlY2tlcnQzUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBrID0gc3FydChwaSAqICg0ICsgcGkpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDIgLyBrICogbGFtYmRhICogKDEgKyBzcXJ0KDEgLSA0ICogcGhpICogcGhpIC8gKHBpICogcGkpKSksXG4gICAgICAgICAgICA0IC8gayAqIHBoaVxuICAgICAgICBdO1xuICAgIH1cbiAgICBlY2tlcnQzUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBrID0gc3FydChwaSAqICg0ICsgcGkpKSAvIDI7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB4ICogayAvICgxICsgc3FydCgxIC0geSAqIHkgKiAoNCArIHBpKSAvICg0ICogcGkpKSksXG4gICAgICAgICAgICB5ICogayAvIDJcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIHZhciBlY2tlcnQzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihlY2tlcnQzUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE4MC43MzkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZWNrZXJ0NFJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgayA9ICgyICsgaGFsZlBpKSAqIHNpbihwaGkpO1xuICAgICAgICBwaGkgLz0gMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGRlbHRhID0gSW5maW5pdHk7IGkgPCAxMCAmJiBhYnMoZGVsdGEpID4gZXBzaWxvbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29zUGhpID0gY29zKHBoaSk7XG4gICAgICAgICAgICBwaGkgLT0gZGVsdGEgPSAocGhpICsgc2luKHBoaSkgKiAoY29zUGhpICsgMikgLSBrKSAvICgyICogY29zUGhpICogKDEgKyBjb3NQaGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMiAvIHNxcnQocGkgKiAoNCArIHBpKSkgKiBsYW1iZGEgKiAoMSArIGNvcyhwaGkpKSxcbiAgICAgICAgICAgIDIgKiBzcXJ0KHBpIC8gKDQgKyBwaSkpICogc2luKHBoaSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZWNrZXJ0NFJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgQSA9IHkgKiBzcXJ0KCg0ICsgcGkpIC8gcGkpIC8gMiwgayA9IGFzaW4oQSksIGMgPSBjb3Moayk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB4IC8gKDIgLyBzcXJ0KHBpICogKDQgKyBwaSkpICogKDEgKyBjKSksXG4gICAgICAgICAgICBhc2luKChrICsgQSAqIChjICsgMikpIC8gKDIgKyBoYWxmUGkpKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIGVja2VydDQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGVja2VydDRSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTgwLjczOSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBlY2tlcnQ1UmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsYW1iZGEgKiAoMSArIGNvcyhwaGkpKSAvIHNxcnQoMiArIHBpKSxcbiAgICAgICAgICAgIDIgKiBwaGkgLyBzcXJ0KDIgKyBwaSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZWNrZXJ0NVJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgayA9IHNxcnQoMiArIHBpKSwgcGhpID0geSAqIGsgLyAyO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgayAqIHggLyAoMSArIGNvcyhwaGkpKSxcbiAgICAgICAgICAgIHBoaVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIGVja2VydDUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGVja2VydDVSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTczLjA0NCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBlY2tlcnQ2UmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBrID0gKDEgKyBoYWxmUGkpICogc2luKHBoaSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBkZWx0YSA9IEluZmluaXR5OyBpIDwgMTAgJiYgYWJzKGRlbHRhKSA+IGVwc2lsb247IGkrKykge1xuICAgICAgICAgICAgcGhpIC09IGRlbHRhID0gKHBoaSArIHNpbihwaGkpIC0gaykgLyAoMSArIGNvcyhwaGkpKTtcbiAgICAgICAgfVxuICAgICAgICBrID0gc3FydCgyICsgcGkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbGFtYmRhICogKDEgKyBjb3MocGhpKSkgLyBrLFxuICAgICAgICAgICAgMiAqIHBoaSAvIGtcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZWNrZXJ0NlJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgaiA9IDEgKyBoYWxmUGksIGsgPSBzcXJ0KGogLyAyKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHggKiAyICogayAvICgxICsgY29zKHkgKj0gaykpLFxuICAgICAgICAgICAgYXNpbigoeSArIHNpbih5KSkgLyBqKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIGVja2VydDYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGVja2VydDZSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTczLjA0NCk7XG4gICAgfTtcbiAgICB2YXIgZWlzZW5sb2hySyA9IDMgKyAyICogc3FydDI7XG4gICAgZnVuY3Rpb24gZWlzZW5sb2hyUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBzMCA9IHNpbihsYW1iZGEgLz0gMiksIGMwID0gY29zKGxhbWJkYSksIGsgPSBzcXJ0KGNvcyhwaGkpKSwgYzEgPSBjb3MocGhpIC89IDIpLCB0ID0gc2luKHBoaSkgLyAoYzEgKyBzcXJ0MiAqIGMwICogayksIGMgPSBzcXJ0KDIgLyAoMSArIHQgKiB0KSksIHYgPSBzcXJ0KChzcXJ0MiAqIGMxICsgKGMwICsgczApICogaykgLyAoc3FydDIgKiBjMSArIChjMCAtIHMwKSAqIGspKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGVpc2VubG9ocksgKiAoYyAqICh2IC0gMSAvIHYpIC0gMiAqIGxvZyh2KSksXG4gICAgICAgICAgICBlaXNlbmxvaHJLICogKGMgKiB0ICogKHYgKyAxIC8gdikgLSAyICogYXRhbih0KSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZWlzZW5sb2hyUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmICghKHAgPSBhdWd1c3RSYXcuaW52ZXJ0KHggLyAxLjIsIHkgKiAxLjA2NSkpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBsYW1iZGEgPSBwWzBdLCBwaGkgPSBwWzFdLCBpID0gMjAsIHA7XG4gICAgICAgIHggLz0gZWlzZW5sb2hySywgeSAvPSBlaXNlbmxvaHJLO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgXzAgPSBsYW1iZGEgLyAyLCBfMSA9IHBoaSAvIDIsIHMwID0gc2luKF8wKSwgYzAgPSBjb3MoXzApLCBzMSA9IHNpbihfMSksIGMxID0gY29zKF8xKSwgY29zMSA9IGNvcyhwaGkpLCBrID0gc3FydChjb3MxKSwgdCA9IHMxIC8gKGMxICsgc3FydDIgKiBjMCAqIGspLCB0MiA9IHQgKiB0LCBjID0gc3FydCgyIC8gKDEgKyB0MikpLCB2MCA9IChzcXJ0MiAqIGMxICsgKGMwICsgczApICogayksIHYxID0gKHNxcnQyICogYzEgKyAoYzAgLSBzMCkgKiBrKSwgdjIgPSB2MCAvIHYxLCB2ID0gc3FydCh2MiksIHZtMXYgPSB2IC0gMSAvIHYsIHZwMXYgPSB2ICsgMSAvIHYsIGZ4ID0gYyAqIHZtMXYgLSAyICogbG9nKHYpIC0geCwgZnkgPSBjICogdCAqIHZwMXYgLSAyICogYXRhbih0KSAtIHksIGRlbHRhdERlbHRhTGFtYmRhID0gczEgJiYgc3FydDFfMiAqIGsgKiBzMCAqIHQyIC8gczEsIGRlbHRhdERlbHRhUGhpID0gKHNxcnQyICogYzAgKiBjMSArIGspIC8gKDIgKiAoYzEgKyBzcXJ0MiAqIGMwICogaykgKiAoYzEgKyBzcXJ0MiAqIGMwICogaykgKiBrKSwgZGVsdGFjRGVsdGF0ID0gLTAuNSAqIHQgKiBjICogYyAqIGMsIGRlbHRhY0RlbHRhTGFtYmRhID0gZGVsdGFjRGVsdGF0ICogZGVsdGF0RGVsdGFMYW1iZGEsIGRlbHRhY0RlbHRhUGhpID0gZGVsdGFjRGVsdGF0ICogZGVsdGF0RGVsdGFQaGksIEEgPSAoQSA9IDIgKiBjMSArIHNxcnQyICogayAqIChjMCAtIHMwKSkgKiBBICogdiwgZGVsdGF2RGVsdGFMYW1iZGEgPSAoc3FydDIgKiBjMCAqIGMxICogayArIGNvczEpIC8gQSwgZGVsdGF2RGVsdGFQaGkgPSAtKHNxcnQyICogczAgKiBzMSkgLyAoayAqIEEpLCBkZWx0YXhEZWx0YUxhbWJkYSA9IHZtMXYgKiBkZWx0YWNEZWx0YUxhbWJkYSAtIDIgKiBkZWx0YXZEZWx0YUxhbWJkYSAvIHYgKyBjICogKGRlbHRhdkRlbHRhTGFtYmRhICsgZGVsdGF2RGVsdGFMYW1iZGEgLyB2MiksIGRlbHRheERlbHRhUGhpID0gdm0xdiAqIGRlbHRhY0RlbHRhUGhpIC0gMiAqIGRlbHRhdkRlbHRhUGhpIC8gdiArIGMgKiAoZGVsdGF2RGVsdGFQaGkgKyBkZWx0YXZEZWx0YVBoaSAvIHYyKSwgZGVsdGF5RGVsdGFMYW1iZGEgPSB0ICogdnAxdiAqIGRlbHRhY0RlbHRhTGFtYmRhIC0gMiAqIGRlbHRhdERlbHRhTGFtYmRhIC8gKDEgKyB0MikgKyBjICogdnAxdiAqIGRlbHRhdERlbHRhTGFtYmRhICsgYyAqIHQgKiAoZGVsdGF2RGVsdGFMYW1iZGEgLSBkZWx0YXZEZWx0YUxhbWJkYSAvIHYyKSwgZGVsdGF5RGVsdGFQaGkgPSB0ICogdnAxdiAqIGRlbHRhY0RlbHRhUGhpIC0gMiAqIGRlbHRhdERlbHRhUGhpIC8gKDEgKyB0MikgKyBjICogdnAxdiAqIGRlbHRhdERlbHRhUGhpICsgYyAqIHQgKiAoZGVsdGF2RGVsdGFQaGkgLSBkZWx0YXZEZWx0YVBoaSAvIHYyKSwgZGVub21pbmF0b3IgPSBkZWx0YXhEZWx0YVBoaSAqIGRlbHRheURlbHRhTGFtYmRhIC0gZGVsdGF5RGVsdGFQaGkgKiBkZWx0YXhEZWx0YUxhbWJkYTtcbiAgICAgICAgICAgIGlmICghZGVub21pbmF0b3IpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgZGVsdGFMYW1iZGEgPSAoZnkgKiBkZWx0YXhEZWx0YVBoaSAtIGZ4ICogZGVsdGF5RGVsdGFQaGkpIC8gZGVub21pbmF0b3IsIGRlbHRhUGhpID0gKGZ4ICogZGVsdGF5RGVsdGFMYW1iZGEgLSBmeSAqIGRlbHRheERlbHRhTGFtYmRhKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgbGFtYmRhIC09IGRlbHRhTGFtYmRhO1xuICAgICAgICAgICAgcGhpID0gbWF4KC1oYWxmUGksIG1pbihoYWxmUGksIHBoaSAtIGRlbHRhUGhpKSk7XG4gICAgICAgIH0gd2hpbGUgKChhYnMoZGVsdGFMYW1iZGEpID4gZXBzaWxvbiB8fCBhYnMoZGVsdGFQaGkpID4gZXBzaWxvbikgJiYgLS1pID4gMCk7XG4gICAgICAgIHJldHVybiBhYnMoYWJzKHBoaSkgLSBoYWxmUGkpIDwgZXBzaWxvbiA/IFswLCBwaGldIDogaSAmJiBbbGFtYmRhLCBwaGldO1xuICAgIH07XG4gICAgdmFyIGVpc2VubG9ociA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oZWlzZW5sb2hyUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDYyLjUyNzEpO1xuICAgIH07XG4gICAgdmFyIGZhaGV5SyA9IGNvcygzNSAqIHJhZGlhbnMpO1xuICAgIGZ1bmN0aW9uIGZhaGV5UmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciB0ID0gdGFuKHBoaSAvIDIpO1xuICAgICAgICByZXR1cm4gW2xhbWJkYSAqIGZhaGV5SyAqIHNxcnQoMSAtIHQgKiB0KSwgKDEgKyBmYWhleUspICogdF07XG4gICAgfVxuICAgIGZhaGV5UmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciB0ID0geSAvICgxICsgZmFoZXlLKTtcbiAgICAgICAgcmV0dXJuIFt4ICYmIHggLyAoZmFoZXlLICogc3FydCgxIC0gdCAqIHQpKSwgMiAqIGF0YW4odCldO1xuICAgIH07XG4gICAgdmFyIGZhaGV5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihmYWhleVJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxMzcuMTUyKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGZvdWNhdXRSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIGsgPSBwaGkgLyAyLCBjb3NrID0gY29zKGspO1xuICAgICAgICByZXR1cm4gWzIgKiBsYW1iZGEgLyBzcXJ0UGkgKiBjb3MocGhpKSAqIGNvc2sgKiBjb3NrLCBzcXJ0UGkgKiB0YW4oayldO1xuICAgIH1cbiAgICBmb3VjYXV0UmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBrID0gYXRhbih5IC8gc3FydFBpKSwgY29zayA9IGNvcyhrKSwgcGhpID0gMiAqIGs7XG4gICAgICAgIHJldHVybiBbeCAqIHNxcnRQaSAvIDIgLyAoY29zKHBoaSkgKiBjb3NrICogY29zayksIHBoaV07XG4gICAgfTtcbiAgICB2YXIgZm91Y2F1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oZm91Y2F1dFJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxMzUuMjY0KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdpbGJlcnRGb3J3YXJkKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBbcG9pbnRbMF0gLyAyLCBhc2luKHRhbihwb2ludFsxXSAvIDIgKiByYWRpYW5zKSkgKiBkZWdyZWVzXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2lsYmVydEludmVydChwb2ludCkge1xuICAgICAgICByZXR1cm4gW3BvaW50WzBdICogMiwgMiAqIGF0YW4oc2luKHBvaW50WzFdICogcmFkaWFucykpICogZGVncmVlc107XG4gICAgfVxuICAgIHZhciBnaWxiZXJ0ID0gZnVuY3Rpb24gKHByb2plY3Rpb25UeXBlKSB7XG4gICAgICAgIGlmIChwcm9qZWN0aW9uVHlwZSA9PSBudWxsKVxuICAgICAgICAgICAgcHJvamVjdGlvblR5cGUgPSBkM0dlby5nZW9PcnRob2dyYXBoaWM7XG4gICAgICAgIHZhciBwcm9qZWN0aW9uID0gcHJvamVjdGlvblR5cGUoKSwgZXF1aXJlY3Rhbmd1bGFyID0gZDNHZW8uZ2VvRXF1aXJlY3Rhbmd1bGFyKCkuc2NhbGUoZGVncmVlcykucHJlY2lzaW9uKDApLmNsaXBBbmdsZShudWxsKS50cmFuc2xhdGUoWzAsIDBdKTsgLy8gYW50aW1lcmlkaWFuIGN1dHRpbmdcbiAgICAgICAgZnVuY3Rpb24gZ2lsYmVydChwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb2plY3Rpb24oZ2lsYmVydEZvcndhcmQocG9pbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvamVjdGlvbi5pbnZlcnQpXG4gICAgICAgICAgICBnaWxiZXJ0LmludmVydCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnaWxiZXJ0SW52ZXJ0KHByb2plY3Rpb24uaW52ZXJ0KHBvaW50KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBnaWxiZXJ0LnN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBzMSA9IHByb2plY3Rpb24uc3RyZWFtKHN0cmVhbSksIHMwID0gZXF1aXJlY3Rhbmd1bGFyLnN0cmVhbSh7XG4gICAgICAgICAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uIChsYW1iZGEsIHBoaSkgeyBzMS5wb2ludChsYW1iZGEgLyAyLCBhc2luKHRhbigtcGhpIC8gMiAqIHJhZGlhbnMpKSAqIGRlZ3JlZXMpOyB9LFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyBzMS5saW5lU3RhcnQoKTsgfSxcbiAgICAgICAgICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHMxLmxpbmVFbmQoKTsgfSxcbiAgICAgICAgICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgczEucG9seWdvblN0YXJ0KCk7IH0sXG4gICAgICAgICAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkgeyBzMS5wb2x5Z29uRW5kKCk7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgczAuc3BoZXJlID0gczEuc3BoZXJlO1xuICAgICAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBwcm9wZXJ0eShuYW1lKSB7XG4gICAgICAgICAgICBnaWxiZXJ0W25hbWVdID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcm9qZWN0aW9uW25hbWVdKF8pLCBnaWxiZXJ0KSA6IHByb2plY3Rpb25bbmFtZV0oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZ2lsYmVydC5yb3RhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXF1aXJlY3Rhbmd1bGFyLnJvdGF0ZShfKSwgZ2lsYmVydCkgOiBlcXVpcmVjdGFuZ3VsYXIucm90YXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGdpbGJlcnQuY2VudGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByb2plY3Rpb24uY2VudGVyKGdpbGJlcnRGb3J3YXJkKF8pKSwgZ2lsYmVydCkgOiBnaWxiZXJ0SW52ZXJ0KHByb2plY3Rpb24uY2VudGVyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBwcm9wZXJ0eShcImNsaXBBbmdsZVwiKTtcbiAgICAgICAgcHJvcGVydHkoXCJjbGlwRXh0ZW50XCIpO1xuICAgICAgICBwcm9wZXJ0eShcInNjYWxlXCIpO1xuICAgICAgICBwcm9wZXJ0eShcInRyYW5zbGF0ZVwiKTtcbiAgICAgICAgcHJvcGVydHkoXCJwcmVjaXNpb25cIik7XG4gICAgICAgIHJldHVybiBnaWxiZXJ0XG4gICAgICAgICAgICAuc2NhbGUoMjQ5LjUpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZ2luZ2VyeVJhdyhyaG8sIG4pIHtcbiAgICAgICAgdmFyIGsgPSAyICogcGkgLyBuLCByaG8yID0gcmhvICogcmhvO1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGQzR2VvLmdlb0F6aW11dGhhbEVxdWlkaXN0YW50UmF3KGxhbWJkYSwgcGhpKSwgeCA9IHBbMF0sIHkgPSBwWzFdLCByMiA9IHggKiB4ICsgeSAqIHk7XG4gICAgICAgICAgICBpZiAocjIgPiByaG8yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBzcXJ0KHIyKSwgdGhldGEgPSBhdGFuMih5LCB4KSwgdGhldGEwID0gayAqIHJvdW5kKHRoZXRhIC8gayksIGFscGhhID0gdGhldGEgLSB0aGV0YTAsIHJob0Nvc0FscGhhID0gcmhvICogY29zKGFscGhhKSwga18gPSAocmhvICogc2luKGFscGhhKSAtIGFscGhhICogc2luKHJob0Nvc0FscGhhKSkgLyAoaGFsZlBpIC0gcmhvQ29zQWxwaGEpLCBzXyA9IGdpbmdlcnlMZW5ndGgoYWxwaGEsIGtfKSwgZSA9IChwaSAtIHJobykgLyBnaW5nZXJ5SW50ZWdyYXRlKHNfLCByaG9Db3NBbHBoYSwgcGkpO1xuICAgICAgICAgICAgICAgIHggPSByO1xuICAgICAgICAgICAgICAgIHZhciBpID0gNTAsIGRlbHRhO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgeCAtPSBkZWx0YSA9IChyaG8gKyBnaW5nZXJ5SW50ZWdyYXRlKHNfLCByaG9Db3NBbHBoYSwgeCkgKiBlIC0gcikgLyAoc18oeCkgKiBlKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChhYnMoZGVsdGEpID4gZXBzaWxvbiAmJiAtLWkgPiAwKTtcbiAgICAgICAgICAgICAgICB5ID0gYWxwaGEgKiBzaW4oeCk7XG4gICAgICAgICAgICAgICAgaWYgKHggPCBoYWxmUGkpXG4gICAgICAgICAgICAgICAgICAgIHkgLT0ga18gKiAoeCAtIGhhbGZQaSk7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzaW4odGhldGEwKSwgYyA9IGNvcyh0aGV0YTApO1xuICAgICAgICAgICAgICAgIHBbMF0gPSB4ICogYyAtIHkgKiBzO1xuICAgICAgICAgICAgICAgIHBbMV0gPSB4ICogcyArIHkgKiBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHIyID0geCAqIHggKyB5ICogeTtcbiAgICAgICAgICAgIGlmIChyMiA+IHJobzIpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHNxcnQocjIpLCB0aGV0YSA9IGF0YW4yKHksIHgpLCB0aGV0YTAgPSBrICogcm91bmQodGhldGEgLyBrKSwgZFRoZXRhID0gdGhldGEgLSB0aGV0YTA7XG4gICAgICAgICAgICAgICAgeCA9IHIgKiBjb3MoZFRoZXRhKTtcbiAgICAgICAgICAgICAgICB5ID0gciAqIHNpbihkVGhldGEpO1xuICAgICAgICAgICAgICAgIHZhciB4X2hhbGZQaSA9IHggLSBoYWxmUGksIHNpbnggPSBzaW4oeCksIGFscGhhID0geSAvIHNpbngsIGRlbHRhID0geCA8IGhhbGZQaSA/IEluZmluaXR5IDogMCwgaSA9IDEwO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByaG9zaW5BbHBoYSA9IHJobyAqIHNpbihhbHBoYSksIHJob0Nvc0FscGhhID0gcmhvICogY29zKGFscGhhKSwgc2luUmhvQ29zQWxwaGEgPSBzaW4ocmhvQ29zQWxwaGEpLCBoYWxmUGlfUmhvQ29zQWxwaGEgPSBoYWxmUGkgLSByaG9Db3NBbHBoYSwga18gPSAocmhvc2luQWxwaGEgLSBhbHBoYSAqIHNpblJob0Nvc0FscGhhKSAvIGhhbGZQaV9SaG9Db3NBbHBoYSwgc18gPSBnaW5nZXJ5TGVuZ3RoKGFscGhhLCBrXyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYnMoZGVsdGEpIDwgZXBzaWxvbjIgfHwgIS0taSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBhbHBoYSAtPSBkZWx0YSA9IChhbHBoYSAqIHNpbnggLSBrXyAqIHhfaGFsZlBpIC0geSkgLyAoc2lueCAtIHhfaGFsZlBpICogMiAqIChoYWxmUGlfUmhvQ29zQWxwaGEgKiAocmhvQ29zQWxwaGEgKyBhbHBoYSAqIHJob3NpbkFscGhhICogY29zKHJob0Nvc0FscGhhKSAtIHNpblJob0Nvc0FscGhhKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICByaG9zaW5BbHBoYSAqIChyaG9zaW5BbHBoYSAtIGFscGhhICogc2luUmhvQ29zQWxwaGEpKSAvIChoYWxmUGlfUmhvQ29zQWxwaGEgKiBoYWxmUGlfUmhvQ29zQWxwaGEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgciA9IHJobyArIGdpbmdlcnlJbnRlZ3JhdGUoc18sIHJob0Nvc0FscGhhLCB4KSAqIChwaSAtIHJobykgLyBnaW5nZXJ5SW50ZWdyYXRlKHNfLCByaG9Db3NBbHBoYSwgcGkpO1xuICAgICAgICAgICAgICAgIHRoZXRhID0gdGhldGEwICsgYWxwaGE7XG4gICAgICAgICAgICAgICAgeCA9IHIgKiBjb3ModGhldGEpO1xuICAgICAgICAgICAgICAgIHkgPSByICogc2luKHRoZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkM0dlby5nZW9BemltdXRoYWxFcXVpZGlzdGFudFJhdy5pbnZlcnQoeCwgeSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnaW5nZXJ5TGVuZ3RoKGFscGhhLCBrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgdmFyIHlfID0gYWxwaGEgKiBjb3MoeCk7XG4gICAgICAgICAgICBpZiAoeCA8IGhhbGZQaSlcbiAgICAgICAgICAgICAgICB5XyAtPSBrO1xuICAgICAgICAgICAgcmV0dXJuIHNxcnQoMSArIHlfICogeV8pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBOdW1lcmljYWwgaW50ZWdyYXRpb246IHRyYXBlem9pZGFsIHJ1bGUuXG4gICAgZnVuY3Rpb24gZ2luZ2VyeUludGVncmF0ZShmLCBhLCBiKSB7XG4gICAgICAgIHZhciBuID0gNTAsIGggPSAoYiAtIGEpIC8gbiwgcyA9IGYoYSkgKyBmKGIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgeCA9IGE7IGkgPCBuOyArK2kpXG4gICAgICAgICAgICBzICs9IDIgKiBmKHggKz0gaCk7XG4gICAgICAgIHJldHVybiBzICogMC41ICogaDtcbiAgICB9XG4gICAgdmFyIGdpbmdlcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuID0gNiwgcmhvID0gMzAgKiByYWRpYW5zLCBjUmhvID0gY29zKHJobyksIHNSaG8gPSBzaW4ocmhvKSwgbSA9IGQzR2VvLmdlb1Byb2plY3Rpb25NdXRhdG9yKGdpbmdlcnlSYXcpLCBwID0gbShyaG8sIG4pLCBzdHJlYW1fID0gcC5zdHJlYW0sIGVwc2lsb24kJDEgPSAxZS0yLCBjciA9IC1jb3MoZXBzaWxvbiQkMSAqIHJhZGlhbnMpLCBzciA9IHNpbihlcHNpbG9uJCQxICogcmFkaWFucyk7XG4gICAgICAgIHAucmFkaXVzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmhvICogZGVncmVlcztcbiAgICAgICAgICAgIGNSaG8gPSBjb3MocmhvID0gXyAqIHJhZGlhbnMpO1xuICAgICAgICAgICAgc1JobyA9IHNpbihyaG8pO1xuICAgICAgICAgICAgcmV0dXJuIG0ocmhvLCBuKTtcbiAgICAgICAgfTtcbiAgICAgICAgcC5sb2JlcyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICByZXR1cm4gbShyaG8sIG4gPSArXyk7XG4gICAgICAgIH07XG4gICAgICAgIHAuc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIHJvdGF0ZSA9IHAucm90YXRlKCksIHJvdGF0ZVN0cmVhbSA9IHN0cmVhbV8oc3RyZWFtKSwgc3BoZXJlU3RyZWFtID0gKHAucm90YXRlKFswLCAwXSksIHN0cmVhbV8oc3RyZWFtKSk7XG4gICAgICAgICAgICBwLnJvdGF0ZShyb3RhdGUpO1xuICAgICAgICAgICAgcm90YXRlU3RyZWFtLnNwaGVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ucG9seWdvblN0YXJ0KCksIHNwaGVyZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZGVsdGEgPSAyICogcGkgLyBuLCBwaGkgPSAwOyBpIDwgbjsgKytpLCBwaGkgLT0gZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BoZXJlU3RyZWFtLnBvaW50KGF0YW4yKHNyICogY29zKHBoaSksIGNyKSAqIGRlZ3JlZXMsIGFzaW4oc3IgKiBzaW4ocGhpKSkgKiBkZWdyZWVzKTtcbiAgICAgICAgICAgICAgICAgICAgc3BoZXJlU3RyZWFtLnBvaW50KGF0YW4yKHNSaG8gKiBjb3MocGhpIC0gZGVsdGEgLyAyKSwgY1JobykgKiBkZWdyZWVzLCBhc2luKHNSaG8gKiBzaW4ocGhpIC0gZGVsdGEgLyAyKSkgKiBkZWdyZWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3BoZXJlU3RyZWFtLmxpbmVFbmQoKSwgc3BoZXJlU3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcm90YXRlU3RyZWFtO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcFxuICAgICAgICAgICAgLnJvdGF0ZShbOTAsIC00MF0pXG4gICAgICAgICAgICAuc2NhbGUoOTEuNzA5NSlcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoMTgwIC0gMWUtMyk7XG4gICAgfTtcbiAgICB2YXIgZ2luemJ1cmdQb2x5Y29uaWNSYXcgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDgpXG4gICAgICAgICAgICBoID0gMDtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgaWYgKCFwaGkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFthICogbGFtYmRhIC8gcGksIDBdO1xuICAgICAgICAgICAgdmFyIHBoaTIgPSBwaGkgKiBwaGksIHhCID0gYSArIHBoaTIgKiAoYiArIHBoaTIgKiAoYyArIHBoaTIgKiBkKSksIHlCID0gcGhpICogKGUgLSAxICsgcGhpMiAqIChmIC0gaCArIHBoaTIgKiBnKSksIG0gPSAoeEIgKiB4QiArIHlCICogeUIpIC8gKDIgKiB5QiksIGFscGhhID0gbGFtYmRhICogYXNpbih4QiAvIG0pIC8gcGk7XG4gICAgICAgICAgICByZXR1cm4gW20gKiBzaW4oYWxwaGEpLCBwaGkgKiAoMSArIHBoaTIgKiBoKSArIG0gKiAoMSAtIGNvcyhhbHBoYSkpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgbGFtYmRhID0gcGkgKiB4IC8gYSwgcGhpID0geSwgZGVsdGFMYW1iZGEsIGRlbHRhUGhpLCBpID0gNTA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIHBoaTIgPSBwaGkgKiBwaGksIHhCID0gYSArIHBoaTIgKiAoYiArIHBoaTIgKiAoYyArIHBoaTIgKiBkKSksIHlCID0gcGhpICogKGUgLSAxICsgcGhpMiAqIChmIC0gaCArIHBoaTIgKiBnKSksIHAgPSB4QiAqIHhCICsgeUIgKiB5QiwgcSA9IDIgKiB5QiwgbSA9IHAgLyBxLCBtMiA9IG0gKiBtLCBkQWxwaGFkTGFtYmRhID0gYXNpbih4QiAvIG0pIC8gcGksIGFscGhhID0gbGFtYmRhICogZEFscGhhZExhbWJkYSwgeEIyID0geEIgKiB4QiwgZHhCZFBoaSA9ICgyICogYiArIHBoaTIgKiAoNCAqIGMgKyBwaGkyICogNiAqIGQpKSAqIHBoaSwgZHlCZFBoaSA9IGUgKyBwaGkyICogKDMgKiBmICsgcGhpMiAqIDUgKiBnKSwgZHBkUGhpID0gMiAqICh4QiAqIGR4QmRQaGkgKyB5QiAqIChkeUJkUGhpIC0gMSkpLCBkcWRQaGkgPSAyICogKGR5QmRQaGkgLSAxKSwgZG1kUGhpID0gKGRwZFBoaSAqIHEgLSBwICogZHFkUGhpKSAvIChxICogcSksIGNvc0FscGhhID0gY29zKGFscGhhKSwgc2luQWxwaGEgPSBzaW4oYWxwaGEpLCBtY29zQWxwaGEgPSBtICogY29zQWxwaGEsIG1zaW5BbHBoYSA9IG0gKiBzaW5BbHBoYSwgZEFscGhhZFBoaSA9ICgobGFtYmRhIC8gcGkpICogKDEgLyBzcXJ0KDEgLSB4QjIgLyBtMikpICogKGR4QmRQaGkgKiBtIC0geEIgKiBkbWRQaGkpKSAvIG0yLCBmeCA9IG1zaW5BbHBoYSAtIHgsIGZ5ID0gcGhpICogKDEgKyBwaGkyICogaCkgKyBtIC0gbWNvc0FscGhhIC0geSwgZGVsdGF4RGVsdGFQaGkgPSBkbWRQaGkgKiBzaW5BbHBoYSArIG1jb3NBbHBoYSAqIGRBbHBoYWRQaGksIGRlbHRheERlbHRhTGFtYmRhID0gbWNvc0FscGhhICogZEFscGhhZExhbWJkYSwgZGVsdGF5RGVsdGFQaGkgPSAxICsgZG1kUGhpIC0gKGRtZFBoaSAqIGNvc0FscGhhIC0gbXNpbkFscGhhICogZEFscGhhZFBoaSksIGRlbHRheURlbHRhTGFtYmRhID0gbXNpbkFscGhhICogZEFscGhhZExhbWJkYSwgZGVub21pbmF0b3IgPSBkZWx0YXhEZWx0YVBoaSAqIGRlbHRheURlbHRhTGFtYmRhIC0gZGVsdGF5RGVsdGFQaGkgKiBkZWx0YXhEZWx0YUxhbWJkYTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlbm9taW5hdG9yKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsYW1iZGEgLT0gZGVsdGFMYW1iZGEgPSAoZnkgKiBkZWx0YXhEZWx0YVBoaSAtIGZ4ICogZGVsdGF5RGVsdGFQaGkpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICAgICAgcGhpIC09IGRlbHRhUGhpID0gKGZ4ICogZGVsdGF5RGVsdGFMYW1iZGEgLSBmeSAqIGRlbHRheERlbHRhTGFtYmRhKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgfSB3aGlsZSAoKGFicyhkZWx0YUxhbWJkYSkgPiBlcHNpbG9uIHx8IGFicyhkZWx0YVBoaSkgPiBlcHNpbG9uKSAmJiAtLWkgPiAwKTtcbiAgICAgICAgICAgIHJldHVybiBbbGFtYmRhLCBwaGldO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9O1xuICAgIHZhciBnaW56YnVyZzRSYXcgPSBnaW56YnVyZ1BvbHljb25pY1JhdygyLjgyODQsIC0xLjY5ODgsIDAuNzU0MzIsIC0wLjE4MDcxLCAxLjc2MDAzLCAtMC4zODkxNCwgMC4wNDI1NTUpO1xuICAgIHZhciBnaW56YnVyZzQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGdpbnpidXJnNFJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNDkuOTk1KTtcbiAgICB9O1xuICAgIHZhciBnaW56YnVyZzVSYXcgPSBnaW56YnVyZ1BvbHljb25pY1JhdygyLjU4MzgxOSwgLTAuODM1ODI3LCAwLjE3MDM1NCwgLTAuMDM4MDk0LCAxLjU0MzMxMywgLTAuNDExNDM1LCAwLjA4Mjc0Mik7XG4gICAgdmFyIGdpbnpidXJnNSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oZ2luemJ1cmc1UmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE1My45Myk7XG4gICAgfTtcbiAgICB2YXIgZ2luemJ1cmc2UmF3ID0gZ2luemJ1cmdQb2x5Y29uaWNSYXcoNSAvIDYgKiBwaSwgLTAuNjI2MzYsIC0wLjAzNDQsIDAsIDEuMzQ5MywgLTAuMDU1MjQsIDAsIDAuMDQ1KTtcbiAgICB2YXIgZ2luemJ1cmc2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihnaW56YnVyZzZSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTMwLjk0NSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBnaW56YnVyZzhSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIGxhbWJkYTIgPSBsYW1iZGEgKiBsYW1iZGEsIHBoaTIgPSBwaGkgKiBwaGk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsYW1iZGEgKiAoMSAtIDAuMTYyMzg4ICogcGhpMikgKiAoMC44NyAtIDAuMDAwOTUyNDI2ICogbGFtYmRhMiAqIGxhbWJkYTIpLFxuICAgICAgICAgICAgcGhpICogKDEgKyBwaGkyIC8gMTIpXG4gICAgICAgIF07XG4gICAgfVxuICAgIGdpbnpidXJnOFJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgbGFtYmRhID0geCwgcGhpID0geSwgaSA9IDUwLCBkZWx0YTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIHBoaTIgPSBwaGkgKiBwaGk7XG4gICAgICAgICAgICBwaGkgLT0gZGVsdGEgPSAocGhpICogKDEgKyBwaGkyIC8gMTIpIC0geSkgLyAoMSArIHBoaTIgLyA0KTtcbiAgICAgICAgfSB3aGlsZSAoYWJzKGRlbHRhKSA+IGVwc2lsb24gJiYgLS1pID4gMCk7XG4gICAgICAgIGkgPSA1MDtcbiAgICAgICAgeCAvPSAxIC0gMC4xNjIzODggKiBwaGkyO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgbGFtYmRhNCA9IChsYW1iZGE0ID0gbGFtYmRhICogbGFtYmRhKSAqIGxhbWJkYTQ7XG4gICAgICAgICAgICBsYW1iZGEgLT0gZGVsdGEgPSAobGFtYmRhICogKDAuODcgLSAwLjAwMDk1MjQyNiAqIGxhbWJkYTQpIC0geCkgLyAoMC44NyAtIDAuMDA0NzYyMTMgKiBsYW1iZGE0KTtcbiAgICAgICAgfSB3aGlsZSAoYWJzKGRlbHRhKSA+IGVwc2lsb24gJiYgLS1pID4gMCk7XG4gICAgICAgIHJldHVybiBbbGFtYmRhLCBwaGldO1xuICAgIH07XG4gICAgdmFyIGdpbnpidXJnOCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oZ2luemJ1cmc4UmF3KVxuICAgICAgICAgICAgLnNjYWxlKDEzMS43NDcpO1xuICAgIH07XG4gICAgdmFyIGdpbnpidXJnOVJhdyA9IGdpbnpidXJnUG9seWNvbmljUmF3KDIuNjUxNiwgLTAuNzY1MzQsIDAuMTkxMjMsIC0wLjA0NzA5NCwgMS4zNjI4OSwgLTAuMTM5NjUsIDAuMDMxNzYyKTtcbiAgICB2YXIgZ2luemJ1cmc5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihnaW56YnVyZzlSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTMxLjA4Nyk7XG4gICAgfTtcbiAgICB2YXIgc3F1YXJlUmF3ID0gZnVuY3Rpb24gKHByb2plY3QpIHtcbiAgICAgICAgdmFyIGR4ID0gcHJvamVjdChoYWxmUGksIDApWzBdIC0gcHJvamVjdCgtaGFsZlBpLCAwKVswXTtcbiAgICAgICAgZnVuY3Rpb24gcHJvamVjdFNxdWFyZShsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIHMgPSBsYW1iZGEgPiAwID8gLTAuNSA6IDAuNSwgcG9pbnQgPSBwcm9qZWN0KGxhbWJkYSArIHMgKiBwaSwgcGhpKTtcbiAgICAgICAgICAgIHBvaW50WzBdIC09IHMgKiBkeDtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvamVjdC5pbnZlcnQpXG4gICAgICAgICAgICBwcm9qZWN0U3F1YXJlLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSB4ID4gMCA/IC0wLjUgOiAwLjUsIGxvY2F0aW9uID0gcHJvamVjdC5pbnZlcnQoeCArIHMgKiBkeCwgeSksIGxhbWJkYSA9IGxvY2F0aW9uWzBdIC0gcyAqIHBpO1xuICAgICAgICAgICAgICAgIGlmIChsYW1iZGEgPCAtcGkpXG4gICAgICAgICAgICAgICAgICAgIGxhbWJkYSArPSAyICogcGk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGFtYmRhID4gcGkpXG4gICAgICAgICAgICAgICAgICAgIGxhbWJkYSAtPSAyICogcGk7XG4gICAgICAgICAgICAgICAgbG9jYXRpb25bMF0gPSBsYW1iZGE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByb2plY3RTcXVhcmU7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBncmluZ29ydGVuUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBzTGFtYmRhID0gc2lnbihsYW1iZGEpLCBzUGhpID0gc2lnbihwaGkpLCBjb3NQaGkgPSBjb3MocGhpKSwgeCA9IGNvcyhsYW1iZGEpICogY29zUGhpLCB5ID0gc2luKGxhbWJkYSkgKiBjb3NQaGksIHogPSBzaW4oc1BoaSAqIHBoaSk7XG4gICAgICAgIGxhbWJkYSA9IGFicyhhdGFuMih5LCB6KSk7XG4gICAgICAgIHBoaSA9IGFzaW4oeCk7XG4gICAgICAgIGlmIChhYnMobGFtYmRhIC0gaGFsZlBpKSA+IGVwc2lsb24pXG4gICAgICAgICAgICBsYW1iZGEgJT0gaGFsZlBpO1xuICAgICAgICB2YXIgcG9pbnQgPSBncmluZ29ydGVuSGV4YWRlY2FudChsYW1iZGEgPiBwaSAvIDQgPyBoYWxmUGkgLSBsYW1iZGEgOiBsYW1iZGEsIHBoaSk7XG4gICAgICAgIGlmIChsYW1iZGEgPiBwaSAvIDQpXG4gICAgICAgICAgICB6ID0gcG9pbnRbMF0sIHBvaW50WzBdID0gLXBvaW50WzFdLCBwb2ludFsxXSA9IC16O1xuICAgICAgICByZXR1cm4gKHBvaW50WzBdICo9IHNMYW1iZGEsIHBvaW50WzFdICo9IC1zUGhpLCBwb2ludCk7XG4gICAgfVxuICAgIGdyaW5nb3J0ZW5SYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgaWYgKGFicyh4KSA+IDEpXG4gICAgICAgICAgICB4ID0gc2lnbih4KSAqIDIgLSB4O1xuICAgICAgICBpZiAoYWJzKHkpID4gMSlcbiAgICAgICAgICAgIHkgPSBzaWduKHkpICogMiAtIHk7XG4gICAgICAgIHZhciBzeCA9IHNpZ24oeCksIHN5ID0gc2lnbih5KSwgeDAgPSAtc3ggKiB4LCB5MCA9IC1zeSAqIHksIHQgPSB5MCAvIHgwIDwgMSwgcCA9IGdyaW5nb3J0ZW5IZXhhZGVjYW50SW52ZXJ0KHQgPyB5MCA6IHgwLCB0ID8geDAgOiB5MCksIGxhbWJkYSA9IHBbMF0sIHBoaSA9IHBbMV0sIGNvc1BoaSA9IGNvcyhwaGkpO1xuICAgICAgICBpZiAodClcbiAgICAgICAgICAgIGxhbWJkYSA9IC1oYWxmUGkgLSBsYW1iZGE7XG4gICAgICAgIHJldHVybiBbc3ggKiAoYXRhbjIoc2luKGxhbWJkYSkgKiBjb3NQaGksIC1zaW4ocGhpKSkgKyBwaSksIHN5ICogYXNpbihjb3MobGFtYmRhKSAqIGNvc1BoaSldO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZ3JpbmdvcnRlbkhleGFkZWNhbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgaWYgKHBoaSA9PT0gaGFsZlBpKVxuICAgICAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICAgICAgdmFyIHNpblBoaSA9IHNpbihwaGkpLCByID0gc2luUGhpICogc2luUGhpLCByMiA9IHIgKiByLCBqID0gMSArIHIyLCBrID0gMSArIDMgKiByMiwgcSA9IDEgLSByMiwgeiA9IGFzaW4oMSAvIHNxcnQoaikpLCB2ID0gcSArIHIgKiBqICogeiwgcDIgPSAoMSAtIHNpblBoaSkgLyB2LCBwID0gc3FydChwMiksIGEyID0gcDIgKiBqLCBhID0gc3FydChhMiksIGggPSBwICogcSwgeCwgaTtcbiAgICAgICAgaWYgKGxhbWJkYSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBbMCwgLShoICsgciAqIGEpXTtcbiAgICAgICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLCBzZWNQaGkgPSAxIC8gY29zUGhpLCBkcmRQaGkgPSAyICogc2luUGhpICogY29zUGhpLCBkdmRQaGkgPSAoLTMgKiByICsgeiAqIGspICogZHJkUGhpLCBkcDJkUGhpID0gKC12ICogY29zUGhpIC0gKDEgLSBzaW5QaGkpICogZHZkUGhpKSAvICh2ICogdiksIGRwZFBoaSA9ICgwLjUgKiBkcDJkUGhpKSAvIHAsIGRoZFBoaSA9IHEgKiBkcGRQaGkgLSAyICogciAqIHAgKiBkcmRQaGksIGRyYTJkUGhpID0gciAqIGogKiBkcDJkUGhpICsgcDIgKiBrICogZHJkUGhpLCBtdSA9IC1zZWNQaGkgKiBkcmRQaGksIG51ID0gLXNlY1BoaSAqIGRyYTJkUGhpLCB6ZXRhID0gLTIgKiBzZWNQaGkgKiBkaGRQaGksIGxhbWJkYTEgPSA0ICogbGFtYmRhIC8gcGksIGRlbHRhO1xuICAgICAgICAvLyBTbG93ZXIgYnV0IGFjY3VyYXRlIGJpc2VjdGlvbiBtZXRob2QuXG4gICAgICAgIGlmIChsYW1iZGEgPiAwLjIyMiAqIHBpIHx8IHBoaSA8IHBpIC8gNCAmJiBsYW1iZGEgPiAwLjE3NSAqIHBpKSB7XG4gICAgICAgICAgICB4ID0gKGggKyByICogc3FydChhMiAqICgxICsgcjIpIC0gaCAqIGgpKSAvICgxICsgcjIpO1xuICAgICAgICAgICAgaWYgKGxhbWJkYSA+IHBpIC8gNClcbiAgICAgICAgICAgICAgICByZXR1cm4gW3gsIHhdO1xuICAgICAgICAgICAgdmFyIHgxID0geCwgeDAgPSAwLjUgKiB4O1xuICAgICAgICAgICAgeCA9IDAuNSAqICh4MCArIHgxKSwgaSA9IDUwO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciBnID0gc3FydChhMiAtIHggKiB4KSwgZiA9ICh4ICogKHpldGEgKyBtdSAqIGcpICsgbnUgKiBhc2luKHggLyBhKSkgLSBsYW1iZGExO1xuICAgICAgICAgICAgICAgIGlmICghZilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGYgPCAwKVxuICAgICAgICAgICAgICAgICAgICB4MCA9IHg7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB4MSA9IHg7XG4gICAgICAgICAgICAgICAgeCA9IDAuNSAqICh4MCArIHgxKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGFicyh4MSAtIHgwKSA+IGVwc2lsb24gJiYgLS1pID4gMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV3dG9uLVJhcGhzb24uXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeCA9IGVwc2lsb24sIGkgPSAyNTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgeDIgPSB4ICogeCwgZzIgPSBzcXJ0KGEyIC0geDIpLCB6ZXRhTXVnID0gemV0YSArIG11ICogZzIsIGYyID0geCAqIHpldGFNdWcgKyBudSAqIGFzaW4oeCAvIGEpIC0gbGFtYmRhMSwgZGYgPSB6ZXRhTXVnICsgKG51IC0gbXUgKiB4MikgLyBnMjtcbiAgICAgICAgICAgICAgICB4IC09IGRlbHRhID0gZzIgPyBmMiAvIGRmIDogMDtcbiAgICAgICAgICAgIH0gd2hpbGUgKGFicyhkZWx0YSkgPiBlcHNpbG9uICYmIC0taSA+IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgLWggLSByICogc3FydChhMiAtIHggKiB4KV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdyaW5nb3J0ZW5IZXhhZGVjYW50SW52ZXJ0KHgsIHkpIHtcbiAgICAgICAgdmFyIHgwID0gMCwgeDEgPSAxLCByID0gMC41LCBpID0gNTA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgcjIgPSByICogciwgc2luUGhpID0gc3FydChyKSwgeiA9IGFzaW4oMSAvIHNxcnQoMSArIHIyKSksIHYgPSAoMSAtIHIyKSArIHIgKiAoMSArIHIyKSAqIHosIHAyID0gKDEgLSBzaW5QaGkpIC8gdiwgcCA9IHNxcnQocDIpLCBhMiA9IHAyICogKDEgKyByMiksIGggPSBwICogKDEgLSByMiksIGcyID0gYTIgLSB4ICogeCwgZyA9IHNxcnQoZzIpLCB5MCA9IHkgKyBoICsgciAqIGc7XG4gICAgICAgICAgICBpZiAoYWJzKHgxIC0geDApIDwgZXBzaWxvbjIgfHwgLS1pID09PSAwIHx8IHkwID09PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHkwID4gMClcbiAgICAgICAgICAgICAgICB4MCA9IHI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgeDEgPSByO1xuICAgICAgICAgICAgciA9IDAuNSAqICh4MCArIHgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHBoaSA9IGFzaW4oc2luUGhpKSwgY29zUGhpID0gY29zKHBoaSksIHNlY1BoaSA9IDEgLyBjb3NQaGksIGRyZFBoaSA9IDIgKiBzaW5QaGkgKiBjb3NQaGksIGR2ZFBoaSA9ICgtMyAqIHIgKyB6ICogKDEgKyAzICogcjIpKSAqIGRyZFBoaSwgZHAyZFBoaSA9ICgtdiAqIGNvc1BoaSAtICgxIC0gc2luUGhpKSAqIGR2ZFBoaSkgLyAodiAqIHYpLCBkcGRQaGkgPSAwLjUgKiBkcDJkUGhpIC8gcCwgZGhkUGhpID0gKDEgLSByMikgKiBkcGRQaGkgLSAyICogciAqIHAgKiBkcmRQaGksIHpldGEgPSAtMiAqIHNlY1BoaSAqIGRoZFBoaSwgbXUgPSAtc2VjUGhpICogZHJkUGhpLCBudSA9IC1zZWNQaGkgKiAociAqICgxICsgcjIpICogZHAyZFBoaSArIHAyICogKDEgKyAzICogcjIpICogZHJkUGhpKTtcbiAgICAgICAgcmV0dXJuIFtwaSAvIDQgKiAoeCAqICh6ZXRhICsgbXUgKiBnKSArIG51ICogYXNpbih4IC8gc3FydChhMikpKSwgcGhpXTtcbiAgICB9XG4gICAgdmFyIGdyaW5nb3J0ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKHNxdWFyZVJhdyhncmluZ29ydGVuUmF3KSlcbiAgICAgICAgICAgIC5zY2FsZSgyMzkuNzUpO1xuICAgIH07XG4gICAgLy8gUmV0dXJucyBbc24sIGNuLCBkbl0odSArIGl2fG0pLlxuICAgIGZ1bmN0aW9uIGVsbGlwdGljSmkodSwgdiwgbSkge1xuICAgICAgICB2YXIgYSwgYiwgYztcbiAgICAgICAgaWYgKCF1KSB7XG4gICAgICAgICAgICBiID0gZWxsaXB0aWNKKHYsIDEgLSBtKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgWzAsIGJbMF0gLyBiWzFdXSxcbiAgICAgICAgICAgICAgICBbMSAvIGJbMV0sIDBdLFxuICAgICAgICAgICAgICAgIFtiWzJdIC8gYlsxXSwgMF1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGVsbGlwdGljSih1LCBtKTtcbiAgICAgICAgaWYgKCF2KVxuICAgICAgICAgICAgcmV0dXJuIFtbYVswXSwgMF0sIFthWzFdLCAwXSwgW2FbMl0sIDBdXTtcbiAgICAgICAgYiA9IGVsbGlwdGljSih2LCAxIC0gbSk7XG4gICAgICAgIGMgPSBiWzFdICogYlsxXSArIG0gKiBhWzBdICogYVswXSAqIGJbMF0gKiBiWzBdO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgW2FbMF0gKiBiWzJdIC8gYywgYVsxXSAqIGFbMl0gKiBiWzBdICogYlsxXSAvIGNdLFxuICAgICAgICAgICAgW2FbMV0gKiBiWzFdIC8gYywgLWFbMF0gKiBhWzJdICogYlswXSAqIGJbMl0gLyBjXSxcbiAgICAgICAgICAgIFthWzJdICogYlsxXSAqIGJbMl0gLyBjLCAtbSAqIGFbMF0gKiBhWzFdICogYlswXSAvIGNdXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8vIFJldHVybnMgW3NuLCBjbiwgZG4sIHBoXSh1fG0pLlxuICAgIGZ1bmN0aW9uIGVsbGlwdGljSih1LCBtKSB7XG4gICAgICAgIHZhciBhaSwgYiwgcGhpLCB0LCB0d29uO1xuICAgICAgICBpZiAobSA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHQgPSBzaW4odSk7XG4gICAgICAgICAgICBiID0gY29zKHUpO1xuICAgICAgICAgICAgYWkgPSBtICogKHUgLSB0ICogYikgLyA0O1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0IC0gYWkgKiBiLFxuICAgICAgICAgICAgICAgIGIgKyBhaSAqIHQsXG4gICAgICAgICAgICAgICAgMSAtIG0gKiB0ICogdCAvIDIsXG4gICAgICAgICAgICAgICAgdSAtIGFpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtID49IDEgLSBlcHNpbG9uKSB7XG4gICAgICAgICAgICBhaSA9ICgxIC0gbSkgLyA0O1xuICAgICAgICAgICAgYiA9IGNvc2godSk7XG4gICAgICAgICAgICB0ID0gdGFuaCh1KTtcbiAgICAgICAgICAgIHBoaSA9IDEgLyBiO1xuICAgICAgICAgICAgdHdvbiA9IGIgKiBzaW5oKHUpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0ICsgYWkgKiAodHdvbiAtIHUpIC8gKGIgKiBiKSxcbiAgICAgICAgICAgICAgICBwaGkgLSBhaSAqIHQgKiBwaGkgKiAodHdvbiAtIHUpLFxuICAgICAgICAgICAgICAgIHBoaSArIGFpICogdCAqIHBoaSAqICh0d29uICsgdSksXG4gICAgICAgICAgICAgICAgMiAqIGF0YW4oZXhwKHUpKSAtIGhhbGZQaSArIGFpICogKHR3b24gLSB1KSAvIGJcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSBbMSwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0sIGMgPSBbc3FydChtKSwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0sIGkgPSAwO1xuICAgICAgICBiID0gc3FydCgxIC0gbSk7XG4gICAgICAgIHR3b24gPSAxO1xuICAgICAgICB3aGlsZSAoYWJzKGNbaV0gLyBhW2ldKSA+IGVwc2lsb24gJiYgaSA8IDgpIHtcbiAgICAgICAgICAgIGFpID0gYVtpKytdO1xuICAgICAgICAgICAgY1tpXSA9IChhaSAtIGIpIC8gMjtcbiAgICAgICAgICAgIGFbaV0gPSAoYWkgKyBiKSAvIDI7XG4gICAgICAgICAgICBiID0gc3FydChhaSAqIGIpO1xuICAgICAgICAgICAgdHdvbiAqPSAyO1xuICAgICAgICB9XG4gICAgICAgIHBoaSA9IHR3b24gKiBhW2ldICogdTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdCA9IGNbaV0gKiBzaW4oYiA9IHBoaSkgLyBhW2ldO1xuICAgICAgICAgICAgcGhpID0gKGFzaW4odCkgKyBwaGkpIC8gMjtcbiAgICAgICAgfSB3aGlsZSAoLS1pKTtcbiAgICAgICAgcmV0dXJuIFtzaW4ocGhpKSwgdCA9IGNvcyhwaGkpLCB0IC8gY29zKHBoaSAtIGIpLCBwaGldO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgRihwaGkraVBzaXxtKS5cbiAgICAvLyBTZWUgQWJyYW1vd2l0eiBhbmQgU3RlZ3VuLCAxNy40LjExLlxuICAgIGZ1bmN0aW9uIGVsbGlwdGljRmkocGhpLCBwc2ksIG0pIHtcbiAgICAgICAgdmFyIHIgPSBhYnMocGhpKSwgaSA9IGFicyhwc2kpLCBzaW5oUHNpID0gc2luaChpKTtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHZhciBjc2NQaGkgPSAxIC8gc2luKHIpLCBjb3RQaGkyID0gMSAvICh0YW4ocikgKiB0YW4ocikpLCBiID0gLShjb3RQaGkyICsgbSAqIChzaW5oUHNpICogc2luaFBzaSAqIGNzY1BoaSAqIGNzY1BoaSkgLSAxICsgbSksIGMgPSAobSAtIDEpICogY290UGhpMiwgY290TGFtYmRhMiA9ICgtYiArIHNxcnQoYiAqIGIgLSA0ICogYykpIC8gMjtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgZWxsaXB0aWNGKGF0YW4oMSAvIHNxcnQoY290TGFtYmRhMikpLCBtKSAqIHNpZ24ocGhpKSxcbiAgICAgICAgICAgICAgICBlbGxpcHRpY0YoYXRhbihzcXJ0KChjb3RMYW1iZGEyIC8gY290UGhpMiAtIDEpIC8gbSkpLCAxIC0gbSkgKiBzaWduKHBzaSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBlbGxpcHRpY0YoYXRhbihzaW5oUHNpKSwgMSAtIG0pICogc2lnbihwc2kpXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBGKHBoaXxtKSB3aGVyZSBtID0ga8KyID0gc2luwrLOsS5cbiAgICAvLyBTZWUgQWJyYW1vd2l0eiBhbmQgU3RlZ3VuLCAxNy42LjcuXG4gICAgZnVuY3Rpb24gZWxsaXB0aWNGKHBoaSwgbSkge1xuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICByZXR1cm4gcGhpO1xuICAgICAgICBpZiAobSA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBsb2codGFuKHBoaSAvIDIgKyBxdWFydGVyUGkpKTtcbiAgICAgICAgdmFyIGEgPSAxLCBiID0gc3FydCgxIC0gbSksIGMgPSBzcXJ0KG0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgYWJzKGMpID4gZXBzaWxvbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGhpICUgcGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZFBoaSA9IGF0YW4oYiAqIHRhbihwaGkpIC8gYSk7XG4gICAgICAgICAgICAgICAgaWYgKGRQaGkgPCAwKVxuICAgICAgICAgICAgICAgICAgICBkUGhpICs9IHBpO1xuICAgICAgICAgICAgICAgIHBoaSArPSBkUGhpICsgfn4ocGhpIC8gcGkpICogcGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGhpICs9IHBoaTtcbiAgICAgICAgICAgIGMgPSAoYSArIGIpIC8gMjtcbiAgICAgICAgICAgIGIgPSBzcXJ0KGEgKiBiKTtcbiAgICAgICAgICAgIGMgPSAoKGEgPSBjKSAtIGIpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGhpIC8gKHBvdygyLCBpKSAqIGEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBndXlvdVJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIga18gPSAoc3FydDIgLSAxKSAvIChzcXJ0MiArIDEpLCBrID0gc3FydCgxIC0ga18gKiBrXyksIEsgPSBlbGxpcHRpY0YoaGFsZlBpLCBrICogayksIGYgPSAtMSwgcHNpID0gbG9nKHRhbihwaSAvIDQgKyBhYnMocGhpKSAvIDIpKSwgciA9IGV4cChmICogcHNpKSAvIHNxcnQoa18pLCBhdCA9IGd1eW91Q29tcGxleEF0YW4ociAqIGNvcyhmICogbGFtYmRhKSwgciAqIHNpbihmICogbGFtYmRhKSksIHQgPSBlbGxpcHRpY0ZpKGF0WzBdLCBhdFsxXSwgayAqIGspO1xuICAgICAgICByZXR1cm4gWy10WzFdLCAocGhpID49IDAgPyAxIDogLTEpICogKDAuNSAqIEsgLSB0WzBdKV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGd1eW91Q29tcGxleEF0YW4oeCwgeSkge1xuICAgICAgICB2YXIgeDIgPSB4ICogeCwgeV8xID0geSArIDEsIHQgPSAxIC0geDIgLSB5ICogeTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDAuNSAqICgoeCA+PSAwID8gaGFsZlBpIDogLWhhbGZQaSkgLSBhdGFuMih0LCAyICogeCkpLFxuICAgICAgICAgICAgLTAuMjUgKiBsb2codCAqIHQgKyA0ICogeDIpICsgMC41ICogbG9nKHlfMSAqIHlfMSArIHgyKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBndXlvdUNvbXBsZXhEaXZpZGUoYSwgYikge1xuICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBiWzBdICogYlswXSArIGJbMV0gKiBiWzFdO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0pIC8gZGVub21pbmF0b3IsXG4gICAgICAgICAgICAoYVsxXSAqIGJbMF0gLSBhWzBdICogYlsxXSkgLyBkZW5vbWluYXRvclxuICAgICAgICBdO1xuICAgIH1cbiAgICBndXlvdVJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIga18gPSAoc3FydDIgLSAxKSAvIChzcXJ0MiArIDEpLCBrID0gc3FydCgxIC0ga18gKiBrXyksIEsgPSBlbGxpcHRpY0YoaGFsZlBpLCBrICogayksIGYgPSAtMSwgaiA9IGVsbGlwdGljSmkoMC41ICogSyAtIHksIC14LCBrICogayksIHRuID0gZ3V5b3VDb21wbGV4RGl2aWRlKGpbMF0sIGpbMV0pLCBsYW1iZGEgPSBhdGFuMih0blsxXSwgdG5bMF0pIC8gZjtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGxhbWJkYSxcbiAgICAgICAgICAgIDIgKiBhdGFuKGV4cCgwLjUgLyBmICogbG9nKGtfICogdG5bMF0gKiB0blswXSArIGtfICogdG5bMV0gKiB0blsxXSkpKSAtIGhhbGZQaVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIGd1eW91ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihzcXVhcmVSYXcoZ3V5b3VSYXcpKVxuICAgICAgICAgICAgLnNjYWxlKDE1MS40OTYpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaGFtbWVyUmF3KEEsIEIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKVxuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgIGlmIChCID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIGQzR2VvLmdlb0F6aW11dGhhbEVxdWFsQXJlYVJhdztcbiAgICAgICAgaWYgKEIgPT09IEluZmluaXR5KVxuICAgICAgICAgICAgcmV0dXJuIGhhbW1lclF1YXJ0aWNBdXRoYWxpY1JhdztcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gZDNHZW8uZ2VvQXppbXV0aGFsRXF1YWxBcmVhUmF3KGxhbWJkYSAvIEIsIHBoaSk7XG4gICAgICAgICAgICBjb29yZGluYXRlc1swXSAqPSBBO1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IGQzR2VvLmdlb0F6aW11dGhhbEVxdWFsQXJlYVJhdy5pbnZlcnQoeCAvIEEsIHkpO1xuICAgICAgICAgICAgY29vcmRpbmF0ZXNbMF0gKj0gQjtcbiAgICAgICAgICAgIHJldHVybiBjb29yZGluYXRlcztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbW1lclF1YXJ0aWNBdXRoYWxpY1JhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbGFtYmRhICogY29zKHBoaSkgLyBjb3MocGhpIC89IDIpLFxuICAgICAgICAgICAgMiAqIHNpbihwaGkpXG4gICAgICAgIF07XG4gICAgfVxuICAgIGhhbW1lclF1YXJ0aWNBdXRoYWxpY1Jhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgcGhpID0gMiAqIGFzaW4oeSAvIDIpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeCAqIGNvcyhwaGkgLyAyKSAvIGNvcyhwaGkpLFxuICAgICAgICAgICAgcGhpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgaGFtbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgQiA9IDIsIG0gPSBkM0dlby5nZW9Qcm9qZWN0aW9uTXV0YXRvcihoYW1tZXJSYXcpLCBwID0gbShCKTtcbiAgICAgICAgcC5jb2VmZmljaWVudCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEI7XG4gICAgICAgICAgICByZXR1cm4gbShCID0gK18pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcFxuICAgICAgICAgICAgLnNjYWxlKDE2OS41MjkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaGFtbWVyUmV0cm9hemltdXRoYWxSYXcocGhpMCkge1xuICAgICAgICB2YXIgc2luUGhpMCA9IHNpbihwaGkwKSwgY29zUGhpMCA9IGNvcyhwaGkwKSwgcm90YXRlID0gaGFtbWVyUmV0cm9hemltdXRoYWxSb3RhdGlvbihwaGkwKTtcbiAgICAgICAgcm90YXRlLmludmVydCA9IGhhbW1lclJldHJvYXppbXV0aGFsUm90YXRpb24oLXBoaTApO1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHJvdGF0ZShsYW1iZGEsIHBoaSk7XG4gICAgICAgICAgICBsYW1iZGEgPSBwWzBdLCBwaGkgPSBwWzFdO1xuICAgICAgICAgICAgdmFyIHNpblBoaSA9IHNpbihwaGkpLCBjb3NQaGkgPSBjb3MocGhpKSwgY29zTGFtYmRhID0gY29zKGxhbWJkYSksIHogPSBhY29zKHNpblBoaTAgKiBzaW5QaGkgKyBjb3NQaGkwICogY29zUGhpICogY29zTGFtYmRhKSwgc2lueiA9IHNpbih6KSwgSyA9IGFicyhzaW56KSA+IGVwc2lsb24gPyB6IC8gc2lueiA6IDE7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIEsgKiBjb3NQaGkwICogc2luKGxhbWJkYSksXG4gICAgICAgICAgICAgICAgKGFicyhsYW1iZGEpID4gaGFsZlBpID8gSyA6IC1LKSAvLyByb3RhdGUgZm9yIGJhY2sgaGVtaXNwaGVyZVxuICAgICAgICAgICAgICAgICAgICAqIChzaW5QaGkwICogY29zUGhpIC0gY29zUGhpMCAqIHNpblBoaSAqIGNvc0xhbWJkYSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHJobyA9IHNxcnQoeCAqIHggKyB5ICogeSksIHNpbnogPSAtc2luKHJobyksIGNvc3ogPSBjb3MocmhvKSwgYSA9IHJobyAqIGNvc3osIGIgPSAteSAqIHNpbnosIGMgPSByaG8gKiBzaW5QaGkwLCBkID0gc3FydChhICogYSArIGIgKiBiIC0gYyAqIGMpLCBwaGkgPSBhdGFuMihhICogYyArIGIgKiBkLCBiICogYyAtIGEgKiBkKSwgbGFtYmRhID0gKHJobyA+IGhhbGZQaSA/IC0xIDogMSkgKiBhdGFuMih4ICogc2lueiwgcmhvICogY29zKHBoaSkgKiBjb3N6ICsgeSAqIHNpbihwaGkpICogc2lueik7XG4gICAgICAgICAgICByZXR1cm4gcm90YXRlLmludmVydChsYW1iZGEsIHBoaSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICAvLyBMYXRpdHVkaW5hbCByb3RhdGlvbiBieSBwaGkwLlxuICAgIC8vIFRlbXBvcmFyeSBoYWNrIHVudGlsIEQzIHN1cHBvcnRzIGFyYml0cmFyeSBzbWFsbC1jaXJjbGUgY2xpcHBpbmcgb3JpZ2lucy5cbiAgICBmdW5jdGlvbiBoYW1tZXJSZXRyb2F6aW11dGhhbFJvdGF0aW9uKHBoaTApIHtcbiAgICAgICAgdmFyIHNpblBoaTAgPSBzaW4ocGhpMCksIGNvc1BoaTAgPSBjb3MocGhpMCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKSwgeCA9IGNvcyhsYW1iZGEpICogY29zUGhpLCB5ID0gc2luKGxhbWJkYSkgKiBjb3NQaGksIHogPSBzaW4ocGhpKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYXRhbjIoeSwgeCAqIGNvc1BoaTAgLSB6ICogc2luUGhpMCksXG4gICAgICAgICAgICAgICAgYXNpbih6ICogY29zUGhpMCArIHggKiBzaW5QaGkwKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGhhbW1lclJldHJvYXppbXV0aGFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGhpMCA9IDAsIG0gPSBkM0dlby5nZW9Qcm9qZWN0aW9uTXV0YXRvcihoYW1tZXJSZXRyb2F6aW11dGhhbFJhdyksIHAgPSBtKHBoaTApLCByb3RhdGVfID0gcC5yb3RhdGUsIHN0cmVhbV8gPSBwLnN0cmVhbSwgY2lyY2xlID0gZDNHZW8uZ2VvQ2lyY2xlKCk7XG4gICAgICAgIHAucGFyYWxsZWwgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBwaGkwICogZGVncmVlcztcbiAgICAgICAgICAgIHZhciByID0gcC5yb3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiBtKHBoaTAgPSBfICogcmFkaWFucykucm90YXRlKHIpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUZW1wb3JhcnkgaGFjazsgc2VlIGhhbW1lclJldHJvYXppbXV0aGFsUm90YXRpb24uXG4gICAgICAgIHAucm90YXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gKF8gPSByb3RhdGVfLmNhbGwocCksIF9bMV0gKz0gcGhpMCAqIGRlZ3JlZXMsIF8pO1xuICAgICAgICAgICAgcm90YXRlXy5jYWxsKHAsIFtfWzBdLCBfWzFdIC0gcGhpMCAqIGRlZ3JlZXNdKTtcbiAgICAgICAgICAgIGNpcmNsZS5jZW50ZXIoWy1fWzBdLCAtX1sxXV0pO1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH07XG4gICAgICAgIHAuc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgc3RyZWFtID0gc3RyZWFtXyhzdHJlYW0pO1xuICAgICAgICAgICAgc3RyZWFtLnNwaGVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGVwc2lsb24kJDEgPSAxZS0yLCByaW5nID0gY2lyY2xlLnJhZGl1cyg5MCAtIGVwc2lsb24kJDEpKCkuY29vcmRpbmF0ZXNbMF0sIG4gPSByaW5nLmxlbmd0aCAtIDEsIGkgPSAtMSwgcDtcbiAgICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludCgocCA9IHJpbmdbaV0pWzBdLCBwWzFdKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJpbmcgPSBjaXJjbGUucmFkaXVzKDkwICsgZXBzaWxvbiQkMSkoKS5jb29yZGluYXRlc1swXTtcbiAgICAgICAgICAgICAgICBuID0gcmluZy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoLS1pID49IDApXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludCgocCA9IHJpbmdbaV0pWzBdLCBwWzFdKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBcbiAgICAgICAgICAgIC5zY2FsZSg3OS40MTg3KVxuICAgICAgICAgICAgLnBhcmFsbGVsKDQ1KVxuICAgICAgICAgICAgLmNsaXBBbmdsZSgxODAgLSAxZS0zKTtcbiAgICB9O1xuICAgIHZhciBoZWFscGl4UGFyYWxsZWwgPSA0MSArIDQ4IC8gMzYgKyAzNyAvIDM2MDA7XG4gICAgdmFyIGhlYWxwaXhMYW1iZXJ0ID0gY3lsaW5kcmljYWxFcXVhbEFyZWFSYXcoMCk7XG4gICAgZnVuY3Rpb24gaGVhbHBpeFJhdyhIKSB7XG4gICAgICAgIHZhciBwaGkwID0gaGVhbHBpeFBhcmFsbGVsICogcmFkaWFucywgZHggPSBjb2xsaWdub25SYXcocGksIHBoaTApWzBdIC0gY29sbGlnbm9uUmF3KC1waSwgcGhpMClbMF0sIHkwID0gaGVhbHBpeExhbWJlcnQoMCwgcGhpMClbMV0sIHkxID0gY29sbGlnbm9uUmF3KDAsIHBoaTApWzFdLCBkeTEgPSBzcXJ0UGkgLSB5MSwgayA9IHRhdSAvIEgsIHcgPSA0IC8gdGF1LCBoID0geTAgKyAoZHkxICogZHkxICogNCkgLyB0YXU7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciBwb2ludCwgcGhpMiA9IGFicyhwaGkpO1xuICAgICAgICAgICAgaWYgKHBoaTIgPiBwaGkwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBtaW4oSCAtIDEsIG1heCgwLCBmbG9vcigobGFtYmRhICsgcGkpIC8gaykpKTtcbiAgICAgICAgICAgICAgICBsYW1iZGEgKz0gcGkgKiAoSCAtIDEpIC8gSCAtIGkgKiBrO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gY29sbGlnbm9uUmF3KGxhbWJkYSwgcGhpMik7XG4gICAgICAgICAgICAgICAgcG9pbnRbMF0gPSBwb2ludFswXSAqIHRhdSAvIGR4IC0gdGF1ICogKEggLSAxKSAvICgyICogSCkgKyBpICogdGF1IC8gSDtcbiAgICAgICAgICAgICAgICBwb2ludFsxXSA9IHkwICsgKHBvaW50WzFdIC0geTEpICogNCAqIGR5MSAvIHRhdTtcbiAgICAgICAgICAgICAgICBpZiAocGhpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRbMV0gPSAtcG9pbnRbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGhlYWxwaXhMYW1iZXJ0KGxhbWJkYSwgcGhpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50WzBdICo9IHcsIHBvaW50WzFdIC89IGg7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgeCAvPSB3LCB5ICo9IGg7XG4gICAgICAgICAgICB2YXIgeTIgPSBhYnMoeSk7XG4gICAgICAgICAgICBpZiAoeTIgPiB5MCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gbWluKEggLSAxLCBtYXgoMCwgZmxvb3IoKHggKyBwaSkgLyBrKSkpO1xuICAgICAgICAgICAgICAgIHggPSAoeCArIHBpICogKEggLSAxKSAvIEggLSBpICogaykgKiBkeCAvIHRhdTtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBjb2xsaWdub25SYXcuaW52ZXJ0KHgsIDAuMjUgKiAoeTIgLSB5MCkgKiB0YXUgLyBkeTEgKyB5MSk7XG4gICAgICAgICAgICAgICAgcG9pbnRbMF0gLT0gcGkgKiAoSCAtIDEpIC8gSCAtIGkgKiBrO1xuICAgICAgICAgICAgICAgIGlmICh5IDwgMClcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRbMV0gPSAtcG9pbnRbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhlYWxwaXhMYW1iZXJ0LmludmVydCh4LCB5KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwaGVyZShzdGVwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgZDNBcnJheS5yYW5nZSgtMTgwLCAxODAgKyBzdGVwIC8gMiwgc3RlcCkubWFwKGZ1bmN0aW9uICh4LCBpKSB7IHJldHVybiBbeCwgaSAmIDEgPyA5MCAtIDFlLTYgOiBoZWFscGl4UGFyYWxsZWxdOyB9KVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGQzQXJyYXkucmFuZ2UoMTgwLCAtMTgwIC0gc3RlcCAvIDIsIC1zdGVwKS5tYXAoZnVuY3Rpb24gKHgsIGkpIHsgcmV0dXJuIFt4LCBpICYgMSA/IC05MCArIDFlLTYgOiAtaGVhbHBpeFBhcmFsbGVsXTsgfSkpXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBoZWFscGl4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgSCA9IDQsIG0gPSBkM0dlby5nZW9Qcm9qZWN0aW9uTXV0YXRvcihoZWFscGl4UmF3KSwgcCA9IG0oSCksIHN0cmVhbV8gPSBwLnN0cmVhbTtcbiAgICAgICAgcC5sb2JlcyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IG0oSCA9ICtfKSA6IEg7XG4gICAgICAgIH07XG4gICAgICAgIHAuc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIHJvdGF0ZSA9IHAucm90YXRlKCksIHJvdGF0ZVN0cmVhbSA9IHN0cmVhbV8oc3RyZWFtKSwgc3BoZXJlU3RyZWFtID0gKHAucm90YXRlKFswLCAwXSksIHN0cmVhbV8oc3RyZWFtKSk7XG4gICAgICAgICAgICBwLnJvdGF0ZShyb3RhdGUpO1xuICAgICAgICAgICAgcm90YXRlU3RyZWFtLnNwaGVyZSA9IGZ1bmN0aW9uICgpIHsgZDNHZW8uZ2VvU3RyZWFtKHNwaGVyZSgxODAgLyBIKSwgc3BoZXJlU3RyZWFtKTsgfTtcbiAgICAgICAgICAgIHJldHVybiByb3RhdGVTdHJlYW07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwXG4gICAgICAgICAgICAuc2NhbGUoMjM5Ljc1KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGhpbGxSYXcoSykge1xuICAgICAgICB2YXIgTCA9IDEgKyBLLCBzaW5CdCA9IHNpbigxIC8gTCksIEJ0ID0gYXNpbihzaW5CdCksIEEgPSAyICogc3FydChwaSAvIChCID0gcGkgKyA0ICogQnQgKiBMKSksIEIsIHJobzAgPSAwLjUgKiBBICogKEwgKyBzcXJ0KEsgKiAoMiArIEspKSksIEsyID0gSyAqIEssIEwyID0gTCAqIEw7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciB0ID0gMSAtIHNpbihwaGkpLCByaG8sIG9tZWdhO1xuICAgICAgICAgICAgaWYgKHQgJiYgdCA8IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBoYWxmUGkgLSBwaGksIGkgPSAyNSwgZGVsdGE7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2luVGhldGEgPSBzaW4odGhldGEpLCBjb3NUaGV0YSA9IGNvcyh0aGV0YSksIEJ0X0J0MSA9IEJ0ICsgYXRhbjIoc2luVGhldGEsIEwgLSBjb3NUaGV0YSksIEMgPSAxICsgTDIgLSAyICogTCAqIGNvc1RoZXRhO1xuICAgICAgICAgICAgICAgICAgICB0aGV0YSAtPSBkZWx0YSA9ICh0aGV0YSAtIEsyICogQnQgLSBMICogc2luVGhldGEgKyBDICogQnRfQnQxIC0gMC41ICogdCAqIEIpIC8gKDIgKiBMICogc2luVGhldGEgKiBCdF9CdDEpO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGFicyhkZWx0YSkgPiBlcHNpbG9uMiAmJiAtLWkgPiAwKTtcbiAgICAgICAgICAgICAgICByaG8gPSBBICogc3FydChDKTtcbiAgICAgICAgICAgICAgICBvbWVnYSA9IGxhbWJkYSAqIEJ0X0J0MSAvIHBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmhvID0gQSAqIChLICsgdCk7XG4gICAgICAgICAgICAgICAgb21lZ2EgPSBsYW1iZGEgKiBCdCAvIHBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICByaG8gKiBzaW4ob21lZ2EpLFxuICAgICAgICAgICAgICAgIHJobzAgLSByaG8gKiBjb3Mob21lZ2EpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciByaG8yID0geCAqIHggKyAoeSAtPSByaG8wKSAqIHksIGNvc1RoZXRhID0gKDEgKyBMMiAtIHJobzIgLyAoQSAqIEEpKSAvICgyICogTCksIHRoZXRhID0gYWNvcyhjb3NUaGV0YSksIHNpblRoZXRhID0gc2luKHRoZXRhKSwgQnRfQnQxID0gQnQgKyBhdGFuMihzaW5UaGV0YSwgTCAtIGNvc1RoZXRhKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYXNpbih4IC8gc3FydChyaG8yKSkgKiBwaSAvIEJ0X0J0MSxcbiAgICAgICAgICAgICAgICBhc2luKDEgLSAyICogKHRoZXRhIC0gSzIgKiBCdCAtIEwgKiBzaW5UaGV0YSArICgxICsgTDIgLSAyICogTCAqIGNvc1RoZXRhKSAqIEJ0X0J0MSkgLyBCKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIHZhciBoaWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgSyA9IDEsIG0gPSBkM0dlby5nZW9Qcm9qZWN0aW9uTXV0YXRvcihoaWxsUmF3KSwgcCA9IG0oSyk7XG4gICAgICAgIHAucmF0aW8gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBtKEsgPSArXykgOiBLO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcFxuICAgICAgICAgICAgLnNjYWxlKDE2Ny43NzQpXG4gICAgICAgICAgICAuY2VudGVyKFswLCAxOC42N10pO1xuICAgIH07XG4gICAgdmFyIHNpbnVNb2xsd2VpZGVQaGkgPSAwLjcxMDk4ODk1OTYyMDc1Njc7XG4gICAgdmFyIHNpbnVNb2xsd2VpZGVZID0gMC4wNTI4MDM1Mjc0NTQyO1xuICAgIGZ1bmN0aW9uIHNpbnVNb2xsd2VpZGVSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgcmV0dXJuIHBoaSA+IC1zaW51TW9sbHdlaWRlUGhpXG4gICAgICAgICAgICA/IChsYW1iZGEgPSBtb2xsd2VpZGVSYXcobGFtYmRhLCBwaGkpLCBsYW1iZGFbMV0gKz0gc2ludU1vbGx3ZWlkZVksIGxhbWJkYSlcbiAgICAgICAgICAgIDogc2ludXNvaWRhbFJhdyhsYW1iZGEsIHBoaSk7XG4gICAgfVxuICAgIHNpbnVNb2xsd2VpZGVSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHkgPiAtc2ludU1vbGx3ZWlkZVBoaVxuICAgICAgICAgICAgPyBtb2xsd2VpZGVSYXcuaW52ZXJ0KHgsIHkgLSBzaW51TW9sbHdlaWRlWSlcbiAgICAgICAgICAgIDogc2ludXNvaWRhbFJhdy5pbnZlcnQoeCwgeSk7XG4gICAgfTtcbiAgICB2YXIgc2ludU1vbGx3ZWlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oc2ludU1vbGx3ZWlkZVJhdylcbiAgICAgICAgICAgIC5yb3RhdGUoWy0yMCwgLTU1XSlcbiAgICAgICAgICAgIC5zY2FsZSgxNjQuMjYzKVxuICAgICAgICAgICAgLmNlbnRlcihbMCwgLTUuNDAzNl0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaG9tb2xvc2luZVJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICByZXR1cm4gYWJzKHBoaSkgPiBzaW51TW9sbHdlaWRlUGhpXG4gICAgICAgICAgICA/IChsYW1iZGEgPSBtb2xsd2VpZGVSYXcobGFtYmRhLCBwaGkpLCBsYW1iZGFbMV0gLT0gcGhpID4gMCA/IHNpbnVNb2xsd2VpZGVZIDogLXNpbnVNb2xsd2VpZGVZLCBsYW1iZGEpXG4gICAgICAgICAgICA6IHNpbnVzb2lkYWxSYXcobGFtYmRhLCBwaGkpO1xuICAgIH1cbiAgICBob21vbG9zaW5lUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiBhYnMoeSkgPiBzaW51TW9sbHdlaWRlUGhpXG4gICAgICAgICAgICA/IG1vbGx3ZWlkZVJhdy5pbnZlcnQoeCwgeSArICh5ID4gMCA/IHNpbnVNb2xsd2VpZGVZIDogLXNpbnVNb2xsd2VpZGVZKSlcbiAgICAgICAgICAgIDogc2ludXNvaWRhbFJhdy5pbnZlcnQoeCwgeSk7XG4gICAgfTtcbiAgICB2YXIgaG9tb2xvc2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oaG9tb2xvc2luZVJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNTIuNjMpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcG9pbnRFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhYnMoYVswXSAtIGJbMF0pIDwgZXBzaWxvbiAmJiBhYnMoYVsxXSAtIGJbMV0pIDwgZXBzaWxvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVMaW5lKGNvb3JkaW5hdGVzLCBtKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGgsIHAwID0gY29vcmRpbmF0ZXNbMF0sIHAxLCBkeCwgZHksIHJlc2FtcGxlZCA9IFtdO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgcDEgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgICAgIGR4ID0gKHAxWzBdIC0gcDBbMF0pIC8gbTtcbiAgICAgICAgICAgIGR5ID0gKHAxWzFdIC0gcDBbMV0pIC8gbTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbTsgKytqKVxuICAgICAgICAgICAgICAgIHJlc2FtcGxlZC5wdXNoKFtwMFswXSArIGogKiBkeCwgcDBbMV0gKyBqICogZHldKTtcbiAgICAgICAgICAgIHAwID0gcDE7XG4gICAgICAgIH1cbiAgICAgICAgcmVzYW1wbGVkLnB1c2gocDEpO1xuICAgICAgICByZXR1cm4gcmVzYW1wbGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZVNwaGVyZShsb2Jlcykge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBbXSwgbG9iZSwgbGFtYmRhMCwgcGhpMCwgcGhpMSwgbGFtYmRhMiwgcGhpMiwgaSwgbiA9IGxvYmVzWzBdLmxlbmd0aDtcbiAgICAgICAgLy8gTm9ydGhlcm4gSGVtaXNwaGVyZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBsb2JlID0gbG9iZXNbMF1baV07XG4gICAgICAgICAgICBsYW1iZGEwID0gbG9iZVswXVswXSwgcGhpMCA9IGxvYmVbMF1bMV0sIHBoaTEgPSBsb2JlWzFdWzFdO1xuICAgICAgICAgICAgbGFtYmRhMiA9IGxvYmVbMl1bMF0sIHBoaTIgPSBsb2JlWzJdWzFdO1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMucHVzaChpbnRlcnBvbGF0ZUxpbmUoW1xuICAgICAgICAgICAgICAgIFtsYW1iZGEwICsgZXBzaWxvbiwgcGhpMCArIGVwc2lsb25dLFxuICAgICAgICAgICAgICAgIFtsYW1iZGEwICsgZXBzaWxvbiwgcGhpMSAtIGVwc2lsb25dLFxuICAgICAgICAgICAgICAgIFtsYW1iZGEyIC0gZXBzaWxvbiwgcGhpMSAtIGVwc2lsb25dLFxuICAgICAgICAgICAgICAgIFtsYW1iZGEyIC0gZXBzaWxvbiwgcGhpMiArIGVwc2lsb25dXG4gICAgICAgICAgICBdLCAzMCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvdXRoZXJuIEhlbWlzcGhlcmVcbiAgICAgICAgZm9yIChpID0gbG9iZXNbMV0ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGxvYmUgPSBsb2Jlc1sxXVtpXTtcbiAgICAgICAgICAgIGxhbWJkYTAgPSBsb2JlWzBdWzBdLCBwaGkwID0gbG9iZVswXVsxXSwgcGhpMSA9IGxvYmVbMV1bMV07XG4gICAgICAgICAgICBsYW1iZGEyID0gbG9iZVsyXVswXSwgcGhpMiA9IGxvYmVbMl1bMV07XG4gICAgICAgICAgICBjb29yZGluYXRlcy5wdXNoKGludGVycG9sYXRlTGluZShbXG4gICAgICAgICAgICAgICAgW2xhbWJkYTIgLSBlcHNpbG9uLCBwaGkyIC0gZXBzaWxvbl0sXG4gICAgICAgICAgICAgICAgW2xhbWJkYTIgLSBlcHNpbG9uLCBwaGkxICsgZXBzaWxvbl0sXG4gICAgICAgICAgICAgICAgW2xhbWJkYTAgKyBlcHNpbG9uLCBwaGkxICsgZXBzaWxvbl0sXG4gICAgICAgICAgICAgICAgW2xhbWJkYTAgKyBlcHNpbG9uLCBwaGkwIC0gZXBzaWxvbl1cbiAgICAgICAgICAgIF0sIDMwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtkM0FycmF5Lm1lcmdlKGNvb3JkaW5hdGVzKV1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGludGVycnVwdCA9IGZ1bmN0aW9uIChwcm9qZWN0LCBsb2Jlcykge1xuICAgICAgICB2YXIgc3BoZXJlID0gaW50ZXJwb2xhdGVTcGhlcmUobG9iZXMpO1xuICAgICAgICBsb2JlcyA9IGxvYmVzLm1hcChmdW5jdGlvbiAobG9iZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYmUubWFwKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgW2xbMF1bMF0gKiByYWRpYW5zLCBsWzBdWzFdICogcmFkaWFuc10sXG4gICAgICAgICAgICAgICAgICAgIFtsWzFdWzBdICogcmFkaWFucywgbFsxXVsxXSAqIHJhZGlhbnNdLFxuICAgICAgICAgICAgICAgICAgICBbbFsyXVswXSAqIHJhZGlhbnMsIGxbMl1bMV0gKiByYWRpYW5zXVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBib3VuZHMgPSBsb2Jlcy5tYXAoZnVuY3Rpb24gKGxvYmUpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2JlLm1hcChmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgICAgIHZhciB4MCA9IHByb2plY3QobFswXVswXSwgbFswXVsxXSlbMF0sIHgxID0gcHJvamVjdChsWzJdWzBdLCBsWzJdWzFdKVswXSwgeTAgPSBwcm9qZWN0KGxbMV1bMF0sIGxbMF1bMV0pWzFdLCB5MSA9IHByb2plY3QobFsxXVswXSwgbFsxXVsxXSlbMV0sIHQ7XG4gICAgICAgICAgICAgICAgaWYgKHkwID4geTEpXG4gICAgICAgICAgICAgICAgICAgIHQgPSB5MCwgeTAgPSB5MSwgeTEgPSB0O1xuICAgICAgICAgICAgICAgIHJldHVybiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIHNpZ24kJDEgPSBwaGkgPCAwID8gLTEgOiArMSwgbG9iZSA9IGxvYmVzWysocGhpIDwgMCldO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBsb2JlLmxlbmd0aCAtIDE7IGkgPCBuICYmIGxhbWJkYSA+IGxvYmVbaV1bMl1bMF07ICsraSlcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB2YXIgcCA9IHByb2plY3QobGFtYmRhIC0gbG9iZVtpXVsxXVswXSwgcGhpKTtcbiAgICAgICAgICAgIHBbMF0gKz0gcHJvamVjdChsb2JlW2ldWzFdWzBdLCBzaWduJCQxICogcGhpID4gc2lnbiQkMSAqIGxvYmVbaV1bMF1bMV0gPyBsb2JlW2ldWzBdWzFdIDogcGhpKVswXTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFzc3VtZXMgbXV0dWFsbHkgZXhjbHVzaXZlIGJvdW5kaW5nIGJveGVzIGZvciBsb2Jlcy5cbiAgICAgICAgaWYgKHByb2plY3QuaW52ZXJ0KVxuICAgICAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHZhciBib3VuZCA9IGJvdW5kc1srKHkgPCAwKV0sIGxvYmUgPSBsb2Jlc1srKHkgPCAwKV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBib3VuZC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBib3VuZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJbMF1bMF0gPD0geCAmJiB4IDwgYlsxXVswXSAmJiBiWzBdWzFdIDw9IHkgJiYgeSA8IGJbMV1bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcHJvamVjdC5pbnZlcnQoeCAtIHByb2plY3QobG9iZVtpXVsxXVswXSwgMClbMF0sIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcFswXSArPSBsb2JlW2ldWzFdWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50RXF1YWwoZm9yd2FyZChwWzBdLCBwWzFdKSwgW3gsIHldKSA/IHAgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdmFyIHAgPSBkM0dlby5nZW9Qcm9qZWN0aW9uKGZvcndhcmQpLCBzdHJlYW1fID0gcC5zdHJlYW07XG4gICAgICAgIHAuc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIHJvdGF0ZSA9IHAucm90YXRlKCksIHJvdGF0ZVN0cmVhbSA9IHN0cmVhbV8oc3RyZWFtKSwgc3BoZXJlU3RyZWFtID0gKHAucm90YXRlKFswLCAwXSksIHN0cmVhbV8oc3RyZWFtKSk7XG4gICAgICAgICAgICBwLnJvdGF0ZShyb3RhdGUpO1xuICAgICAgICAgICAgcm90YXRlU3RyZWFtLnNwaGVyZSA9IGZ1bmN0aW9uICgpIHsgZDNHZW8uZ2VvU3RyZWFtKHNwaGVyZSwgc3BoZXJlU3RyZWFtKTsgfTtcbiAgICAgICAgICAgIHJldHVybiByb3RhdGVTdHJlYW07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG4gICAgdmFyIGxvYmVzID0gW1tcbiAgICAgICAgICAgIFtbLTE4MCwgMF0sIFstMTAwLCA5MF0sIFstNDAsIDBdXSxcbiAgICAgICAgICAgIFtbLTQwLCAwXSwgWzMwLCA5MF0sIFsxODAsIDBdXVxuICAgICAgICBdLCBbXG4gICAgICAgICAgICBbWy0xODAsIDBdLCBbLTE2MCwgLTkwXSwgWy0xMDAsIDBdXSxcbiAgICAgICAgICAgIFtbLTEwMCwgMF0sIFstNjAsIC05MF0sIFstMjAsIDBdXSxcbiAgICAgICAgICAgIFtbLTIwLCAwXSwgWzIwLCAtOTBdLCBbODAsIDBdXSxcbiAgICAgICAgICAgIFtbODAsIDBdLCBbMTQwLCAtOTBdLCBbMTgwLCAwXV1cbiAgICAgICAgXV07XG4gICAgdmFyIGJvZ2dzJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnJ1cHQoYm9nZ3NSYXcsIGxvYmVzKVxuICAgICAgICAgICAgLnNjYWxlKDE2MC44NTcpO1xuICAgIH07XG4gICAgdmFyIGxvYmVzJDEgPSBbW1xuICAgICAgICAgICAgW1stMTgwLCAwXSwgWy0xMDAsIDkwXSwgWy00MCwgMF1dLFxuICAgICAgICAgICAgW1stNDAsIDBdLCBbMzAsIDkwXSwgWzE4MCwgMF1dXG4gICAgICAgIF0sIFtcbiAgICAgICAgICAgIFtbLTE4MCwgMF0sIFstMTYwLCAtOTBdLCBbLTEwMCwgMF1dLFxuICAgICAgICAgICAgW1stMTAwLCAwXSwgWy02MCwgLTkwXSwgWy0yMCwgMF1dLFxuICAgICAgICAgICAgW1stMjAsIDBdLCBbMjAsIC05MF0sIFs4MCwgMF1dLFxuICAgICAgICAgICAgW1s4MCwgMF0sIFsxNDAsIC05MF0sIFsxODAsIDBdXVxuICAgICAgICBdXTtcbiAgICB2YXIgaG9tb2xvc2luZSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW50ZXJydXB0KGhvbW9sb3NpbmVSYXcsIGxvYmVzJDEpXG4gICAgICAgICAgICAuc2NhbGUoMTUyLjYzKTtcbiAgICB9O1xuICAgIHZhciBsb2JlcyQyID0gW1tcbiAgICAgICAgICAgIFtbLTE4MCwgMF0sIFstMTAwLCA5MF0sIFstNDAsIDBdXSxcbiAgICAgICAgICAgIFtbLTQwLCAwXSwgWzMwLCA5MF0sIFsxODAsIDBdXVxuICAgICAgICBdLCBbXG4gICAgICAgICAgICBbWy0xODAsIDBdLCBbLTE2MCwgLTkwXSwgWy0xMDAsIDBdXSxcbiAgICAgICAgICAgIFtbLTEwMCwgMF0sIFstNjAsIC05MF0sIFstMjAsIDBdXSxcbiAgICAgICAgICAgIFtbLTIwLCAwXSwgWzIwLCAtOTBdLCBbODAsIDBdXSxcbiAgICAgICAgICAgIFtbODAsIDBdLCBbMTQwLCAtOTBdLCBbMTgwLCAwXV1cbiAgICAgICAgXV07XG4gICAgdmFyIG1vbGx3ZWlkZSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW50ZXJydXB0KG1vbGx3ZWlkZVJhdywgbG9iZXMkMilcbiAgICAgICAgICAgIC5zY2FsZSgxNjkuNTI5KTtcbiAgICB9O1xuICAgIHZhciBsb2JlcyQzID0gW1tcbiAgICAgICAgICAgIFtbLTE4MCwgMF0sIFstOTAsIDkwXSwgWzAsIDBdXSxcbiAgICAgICAgICAgIFtbMCwgMF0sIFs5MCwgOTBdLCBbMTgwLCAwXV1cbiAgICAgICAgXSwgW1xuICAgICAgICAgICAgW1stMTgwLCAwXSwgWy05MCwgLTkwXSwgWzAsIDBdXSxcbiAgICAgICAgICAgIFtbMCwgMF0sIFs5MCwgLTkwXSwgWzE4MCwgMF1dXG4gICAgICAgIF1dO1xuICAgIHZhciBtb2xsd2VpZGVIZW1pc3BoZXJlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGludGVycnVwdChtb2xsd2VpZGVSYXcsIGxvYmVzJDMpXG4gICAgICAgICAgICAuc2NhbGUoMTY5LjUyOSlcbiAgICAgICAgICAgIC5yb3RhdGUoWzIwLCAwXSk7XG4gICAgfTtcbiAgICB2YXIgbG9iZXMkNCA9IFtbXG4gICAgICAgICAgICBbWy0xODAsIDM1XSwgWy0zMCwgOTBdLCBbMCwgMzVdXSxcbiAgICAgICAgICAgIFtbMCwgMzVdLCBbMzAsIDkwXSwgWzE4MCwgMzVdXVxuICAgICAgICBdLCBbXG4gICAgICAgICAgICBbWy0xODAsIC0xMF0sIFstMTAyLCAtOTBdLCBbLTY1LCAtMTBdXSxcbiAgICAgICAgICAgIFtbLTY1LCAtMTBdLCBbNSwgLTkwXSwgWzc3LCAtMTBdXSxcbiAgICAgICAgICAgIFtbNzcsIC0xMF0sIFsxMDMsIC05MF0sIFsxODAsIC0xMF1dXG4gICAgICAgIF1dO1xuICAgIHZhciBzaW51TW9sbHdlaWRlJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnJ1cHQoc2ludU1vbGx3ZWlkZVJhdywgbG9iZXMkNClcbiAgICAgICAgICAgIC5yb3RhdGUoWy0yMCwgLTU1XSlcbiAgICAgICAgICAgIC5zY2FsZSgxNjQuMjYzKVxuICAgICAgICAgICAgLmNlbnRlcihbMCwgLTUuNDAzNl0pO1xuICAgIH07XG4gICAgdmFyIGxvYmVzJDUgPSBbW1xuICAgICAgICAgICAgW1stMTgwLCAwXSwgWy0xMTAsIDkwXSwgWy00MCwgMF1dLFxuICAgICAgICAgICAgW1stNDAsIDBdLCBbMCwgOTBdLCBbNDAsIDBdXSxcbiAgICAgICAgICAgIFtbNDAsIDBdLCBbMTEwLCA5MF0sIFsxODAsIDBdXVxuICAgICAgICBdLCBbXG4gICAgICAgICAgICBbWy0xODAsIDBdLCBbLTExMCwgLTkwXSwgWy00MCwgMF1dLFxuICAgICAgICAgICAgW1stNDAsIDBdLCBbMCwgLTkwXSwgWzQwLCAwXV0sXG4gICAgICAgICAgICBbWzQwLCAwXSwgWzExMCwgLTkwXSwgWzE4MCwgMF1dXG4gICAgICAgIF1dO1xuICAgIHZhciBzaW51c29pZGFsJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnJ1cHQoc2ludXNvaWRhbFJhdywgbG9iZXMkNSlcbiAgICAgICAgICAgIC5zY2FsZSgxNTIuNjMpXG4gICAgICAgICAgICAucm90YXRlKFstMjAsIDBdKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGthdnJheXNraXk3UmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJldHVybiBbMyAvIHRhdSAqIGxhbWJkYSAqIHNxcnQocGkgKiBwaSAvIDMgLSBwaGkgKiBwaGkpLCBwaGldO1xuICAgIH1cbiAgICBrYXZyYXlza2l5N1Jhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gW3RhdSAvIDMgKiB4IC8gc3FydChwaSAqIHBpIC8gMyAtIHkgKiB5KSwgeV07XG4gICAgfTtcbiAgICB2YXIga2F2cmF5c2tpeTcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGthdnJheXNraXk3UmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE1OC44MzcpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbGFncmFuZ2VSYXcobikge1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICBpZiAoYWJzKGFicyhwaGkpIC0gaGFsZlBpKSA8IGVwc2lsb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIFswLCBwaGkgPCAwID8gLTIgOiAyXTtcbiAgICAgICAgICAgIHZhciBzaW5QaGkgPSBzaW4ocGhpKSwgdiA9IHBvdygoMSArIHNpblBoaSkgLyAoMSAtIHNpblBoaSksIG4gLyAyKSwgYyA9IDAuNSAqICh2ICsgMSAvIHYpICsgY29zKGxhbWJkYSAqPSBuKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgMiAqIHNpbihsYW1iZGEpIC8gYyxcbiAgICAgICAgICAgICAgICAodiAtIDEgLyB2KSAvIGNcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHkwID0gYWJzKHkpO1xuICAgICAgICAgICAgaWYgKGFicyh5MCAtIDIpIDwgZXBzaWxvbilcbiAgICAgICAgICAgICAgICByZXR1cm4geCA/IG51bGwgOiBbMCwgc2lnbih5KSAqIGhhbGZQaV07XG4gICAgICAgICAgICBpZiAoeTAgPiAyKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgeCAvPSAyLCB5IC89IDI7XG4gICAgICAgICAgICB2YXIgeDIgPSB4ICogeCwgeTIgPSB5ICogeSwgdCA9IDIgKiB5IC8gKDEgKyB4MiArIHkyKTsgLy8gdGFuaChuUGhpKVxuICAgICAgICAgICAgdCA9IHBvdygoMSArIHQpIC8gKDEgLSB0KSwgMSAvIG4pO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBhdGFuMigyICogeCwgMSAtIHgyIC0geTIpIC8gbixcbiAgICAgICAgICAgICAgICBhc2luKCh0IC0gMSkgLyAodCArIDEpKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIHZhciBsYWdyYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG4gPSAwLjUsIG0gPSBkM0dlby5nZW9Qcm9qZWN0aW9uTXV0YXRvcihsYWdyYW5nZVJhdyksIHAgPSBtKG4pO1xuICAgICAgICBwLnNwYWNpbmcgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBtKG4gPSArXykgOiBuO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcFxuICAgICAgICAgICAgLnNjYWxlKDEyNC43NSk7XG4gICAgfTtcbiAgICB2YXIgcGlfc3FydDIgPSBwaSAvIHNxcnQyO1xuICAgIGZ1bmN0aW9uIGxhcnJpdmVlUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsYW1iZGEgKiAoMSArIHNxcnQoY29zKHBoaSkpKSAvIDIsXG4gICAgICAgICAgICBwaGkgLyAoY29zKHBoaSAvIDIpICogY29zKGxhbWJkYSAvIDYpKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBsYXJyaXZlZVJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgeDAgPSBhYnMoeCksIHkwID0gYWJzKHkpLCBsYW1iZGEgPSBlcHNpbG9uLCBwaGkgPSBoYWxmUGk7XG4gICAgICAgIGlmICh5MCA8IHBpX3NxcnQyKVxuICAgICAgICAgICAgcGhpICo9IHkwIC8gcGlfc3FydDI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxhbWJkYSArPSA2ICogYWNvcyhwaV9zcXJ0MiAvIHkwKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2luUGhpID0gc2luKHBoaSksIHNxcnRjb3NQaGkgPSBzcXJ0KGNvcyhwaGkpKSwgc2luUGhpXzIgPSBzaW4ocGhpIC8gMiksIGNvc1BoaV8yID0gY29zKHBoaSAvIDIpLCBzaW5MYW1iZGFfNiA9IHNpbihsYW1iZGEgLyA2KSwgY29zTGFtYmRhXzYgPSBjb3MobGFtYmRhIC8gNiksIGYwID0gMC41ICogbGFtYmRhICogKDEgKyBzcXJ0Y29zUGhpKSAtIHgwLCBmMSA9IHBoaSAvIChjb3NQaGlfMiAqIGNvc0xhbWJkYV82KSAtIHkwLCBkZjBkUGhpID0gc3FydGNvc1BoaSA/IC0wLjI1ICogbGFtYmRhICogc2luUGhpIC8gc3FydGNvc1BoaSA6IDAsIGRmMGRMYW1iZGEgPSAwLjUgKiAoMSArIHNxcnRjb3NQaGkpLCBkZjFkUGhpID0gKDEgKyAwLjUgKiBwaGkgKiBzaW5QaGlfMiAvIGNvc1BoaV8yKSAvIChjb3NQaGlfMiAqIGNvc0xhbWJkYV82KSwgZGYxZExhbWJkYSA9IChwaGkgLyBjb3NQaGlfMikgKiAoc2luTGFtYmRhXzYgLyA2KSAvIChjb3NMYW1iZGFfNiAqIGNvc0xhbWJkYV82KSwgZGVub20gPSBkZjBkUGhpICogZGYxZExhbWJkYSAtIGRmMWRQaGkgKiBkZjBkTGFtYmRhLCBkUGhpID0gKGYwICogZGYxZExhbWJkYSAtIGYxICogZGYwZExhbWJkYSkgLyBkZW5vbSwgZExhbWJkYSA9IChmMSAqIGRmMGRQaGkgLSBmMCAqIGRmMWRQaGkpIC8gZGVub207XG4gICAgICAgICAgICBwaGkgLT0gZFBoaTtcbiAgICAgICAgICAgIGxhbWJkYSAtPSBkTGFtYmRhO1xuICAgICAgICAgICAgaWYgKGFicyhkUGhpKSA8IGVwc2lsb24gJiYgYWJzKGRMYW1iZGEpIDwgZXBzaWxvbilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3ggPCAwID8gLWxhbWJkYSA6IGxhbWJkYSwgeSA8IDAgPyAtcGhpIDogcGhpXTtcbiAgICB9O1xuICAgIHZhciBsYXJyaXZlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24obGFycml2ZWVSYXcpXG4gICAgICAgICAgICAuc2NhbGUoOTcuMjY3Mik7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsYXNrb3dza2lSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIGxhbWJkYTIgPSBsYW1iZGEgKiBsYW1iZGEsIHBoaTIgPSBwaGkgKiBwaGk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsYW1iZGEgKiAoMC45NzU1MzQgKyBwaGkyICogKC0wLjExOTE2MSArIGxhbWJkYTIgKiAtMC4wMTQzMDU5ICsgcGhpMiAqIC0wLjA1NDcwMDkpKSxcbiAgICAgICAgICAgIHBoaSAqICgxLjAwMzg0ICsgbGFtYmRhMiAqICgwLjA4MDI4OTQgKyBwaGkyICogLTAuMDI4NTUgKyBsYW1iZGEyICogMC4wMDAxOTkwMjUpICsgcGhpMiAqICgwLjA5OTg5MDkgKyBwaGkyICogLTAuMDQ5MTAzMikpXG4gICAgICAgIF07XG4gICAgfVxuICAgIGxhc2tvd3NraVJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgbGFtYmRhID0gc2lnbih4KSAqIHBpLCBwaGkgPSB5IC8gMiwgaSA9IDUwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgbGFtYmRhMiA9IGxhbWJkYSAqIGxhbWJkYSwgcGhpMiA9IHBoaSAqIHBoaSwgbGFtYmRhUGhpID0gbGFtYmRhICogcGhpLCBmeCA9IGxhbWJkYSAqICgwLjk3NTUzNCArIHBoaTIgKiAoLTAuMTE5MTYxICsgbGFtYmRhMiAqIC0wLjAxNDMwNTkgKyBwaGkyICogLTAuMDU0NzAwOSkpIC0geCwgZnkgPSBwaGkgKiAoMS4wMDM4NCArIGxhbWJkYTIgKiAoMC4wODAyODk0ICsgcGhpMiAqIC0wLjAyODU1ICsgbGFtYmRhMiAqIDAuMDAwMTk5MDI1KSArIHBoaTIgKiAoMC4wOTk4OTA5ICsgcGhpMiAqIC0wLjA0OTEwMzIpKSAtIHksIGRlbHRheERlbHRhTGFtYmRhID0gMC45NzU1MzQgLSBwaGkyICogKDAuMTE5MTYxICsgMyAqIGxhbWJkYTIgKiAwLjAxNDMwNTkgKyBwaGkyICogMC4wNTQ3MDA5KSwgZGVsdGF4RGVsdGFQaGkgPSAtbGFtYmRhUGhpICogKDIgKiAwLjExOTE2MSArIDQgKiAwLjA1NDcwMDkgKiBwaGkyICsgMiAqIDAuMDE0MzA1OSAqIGxhbWJkYTIpLCBkZWx0YXlEZWx0YUxhbWJkYSA9IGxhbWJkYVBoaSAqICgyICogMC4wODAyODk0ICsgNCAqIDAuMDAwMTk5MDI1ICogbGFtYmRhMiArIDIgKiAtMC4wMjg1NSAqIHBoaTIpLCBkZWx0YXlEZWx0YVBoaSA9IDEuMDAzODQgKyBsYW1iZGEyICogKDAuMDgwMjg5NCArIDAuMDAwMTk5MDI1ICogbGFtYmRhMikgKyBwaGkyICogKDMgKiAoMC4wOTk4OTA5IC0gMC4wMjg1NSAqIGxhbWJkYTIpIC0gNSAqIDAuMDQ5MTAzMiAqIHBoaTIpLCBkZW5vbWluYXRvciA9IGRlbHRheERlbHRhUGhpICogZGVsdGF5RGVsdGFMYW1iZGEgLSBkZWx0YXlEZWx0YVBoaSAqIGRlbHRheERlbHRhTGFtYmRhLCBkZWx0YUxhbWJkYSA9IChmeSAqIGRlbHRheERlbHRhUGhpIC0gZnggKiBkZWx0YXlEZWx0YVBoaSkgLyBkZW5vbWluYXRvciwgZGVsdGFQaGkgPSAoZnggKiBkZWx0YXlEZWx0YUxhbWJkYSAtIGZ5ICogZGVsdGF4RGVsdGFMYW1iZGEpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICBsYW1iZGEgLT0gZGVsdGFMYW1iZGEsIHBoaSAtPSBkZWx0YVBoaTtcbiAgICAgICAgfSB3aGlsZSAoKGFicyhkZWx0YUxhbWJkYSkgPiBlcHNpbG9uIHx8IGFicyhkZWx0YVBoaSkgPiBlcHNpbG9uKSAmJiAtLWkgPiAwKTtcbiAgICAgICAgcmV0dXJuIGkgJiYgW2xhbWJkYSwgcGhpXTtcbiAgICB9O1xuICAgIHZhciBsYXNrb3dza2kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGxhc2tvd3NraVJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxMzkuOTgpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbGl0dHJvd1JhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc2luKGxhbWJkYSkgLyBjb3MocGhpKSxcbiAgICAgICAgICAgIHRhbihwaGkpICogY29zKGxhbWJkYSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgbGl0dHJvd1Jhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgeDIgPSB4ICogeCwgeTIgPSB5ICogeSwgeTJfMSA9IHkyICsgMSwgY29zUGhpID0geFxuICAgICAgICAgICAgPyBzcXJ0MV8yICogc3FydCgoeTJfMSAtIHNxcnQoeDIgKiB4MiArIDIgKiB4MiAqICh5MiAtIDEpICsgeTJfMSAqIHkyXzEpKSAvIHgyICsgMSlcbiAgICAgICAgICAgIDogMSAvIHNxcnQoeTJfMSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBhc2luKHggKiBjb3NQaGkpLFxuICAgICAgICAgICAgc2lnbih5KSAqIGFjb3MoY29zUGhpKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIGxpdHRyb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGxpdHRyb3dSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTQ0LjA0OSlcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoOTAgLSAxZS0zKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxveGltdXRoYWxSYXcocGhpMCkge1xuICAgICAgICB2YXIgY29zUGhpMCA9IGNvcyhwaGkwKSwgdGFuUGhpMCA9IHRhbihxdWFydGVyUGkgKyBwaGkwIC8gMik7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciB5ID0gcGhpIC0gcGhpMCwgeCA9IGFicyh5KSA8IGVwc2lsb24gPyBsYW1iZGEgKiBjb3NQaGkwXG4gICAgICAgICAgICAgICAgOiBhYnMoeCA9IHF1YXJ0ZXJQaSArIHBoaSAvIDIpIDwgZXBzaWxvbiB8fCBhYnMoYWJzKHgpIC0gaGFsZlBpKSA8IGVwc2lsb25cbiAgICAgICAgICAgICAgICAgICAgPyAwIDogbGFtYmRhICogeSAvIGxvZyh0YW4oeCkgLyB0YW5QaGkwKTtcbiAgICAgICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGxhbWJkYSwgcGhpID0geSArIHBoaTA7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGFicyh5KSA8IGVwc2lsb24gPyB4IC8gY29zUGhpMFxuICAgICAgICAgICAgICAgICAgICA6IChhYnMobGFtYmRhID0gcXVhcnRlclBpICsgcGhpIC8gMikgPCBlcHNpbG9uIHx8IGFicyhhYnMobGFtYmRhKSAtIGhhbGZQaSkgPCBlcHNpbG9uKSA/IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogeCAqIGxvZyh0YW4obGFtYmRhKSAvIHRhblBoaTApIC8geSxcbiAgICAgICAgICAgICAgICBwaGlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICB2YXIgbG94aW11dGhhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFsbGVsMShsb3hpbXV0aGFsUmF3KVxuICAgICAgICAgICAgLnBhcmFsbGVsKDQwKVxuICAgICAgICAgICAgLnNjYWxlKDE1OC44MzcpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbWlsbGVyUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJldHVybiBbbGFtYmRhLCAxLjI1ICogbG9nKHRhbihxdWFydGVyUGkgKyAwLjQgKiBwaGkpKV07XG4gICAgfVxuICAgIG1pbGxlclJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gW3gsIDIuNSAqIGF0YW4oZXhwKDAuOCAqIHkpKSAtIDAuNjI1ICogcGldO1xuICAgIH07XG4gICAgdmFyIG1pbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24obWlsbGVyUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDEwOC4zMTgpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbW9kaWZpZWRTdGVyZW9ncmFwaGljUmF3KEMpIHtcbiAgICAgICAgdmFyIG0gPSBDLmxlbmd0aCAtIDE7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKSwgayA9IDIgLyAoMSArIGNvc1BoaSAqIGNvcyhsYW1iZGEpKSwgenIgPSBrICogY29zUGhpICogc2luKGxhbWJkYSksIHppID0gayAqIHNpbihwaGkpLCBpID0gbSwgdyA9IENbaV0sIGFyID0gd1swXSwgYWkgPSB3WzFdLCB0O1xuICAgICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdyA9IENbaV07XG4gICAgICAgICAgICAgICAgYXIgPSB3WzBdICsgenIgKiAodCA9IGFyKSAtIHppICogYWk7XG4gICAgICAgICAgICAgICAgYWkgPSB3WzFdICsgenIgKiBhaSArIHppICogdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyID0genIgKiAodCA9IGFyKSAtIHppICogYWk7XG4gICAgICAgICAgICBhaSA9IHpyICogYWkgKyB6aSAqIHQ7XG4gICAgICAgICAgICByZXR1cm4gW2FyLCBhaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGkgPSAyMCwgenIgPSB4LCB6aSA9IHk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIGogPSBtLCB3ID0gQ1tqXSwgYXIgPSB3WzBdLCBhaSA9IHdbMV0sIGJyID0gMCwgYmkgPSAwLCB0O1xuICAgICAgICAgICAgICAgIHdoaWxlICgtLWogPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB3ID0gQ1tqXTtcbiAgICAgICAgICAgICAgICAgICAgYnIgPSBhciArIHpyICogKHQgPSBicikgLSB6aSAqIGJpO1xuICAgICAgICAgICAgICAgICAgICBiaSA9IGFpICsgenIgKiBiaSArIHppICogdDtcbiAgICAgICAgICAgICAgICAgICAgYXIgPSB3WzBdICsgenIgKiAodCA9IGFyKSAtIHppICogYWk7XG4gICAgICAgICAgICAgICAgICAgIGFpID0gd1sxXSArIHpyICogYWkgKyB6aSAqIHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyID0gYXIgKyB6ciAqICh0ID0gYnIpIC0gemkgKiBiaTtcbiAgICAgICAgICAgICAgICBiaSA9IGFpICsgenIgKiBiaSArIHppICogdDtcbiAgICAgICAgICAgICAgICBhciA9IHpyICogKHQgPSBhcikgLSB6aSAqIGFpIC0geDtcbiAgICAgICAgICAgICAgICBhaSA9IHpyICogYWkgKyB6aSAqIHQgLSB5O1xuICAgICAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IGJyICogYnIgKyBiaSAqIGJpLCBkZWx0YXIsIGRlbHRhaTtcbiAgICAgICAgICAgICAgICB6ciAtPSBkZWx0YXIgPSAoYXIgKiBiciArIGFpICogYmkpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICAgICAgemkgLT0gZGVsdGFpID0gKGFpICogYnIgLSBhciAqIGJpKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgfSB3aGlsZSAoYWJzKGRlbHRhcikgKyBhYnMoZGVsdGFpKSA+IGVwc2lsb24gKiBlcHNpbG9uICYmIC0taSA+IDApO1xuICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmhvID0gc3FydCh6ciAqIHpyICsgemkgKiB6aSksIGMgPSAyICogYXRhbihyaG8gKiAwLjUpLCBzaW5jID0gc2luKGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYXRhbjIoenIgKiBzaW5jLCByaG8gKiBjb3MoYykpLCByaG8gPyBhc2luKHppICogc2luYyAvIHJobykgOiAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIHZhciBhbGFza2EgPSBbWzAuOTk3MjUyMywgMF0sIFswLjAwNTI1MTMsIC0wLjAwNDExNzVdLCBbMC4wMDc0NjA2LCAwLjAwNDgxMjVdLCBbLTAuMDE1Mzc4MywgLTAuMTk2ODI1M10sIFswLjA2MzY4NzEsIC0wLjE0MDgwMjddLCBbMC4zNjYwOTc2LCAtMC4yOTM3MzgyXV07XG4gICAgdmFyIGdzNDggPSBbWzAuOTg4NzksIDBdLCBbMCwgMF0sIFstMC4wNTA5MDksIDBdLCBbMCwgMF0sIFswLjA3NTUyOCwgMF1dO1xuICAgIHZhciBnczUwID0gW1swLjk4NDI5OTAsIDBdLCBbMC4wMjExNjQyLCAwLjAwMzc2MDhdLCBbLTAuMTAzNjAxOCwgLTAuMDU3NTEwMl0sIFstMC4wMzI5MDk1LCAtMC4wMzIwMTE5XSwgWzAuMDQ5OTQ3MSwgMC4xMjIzMzM1XSwgWzAuMDI2MDQ2MCwgMC4wODk5ODA1XSwgWzAuMDAwNzM4OCwgLTAuMTQzNTc5Ml0sIFswLjAwNzU4NDgsIC0wLjEzMzQxMDhdLCBbLTAuMDIxNjQ3MywgMC4wNzc2NjQ1XSwgWy0wLjAyMjUxNjEsIDAuMDg1MzY3M11dO1xuICAgIHZhciBtaWxsZXIkMSA9IFtbMC45MjQ1LCAwXSwgWzAsIDBdLCBbMC4wMTk0MywgMF1dO1xuICAgIHZhciBsZWUgPSBbWzAuNzIxMzE2LCAwXSwgWzAsIDBdLCBbLTAuMDA4ODE2MjUsIC0wLjAwNjE3MzI1XV07XG4gICAgZnVuY3Rpb24gbW9kaWZpZWRTdGVyZW9ncmFwaGljQWxhc2thKCkge1xuICAgICAgICByZXR1cm4gbW9kaWZpZWRTdGVyZW9ncmFwaGljKGFsYXNrYSwgWzE1MiwgLTY0XSlcbiAgICAgICAgICAgIC5zY2FsZSgxNTAwKVxuICAgICAgICAgICAgLmNlbnRlcihbLTE2MC45MDgsIDYyLjQ4NjRdKVxuICAgICAgICAgICAgLmNsaXBBbmdsZSgyNSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vZGlmaWVkU3RlcmVvZ3JhcGhpY0dzNDgoKSB7XG4gICAgICAgIHJldHVybiBtb2RpZmllZFN0ZXJlb2dyYXBoaWMoZ3M0OCwgWzk1LCAtMzhdKVxuICAgICAgICAgICAgLnNjYWxlKDEwMDApXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDU1KVxuICAgICAgICAgICAgLmNlbnRlcihbLTk2LjU1NjMsIDM4Ljg2NzVdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kaWZpZWRTdGVyZW9ncmFwaGljR3M1MCgpIHtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVkU3RlcmVvZ3JhcGhpYyhnczUwLCBbMTIwLCAtNDVdKVxuICAgICAgICAgICAgLnNjYWxlKDM1OS41MTMpXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDU1KVxuICAgICAgICAgICAgLmNlbnRlcihbLTExNy40NzQsIDUzLjA2MjhdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kaWZpZWRTdGVyZW9ncmFwaGljTWlsbGVyKCkge1xuICAgICAgICByZXR1cm4gbW9kaWZpZWRTdGVyZW9ncmFwaGljKG1pbGxlciQxLCBbLTIwLCAtMThdKVxuICAgICAgICAgICAgLnNjYWxlKDIwOS4wOTEpXG4gICAgICAgICAgICAuY2VudGVyKFsyMCwgMTYuNzIxNF0pXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDgyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kaWZpZWRTdGVyZW9ncmFwaGljTGVlKCkge1xuICAgICAgICByZXR1cm4gbW9kaWZpZWRTdGVyZW9ncmFwaGljKGxlZSwgWzE2NSwgMTBdKVxuICAgICAgICAgICAgLnNjYWxlKDI1MClcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoMTMwKVxuICAgICAgICAgICAgLmNlbnRlcihbLTE2NSwgLTEwXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vZGlmaWVkU3RlcmVvZ3JhcGhpYyhjb2VmZmljaWVudHMsIHJvdGF0ZSkge1xuICAgICAgICB2YXIgcCA9IGQzR2VvLmdlb1Byb2plY3Rpb24obW9kaWZpZWRTdGVyZW9ncmFwaGljUmF3KGNvZWZmaWNpZW50cykpLnJvdGF0ZShyb3RhdGUpLmNsaXBBbmdsZSg5MCksIHIgPSBkM0dlby5nZW9Sb3RhdGlvbihyb3RhdGUpLCBjZW50ZXIgPSBwLmNlbnRlcjtcbiAgICAgICAgZGVsZXRlIHAucm90YXRlO1xuICAgICAgICBwLmNlbnRlciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGNlbnRlcihyKF8pKSA6IHIuaW52ZXJ0KGNlbnRlcigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIHZhciBzcXJ0NiA9IHNxcnQoNik7XG4gICAgdmFyIHNxcnQ3ID0gc3FydCg3KTtcbiAgICBmdW5jdGlvbiBtdEZsYXRQb2xhclBhcmFib2xpY1JhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgdGhldGEgPSBhc2luKDcgKiBzaW4ocGhpKSAvICgzICogc3FydDYpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHNxcnQ2ICogbGFtYmRhICogKDIgKiBjb3MoMiAqIHRoZXRhIC8gMykgLSAxKSAvIHNxcnQ3LFxuICAgICAgICAgICAgOSAqIHNpbih0aGV0YSAvIDMpIC8gc3FydDdcbiAgICAgICAgXTtcbiAgICB9XG4gICAgbXRGbGF0UG9sYXJQYXJhYm9saWNSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHRoZXRhID0gMyAqIGFzaW4oeSAqIHNxcnQ3IC8gOSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB4ICogc3FydDcgLyAoc3FydDYgKiAoMiAqIGNvcygyICogdGhldGEgLyAzKSAtIDEpKSxcbiAgICAgICAgICAgIGFzaW4oc2luKHRoZXRhKSAqIDMgKiBzcXJ0NiAvIDcpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgbXRGbGF0UG9sYXJQYXJhYm9saWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKG10RmxhdFBvbGFyUGFyYWJvbGljUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE2NC44NTkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbXRGbGF0UG9sYXJRdWFydGljUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBrID0gKDEgKyBzcXJ0MV8yKSAqIHNpbihwaGkpLCB0aGV0YSA9IHBoaTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGRlbHRhOyBpIDwgMjU7IGkrKykge1xuICAgICAgICAgICAgdGhldGEgLT0gZGVsdGEgPSAoc2luKHRoZXRhIC8gMikgKyBzaW4odGhldGEpIC0gaykgLyAoMC41ICogY29zKHRoZXRhIC8gMikgKyBjb3ModGhldGEpKTtcbiAgICAgICAgICAgIGlmIChhYnMoZGVsdGEpIDwgZXBzaWxvbilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbGFtYmRhICogKDEgKyAyICogY29zKHRoZXRhKSAvIGNvcyh0aGV0YSAvIDIpKSAvICgzICogc3FydDIpLFxuICAgICAgICAgICAgMiAqIHNxcnQoMykgKiBzaW4odGhldGEgLyAyKSAvIHNxcnQoMiArIHNxcnQyKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBtdEZsYXRQb2xhclF1YXJ0aWNSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHNpblRoZXRhXzIgPSB5ICogc3FydCgyICsgc3FydDIpIC8gKDIgKiBzcXJ0KDMpKSwgdGhldGEgPSAyICogYXNpbihzaW5UaGV0YV8yKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDMgKiBzcXJ0MiAqIHggLyAoMSArIDIgKiBjb3ModGhldGEpIC8gY29zKHRoZXRhIC8gMikpLFxuICAgICAgICAgICAgYXNpbigoc2luVGhldGFfMiArIHNpbih0aGV0YSkpIC8gKDEgKyBzcXJ0MV8yKSlcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIHZhciBtdEZsYXRQb2xhclF1YXJ0aWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKG10RmxhdFBvbGFyUXVhcnRpY1JhdylcbiAgICAgICAgICAgIC5zY2FsZSgxODguMjA5KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG10RmxhdFBvbGFyU2ludXNvaWRhbFJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgQSA9IHNxcnQoNiAvICg0ICsgcGkpKSwgayA9ICgxICsgcGkgLyA0KSAqIHNpbihwaGkpLCB0aGV0YSA9IHBoaSAvIDI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBkZWx0YTsgaSA8IDI1OyBpKyspIHtcbiAgICAgICAgICAgIHRoZXRhIC09IGRlbHRhID0gKHRoZXRhIC8gMiArIHNpbih0aGV0YSkgLSBrKSAvICgwLjUgKyBjb3ModGhldGEpKTtcbiAgICAgICAgICAgIGlmIChhYnMoZGVsdGEpIDwgZXBzaWxvbilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgQSAqICgwLjUgKyBjb3ModGhldGEpKSAqIGxhbWJkYSAvIDEuNSxcbiAgICAgICAgICAgIEEgKiB0aGV0YVxuICAgICAgICBdO1xuICAgIH1cbiAgICBtdEZsYXRQb2xhclNpbnVzb2lkYWxSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIEEgPSBzcXJ0KDYgLyAoNCArIHBpKSksIHRoZXRhID0geSAvIEE7XG4gICAgICAgIGlmIChhYnMoYWJzKHRoZXRhKSAtIGhhbGZQaSkgPCBlcHNpbG9uKVxuICAgICAgICAgICAgdGhldGEgPSB0aGV0YSA8IDAgPyAtaGFsZlBpIDogaGFsZlBpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMS41ICogeCAvIChBICogKDAuNSArIGNvcyh0aGV0YSkpKSxcbiAgICAgICAgICAgIGFzaW4oKHRoZXRhIC8gMiArIHNpbih0aGV0YSkpIC8gKDEgKyBwaSAvIDQpKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIG10RmxhdFBvbGFyU2ludXNvaWRhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24obXRGbGF0UG9sYXJTaW51c29pZGFsUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE2Ni41MTgpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmF0dXJhbEVhcnRoUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBwaGkyID0gcGhpICogcGhpLCBwaGk0ID0gcGhpMiAqIHBoaTI7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsYW1iZGEgKiAoMC44NzA3IC0gMC4xMzE5NzkgKiBwaGkyICsgcGhpNCAqICgtMC4wMTM3OTEgKyBwaGk0ICogKDAuMDAzOTcxICogcGhpMiAtIDAuMDAxNTI5ICogcGhpNCkpKSxcbiAgICAgICAgICAgIHBoaSAqICgxLjAwNzIyNiArIHBoaTIgKiAoMC4wMTUwODUgKyBwaGk0ICogKC0wLjA0NDQ3NSArIDAuMDI4ODc0ICogcGhpMiAtIDAuMDA1OTE2ICogcGhpNCkpKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBuYXR1cmFsRWFydGhSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHBoaSA9IHksIGkgPSAyNSwgZGVsdGE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBwaGkyID0gcGhpICogcGhpLCBwaGk0ID0gcGhpMiAqIHBoaTI7XG4gICAgICAgICAgICBwaGkgLT0gZGVsdGEgPSAocGhpICogKDEuMDA3MjI2ICsgcGhpMiAqICgwLjAxNTA4NSArIHBoaTQgKiAoLTAuMDQ0NDc1ICsgMC4wMjg4NzQgKiBwaGkyIC0gMC4wMDU5MTYgKiBwaGk0KSkpIC0geSkgL1xuICAgICAgICAgICAgICAgICgxLjAwNzIyNiArIHBoaTIgKiAoMC4wMTUwODUgKiAzICsgcGhpNCAqICgtMC4wNDQ0NzUgKiA3ICsgMC4wMjg4NzQgKiA5ICogcGhpMiAtIDAuMDA1OTE2ICogMTEgKiBwaGk0KSkpO1xuICAgICAgICB9IHdoaWxlIChhYnMoZGVsdGEpID4gZXBzaWxvbiAmJiAtLWkgPiAwKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHggLyAoMC44NzA3ICsgKHBoaTIgPSBwaGkgKiBwaGkpICogKC0wLjEzMTk3OSArIHBoaTIgKiAoLTAuMDEzNzkxICsgcGhpMiAqIHBoaTIgKiBwaGkyICogKDAuMDAzOTcxIC0gMC4wMDE1MjkgKiBwaGkyKSkpKSxcbiAgICAgICAgICAgIHBoaVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIG5hdHVyYWxFYXJ0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24obmF0dXJhbEVhcnRoUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE3NS4yOTUpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmF0dXJhbEVhcnRoMlJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgcGhpMiA9IHBoaSAqIHBoaSwgcGhpNCA9IHBoaTIgKiBwaGkyLCBwaGk2ID0gcGhpMiAqIHBoaTQ7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsYW1iZGEgKiAoMC44NDcxOSAtIDAuMTMwNjMgKiBwaGkyICsgcGhpNiAqIHBoaTYgKiAoLTAuMDQ1MTUgKyAwLjA1NDk0ICogcGhpMiAtIDAuMDIzMjYgKiBwaGk0ICsgMC4wMDMzMSAqIHBoaTYpKSxcbiAgICAgICAgICAgIHBoaSAqICgxLjAxMTgzICsgcGhpNCAqIHBoaTQgKiAoLTAuMDI2MjUgKyAwLjAxOTI2ICogcGhpMiAtIDAuMDAzOTYgKiBwaGk0KSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgbmF0dXJhbEVhcnRoMlJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgcGhpID0geSwgaSA9IDI1LCBkZWx0YSwgcGhpMiwgcGhpNCwgcGhpNjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcGhpMiA9IHBoaSAqIHBoaTtcbiAgICAgICAgICAgIHBoaTQgPSBwaGkyICogcGhpMjtcbiAgICAgICAgICAgIHBoaSAtPSBkZWx0YSA9ICgocGhpICogKDEuMDExODMgKyBwaGk0ICogcGhpNCAqICgtMC4wMjYyNSArIDAuMDE5MjYgKiBwaGkyIC0gMC4wMDM5NiAqIHBoaTQpKSkgLSB5KSAvXG4gICAgICAgICAgICAgICAgKDEuMDExODMgKyBwaGk0ICogcGhpNCAqICgoOSAqIC0wLjAyNjI1KSArICgxMSAqIDAuMDE5MjYpICogcGhpMiArICgxMyAqIC0wLjAwMzk2KSAqIHBoaTQpKTtcbiAgICAgICAgfSB3aGlsZSAoYWJzKGRlbHRhKSA+IGVwc2lsb24yICYmIC0taSA+IDApO1xuICAgICAgICBwaGkyID0gcGhpICogcGhpO1xuICAgICAgICBwaGk0ID0gcGhpMiAqIHBoaTI7XG4gICAgICAgIHBoaTYgPSBwaGkyICogcGhpNDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHggLyAoMC44NDcxOSAtIDAuMTMwNjMgKiBwaGkyICsgcGhpNiAqIHBoaTYgKiAoLTAuMDQ1MTUgKyAwLjA1NDk0ICogcGhpMiAtIDAuMDIzMjYgKiBwaGk0ICsgMC4wMDMzMSAqIHBoaTYpKSxcbiAgICAgICAgICAgIHBoaVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIG5hdHVyYWxFYXJ0aDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKG5hdHVyYWxFYXJ0aDJSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTc1LjI5NSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZWxsSGFtbWVyUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsYW1iZGEgKiAoMSArIGNvcyhwaGkpKSAvIDIsXG4gICAgICAgICAgICAyICogKHBoaSAtIHRhbihwaGkgLyAyKSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgbmVsbEhhbW1lclJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgcCA9IHkgLyAyO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgZGVsdGEgPSBJbmZpbml0eTsgaSA8IDEwICYmIGFicyhkZWx0YSkgPiBlcHNpbG9uOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0gY29zKHkgLyAyKTtcbiAgICAgICAgICAgIHkgLT0gZGVsdGEgPSAoeSAtIHRhbih5IC8gMikgLSBwKSAvICgxIC0gMC41IC8gKGMgKiBjKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDIgKiB4IC8gKDEgKyBjb3MoeSkpLFxuICAgICAgICAgICAgeVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIG5lbGxIYW1tZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKG5lbGxIYW1tZXJSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTUyLjYzKTtcbiAgICB9O1xuICAgIC8vIEJhc2VkIG9uIEphdmEgaW1wbGVtZW50YXRpb24gYnkgQm9qYW4gU2F2cmljLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9PU1VDYXJ0b2dyYXBoeS9KTWFwUHJvakxpYi9ibG9iL21hc3Rlci9zcmMvY29tL2pobGFicy9tYXAvcHJvai9QYXR0ZXJzb25Qcm9qZWN0aW9uLmphdmFcbiAgICB2YXIgcGF0dGVyc29uSzEgPSAxLjAxNDg7XG4gICAgdmFyIHBhdHRlcnNvbksyID0gMC4yMzE4NTtcbiAgICB2YXIgcGF0dGVyc29uSzMgPSAtMC4xNDQ5OTtcbiAgICB2YXIgcGF0dGVyc29uSzQgPSAwLjAyNDA2O1xuICAgIHZhciBwYXR0ZXJzb25DMSA9IHBhdHRlcnNvbksxO1xuICAgIHZhciBwYXR0ZXJzb25DMiA9IDUgKiBwYXR0ZXJzb25LMjtcbiAgICB2YXIgcGF0dGVyc29uQzMgPSA3ICogcGF0dGVyc29uSzM7XG4gICAgdmFyIHBhdHRlcnNvbkM0ID0gOSAqIHBhdHRlcnNvbks0O1xuICAgIHZhciBwYXR0ZXJzb25ZbWF4ID0gMS43OTA4NTcxODM7XG4gICAgZnVuY3Rpb24gcGF0dGVyc29uUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBwaGkyID0gcGhpICogcGhpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbGFtYmRhLFxuICAgICAgICAgICAgcGhpICogKHBhdHRlcnNvbksxICsgcGhpMiAqIHBoaTIgKiAocGF0dGVyc29uSzIgKyBwaGkyICogKHBhdHRlcnNvbkszICsgcGF0dGVyc29uSzQgKiBwaGkyKSkpXG4gICAgICAgIF07XG4gICAgfVxuICAgIHBhdHRlcnNvblJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoeSA+IHBhdHRlcnNvblltYXgpXG4gICAgICAgICAgICB5ID0gcGF0dGVyc29uWW1heDtcbiAgICAgICAgZWxzZSBpZiAoeSA8IC1wYXR0ZXJzb25ZbWF4KVxuICAgICAgICAgICAgeSA9IC1wYXR0ZXJzb25ZbWF4O1xuICAgICAgICB2YXIgeWMgPSB5LCBkZWx0YTtcbiAgICAgICAgZG8geyAvLyBOZXd0b24tUmFwaHNvblxuICAgICAgICAgICAgdmFyIHkyID0geWMgKiB5YztcbiAgICAgICAgICAgIHljIC09IGRlbHRhID0gKCh5YyAqIChwYXR0ZXJzb25LMSArIHkyICogeTIgKiAocGF0dGVyc29uSzIgKyB5MiAqIChwYXR0ZXJzb25LMyArIHBhdHRlcnNvbks0ICogeTIpKSkpIC0geSkgLyAocGF0dGVyc29uQzEgKyB5MiAqIHkyICogKHBhdHRlcnNvbkMyICsgeTIgKiAocGF0dGVyc29uQzMgKyBwYXR0ZXJzb25DNCAqIHkyKSkpO1xuICAgICAgICB9IHdoaWxlIChhYnMoZGVsdGEpID4gZXBzaWxvbik7XG4gICAgICAgIHJldHVybiBbeCwgeWNdO1xuICAgIH07XG4gICAgdmFyIHBhdHRlcnNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24ocGF0dGVyc29uUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDEzOS4zMTkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcG9seWNvbmljUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGlmIChhYnMocGhpKSA8IGVwc2lsb24pXG4gICAgICAgICAgICByZXR1cm4gW2xhbWJkYSwgMF07XG4gICAgICAgIHZhciB0YW5QaGkgPSB0YW4ocGhpKSwgayA9IGxhbWJkYSAqIHNpbihwaGkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc2luKGspIC8gdGFuUGhpLFxuICAgICAgICAgICAgcGhpICsgKDEgLSBjb3MoaykpIC8gdGFuUGhpXG4gICAgICAgIF07XG4gICAgfVxuICAgIHBvbHljb25pY1Jhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoYWJzKHkpIDwgZXBzaWxvbilcbiAgICAgICAgICAgIHJldHVybiBbeCwgMF07XG4gICAgICAgIHZhciBrID0geCAqIHggKyB5ICogeSwgcGhpID0geSAqIDAuNSwgaSA9IDEwLCBkZWx0YTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIHRhblBoaSA9IHRhbihwaGkpLCBzZWNQaGkgPSAxIC8gY29zKHBoaSksIGogPSBrIC0gMiAqIHkgKiBwaGkgKyBwaGkgKiBwaGk7XG4gICAgICAgICAgICBwaGkgLT0gZGVsdGEgPSAodGFuUGhpICogaiArIDIgKiAocGhpIC0geSkpIC8gKDIgKyBqICogc2VjUGhpICogc2VjUGhpICsgMiAqIChwaGkgLSB5KSAqIHRhblBoaSk7XG4gICAgICAgIH0gd2hpbGUgKGFicyhkZWx0YSkgPiBlcHNpbG9uICYmIC0taSA+IDApO1xuICAgICAgICB0YW5QaGkgPSB0YW4ocGhpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIChhYnMoeSkgPCBhYnMocGhpICsgMSAvIHRhblBoaSkgPyBhc2luKHggKiB0YW5QaGkpIDogc2lnbih4KSAqIChhY29zKGFicyh4ICogdGFuUGhpKSkgKyBoYWxmUGkpKSAvIHNpbihwaGkpLFxuICAgICAgICAgICAgcGhpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgcG9seWNvbmljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihwb2x5Y29uaWNSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTAzLjc0KTtcbiAgICB9O1xuICAgIC8vIE5vdGU6IDYtZWxlbWVudCBhcnJheXMgYXJlIHVzZWQgdG8gZGVub3RlIHRoZSAzeDMgYWZmaW5lIHRyYW5zZm9ybSBtYXRyaXg6XG4gICAgLy8gW2EsIGIsIGMsXG4gICAgLy8gIGQsIGUsIGYsXG4gICAgLy8gIDAsIDAsIDFdIC0gdGhpcyByZWR1bmRhbnQgcm93IGlzIGxlZnQgb3V0LlxuICAgIC8vIFRyYW5zZm9ybSBtYXRyaXggZm9yIFthMCwgYTFdIC0+IFtiMCwgYjFdLlxuICAgIHZhciBtYXRyaXggPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgdSA9IHN1YnRyYWN0KGFbMV0sIGFbMF0pLCB2ID0gc3VidHJhY3QoYlsxXSwgYlswXSksIHBoaSA9IGFuZ2xlJDEodSwgdiksIHMgPSBsZW5ndGgodSkgLyBsZW5ndGgodik7XG4gICAgICAgIHJldHVybiBtdWx0aXBseShbXG4gICAgICAgICAgICAxLCAwLCBhWzBdWzBdLFxuICAgICAgICAgICAgMCwgMSwgYVswXVsxXVxuICAgICAgICBdLCBtdWx0aXBseShbXG4gICAgICAgICAgICBzLCAwLCAwLFxuICAgICAgICAgICAgMCwgcywgMFxuICAgICAgICBdLCBtdWx0aXBseShbXG4gICAgICAgICAgICBjb3MocGhpKSwgc2luKHBoaSksIDAsXG4gICAgICAgICAgICAtc2luKHBoaSksIGNvcyhwaGkpLCAwXG4gICAgICAgIF0sIFtcbiAgICAgICAgICAgIDEsIDAsIC1iWzBdWzBdLFxuICAgICAgICAgICAgMCwgMSwgLWJbMF1bMV1cbiAgICAgICAgXSkpKTtcbiAgICB9O1xuICAgIC8vIEludmVydHMgYSB0cmFuc2Zvcm0gbWF0cml4LlxuICAgIGZ1bmN0aW9uIGludmVyc2UobSkge1xuICAgICAgICB2YXIgayA9IDEgLyAobVswXSAqIG1bNF0gLSBtWzFdICogbVszXSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBrICogbVs0XSwgLWsgKiBtWzFdLCBrICogKG1bMV0gKiBtWzVdIC0gbVsyXSAqIG1bNF0pLFxuICAgICAgICAgICAgLWsgKiBtWzNdLCBrICogbVswXSwgayAqIChtWzJdICogbVszXSAtIG1bMF0gKiBtWzVdKVxuICAgICAgICBdO1xuICAgIH1cbiAgICAvLyBNdWx0aXBsaWVzIHR3byAzeDIgbWF0cmljZXMuXG4gICAgZnVuY3Rpb24gbXVsdGlwbHkoYSwgYikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYVswXSAqIGJbMF0gKyBhWzFdICogYlszXSxcbiAgICAgICAgICAgIGFbMF0gKiBiWzFdICsgYVsxXSAqIGJbNF0sXG4gICAgICAgICAgICBhWzBdICogYlsyXSArIGFbMV0gKiBiWzVdICsgYVsyXSxcbiAgICAgICAgICAgIGFbM10gKiBiWzBdICsgYVs0XSAqIGJbM10sXG4gICAgICAgICAgICBhWzNdICogYlsxXSArIGFbNF0gKiBiWzRdLFxuICAgICAgICAgICAgYVszXSAqIGJbMl0gKyBhWzRdICogYls1XSArIGFbNV1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgLy8gU3VidHJhY3RzIDJEIHZlY3RvcnMuXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYikge1xuICAgICAgICByZXR1cm4gW2FbMF0gLSBiWzBdLCBhWzFdIC0gYlsxXV07XG4gICAgfVxuICAgIC8vIE1hZ25pdHVkZSBvZiBhIDJEIHZlY3Rvci5cbiAgICBmdW5jdGlvbiBsZW5ndGgodikge1xuICAgICAgICByZXR1cm4gc3FydCh2WzBdICogdlswXSArIHZbMV0gKiB2WzFdKTtcbiAgICB9XG4gICAgLy8gQW5nbGUgYmV0d2VlbiB0d28gMkQgdmVjdG9ycy5cbiAgICBmdW5jdGlvbiBhbmdsZSQxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGF0YW4yKGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF0sIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0pO1xuICAgIH1cbiAgICAvLyBDcmVhdGVzIGEgcG9seWhlZHJhbCBwcm9qZWN0aW9uLlxuICAgIC8vICAqIHJvb3Q6IGEgc3Bhbm5pbmcgdHJlZSBvZiBwb2x5Z29uIGZhY2VzLiAgTm9kZXMgYXJlIGF1dG9tYXRpY2FsbHlcbiAgICAvLyAgICBhdWdtZW50ZWQgd2l0aCBhIHRyYW5zZm9ybSBtYXRyaXguXG4gICAgLy8gICogZmFjZTogYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGFwcHJvcHJpYXRlIG5vZGUgZm9yIGEgZ2l2ZW4ge2xhbWJkYSwgcGhpfVxuICAgIC8vICAgIHBvaW50IChyYWRpYW5zKS5cbiAgICAvLyAgKiByOiByb3RhdGlvbiBhbmdsZSBmb3IgZmluYWwgcG9seWhlZHJhbCBuZXQuICBEZWZhdWx0cyB0byAtcGkgLyA2IChmb3JcbiAgICAvLyAgICBidXR0ZXJmbGllcykuXG4gICAgdmFyIHBvbHloZWRyYWwgPSBmdW5jdGlvbiAocm9vdCwgZmFjZSwgcikge1xuICAgICAgICByID0gciA9PSBudWxsID8gLXBpIC8gNiA6IHI7IC8vIFRPRE8gYXV0b21hdGVcbiAgICAgICAgcmVjdXJzZShyb290LCB7IHRyYW5zZm9ybTogW1xuICAgICAgICAgICAgICAgIGNvcyhyKSwgc2luKHIpLCAwLFxuICAgICAgICAgICAgICAgIC1zaW4ociksIGNvcyhyKSwgMFxuICAgICAgICAgICAgXSB9KTtcbiAgICAgICAgZnVuY3Rpb24gcmVjdXJzZShub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIG5vZGUuZWRnZXMgPSBmYWNlRWRnZXMobm9kZS5mYWNlKTtcbiAgICAgICAgICAgIC8vIEZpbmQgc2hhcmVkIGVkZ2UuXG4gICAgICAgICAgICBpZiAocGFyZW50LmZhY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcmVkID0gbm9kZS5zaGFyZWQgPSBzaGFyZWRFZGdlKG5vZGUuZmFjZSwgcGFyZW50LmZhY2UpLCBtID0gbWF0cml4KHNoYXJlZC5tYXAocGFyZW50LnByb2plY3QpLCBzaGFyZWQubWFwKG5vZGUucHJvamVjdCkpO1xuICAgICAgICAgICAgICAgIG5vZGUudHJhbnNmb3JtID0gcGFyZW50LnRyYW5zZm9ybSA/IG11bHRpcGx5KHBhcmVudC50cmFuc2Zvcm0sIG0pIDogbTtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHNoYXJlZCBlZGdlIGluIHBhcmVudCBlZGdlcyBhcnJheS5cbiAgICAgICAgICAgICAgICB2YXIgZWRnZXMgPSBwYXJlbnQuZWRnZXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBlZGdlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50RXF1YWwkMShzaGFyZWRbMF0sIGVkZ2VzW2ldWzFdKSAmJiBwb2ludEVxdWFsJDEoc2hhcmVkWzFdLCBlZGdlc1tpXVswXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlc1tpXSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludEVxdWFsJDEoc2hhcmVkWzBdLCBlZGdlc1tpXVswXSkgJiYgcG9pbnRFcXVhbCQxKHNoYXJlZFsxXSwgZWRnZXNbaV1bMV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXNbaV0gPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlZGdlcyA9IG5vZGUuZWRnZXM7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbiA9IGVkZ2VzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRFcXVhbCQxKHNoYXJlZFswXSwgZWRnZXNbaV1bMF0pICYmIHBvaW50RXF1YWwkMShzaGFyZWRbMV0sIGVkZ2VzW2ldWzFdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzW2ldID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRFcXVhbCQxKHNoYXJlZFswXSwgZWRnZXNbaV1bMV0pICYmIHBvaW50RXF1YWwkMShzaGFyZWRbMV0sIGVkZ2VzW2ldWzBdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzW2ldID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUudHJhbnNmb3JtID0gcGFyZW50LnRyYW5zZm9ybTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICByZWN1cnNlKGNoaWxkLCBub2RlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZmFjZShsYW1iZGEsIHBoaSksIHBvaW50ID0gbm9kZS5wcm9qZWN0KFtsYW1iZGEgKiBkZWdyZWVzLCBwaGkgKiBkZWdyZWVzXSksIHQ7XG4gICAgICAgICAgICBpZiAodCA9IG5vZGUudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgdFswXSAqIHBvaW50WzBdICsgdFsxXSAqIHBvaW50WzFdICsgdFsyXSxcbiAgICAgICAgICAgICAgICAgICAgLSh0WzNdICogcG9pbnRbMF0gKyB0WzRdICogcG9pbnRbMV0gKyB0WzVdKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludFsxXSA9IC1wb2ludFsxXTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOYWl2ZSBpbnZlcnNlISAgQSBmYXN0ZXIgc29sdXRpb24gd291bGQgdXNlIGJvdW5kaW5nIGJveGVzLCBvciBldmVuIGFcbiAgICAgICAgLy8gcG9seWdvbmFsIHF1YWR0cmVlLlxuICAgICAgICBpZiAoaGFzSW52ZXJzZShyb290KSlcbiAgICAgICAgICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBmYWNlSW52ZXJ0KHJvb3QsIFt4LCAteV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb29yZGluYXRlcyAmJiAoY29vcmRpbmF0ZXNbMF0gKj0gcmFkaWFucywgY29vcmRpbmF0ZXNbMV0gKj0gcmFkaWFucywgY29vcmRpbmF0ZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gZmFjZUludmVydChub2RlLCBjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIGludmVydCA9IG5vZGUucHJvamVjdC5pbnZlcnQsIHQgPSBub2RlLnRyYW5zZm9ybSwgcG9pbnQgPSBjb29yZGluYXRlcztcbiAgICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICAgICAgdCA9IGludmVyc2UodCk7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIHRbMF0gKiBwb2ludFswXSArIHRbMV0gKiBwb2ludFsxXSArIHRbMl0sXG4gICAgICAgICAgICAgICAgICAgICh0WzNdICogcG9pbnRbMF0gKyB0WzRdICogcG9pbnRbMV0gKyB0WzVdKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW52ZXJ0ICYmIG5vZGUgPT09IGZhY2VEZWdyZWVzKHAgPSBpbnZlcnQocG9pbnQpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIHZhciBwLCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChwID0gZmFjZUludmVydChjaGlsZHJlbltpXSwgY29vcmRpbmF0ZXMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmYWNlRGVncmVlcyhjb29yZGluYXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhY2UoY29vcmRpbmF0ZXNbMF0gKiByYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIHJhZGlhbnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9qID0gZDNHZW8uZ2VvUHJvamVjdGlvbihmb3J3YXJkKSwgc3RyZWFtXyA9IHByb2ouc3RyZWFtO1xuICAgICAgICBwcm9qLnN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciByb3RhdGUgPSBwcm9qLnJvdGF0ZSgpLCByb3RhdGVTdHJlYW0gPSBzdHJlYW1fKHN0cmVhbSksIHNwaGVyZVN0cmVhbSA9IChwcm9qLnJvdGF0ZShbMCwgMF0pLCBzdHJlYW1fKHN0cmVhbSkpO1xuICAgICAgICAgICAgcHJvai5yb3RhdGUocm90YXRlKTtcbiAgICAgICAgICAgIHJvdGF0ZVN0cmVhbS5zcGhlcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3BoZXJlU3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgICAgICAgIHNwaGVyZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICBvdXRsaW5lKHNwaGVyZVN0cmVhbSwgcm9vdCk7XG4gICAgICAgICAgICAgICAgc3BoZXJlU3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByb3RhdGVTdHJlYW07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcm9qO1xuICAgIH07XG4gICAgZnVuY3Rpb24gb3V0bGluZShzdHJlYW0sIG5vZGUsIHBhcmVudCkge1xuICAgICAgICB2YXIgcG9pbnQsIGVkZ2VzID0gbm9kZS5lZGdlcywgbiA9IGVkZ2VzLmxlbmd0aCwgZWRnZSwgbXVsdGlQb2ludCA9IHsgdHlwZTogXCJNdWx0aVBvaW50XCIsIGNvb3JkaW5hdGVzOiBub2RlLmZhY2UgfSwgbm90UG9sZXMgPSBub2RlLmZhY2UuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBhYnMoZFsxXSkgIT09IDkwOyB9KSwgYiA9IGQzR2VvLmdlb0JvdW5kcyh7IHR5cGU6IFwiTXVsdGlQb2ludFwiLCBjb29yZGluYXRlczogbm90UG9sZXMgfSksIGluc2lkZSA9IGZhbHNlLCBqID0gLTEsIGR4ID0gYlsxXVswXSAtIGJbMF1bMF07XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgdmFyIGMgPSBkeCA9PT0gMTgwIHx8IGR4ID09PSAzNjBcbiAgICAgICAgICAgID8gWyhiWzBdWzBdICsgYlsxXVswXSkgLyAyLCAoYlswXVsxXSArIGJbMV1bMV0pIC8gMl1cbiAgICAgICAgICAgIDogZDNHZW8uZ2VvQ2VudHJvaWQobXVsdGlQb2ludCk7XG4gICAgICAgIC8vIEZpcnN0IGZpbmQgdGhlIHNoYXJlZCBlZGdl4oCmXG4gICAgICAgIGlmIChwYXJlbnQpXG4gICAgICAgICAgICB3aGlsZSAoKytqIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChlZGdlc1tqXSA9PT0gcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgKytqO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgZWRnZSA9IGVkZ2VzWyhpICsgaikgJSBuXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVkZ2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KChwb2ludCA9IGQzR2VvLmdlb0ludGVycG9sYXRlKGVkZ2VbMF0sIGMpKGVwc2lsb24pKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQoKHBvaW50ID0gZDNHZW8uZ2VvSW50ZXJwb2xhdGUoZWRnZVsxXSwgYykoZXBzaWxvbikpWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZSAhPT0gcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICBvdXRsaW5lKHN0cmVhbSwgZWRnZSwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGVzdHMgZXF1YWxpdHkgb2YgdHdvIHNwaGVyaWNhbCBwb2ludHMuXG4gICAgZnVuY3Rpb24gcG9pbnRFcXVhbCQxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgJiYgYiAmJiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV07XG4gICAgfVxuICAgIC8vIEZpbmRzIGEgc2hhcmVkIGVkZ2UgZ2l2ZW4gdHdvIGNsb2Nrd2lzZSBwb2x5Z29ucy5cbiAgICBmdW5jdGlvbiBzaGFyZWRFZGdlKGEsIGIpIHtcbiAgICAgICAgdmFyIHgsIHksIG4gPSBhLmxlbmd0aCwgZm91bmQgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgeCA9IGFbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gYi5sZW5ndGg7IC0taiA+PSAwOykge1xuICAgICAgICAgICAgICAgIHkgPSBiW2pdO1xuICAgICAgICAgICAgICAgIGlmICh4WzBdID09PSB5WzBdICYmIHhbMV0gPT09IHlbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtmb3VuZCwgeF07XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29udmVydHMgYW4gYXJyYXkgb2YgbiBmYWNlIHZlcnRpY2VzIHRvIGFuIGFycmF5IG9mIG4gKyAxIGVkZ2VzLlxuICAgIGZ1bmN0aW9uIGZhY2VFZGdlcyhmYWNlKSB7XG4gICAgICAgIHZhciBuID0gZmFjZS5sZW5ndGgsIGVkZ2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGEgPSBmYWNlW24gLSAxXSwgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgICAgICAgICBlZGdlcy5wdXNoKFthLCBhID0gZmFjZVtpXV0pO1xuICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc0ludmVyc2Uobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5wcm9qZWN0LmludmVydCB8fCBub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4uc29tZShoYXNJbnZlcnNlKTtcbiAgICB9XG4gICAgLy8gVE9ETyBnZW5lcmF0ZSBvbi10aGUtZmx5IHRvIGF2b2lkIGV4dGVybmFsIG1vZGlmaWNhdGlvbi5cbiAgICB2YXIgb2N0YWhlZHJvbiA9IFtcbiAgICAgICAgWzAsIDkwXSxcbiAgICAgICAgWy05MCwgMF0sIFswLCAwXSwgWzkwLCAwXSwgWzE4MCwgMF0sXG4gICAgICAgIFswLCAtOTBdXG4gICAgXTtcbiAgICB2YXIgb2N0YWhlZHJvbiQxID0gW1xuICAgICAgICBbMCwgMiwgMV0sXG4gICAgICAgIFswLCAzLCAyXSxcbiAgICAgICAgWzUsIDEsIDJdLFxuICAgICAgICBbNSwgMiwgM10sXG4gICAgICAgIFswLCAxLCA0XSxcbiAgICAgICAgWzAsIDQsIDNdLFxuICAgICAgICBbNSwgNCwgMV0sXG4gICAgICAgIFs1LCAzLCA0XVxuICAgIF0ubWFwKGZ1bmN0aW9uIChmYWNlKSB7XG4gICAgICAgIHJldHVybiBmYWNlLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuIG9jdGFoZWRyb25baV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBidXR0ZXJmbHkgPSBmdW5jdGlvbiAoZmFjZVByb2plY3Rpb24pIHtcbiAgICAgICAgZmFjZVByb2plY3Rpb24gPSBmYWNlUHJvamVjdGlvbiB8fCBmdW5jdGlvbiAoZmFjZSkge1xuICAgICAgICAgICAgdmFyIGMgPSBkM0dlby5nZW9DZW50cm9pZCh7IHR5cGU6IFwiTXVsdGlQb2ludFwiLCBjb29yZGluYXRlczogZmFjZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBkM0dlby5nZW9Hbm9tb25pYygpLnNjYWxlKDEpLnRyYW5zbGF0ZShbMCwgMF0pLnJvdGF0ZShbLWNbMF0sIC1jWzFdXSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmYWNlcyA9IG9jdGFoZWRyb24kMS5tYXAoZnVuY3Rpb24gKGZhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGZhY2U6IGZhY2UsIHByb2plY3Q6IGZhY2VQcm9qZWN0aW9uKGZhY2UpIH07XG4gICAgICAgIH0pO1xuICAgICAgICBbLTEsIDAsIDAsIDEsIDAsIDEsIDQsIDVdLmZvckVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZmFjZXNbZF07XG4gICAgICAgICAgICBub2RlICYmIChub2RlLmNoaWxkcmVuIHx8IChub2RlLmNoaWxkcmVuID0gW10pKS5wdXNoKGZhY2VzW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwb2x5aGVkcmFsKGZhY2VzWzBdLCBmdW5jdGlvbiAobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWNlc1tsYW1iZGEgPCAtcGkgLyAyID8gcGhpIDwgMCA/IDYgOiA0XG4gICAgICAgICAgICAgICAgOiBsYW1iZGEgPCAwID8gcGhpIDwgMCA/IDIgOiAwXG4gICAgICAgICAgICAgICAgICAgIDogbGFtYmRhIDwgcGkgLyAyID8gcGhpIDwgMCA/IDMgOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBoaSA8IDAgPyA3IDogNV07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuc2NhbGUoMTAxLjg1OClcbiAgICAgICAgICAgIC5jZW50ZXIoWzAsIDQ1XSk7XG4gICAgfTtcbiAgICB2YXIga3ggPSAyIC8gc3FydCgzKTtcbiAgICBmdW5jdGlvbiBjb2xsaWdub25LKGEsIGIpIHtcbiAgICAgICAgdmFyIHAgPSBjb2xsaWdub25SYXcoYSwgYik7XG4gICAgICAgIHJldHVybiBbcFswXSAqIGt4LCBwWzFdXTtcbiAgICB9XG4gICAgY29sbGlnbm9uSy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gY29sbGlnbm9uUmF3LmludmVydCh4IC8ga3gsIHkpO1xuICAgIH07XG4gICAgdmFyIGNvbGxpZ25vbiQxID0gZnVuY3Rpb24gKGZhY2VQcm9qZWN0aW9uKSB7XG4gICAgICAgIGZhY2VQcm9qZWN0aW9uID0gZmFjZVByb2plY3Rpb24gfHwgZnVuY3Rpb24gKGZhY2UpIHtcbiAgICAgICAgICAgIHZhciBjID0gZDNHZW8uZ2VvQ2VudHJvaWQoeyB0eXBlOiBcIk11bHRpUG9pbnRcIiwgY29vcmRpbmF0ZXM6IGZhY2UgfSk7XG4gICAgICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihjb2xsaWdub25LKS50cmFuc2xhdGUoWzAsIDBdKS5zY2FsZSgxKS5yb3RhdGUoY1sxXSA+IDAgPyBbLWNbMF0sIDBdIDogWzE4MCAtIGNbMF0sIDE4MF0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZmFjZXMgPSBvY3RhaGVkcm9uJDEubWFwKGZ1bmN0aW9uIChmYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBmYWNlOiBmYWNlLCBwcm9qZWN0OiBmYWNlUHJvamVjdGlvbihmYWNlKSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgWy0xLCAwLCAwLCAxLCAwLCAxLCA0LCA1XS5mb3JFYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGZhY2VzW2RdO1xuICAgICAgICAgICAgbm9kZSAmJiAobm9kZS5jaGlsZHJlbiB8fCAobm9kZS5jaGlsZHJlbiA9IFtdKSkucHVzaChmYWNlc1tpXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcG9seWhlZHJhbChmYWNlc1swXSwgZnVuY3Rpb24gKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFjZXNbbGFtYmRhIDwgLXBpIC8gMiA/IHBoaSA8IDAgPyA2IDogNFxuICAgICAgICAgICAgICAgIDogbGFtYmRhIDwgMCA/IHBoaSA8IDAgPyAyIDogMFxuICAgICAgICAgICAgICAgICAgICA6IGxhbWJkYSA8IHBpIC8gMiA/IHBoaSA8IDAgPyAzIDogMVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwaGkgPCAwID8gNyA6IDVdO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnNjYWxlKDEyMS45MDYpXG4gICAgICAgICAgICAuY2VudGVyKFswLCA0OC41OTA0XSk7XG4gICAgfTtcbiAgICB2YXIgd2F0ZXJtYW4gPSBmdW5jdGlvbiAoZmFjZVByb2plY3Rpb24pIHtcbiAgICAgICAgZmFjZVByb2plY3Rpb24gPSBmYWNlUHJvamVjdGlvbiB8fCBmdW5jdGlvbiAoZmFjZSkge1xuICAgICAgICAgICAgdmFyIGMgPSBmYWNlLmxlbmd0aCA9PT0gNiA/IGQzR2VvLmdlb0NlbnRyb2lkKHsgdHlwZTogXCJNdWx0aVBvaW50XCIsIGNvb3JkaW5hdGVzOiBmYWNlIH0pIDogZmFjZVswXTtcbiAgICAgICAgICAgIHJldHVybiBkM0dlby5nZW9Hbm9tb25pYygpLnNjYWxlKDEpLnRyYW5zbGF0ZShbMCwgMF0pLnJvdGF0ZShbLWNbMF0sIC1jWzFdXSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB3NSA9IG9jdGFoZWRyb24kMS5tYXAoZnVuY3Rpb24gKGZhY2UpIHtcbiAgICAgICAgICAgIHZhciB4eXogPSBmYWNlLm1hcChjYXJ0ZXNpYW4pLCBuID0geHl6Lmxlbmd0aCwgYSA9IHh5eltuIC0gMV0sIGIsIGhleGFnb24gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgYiA9IHh5eltpXTtcbiAgICAgICAgICAgICAgICBoZXhhZ29uLnB1c2goc3BoZXJpY2FsKFtcbiAgICAgICAgICAgICAgICAgICAgYVswXSAqIDAuOTQ4NjgzMjk4MDUwNTEzOCArIGJbMF0gKiAwLjMxNjIyNzc2NjAxNjgzNzk0LFxuICAgICAgICAgICAgICAgICAgICBhWzFdICogMC45NDg2ODMyOTgwNTA1MTM4ICsgYlsxXSAqIDAuMzE2MjI3NzY2MDE2ODM3OTQsXG4gICAgICAgICAgICAgICAgICAgIGFbMl0gKiAwLjk0ODY4MzI5ODA1MDUxMzggKyBiWzJdICogMC4zMTYyMjc3NjYwMTY4Mzc5NFxuICAgICAgICAgICAgICAgIF0pLCBzcGhlcmljYWwoW1xuICAgICAgICAgICAgICAgICAgICBiWzBdICogMC45NDg2ODMyOTgwNTA1MTM4ICsgYVswXSAqIDAuMzE2MjI3NzY2MDE2ODM3OTQsXG4gICAgICAgICAgICAgICAgICAgIGJbMV0gKiAwLjk0ODY4MzI5ODA1MDUxMzggKyBhWzFdICogMC4zMTYyMjc3NjYwMTY4Mzc5NCxcbiAgICAgICAgICAgICAgICAgICAgYlsyXSAqIDAuOTQ4NjgzMjk4MDUwNTEzOCArIGFbMl0gKiAwLjMxNjIyNzc2NjAxNjgzNzk0XG4gICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhleGFnb247XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY29ybmVyTm9ybWFscyA9IFtdO1xuICAgICAgICB2YXIgcGFyZW50cyA9IFstMSwgMCwgMCwgMSwgMCwgMSwgNCwgNV07XG4gICAgICAgIHc1LmZvckVhY2goZnVuY3Rpb24gKGhleGFnb24sIGopIHtcbiAgICAgICAgICAgIHZhciBmYWNlID0gb2N0YWhlZHJvbiQxW2pdLCBuID0gZmFjZS5sZW5ndGgsIG5vcm1hbHMgPSBjb3JuZXJOb3JtYWxzW2pdID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIHc1LnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBmYWNlW2ldLFxuICAgICAgICAgICAgICAgICAgICBoZXhhZ29uWyhpICogMiArIDIpICUgKDIgKiBuKV0sXG4gICAgICAgICAgICAgICAgICAgIGhleGFnb25bKGkgKiAyICsgMSkgJSAoMiAqIG4pXVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChqKTtcbiAgICAgICAgICAgICAgICBub3JtYWxzLnB1c2goY3Jvc3MoY2FydGVzaWFuKGhleGFnb25bKGkgKiAyICsgMikgJSAoMiAqIG4pXSksIGNhcnRlc2lhbihoZXhhZ29uWyhpICogMiArIDEpICUgKDIgKiBuKV0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZmFjZXMgPSB3NS5tYXAoZnVuY3Rpb24gKGZhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJvamVjdDogZmFjZVByb2plY3Rpb24oZmFjZSksXG4gICAgICAgICAgICAgICAgZmFjZTogZmFjZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGZhY2VzW2RdO1xuICAgICAgICAgICAgcGFyZW50ICYmIChwYXJlbnQuY2hpbGRyZW4gfHwgKHBhcmVudC5jaGlsZHJlbiA9IFtdKSkucHVzaChmYWNlc1tpXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBmYWNlKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICB2YXIgY29zcGhpID0gY29zKHBoaSksIHAgPSBbY29zcGhpICogY29zKGxhbWJkYSksIGNvc3BoaSAqIHNpbihsYW1iZGEpLCBzaW4ocGhpKV07XG4gICAgICAgICAgICB2YXIgaGV4YWdvbiA9IGxhbWJkYSA8IC1waSAvIDIgPyBwaGkgPCAwID8gNiA6IDRcbiAgICAgICAgICAgICAgICA6IGxhbWJkYSA8IDAgPyBwaGkgPCAwID8gMiA6IDBcbiAgICAgICAgICAgICAgICAgICAgOiBsYW1iZGEgPCBwaSAvIDIgPyBwaGkgPCAwID8gMyA6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGhpIDwgMCA/IDcgOiA1O1xuICAgICAgICAgICAgdmFyIG4gPSBjb3JuZXJOb3JtYWxzW2hleGFnb25dO1xuICAgICAgICAgICAgcmV0dXJuIGZhY2VzW2RvdChuWzBdLCBwKSA8IDAgPyA4ICsgMyAqIGhleGFnb25cbiAgICAgICAgICAgICAgICA6IGRvdChuWzFdLCBwKSA8IDAgPyA4ICsgMyAqIGhleGFnb24gKyAxXG4gICAgICAgICAgICAgICAgICAgIDogZG90KG5bMl0sIHApIDwgMCA/IDggKyAzICogaGV4YWdvbiArIDJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaGV4YWdvbl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvbHloZWRyYWwoZmFjZXNbMF0sIGZhY2UpXG4gICAgICAgICAgICAuc2NhbGUoMTEwLjYyNSlcbiAgICAgICAgICAgIC5jZW50ZXIoWzAsIDQ1XSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBkb3QoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGEubGVuZ3RoLCBzID0gMDsgaSA8IG47ICsraSlcbiAgICAgICAgICAgIHMgKz0gYVtpXSAqIGJbaV07XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcm9zcyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBhWzFdICogYlsyXSAtIGFbMl0gKiBiWzFdLFxuICAgICAgICAgICAgYVsyXSAqIGJbMF0gLSBhWzBdICogYlsyXSxcbiAgICAgICAgICAgIGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgLy8gQ29udmVydHMgM0QgQ2FydGVzaWFuIHRvIHNwaGVyaWNhbCBjb29yZGluYXRlcyAoZGVncmVlcykuXG4gICAgZnVuY3Rpb24gc3BoZXJpY2FsKGNhcnRlc2lhbikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYXRhbjIoY2FydGVzaWFuWzFdLCBjYXJ0ZXNpYW5bMF0pICogZGVncmVlcyxcbiAgICAgICAgICAgIGFzaW4obWF4KC0xLCBtaW4oMSwgY2FydGVzaWFuWzJdKSkpICogZGVncmVlc1xuICAgICAgICBdO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0cyBzcGhlcmljYWwgY29vcmRpbmF0ZXMgKGRlZ3JlZXMpIHRvIDNEIENhcnRlc2lhbi5cbiAgICBmdW5jdGlvbiBjYXJ0ZXNpYW4oY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdmFyIGxhbWJkYSA9IGNvb3JkaW5hdGVzWzBdICogcmFkaWFucywgcGhpID0gY29vcmRpbmF0ZXNbMV0gKiByYWRpYW5zLCBjb3NwaGkgPSBjb3MocGhpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGNvc3BoaSAqIGNvcyhsYW1iZGEpLFxuICAgICAgICAgICAgY29zcGhpICogc2luKGxhbWJkYSksXG4gICAgICAgICAgICBzaW4ocGhpKVxuICAgICAgICBdO1xuICAgIH1cbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICB2YXIgY2xvY2t3aXNlID0gZnVuY3Rpb24gKHJpbmcpIHtcbiAgICAgICAgaWYgKChuID0gcmluZy5sZW5ndGgpIDwgNClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGkgPSAwLCBuLCBhcmVhID0gcmluZ1tuIC0gMV1bMV0gKiByaW5nWzBdWzBdIC0gcmluZ1tuIC0gMV1bMF0gKiByaW5nWzBdWzFdO1xuICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgIGFyZWEgKz0gcmluZ1tpIC0gMV1bMV0gKiByaW5nW2ldWzBdIC0gcmluZ1tpIC0gMV1bMF0gKiByaW5nW2ldWzFdO1xuICAgICAgICByZXR1cm4gYXJlYSA8PSAwO1xuICAgIH07XG4gICAgdmFyIGNvbnRhaW5zID0gZnVuY3Rpb24gKHJpbmcsIHBvaW50KSB7XG4gICAgICAgIHZhciB4ID0gcG9pbnRbMF0sIHkgPSBwb2ludFsxXSwgY29udGFpbnMgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSByaW5nLmxlbmd0aCwgaiA9IG4gLSAxOyBpIDwgbjsgaiA9IGkrKykge1xuICAgICAgICAgICAgdmFyIHBpID0gcmluZ1tpXSwgeGkgPSBwaVswXSwgeWkgPSBwaVsxXSwgcGogPSByaW5nW2pdLCB4aiA9IHBqWzBdLCB5aiA9IHBqWzFdO1xuICAgICAgICAgICAgaWYgKCgoeWkgPiB5KSBeICh5aiA+IHkpKSAmJiAoeCA8ICh4aiAtIHhpKSAqICh5IC0geWkpIC8gKHlqIC0geWkpICsgeGkpKVxuICAgICAgICAgICAgICAgIGNvbnRhaW5zID0gIWNvbnRhaW5zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250YWlucztcbiAgICB9O1xuICAgIHZhciBpbmRleCA9IGZ1bmN0aW9uIChvYmplY3QsIHByb2plY3Rpb24pIHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IHByb2plY3Rpb24uc3RyZWFtLCBwcm9qZWN0O1xuICAgICAgICBpZiAoIXN0cmVhbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcHJvamVjdGlvblwiKTtcbiAgICAgICAgc3dpdGNoIChvYmplY3QgJiYgb2JqZWN0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJGZWF0dXJlXCI6XG4gICAgICAgICAgICAgICAgcHJvamVjdCA9IHByb2plY3RGZWF0dXJlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkZlYXR1cmVDb2xsZWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcHJvamVjdCA9IHByb2plY3RGZWF0dXJlQ29sbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHJvamVjdCA9IHByb2plY3RHZW9tZXRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvamVjdChvYmplY3QsIHN0cmVhbSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwcm9qZWN0RmVhdHVyZUNvbGxlY3Rpb24obywgc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gICAgICAgICAgICBmZWF0dXJlczogby5mZWF0dXJlcy5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvamVjdEZlYXR1cmUoZiwgc3RyZWFtKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2plY3RGZWF0dXJlKG8sIHN0cmVhbSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgICAgICAgICBpZDogby5pZCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IG8ucHJvcGVydGllcyxcbiAgICAgICAgICAgIGdlb21ldHJ5OiBwcm9qZWN0R2VvbWV0cnkoby5nZW9tZXRyeSwgc3RyZWFtKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9qZWN0R2VvbWV0cnlDb2xsZWN0aW9uKG8sIHN0cmVhbSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcbiAgICAgICAgICAgIGdlb21ldHJpZXM6IG8uZ2VvbWV0cmllcy5tYXAoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvamVjdEdlb21ldHJ5KG8sIHN0cmVhbSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9qZWN0R2VvbWV0cnkobywgc3RyZWFtKSB7XG4gICAgICAgIGlmICghbylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiKVxuICAgICAgICAgICAgcmV0dXJuIHByb2plY3RHZW9tZXRyeUNvbGxlY3Rpb24obywgc3RyZWFtKTtcbiAgICAgICAgdmFyIHNpbms7XG4gICAgICAgIHN3aXRjaCAoby50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICAgICAgICAgICAgICBzaW5rID0gc2lua1BvaW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjpcbiAgICAgICAgICAgICAgICBzaW5rID0gc2lua1BvaW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBzaW5rID0gc2lua0xpbmU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgc2luayA9IHNpbmtMaW5lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgICAgICAgICAgICBzaW5rID0gc2lua1BvbHlnb247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6XG4gICAgICAgICAgICAgICAgc2luayA9IHNpbmtQb2x5Z29uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNwaGVyZVwiOlxuICAgICAgICAgICAgICAgIHNpbmsgPSBzaW5rUG9seWdvbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGQzR2VvLmdlb1N0cmVhbShvLCBzdHJlYW0oc2luaykpO1xuICAgICAgICByZXR1cm4gc2luay5yZXN1bHQoKTtcbiAgICB9XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHZhciBzaW5rUG9pbnQgPSB7XG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goW3gsIHldKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gIXBvaW50cy5sZW5ndGggPyBudWxsXG4gICAgICAgICAgICAgICAgOiBwb2ludHMubGVuZ3RoIDwgMiA/IHsgdHlwZTogXCJQb2ludFwiLCBjb29yZGluYXRlczogcG9pbnRzWzBdIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7IHR5cGU6IFwiTXVsdGlQb2ludFwiLCBjb29yZGluYXRlczogcG9pbnRzIH07XG4gICAgICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzaW5rTGluZSA9IHtcbiAgICAgICAgbGluZVN0YXJ0OiBub29wLFxuICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKFt4LCB5XSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChwb2ludHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gocG9pbnRzKSwgcG9pbnRzID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICFsaW5lcy5sZW5ndGggPyBudWxsXG4gICAgICAgICAgICAgICAgOiBsaW5lcy5sZW5ndGggPCAyID8geyB0eXBlOiBcIkxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IGxpbmVzWzBdIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7IHR5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBsaW5lcyB9O1xuICAgICAgICAgICAgbGluZXMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzaW5rUG9seWdvbiA9IHtcbiAgICAgICAgcG9seWdvblN0YXJ0OiBub29wLFxuICAgICAgICBsaW5lU3RhcnQ6IG5vb3AsXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goW3gsIHldKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwb2ludHNbMF0uc2xpY2UoKSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCsrbiA8IDQpO1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gocG9pbnRzKSwgcG9pbnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IG5vb3AsXG4gICAgICAgIHJlc3VsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFsaW5lcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgcG9seWdvbnMgPSBbXSwgaG9sZXMgPSBbXTtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy9pc3N1ZXMvMTU1OFxuICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAocmluZykge1xuICAgICAgICAgICAgICAgIGlmIChjbG9ja3dpc2UocmluZykpXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25zLnB1c2goW3JpbmddKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGhvbGVzLnB1c2gocmluZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhvbGVzLmZvckVhY2goZnVuY3Rpb24gKGhvbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBob2xlWzBdO1xuICAgICAgICAgICAgICAgIHBvbHlnb25zLnNvbWUoZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKHBvbHlnb25bMF0sIHBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5wdXNoKGhvbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSB8fCBwb2x5Z29ucy5wdXNoKFtob2xlXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxpbmVzID0gW107XG4gICAgICAgICAgICByZXR1cm4gIXBvbHlnb25zLmxlbmd0aCA/IG51bGxcbiAgICAgICAgICAgICAgICA6IHBvbHlnb25zLmxlbmd0aCA+IDEgPyB7IHR5cGU6IFwiTXVsdGlQb2x5Z29uXCIsIGNvb3JkaW5hdGVzOiBwb2x5Z29ucyB9XG4gICAgICAgICAgICAgICAgICAgIDogeyB0eXBlOiBcIlBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IHBvbHlnb25zWzBdIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBxdWluY3VuY2lhbCA9IGZ1bmN0aW9uIChwcm9qZWN0KSB7XG4gICAgICAgIHZhciBkeCA9IHByb2plY3QoaGFsZlBpLCAwKVswXSAtIHByb2plY3QoLWhhbGZQaSwgMClbMF07XG4gICAgICAgIGZ1bmN0aW9uIHByb2plY3RRdWluY3VuY2lhbChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIHQgPSBhYnMobGFtYmRhKSA8IGhhbGZQaSwgcCA9IHByb2plY3QodCA/IGxhbWJkYSA6IGxhbWJkYSA+IDAgPyBsYW1iZGEgLSBwaSA6IGxhbWJkYSArIHBpLCBwaGkpLCB4ID0gKHBbMF0gLSBwWzFdKSAqIHNxcnQxXzIsIHkgPSAocFswXSArIHBbMV0pICogc3FydDFfMjtcbiAgICAgICAgICAgIGlmICh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgICAgICAgICB2YXIgZCA9IGR4ICogc3FydDFfMiwgcyA9IHggPiAwIF4geSA+IDAgPyAtMSA6IDE7XG4gICAgICAgICAgICByZXR1cm4gW3MgKiB4IC0gc2lnbih5KSAqIGQsIHMgKiB5IC0gc2lnbih4KSAqIGRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9qZWN0LmludmVydClcbiAgICAgICAgICAgIHByb2plY3RRdWluY3VuY2lhbC5pbnZlcnQgPSBmdW5jdGlvbiAoeDAsIHkwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSAoeDAgKyB5MCkgKiBzcXJ0MV8yLCB5ID0gKHkwIC0geDApICogc3FydDFfMiwgdCA9IGFicyh4KSA8IDAuNSAqIGR4ICYmIGFicyh5KSA8IDAuNSAqIGR4O1xuICAgICAgICAgICAgICAgIGlmICghdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGR4ICogc3FydDFfMiwgcyA9IHggPiAwIF4geSA+IDAgPyAtMSA6IDEsIHgxID0gLXMgKiB4MCArICh5ID4gMCA/IDEgOiAtMSkgKiBkLCB5MSA9IC1zICogeTAgKyAoeCA+IDAgPyAxIDogLTEpICogZDtcbiAgICAgICAgICAgICAgICAgICAgeCA9ICgteDEgLSB5MSkgKiBzcXJ0MV8yO1xuICAgICAgICAgICAgICAgICAgICB5ID0gKHgxIC0geTEpICogc3FydDFfMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwcm9qZWN0LmludmVydCh4LCB5KTtcbiAgICAgICAgICAgICAgICBpZiAoIXQpXG4gICAgICAgICAgICAgICAgICAgIHBbMF0gKz0geCA+IDAgPyBwaSA6IC1waTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKHByb2plY3RRdWluY3VuY2lhbClcbiAgICAgICAgICAgIC5yb3RhdGUoWy05MCwgLTkwLCA0NV0pXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDE4MCAtIDFlLTMpO1xuICAgIH07XG4gICAgdmFyIGdyaW5nb3J0ZW4kMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHF1aW5jdW5jaWFsKGdyaW5nb3J0ZW5SYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTc2LjQyMyk7XG4gICAgfTtcbiAgICB2YXIgcGVpcmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcXVpbmN1bmNpYWwoZ3V5b3VSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTExLjQ4KTtcbiAgICB9O1xuICAgIHZhciBxdWFudGl6ZSA9IGZ1bmN0aW9uIChpbnB1dCwgZGlnaXRzKSB7XG4gICAgICAgIGlmICghKDAgPD0gKGRpZ2l0cyA9ICtkaWdpdHMpICYmIGRpZ2l0cyA8PSAyMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGRpZ2l0c1wiKTtcbiAgICAgICAgZnVuY3Rpb24gcXVhbnRpemVQb2ludChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIG4gPSBpbnB1dC5sZW5ndGgsIGkgPSAyLCBvdXRwdXQgPSBuZXcgQXJyYXkobik7XG4gICAgICAgICAgICBvdXRwdXRbMF0gPSAraW5wdXRbMF0udG9GaXhlZChkaWdpdHMpO1xuICAgICAgICAgICAgb3V0cHV0WzFdID0gK2lucHV0WzFdLnRvRml4ZWQoZGlnaXRzKTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbilcbiAgICAgICAgICAgICAgICBvdXRwdXRbaV0gPSBpbnB1dFtpXSwgKytpO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBxdWFudGl6ZVBvaW50cyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcChxdWFudGl6ZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBxdWFudGl6ZVBvbHlnb24oaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5tYXAocXVhbnRpemVQb2ludHMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHF1YW50aXplR2VvbWV0cnkoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgIHZhciBvdXRwdXQ7XG4gICAgICAgICAgICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHsgdHlwZTogXCJHZW9tZXRyeUNvbGxlY3Rpb25cIiwgZ2VvbWV0cmllczogaW5wdXQuZ2VvbWV0cmllcy5tYXAocXVhbnRpemVHZW9tZXRyeSkgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHsgdHlwZTogXCJQb2ludFwiLCBjb29yZGluYXRlczogcXVhbnRpemVQb2ludChpbnB1dC5jb29yZGluYXRlcykgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB7IHR5cGU6IGlucHV0LnR5cGUsIGNvb3JkaW5hdGVzOiBxdWFudGl6ZVBvaW50cyhpbnB1dC5jb29yZGluYXRlcykgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHsgdHlwZTogaW5wdXQudHlwZSwgY29vcmRpbmF0ZXM6IHF1YW50aXplUG9seWdvbihpbnB1dC5jb29yZGluYXRlcykgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB7IHR5cGU6IFwiTXVsdGlQb2x5Z29uXCIsIGNvb3JkaW5hdGVzOiBpbnB1dC5jb29yZGluYXRlcy5tYXAocXVhbnRpemVQb2x5Z29uKSB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5wdXQuYmJveCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG91dHB1dC5iYm94ID0gaW5wdXQuYmJveDtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcXVhbnRpemVGZWF0dXJlKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0geyB0eXBlOiBcIkZlYXR1cmVcIiwgcHJvcGVydGllczogaW5wdXQucHJvcGVydGllcywgZ2VvbWV0cnk6IHF1YW50aXplR2VvbWV0cnkoaW5wdXQuZ2VvbWV0cnkpIH07XG4gICAgICAgICAgICBpZiAoaW5wdXQuaWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBvdXRwdXQuaWQgPSBpbnB1dC5pZDtcbiAgICAgICAgICAgIGlmIChpbnB1dC5iYm94ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgb3V0cHV0LmJib3ggPSBpbnB1dC5iYm94O1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbClcbiAgICAgICAgICAgIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJGZWF0dXJlXCI6IHJldHVybiBxdWFudGl6ZUZlYXR1cmUoaW5wdXQpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJGZWF0dXJlQ29sbGVjdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSB7IHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIiwgZmVhdHVyZXM6IGlucHV0LmZlYXR1cmVzLm1hcChxdWFudGl6ZUZlYXR1cmUpIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5iYm94ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYmJveCA9IGlucHV0LmJib3g7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBxdWFudGl6ZUdlb21ldHJ5KGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVjdGFuZ3VsYXJQb2x5Y29uaWNSYXcocGhpMCkge1xuICAgICAgICB2YXIgc2luUGhpMCA9IHNpbihwaGkwKTtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIEEgPSBzaW5QaGkwID8gdGFuKGxhbWJkYSAqIHNpblBoaTAgLyAyKSAvIHNpblBoaTAgOiBsYW1iZGEgLyAyO1xuICAgICAgICAgICAgaWYgKCFwaGkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyICogQSwgLXBoaTBdO1xuICAgICAgICAgICAgdmFyIEUgPSAyICogYXRhbihBICogc2luKHBoaSkpLCBjb3RQaGkgPSAxIC8gdGFuKHBoaSk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHNpbihFKSAqIGNvdFBoaSxcbiAgICAgICAgICAgICAgICBwaGkgKyAoMSAtIGNvcyhFKSkgKiBjb3RQaGkgLSBwaGkwXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gcmV0dXJuIG51bGwgZm9yIHBvaW50cyBvdXRzaWRlIG91dGxpbmUuXG4gICAgICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChhYnMoeSArPSBwaGkwKSA8IGVwc2lsb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzaW5QaGkwID8gMiAqIGF0YW4oc2luUGhpMCAqIHggLyAyKSAvIHNpblBoaTAgOiB4LCAwXTtcbiAgICAgICAgICAgIHZhciBrID0geCAqIHggKyB5ICogeSwgcGhpID0gMCwgaSA9IDEwLCBkZWx0YTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFuUGhpID0gdGFuKHBoaSksIHNlY1BoaSA9IDEgLyBjb3MocGhpKSwgaiA9IGsgLSAyICogeSAqIHBoaSArIHBoaSAqIHBoaTtcbiAgICAgICAgICAgICAgICBwaGkgLT0gZGVsdGEgPSAodGFuUGhpICogaiArIDIgKiAocGhpIC0geSkpIC8gKDIgKyBqICogc2VjUGhpICogc2VjUGhpICsgMiAqIChwaGkgLSB5KSAqIHRhblBoaSk7XG4gICAgICAgICAgICB9IHdoaWxlIChhYnMoZGVsdGEpID4gZXBzaWxvbiAmJiAtLWkgPiAwKTtcbiAgICAgICAgICAgIHZhciBFID0geCAqICh0YW5QaGkgPSB0YW4ocGhpKSksIEEgPSB0YW4oYWJzKHkpIDwgYWJzKHBoaSArIDEgLyB0YW5QaGkpID8gYXNpbihFKSAqIDAuNSA6IGFjb3MoRSkgKiAwLjUgKyBwaSAvIDQpIC8gc2luKHBoaSk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHNpblBoaTAgPyAyICogYXRhbihzaW5QaGkwICogQSkgLyBzaW5QaGkwIDogMiAqIEEsXG4gICAgICAgICAgICAgICAgcGhpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9XG4gICAgdmFyIHJlY3Rhbmd1bGFyUG9seWNvbmljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGFyYWxsZWwxKHJlY3Rhbmd1bGFyUG9seWNvbmljUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDEzMS4yMTUpO1xuICAgIH07XG4gICAgdmFyIEsgPSBbXG4gICAgICAgIFswLjk5ODYsIC0wLjA2Ml0sXG4gICAgICAgIFsxLjAwMDAsIDAuMDAwMF0sXG4gICAgICAgIFswLjk5ODYsIDAuMDYyMF0sXG4gICAgICAgIFswLjk5NTQsIDAuMTI0MF0sXG4gICAgICAgIFswLjk5MDAsIDAuMTg2MF0sXG4gICAgICAgIFswLjk4MjIsIDAuMjQ4MF0sXG4gICAgICAgIFswLjk3MzAsIDAuMzEwMF0sXG4gICAgICAgIFswLjk2MDAsIDAuMzcyMF0sXG4gICAgICAgIFswLjk0MjcsIDAuNDM0MF0sXG4gICAgICAgIFswLjkyMTYsIDAuNDk1OF0sXG4gICAgICAgIFswLjg5NjIsIDAuNTU3MV0sXG4gICAgICAgIFswLjg2NzksIDAuNjE3Nl0sXG4gICAgICAgIFswLjgzNTAsIDAuNjc2OV0sXG4gICAgICAgIFswLjc5ODYsIDAuNzM0Nl0sXG4gICAgICAgIFswLjc1OTcsIDAuNzkwM10sXG4gICAgICAgIFswLjcxODYsIDAuODQzNV0sXG4gICAgICAgIFswLjY3MzIsIDAuODkzNl0sXG4gICAgICAgIFswLjYyMTMsIDAuOTM5NF0sXG4gICAgICAgIFswLjU3MjIsIDAuOTc2MV0sXG4gICAgICAgIFswLjUzMjIsIDEuMDAwMF1cbiAgICBdO1xuICAgIEsuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBkWzFdICo9IDEuMDE0NDtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiByb2JpbnNvblJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgaSA9IG1pbigxOCwgYWJzKHBoaSkgKiAzNiAvIHBpKSwgaTAgPSBmbG9vcihpKSwgZGkgPSBpIC0gaTAsIGF4ID0gKGsgPSBLW2kwXSlbMF0sIGF5ID0ga1sxXSwgYnggPSAoayA9IEtbKytpMF0pWzBdLCBieSA9IGtbMV0sIGN4ID0gKGsgPSBLW21pbigxOSwgKytpMCldKVswXSwgY3kgPSBrWzFdLCBrO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbGFtYmRhICogKGJ4ICsgZGkgKiAoY3ggLSBheCkgLyAyICsgZGkgKiBkaSAqIChjeCAtIDIgKiBieCArIGF4KSAvIDIpLFxuICAgICAgICAgICAgKHBoaSA+IDAgPyBoYWxmUGkgOiAtaGFsZlBpKSAqIChieSArIGRpICogKGN5IC0gYXkpIC8gMiArIGRpICogZGkgKiAoY3kgLSAyICogYnkgKyBheSkgLyAyKVxuICAgICAgICBdO1xuICAgIH1cbiAgICByb2JpbnNvblJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgeXkgPSB5IC8gaGFsZlBpLCBwaGkgPSB5eSAqIDkwLCBpID0gbWluKDE4LCBhYnMocGhpIC8gNSkpLCBpMCA9IG1heCgwLCBmbG9vcihpKSk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBheSA9IEtbaTBdWzFdLCBieSA9IEtbaTAgKyAxXVsxXSwgY3kgPSBLW21pbigxOSwgaTAgKyAyKV1bMV0sIHUgPSBjeSAtIGF5LCB2ID0gY3kgLSAyICogYnkgKyBheSwgdCA9IDIgKiAoYWJzKHl5KSAtIGJ5KSAvIHUsIGMgPSB2IC8gdSwgZGkgPSB0ICogKDEgLSBjICogdCAqICgxIC0gMiAqIGMgKiB0KSk7XG4gICAgICAgICAgICBpZiAoZGkgPj0gMCB8fCBpMCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHBoaSA9ICh5ID49IDAgPyA1IDogLTUpICogKGRpICsgaSk7XG4gICAgICAgICAgICAgICAgdmFyIGogPSA1MCwgZGVsdGE7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBpID0gbWluKDE4LCBhYnMocGhpKSAvIDUpO1xuICAgICAgICAgICAgICAgICAgICBpMCA9IGZsb29yKGkpO1xuICAgICAgICAgICAgICAgICAgICBkaSA9IGkgLSBpMDtcbiAgICAgICAgICAgICAgICAgICAgYXkgPSBLW2kwXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgYnkgPSBLW2kwICsgMV1bMV07XG4gICAgICAgICAgICAgICAgICAgIGN5ID0gS1ttaW4oMTksIGkwICsgMildWzFdO1xuICAgICAgICAgICAgICAgICAgICBwaGkgLT0gKGRlbHRhID0gKHkgPj0gMCA/IGhhbGZQaSA6IC1oYWxmUGkpICogKGJ5ICsgZGkgKiAoY3kgLSBheSkgLyAyICsgZGkgKiBkaSAqIChjeSAtIDIgKiBieSArIGF5KSAvIDIpIC0geSkgKiBkZWdyZWVzO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGFicyhkZWx0YSkgPiBlcHNpbG9uMiAmJiAtLWogPiAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoLS1pMCA+PSAwKTtcbiAgICAgICAgdmFyIGF4ID0gS1tpMF1bMF0sIGJ4ID0gS1tpMCArIDFdWzBdLCBjeCA9IEtbbWluKDE5LCBpMCArIDIpXVswXTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHggLyAoYnggKyBkaSAqIChjeCAtIGF4KSAvIDIgKyBkaSAqIGRpICogKGN4IC0gMiAqIGJ4ICsgYXgpIC8gMiksXG4gICAgICAgICAgICBwaGkgKiByYWRpYW5zXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgcm9iaW5zb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKHJvYmluc29uUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE1Mi42Myk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBzYXRlbGxpdGVWZXJ0aWNhbFJhdyhQKSB7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKSwgayA9IChQIC0gMSkgLyAoUCAtIGNvc1BoaSAqIGNvcyhsYW1iZGEpKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgayAqIGNvc1BoaSAqIHNpbihsYW1iZGEpLFxuICAgICAgICAgICAgICAgIGsgKiBzaW4ocGhpKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgcmhvMiA9IHggKiB4ICsgeSAqIHksIHJobyA9IHNxcnQocmhvMiksIHNpbmMgPSAoUCAtIHNxcnQoMSAtIHJobzIgKiAoUCArIDEpIC8gKFAgLSAxKSkpIC8gKChQIC0gMSkgLyByaG8gKyByaG8gLyAoUCAtIDEpKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYXRhbjIoeCAqIHNpbmMsIHJobyAqIHNxcnQoMSAtIHNpbmMgKiBzaW5jKSksXG4gICAgICAgICAgICAgICAgcmhvID8gYXNpbih5ICogc2luYyAvIHJobykgOiAwXG4gICAgICAgICAgICBdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2F0ZWxsaXRlUmF3KFAsIG9tZWdhKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNhbCA9IHNhdGVsbGl0ZVZlcnRpY2FsUmF3KFApO1xuICAgICAgICBpZiAoIW9tZWdhKVxuICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2FsO1xuICAgICAgICB2YXIgY29zT21lZ2EgPSBjb3Mob21lZ2EpLCBzaW5PbWVnYSA9IHNpbihvbWVnYSk7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IHZlcnRpY2FsKGxhbWJkYSwgcGhpKSwgeSA9IGNvb3JkaW5hdGVzWzFdLCBBID0geSAqIHNpbk9tZWdhIC8gKFAgLSAxKSArIGNvc09tZWdhO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlc1swXSAqIGNvc09tZWdhIC8gQSxcbiAgICAgICAgICAgICAgICB5IC8gQVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgayA9IChQIC0gMSkgLyAoUCAtIDEgLSB5ICogc2luT21lZ2EpO1xuICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2FsLmludmVydChrICogeCwgayAqIHkgKiBjb3NPbWVnYSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICB2YXIgc2F0ZWxsaXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSAyLCBvbWVnYSA9IDAsIG0gPSBkM0dlby5nZW9Qcm9qZWN0aW9uTXV0YXRvcihzYXRlbGxpdGVSYXcpLCBwID0gbShkaXN0YW5jZSwgb21lZ2EpO1xuICAgICAgICAvLyBBcyBhIG11bHRpcGxlIG9mIHJhZGl1cy5cbiAgICAgICAgcC5kaXN0YW5jZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIG0oZGlzdGFuY2UgPSArXywgb21lZ2EpO1xuICAgICAgICB9O1xuICAgICAgICBwLnRpbHQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBvbWVnYSAqIGRlZ3JlZXM7XG4gICAgICAgICAgICByZXR1cm4gbShkaXN0YW5jZSwgb21lZ2EgPSBfICogcmFkaWFucyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwXG4gICAgICAgICAgICAuc2NhbGUoNDMyLjE0NylcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoYWNvcygxIC8gZGlzdGFuY2UpICogZGVncmVlcyAtIDFlLTYpO1xuICAgIH07XG4gICAgdmFyIGVwc2lsb24kMSA9IDFlLTQ7XG4gICAgdmFyIGVwc2lsb25JbnZlcnNlID0gMWU0O1xuICAgIHZhciB4MCA9IC0xODA7XG4gICAgdmFyIHgwZSA9IHgwICsgZXBzaWxvbiQxO1xuICAgIHZhciB4MSA9IDE4MDtcbiAgICB2YXIgeDFlID0geDEgLSBlcHNpbG9uJDE7XG4gICAgdmFyIHkwID0gLTkwO1xuICAgIHZhciB5MGUgPSB5MCArIGVwc2lsb24kMTtcbiAgICB2YXIgeTEgPSA5MDtcbiAgICB2YXIgeTFlID0geTEgLSBlcHNpbG9uJDE7XG4gICAgZnVuY3Rpb24gbm9uZW1wdHkoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHF1YW50aXplJDEoeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih4ICogZXBzaWxvbkludmVyc2UpIC8gZXBzaWxvbkludmVyc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVBvaW50KHkpIHtcbiAgICAgICAgcmV0dXJuIHkgPT09IHkwIHx8IHkgPT09IHkxID8gWzAsIHldIDogW3gwLCBxdWFudGl6ZSQxKHkpXTsgLy8gcG9sZSBvciBhbnRpbWVyaWRpYW4/XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsYW1wUG9pbnQocCkge1xuICAgICAgICB2YXIgeCA9IHBbMF0sIHkgPSBwWzFdLCBjbGFtcGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh4IDw9IHgwZSlcbiAgICAgICAgICAgIHggPSB4MCwgY2xhbXBlZCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKHggPj0geDFlKVxuICAgICAgICAgICAgeCA9IHgxLCBjbGFtcGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHkgPD0geTBlKVxuICAgICAgICAgICAgeSA9IHkwLCBjbGFtcGVkID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoeSA+PSB5MWUpXG4gICAgICAgICAgICB5ID0geTEsIGNsYW1wZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gY2xhbXBlZCA/IFt4LCB5XSA6IHA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsYW1wUG9pbnRzKHBvaW50cykge1xuICAgICAgICByZXR1cm4gcG9pbnRzLm1hcChjbGFtcFBvaW50KTtcbiAgICB9XG4gICAgLy8gRm9yIGVhY2ggcmluZywgZGV0ZWN0IHdoZXJlIGl0IGNyb3NzZXMgdGhlIGFudGltZXJpZGlhbiBvciBwb2xlLlxuICAgIGZ1bmN0aW9uIGV4dHJhY3RGcmFnbWVudHMocmluZ3MsIHBvbHlnb24sIGZyYWdtZW50cykge1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgbSA9IHJpbmdzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgICAgICAgdmFyIHJpbmcgPSByaW5nc1tqXS5zbGljZSgpO1xuICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgYXNzdW1lIHRoYXQgdGhpcyByaW5nIGRvZXNu4oCZdCBuZWVkIGFueSBzdGl0Y2hpbmcuXG4gICAgICAgICAgICBmcmFnbWVudHMucHVzaCh7IGluZGV4OiAtMSwgcG9seWdvbjogcG9seWdvbiwgcmluZzogcmluZyB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcmluZy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSByaW5nW2ldLCB4ID0gcG9pbnRbMF0sIHkgPSBwb2ludFsxXTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGFudGltZXJpZGlhbiBvciBwb2xhciBwb2ludOKAplxuICAgICAgICAgICAgICAgIGlmICh4IDw9IHgwZSB8fCB4ID49IHgxZSB8fCB5IDw9IHkwZSB8fCB5ID49IHkxZSkge1xuICAgICAgICAgICAgICAgICAgICByaW5nW2ldID0gY2xhbXBQb2ludChwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhyb3VnaCBhbnkgYW50aW1lcmlkaWFuIG9yIHBvbGFyIHBvaW50c+KAplxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gaSArIDE7IGsgPCBuOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludGsgPSByaW5nW2tdLCB4ayA9IHBvaW50a1swXSwgeWsgPSBwb2ludGtbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGsgPiB4MGUgJiYgeGsgPCB4MWUgJiYgeWsgPiB5MGUgJiYgeWsgPCB5MWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyB3YXMganVzdCBhIHNpbmdsZSBhbnRpbWVyaWRpYW4gb3IgcG9sYXIgcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbuKAmXQgbmVlZCB0byBjdXQgdGhpcyByaW5nIGludG8gYSBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIGp1c3QgbGVhdmUgaXQgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChrID09PSBpICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHRoaXMgaXMgbm90IHRoZSBmaXJzdCBwb2ludCBpbiB0aGUgcmluZyxcbiAgICAgICAgICAgICAgICAgICAgLy8gY3V0IHRoZSBjdXJyZW50IGZyYWdtZW50IHNvIHRoYXQgaXQgZW5kcyBhdCB0aGUgY3VycmVudCBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgcG9pbnQgaXMgYWxzbyBub3JtYWxpemVkIGZvciBsYXRlciBqb2luaW5nLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50QmVmb3JlID0geyBpbmRleDogLTEsIHBvbHlnb246IHBvbHlnb24sIHJpbmc6IHJpbmcuc2xpY2UoMCwgaSArIDEpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudEJlZm9yZS5yaW5nW2ZyYWdtZW50QmVmb3JlLnJpbmcubGVuZ3RoIC0gMV0gPSBub3JtYWxpemVQb2ludCh5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0gPSBmcmFnbWVudEJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmluZyBzdGFydGVkIHdpdGggYW4gYW50aW1lcmlkaWFuIGZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gaWdub3JlIHRoYXQgZnJhZ21lbnQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlbWFpbmRlciBvZiB0aGUgcmluZyBpcyBhbiBhbnRpbWVyaWRpYW4gZnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgb24gdG8gdGhlIG5leHQgcmluZy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgPj0gbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGFkZCB0aGUgcmVtYWluaW5nIHJpbmcgZnJhZ21lbnQgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudHMucHVzaCh7IGluZGV4OiAtMSwgcG9seWdvbjogcG9seWdvbiwgcmluZzogcmluZyA9IHJpbmcuc2xpY2UoayAtIDEpIH0pO1xuICAgICAgICAgICAgICAgICAgICByaW5nWzBdID0gbm9ybWFsaXplUG9pbnQocmluZ1swXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgbiA9IHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3cgc3RpdGNoIHRoZSBmcmFnbWVudHMgYmFjayB0b2dldGhlciBpbnRvIHJpbmdzLlxuICAgIGZ1bmN0aW9uIHN0aXRjaEZyYWdtZW50cyhmcmFnbWVudHMpIHtcbiAgICAgICAgdmFyIGksIG4gPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgICAgICAvLyBUbyBjb25uZWN0IHRoZSBmcmFnbWVudHMgc3RhcnQtdG8tZW5kLCBjcmVhdGUgYSBzaW1wbGUgaW5kZXggYnkgZW5kLlxuICAgICAgICB2YXIgZnJhZ21lbnRCeVN0YXJ0ID0ge30sIGZyYWdtZW50QnlFbmQgPSB7fSwgZnJhZ21lbnQsIHN0YXJ0LCBzdGFydEZyYWdtZW50LCBlbmQsIGVuZEZyYWdtZW50O1xuICAgICAgICAvLyBGb3IgZWFjaCBmcmFnbWVudOKAplxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50c1tpXTtcbiAgICAgICAgICAgIHN0YXJ0ID0gZnJhZ21lbnQucmluZ1swXTtcbiAgICAgICAgICAgIGVuZCA9IGZyYWdtZW50LnJpbmdbZnJhZ21lbnQucmluZy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgZnJhZ21lbnQgaXMgY2xvc2VkLCBhZGQgaXQgYXMgYSBzdGFuZGFsb25lIHJpbmcuXG4gICAgICAgICAgICBpZiAoc3RhcnRbMF0gPT09IGVuZFswXSAmJiBzdGFydFsxXSA9PT0gZW5kWzFdKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQucG9seWdvbi5wdXNoKGZyYWdtZW50LnJpbmcpO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50c1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFnbWVudC5pbmRleCA9IGk7XG4gICAgICAgICAgICBmcmFnbWVudEJ5U3RhcnRbc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtlbmRdID0gZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIGVhY2ggb3BlbiBmcmFnbWVudOKAplxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZnJhZ21lbnQucmluZ1swXTtcbiAgICAgICAgICAgICAgICBlbmQgPSBmcmFnbWVudC5yaW5nW2ZyYWdtZW50LnJpbmcubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgc3RhcnRGcmFnbWVudCA9IGZyYWdtZW50QnlFbmRbc3RhcnRdO1xuICAgICAgICAgICAgICAgIGVuZEZyYWdtZW50ID0gZnJhZ21lbnRCeVN0YXJ0W2VuZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtzdGFydF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZW5kXTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGZyYWdtZW50IGlzIGNsb3NlZCwgYWRkIGl0IGFzIGEgc3RhbmRhbG9uZSByaW5nLlxuICAgICAgICAgICAgICAgIGlmIChzdGFydFswXSA9PT0gZW5kWzBdICYmIHN0YXJ0WzFdID09PSBlbmRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQucG9seWdvbi5wdXNoKGZyYWdtZW50LnJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0RnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W3N0YXJ0RnJhZ21lbnQucmluZ1swXV07XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RnJhZ21lbnQucmluZy5wb3AoKTsgLy8gZHJvcCB0aGUgc2hhcmVkIGNvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRzW3N0YXJ0RnJhZ21lbnQuaW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB7IGluZGV4OiAtMSwgcG9seWdvbjogc3RhcnRGcmFnbWVudC5wb2x5Z29uLCByaW5nOiBzdGFydEZyYWdtZW50LnJpbmcuY29uY2F0KGZyYWdtZW50LnJpbmcpIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydEZyYWdtZW50ID09PSBlbmRGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29ubmVjdCBib3RoIGVuZHMgdG8gdGhpcyBzaW5nbGUgZnJhZ21lbnQgdG8gY3JlYXRlIGEgcmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LnBvbHlnb24ucHVzaChmcmFnbWVudC5yaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmluZGV4ID0gbisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRzLnB1c2goZnJhZ21lbnRCeVN0YXJ0W2ZyYWdtZW50LnJpbmdbMF1dID0gZnJhZ21lbnRCeUVuZFtmcmFnbWVudC5yaW5nW2ZyYWdtZW50LnJpbmcubGVuZ3RoIC0gMV1dID0gZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVuZEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZW5kXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZW5kRnJhZ21lbnQucmluZ1tlbmRGcmFnbWVudC5yaW5nLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQucmluZy5wb3AoKTsgLy8gZHJvcCB0aGUgc2hhcmVkIGNvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB7IGluZGV4OiBuKyssIHBvbHlnb246IGVuZEZyYWdtZW50LnBvbHlnb24sIHJpbmc6IGZyYWdtZW50LnJpbmcuY29uY2F0KGVuZEZyYWdtZW50LnJpbmcpIH07XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50c1tlbmRGcmFnbWVudC5pbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudHMucHVzaChmcmFnbWVudEJ5U3RhcnRbZnJhZ21lbnQucmluZ1swXV0gPSBmcmFnbWVudEJ5RW5kW2ZyYWdtZW50LnJpbmdbZnJhZ21lbnQucmluZy5sZW5ndGggLSAxXV0gPSBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5yaW5nLnB1c2goZnJhZ21lbnQucmluZ1swXSk7IC8vIGNsb3NlIHJpbmdcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQucG9seWdvbi5wdXNoKGZyYWdtZW50LnJpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdGl0Y2hGZWF0dXJlKGlucHV0KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB7IHR5cGU6IFwiRmVhdHVyZVwiLCBnZW9tZXRyeTogc3RpdGNoR2VvbWV0cnkoaW5wdXQuZ2VvbWV0cnkpIH07XG4gICAgICAgIGlmIChpbnB1dC5pZCAhPSBudWxsKVxuICAgICAgICAgICAgb3V0cHV0LmlkID0gaW5wdXQuaWQ7XG4gICAgICAgIGlmIChpbnB1dC5iYm94ICE9IG51bGwpXG4gICAgICAgICAgICBvdXRwdXQuYmJveCA9IGlucHV0LmJib3g7XG4gICAgICAgIGlmIChpbnB1dC5wcm9wZXJ0aWVzICE9IG51bGwpXG4gICAgICAgICAgICBvdXRwdXQucHJvcGVydGllcyA9IGlucHV0LnByb3BlcnRpZXM7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0aXRjaEdlb21ldHJ5KGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB2YXIgb3V0cHV0LCBmcmFnbWVudHMsIGksIG47XG4gICAgICAgIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IHsgdHlwZTogXCJHZW9tZXRyeUNvbGxlY3Rpb25cIiwgZ2VvbWV0cmllczogaW5wdXQuZ2VvbWV0cmllcy5tYXAoc3RpdGNoR2VvbWV0cnkpIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7IHR5cGU6IFwiUG9pbnRcIiwgY29vcmRpbmF0ZXM6IGNsYW1wUG9pbnQoaW5wdXQuY29vcmRpbmF0ZXMpIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7IHR5cGU6IGlucHV0LnR5cGUsIGNvb3JkaW5hdGVzOiBjbGFtcFBvaW50cyhpbnB1dC5jb29yZGluYXRlcykgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7IHR5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBpbnB1dC5jb29yZGluYXRlcy5tYXAoY2xhbXBQb2ludHMpIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUG9seWdvblwiOiB7XG4gICAgICAgICAgICAgICAgdmFyIHBvbHlnb24gPSBbXTtcbiAgICAgICAgICAgICAgICBleHRyYWN0RnJhZ21lbnRzKGlucHV0LmNvb3JkaW5hdGVzLCBwb2x5Z29uLCBmcmFnbWVudHMgPSBbXSk7XG4gICAgICAgICAgICAgICAgc3RpdGNoRnJhZ21lbnRzKGZyYWdtZW50cyk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0geyB0eXBlOiBcIlBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IHBvbHlnb24gfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjoge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50cyA9IFtdLCBpID0gLTEsIG4gPSBpbnB1dC5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHBvbHlnb25zID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgICAgICBleHRyYWN0RnJhZ21lbnRzKGlucHV0LmNvb3JkaW5hdGVzW2ldLCBwb2x5Z29uc1tpXSA9IFtdLCBmcmFnbWVudHMpO1xuICAgICAgICAgICAgICAgIHN0aXRjaEZyYWdtZW50cyhmcmFnbWVudHMpO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHsgdHlwZTogXCJNdWx0aVBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IHBvbHlnb25zLmZpbHRlcihub25lbXB0eSkgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQuYmJveCAhPSBudWxsKVxuICAgICAgICAgICAgb3V0cHV0LmJib3ggPSBpbnB1dC5iYm94O1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICB2YXIgc3RpdGNoID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJGZWF0dXJlXCI6IHJldHVybiBzdGl0Y2hGZWF0dXJlKGlucHV0KTtcbiAgICAgICAgICAgIGNhc2UgXCJGZWF0dXJlQ29sbGVjdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IHsgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiLCBmZWF0dXJlczogaW5wdXQuZmVhdHVyZXMubWFwKHN0aXRjaEZlYXR1cmUpIH07XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmJib3ggIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmJib3ggPSBpbnB1dC5iYm94O1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gc3RpdGNoR2VvbWV0cnkoaW5wdXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiB0aW1lc1JhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgdCA9IHRhbihwaGkgLyAyKSwgcyA9IHNpbihxdWFydGVyUGkgKiB0KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGxhbWJkYSAqICgwLjc0NDgyIC0gMC4zNDU4OCAqIHMgKiBzKSxcbiAgICAgICAgICAgIDEuNzA3MTEgKiB0XG4gICAgICAgIF07XG4gICAgfVxuICAgIHRpbWVzUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciB0ID0geSAvIDEuNzA3MTEsIHMgPSBzaW4ocXVhcnRlclBpICogdCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB4IC8gKDAuNzQ0ODIgLSAwLjM0NTg4ICogcyAqIHMpLFxuICAgICAgICAgICAgMiAqIGF0YW4odClcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIHZhciB0aW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24odGltZXNSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTQ2LjE1Myk7XG4gICAgfTtcbiAgICAvLyBDb21wdXRlIHRoZSBvcmlnaW4gYXMgdGhlIG1pZHBvaW50IG9mIHRoZSB0d28gcmVmZXJlbmNlIHBvaW50cy5cbiAgICAvLyBSb3RhdGUgb25lIG9mIHRoZSByZWZlcmVuY2UgcG9pbnRzIGJ5IHRoZSBvcmlnaW4uXG4gICAgLy8gQXBwbHkgdGhlIHNwaGVyaWNhbCBsYXcgb2Ygc2luZXMgdG8gY29tcHV0ZSBnYW1tYSByb3RhdGlvbi5cbiAgICB2YXIgdHdvUG9pbnQgPSBmdW5jdGlvbiAocmF3LCBwMCwgcDEpIHtcbiAgICAgICAgdmFyIGkgPSBkM0dlby5nZW9JbnRlcnBvbGF0ZShwMCwgcDEpLCBvID0gaSgwLjUpLCBhID0gZDNHZW8uZ2VvUm90YXRpb24oWy1vWzBdLCAtb1sxXV0pKHAwKSwgYiA9IGkuZGlzdGFuY2UgLyAyLCB5ID0gLWFzaW4oc2luKGFbMV0gKiByYWRpYW5zKSAvIHNpbihiKSksIFIgPSBbLW9bMF0sIC1vWzFdLCAtKGFbMF0gPiAwID8gcGkgLSB5IDogeSkgKiBkZWdyZWVzXSwgcCA9IGQzR2VvLmdlb1Byb2plY3Rpb24ocmF3KGIpKS5yb3RhdGUoUiksIHIgPSBkM0dlby5nZW9Sb3RhdGlvbihSKSwgY2VudGVyID0gcC5jZW50ZXI7XG4gICAgICAgIGRlbGV0ZSBwLnJvdGF0ZTtcbiAgICAgICAgcC5jZW50ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjZW50ZXIocihfKSkgOiByLmludmVydChjZW50ZXIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDkwKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHR3b1BvaW50QXppbXV0aGFsUmF3KGQpIHtcbiAgICAgICAgdmFyIGNvc2QgPSBjb3MoZCk7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IGQzR2VvLmdlb0dub21vbmljUmF3KGxhbWJkYSwgcGhpKTtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzWzBdICo9IGNvc2Q7XG4gICAgICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIGQzR2VvLmdlb0dub21vbmljUmF3LmludmVydCh4IC8gY29zZCwgeSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0d29Qb2ludEF6aW11dGhhbFVzYSgpIHtcbiAgICAgICAgcmV0dXJuIHR3b1BvaW50QXppbXV0aGFsKFstMTU4LCAyMS41XSwgWy03NywgMzldKVxuICAgICAgICAgICAgLmNsaXBBbmdsZSg2MClcbiAgICAgICAgICAgIC5zY2FsZSg0MDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0d29Qb2ludEF6aW11dGhhbChwMCwgcDEpIHtcbiAgICAgICAgcmV0dXJuIHR3b1BvaW50KHR3b1BvaW50QXppbXV0aGFsUmF3LCBwMCwgcDEpO1xuICAgIH1cbiAgICAvLyBUT0RPIGNsaXAgdG8gZWxsaXBzZVxuICAgIGZ1bmN0aW9uIHR3b1BvaW50RXF1aWRpc3RhbnRSYXcoejApIHtcbiAgICAgICAgaWYgKCEoejAgKj0gMikpXG4gICAgICAgICAgICByZXR1cm4gZDNHZW8uZ2VvQXppbXV0aGFsRXF1aWRpc3RhbnRSYXc7XG4gICAgICAgIHZhciBsYW1iZGFhID0gLXowIC8gMiwgbGFtYmRhYiA9IC1sYW1iZGFhLCB6MDIgPSB6MCAqIHowLCB0YW5MYW1iZGEwID0gdGFuKGxhbWJkYWIpLCBTID0gMC41IC8gc2luKGxhbWJkYWIpO1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICB2YXIgemEgPSBhY29zKGNvcyhwaGkpICogY29zKGxhbWJkYSAtIGxhbWJkYWEpKSwgemIgPSBhY29zKGNvcyhwaGkpICogY29zKGxhbWJkYSAtIGxhbWJkYWIpKSwgeXMgPSBwaGkgPCAwID8gLTEgOiAxO1xuICAgICAgICAgICAgemEgKj0gemEsIHpiICo9IHpiO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAoemEgLSB6YikgLyAoMiAqIHowKSxcbiAgICAgICAgICAgICAgICB5cyAqIHNxcnQoNCAqIHowMiAqIHpiIC0gKHowMiAtIHphICsgemIpICogKHowMiAtIHphICsgemIpKSAvICgyICogejApXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciB5MiA9IHkgKiB5LCBjb3N6YSA9IGNvcyhzcXJ0KHkyICsgKHQgPSB4ICsgbGFtYmRhYSkgKiB0KSksIGNvc3piID0gY29zKHNxcnQoeTIgKyAodCA9IHggKyBsYW1iZGFiKSAqIHQpKSwgdCwgZDtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYXRhbjIoZCA9IGNvc3phIC0gY29zemIsIHQgPSAoY29zemEgKyBjb3N6YikgKiB0YW5MYW1iZGEwKSxcbiAgICAgICAgICAgICAgICAoeSA8IDAgPyAtMSA6IDEpICogYWNvcyhzcXJ0KHQgKiB0ICsgZCAqIGQpICogUylcbiAgICAgICAgICAgIF07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0d29Qb2ludEVxdWlkaXN0YW50VXNhKCkge1xuICAgICAgICByZXR1cm4gdHdvUG9pbnRFcXVpZGlzdGFudChbLTE1OCwgMjEuNV0sIFstNzcsIDM5XSlcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoMTMwKVxuICAgICAgICAgICAgLnNjYWxlKDEyMi41NzEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0d29Qb2ludEVxdWlkaXN0YW50KHAwLCBwMSkge1xuICAgICAgICByZXR1cm4gdHdvUG9pbnQodHdvUG9pbnRFcXVpZGlzdGFudFJhdywgcDAsIHAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFuRGVyR3JpbnRlblJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICBpZiAoYWJzKHBoaSkgPCBlcHNpbG9uKVxuICAgICAgICAgICAgcmV0dXJuIFtsYW1iZGEsIDBdO1xuICAgICAgICB2YXIgc2luVGhldGEgPSBhYnMocGhpIC8gaGFsZlBpKSwgdGhldGEgPSBhc2luKHNpblRoZXRhKTtcbiAgICAgICAgaWYgKGFicyhsYW1iZGEpIDwgZXBzaWxvbiB8fCBhYnMoYWJzKHBoaSkgLSBoYWxmUGkpIDwgZXBzaWxvbilcbiAgICAgICAgICAgIHJldHVybiBbMCwgc2lnbihwaGkpICogcGkgKiB0YW4odGhldGEgLyAyKV07XG4gICAgICAgIHZhciBjb3NUaGV0YSA9IGNvcyh0aGV0YSksIEEgPSBhYnMocGkgLyBsYW1iZGEgLSBsYW1iZGEgLyBwaSkgLyAyLCBBMiA9IEEgKiBBLCBHID0gY29zVGhldGEgLyAoc2luVGhldGEgKyBjb3NUaGV0YSAtIDEpLCBQID0gRyAqICgyIC8gc2luVGhldGEgLSAxKSwgUDIgPSBQICogUCwgUDJfQTIgPSBQMiArIEEyLCBHX1AyID0gRyAtIFAyLCBRID0gQTIgKyBHO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc2lnbihsYW1iZGEpICogcGkgKiAoQSAqIEdfUDIgKyBzcXJ0KEEyICogR19QMiAqIEdfUDIgLSBQMl9BMiAqIChHICogRyAtIFAyKSkpIC8gUDJfQTIsXG4gICAgICAgICAgICBzaWduKHBoaSkgKiBwaSAqIChQICogUSAtIEEgKiBzcXJ0KChBMiArIDEpICogUDJfQTIgLSBRICogUSkpIC8gUDJfQTJcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFuRGVyR3JpbnRlblJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoYWJzKHkpIDwgZXBzaWxvbilcbiAgICAgICAgICAgIHJldHVybiBbeCwgMF07XG4gICAgICAgIGlmIChhYnMoeCkgPCBlcHNpbG9uKVxuICAgICAgICAgICAgcmV0dXJuIFswLCBoYWxmUGkgKiBzaW4oMiAqIGF0YW4oeSAvIHBpKSldO1xuICAgICAgICB2YXIgeDIgPSAoeCAvPSBwaSkgKiB4LCB5MiA9ICh5IC89IHBpKSAqIHksIHgyX3kyID0geDIgKyB5MiwgeiA9IHgyX3kyICogeDJfeTIsIGMxID0gLWFicyh5KSAqICgxICsgeDJfeTIpLCBjMiA9IGMxIC0gMiAqIHkyICsgeDIsIGMzID0gLTIgKiBjMSArIDEgKyAyICogeTIgKyB6LCBkID0geTIgLyBjMyArICgyICogYzIgKiBjMiAqIGMyIC8gKGMzICogYzMgKiBjMykgLSA5ICogYzEgKiBjMiAvIChjMyAqIGMzKSkgLyAyNywgYTEgPSAoYzEgLSBjMiAqIGMyIC8gKDMgKiBjMykpIC8gYzMsIG0xID0gMiAqIHNxcnQoLWExIC8gMyksIHRoZXRhMSA9IGFjb3MoMyAqIGQgLyAoYTEgKiBtMSkpIC8gMztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHBpICogKHgyX3kyIC0gMSArIHNxcnQoMSArIDIgKiAoeDIgLSB5MikgKyB6KSkgLyAoMiAqIHgpLFxuICAgICAgICAgICAgc2lnbih5KSAqIHBpICogKC1tMSAqIGNvcyh0aGV0YTEgKyBwaSAvIDMpIC0gYzIgLyAoMyAqIGMzKSlcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIHZhciB2YW5EZXJHcmludGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbih2YW5EZXJHcmludGVuUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDc5LjQxODMpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gdmFuRGVyR3JpbnRlbjJSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgaWYgKGFicyhwaGkpIDwgZXBzaWxvbilcbiAgICAgICAgICAgIHJldHVybiBbbGFtYmRhLCAwXTtcbiAgICAgICAgdmFyIHNpblRoZXRhID0gYWJzKHBoaSAvIGhhbGZQaSksIHRoZXRhID0gYXNpbihzaW5UaGV0YSk7XG4gICAgICAgIGlmIChhYnMobGFtYmRhKSA8IGVwc2lsb24gfHwgYWJzKGFicyhwaGkpIC0gaGFsZlBpKSA8IGVwc2lsb24pXG4gICAgICAgICAgICByZXR1cm4gWzAsIHNpZ24ocGhpKSAqIHBpICogdGFuKHRoZXRhIC8gMildO1xuICAgICAgICB2YXIgY29zVGhldGEgPSBjb3ModGhldGEpLCBBID0gYWJzKHBpIC8gbGFtYmRhIC0gbGFtYmRhIC8gcGkpIC8gMiwgQTIgPSBBICogQSwgeDEgPSBjb3NUaGV0YSAqIChzcXJ0KDEgKyBBMikgLSBBICogY29zVGhldGEpIC8gKDEgKyBBMiAqIHNpblRoZXRhICogc2luVGhldGEpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc2lnbihsYW1iZGEpICogcGkgKiB4MSxcbiAgICAgICAgICAgIHNpZ24ocGhpKSAqIHBpICogc3FydCgxIC0geDEgKiAoMiAqIEEgKyB4MSkpXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZhbkRlckdyaW50ZW4yUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmICgheClcbiAgICAgICAgICAgIHJldHVybiBbMCwgaGFsZlBpICogc2luKDIgKiBhdGFuKHkgLyBwaSkpXTtcbiAgICAgICAgdmFyIHgxID0gYWJzKHggLyBwaSksIEEgPSAoMSAtIHgxICogeDEgLSAoeSAvPSBwaSkgKiB5KSAvICgyICogeDEpLCBBMiA9IEEgKiBBLCBCID0gc3FydChBMiArIDEpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc2lnbih4KSAqIHBpICogKEIgLSBBKSxcbiAgICAgICAgICAgIHNpZ24oeSkgKiBoYWxmUGkgKiBzaW4oMiAqIGF0YW4yKHNxcnQoKDEgLSAyICogQSAqIHgxKSAqIChBICsgQikgLSB4MSksIHNxcnQoQiArIEEgKyB4MSkpKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIHZhbkRlckdyaW50ZW4yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbih2YW5EZXJHcmludGVuMlJhdylcbiAgICAgICAgICAgIC5zY2FsZSg3OS40MTgzKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHZhbkRlckdyaW50ZW4zUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGlmIChhYnMocGhpKSA8IGVwc2lsb24pXG4gICAgICAgICAgICByZXR1cm4gW2xhbWJkYSwgMF07XG4gICAgICAgIHZhciBzaW5UaGV0YSA9IHBoaSAvIGhhbGZQaSwgdGhldGEgPSBhc2luKHNpblRoZXRhKTtcbiAgICAgICAgaWYgKGFicyhsYW1iZGEpIDwgZXBzaWxvbiB8fCBhYnMoYWJzKHBoaSkgLSBoYWxmUGkpIDwgZXBzaWxvbilcbiAgICAgICAgICAgIHJldHVybiBbMCwgcGkgKiB0YW4odGhldGEgLyAyKV07XG4gICAgICAgIHZhciBBID0gKHBpIC8gbGFtYmRhIC0gbGFtYmRhIC8gcGkpIC8gMiwgeTEgPSBzaW5UaGV0YSAvICgxICsgY29zKHRoZXRhKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwaSAqIChzaWduKGxhbWJkYSkgKiBzcXJ0KEEgKiBBICsgMSAtIHkxICogeTEpIC0gQSksXG4gICAgICAgICAgICBwaSAqIHkxXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZhbkRlckdyaW50ZW4zUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmICgheSlcbiAgICAgICAgICAgIHJldHVybiBbeCwgMF07XG4gICAgICAgIHZhciB5MSA9IHkgLyBwaSwgQSA9IChwaSAqIHBpICogKDEgLSB5MSAqIHkxKSAtIHggKiB4KSAvICgyICogcGkgKiB4KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHggPyBwaSAqIChzaWduKHgpICogc3FydChBICogQSArIDEpIC0gQSkgOiAwLFxuICAgICAgICAgICAgaGFsZlBpICogc2luKDIgKiBhdGFuKHkxKSlcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIHZhciB2YW5EZXJHcmludGVuMyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24odmFuRGVyR3JpbnRlbjNSYXcpXG4gICAgICAgICAgICAuc2NhbGUoNzkuNDE4Myk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB2YW5EZXJHcmludGVuNFJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICBpZiAoIXBoaSlcbiAgICAgICAgICAgIHJldHVybiBbbGFtYmRhLCAwXTtcbiAgICAgICAgdmFyIHBoaTAgPSBhYnMocGhpKTtcbiAgICAgICAgaWYgKCFsYW1iZGEgfHwgcGhpMCA9PT0gaGFsZlBpKVxuICAgICAgICAgICAgcmV0dXJuIFswLCBwaGldO1xuICAgICAgICB2YXIgQiA9IHBoaTAgLyBoYWxmUGksIEIyID0gQiAqIEIsIEMgPSAoOCAqIEIgLSBCMiAqIChCMiArIDIpIC0gNSkgLyAoMiAqIEIyICogKEIgLSAxKSksIEMyID0gQyAqIEMsIEJDID0gQiAqIEMsIEJfQzIgPSBCMiArIEMyICsgMiAqIEJDLCBCXzNDID0gQiArIDMgKiBDLCBsYW1iZGEwID0gbGFtYmRhIC8gaGFsZlBpLCBsYW1iZGExID0gbGFtYmRhMCArIDEgLyBsYW1iZGEwLCBEID0gc2lnbihhYnMobGFtYmRhKSAtIGhhbGZQaSkgKiBzcXJ0KGxhbWJkYTEgKiBsYW1iZGExIC0gNCksIEQyID0gRCAqIEQsIEYgPSBCX0MyICogKEIyICsgQzIgKiBEMiAtIDEpICsgKDEgLSBCMikgKiAoQjIgKiAoQl8zQyAqIEJfM0MgKyA0ICogQzIpICsgMTIgKiBCQyAqIEMyICsgNCAqIEMyICogQzIpLCB4MSA9IChEICogKEJfQzIgKyBDMiAtIDEpICsgMiAqIHNxcnQoRikpIC8gKDQgKiBCX0MyICsgRDIpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc2lnbihsYW1iZGEpICogaGFsZlBpICogeDEsXG4gICAgICAgICAgICBzaWduKHBoaSkgKiBoYWxmUGkgKiBzcXJ0KDEgKyBEICogYWJzKHgxKSAtIHgxICogeDEpXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZhbkRlckdyaW50ZW40UmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBkZWx0YTtcbiAgICAgICAgaWYgKCF4IHx8ICF5KVxuICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgeSAvPSBwaTtcbiAgICAgICAgdmFyIHgxID0gc2lnbih4KSAqIHggLyBoYWxmUGksIEQgPSAoeDEgKiB4MSAtIDEgKyA0ICogeSAqIHkpIC8gYWJzKHgxKSwgRDIgPSBEICogRCwgQiA9IDIgKiB5LCBpID0gNTA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBCMiA9IEIgKiBCLCBDID0gKDggKiBCIC0gQjIgKiAoQjIgKyAyKSAtIDUpIC8gKDIgKiBCMiAqIChCIC0gMSkpLCBDXyA9ICgzICogQiAtIEIyICogQiAtIDEwKSAvICgyICogQjIgKiBCKSwgQzIgPSBDICogQywgQkMgPSBCICogQywgQl9DID0gQiArIEMsIEJfQzIgPSBCX0MgKiBCX0MsIEJfM0MgPSBCICsgMyAqIEMsIEYgPSBCX0MyICogKEIyICsgQzIgKiBEMiAtIDEpICsgKDEgLSBCMikgKiAoQjIgKiAoQl8zQyAqIEJfM0MgKyA0ICogQzIpICsgQzIgKiAoMTIgKiBCQyArIDQgKiBDMikpLCBGXyA9IC0yICogQl9DICogKDQgKiBCQyAqIEMyICsgKDEgLSA0ICogQjIgKyAzICogQjIgKiBCMikgKiAoMSArIENfKSArIEMyICogKC02ICsgMTQgKiBCMiAtIEQyICsgKC04ICsgOCAqIEIyIC0gMiAqIEQyKSAqIENfKSArIEJDICogKC04ICsgMTIgKiBCMiArICgtMTAgKyAxMCAqIEIyIC0gRDIpICogQ18pKSwgc3FydEYgPSBzcXJ0KEYpLCBmID0gRCAqIChCX0MyICsgQzIgLSAxKSArIDIgKiBzcXJ0RiAtIHgxICogKDQgKiBCX0MyICsgRDIpLCBmXyA9IEQgKiAoMiAqIEMgKiBDXyArIDIgKiBCX0MgKiAoMSArIENfKSkgKyBGXyAvIHNxcnRGIC0gOCAqIEJfQyAqIChEICogKC0xICsgQzIgKyBCX0MyKSArIDIgKiBzcXJ0RikgKiAoMSArIENfKSAvIChEMiArIDQgKiBCX0MyKTtcbiAgICAgICAgICAgIEIgLT0gZGVsdGEgPSBmIC8gZl87XG4gICAgICAgIH0gd2hpbGUgKGRlbHRhID4gZXBzaWxvbiAmJiAtLWkgPiAwKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHNpZ24oeCkgKiAoc3FydChEICogRCArIDQpICsgRCkgKiBwaSAvIDQsXG4gICAgICAgICAgICBoYWxmUGkgKiBCXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgdmFuRGVyR3JpbnRlbjQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKHZhbkRlckdyaW50ZW40UmF3KVxuICAgICAgICAgICAgLnNjYWxlKDEyNy4xNik7XG4gICAgfTtcbiAgICB2YXIgQSA9IDQgKiBwaSArIDMgKiBzcXJ0KDMpO1xuICAgIHZhciBCID0gMiAqIHNxcnQoMiAqIHBpICogc3FydCgzKSAvIEEpO1xuICAgIHZhciB3YWduZXI0UmF3ID0gbW9sbHdlaWRlQnJvbWxleVJhdyhCICogc3FydCgzKSAvIHBpLCBCLCBBIC8gNik7XG4gICAgdmFyIHdhZ25lcjQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKHdhZ25lcjRSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTc2Ljg0KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHdhZ25lcjZSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgcmV0dXJuIFtsYW1iZGEgKiBzcXJ0KDEgLSAzICogcGhpICogcGhpIC8gKHBpICogcGkpKSwgcGhpXTtcbiAgICB9XG4gICAgd2FnbmVyNlJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gW3ggLyBzcXJ0KDEgLSAzICogeSAqIHkgLyAocGkgKiBwaSkpLCB5XTtcbiAgICB9O1xuICAgIHZhciB3YWduZXI2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbih3YWduZXI2UmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE1Mi42Myk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB3YWduZXI3UmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBzID0gMC45MDYzMSAqIHNpbihwaGkpLCBjMCA9IHNxcnQoMSAtIHMgKiBzKSwgYzEgPSBzcXJ0KDIgLyAoMSArIGMwICogY29zKGxhbWJkYSAvPSAzKSkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMi42NjcyMyAqIGMwICogYzEgKiBzaW4obGFtYmRhKSxcbiAgICAgICAgICAgIDEuMjQxMDQgKiBzICogYzFcbiAgICAgICAgXTtcbiAgICB9XG4gICAgd2FnbmVyN1Jhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgdDEgPSB4IC8gMi42NjcyMywgdDIgPSB5IC8gMS4yNDEwNCwgcCA9IHNxcnQodDEgKiB0MSArIHQyICogdDIpLCBjID0gMiAqIGFzaW4ocCAvIDIpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMyAqIGF0YW4yKHggKiB0YW4oYyksIDIuNjY3MjMgKiBwKSxcbiAgICAgICAgICAgIHAgJiYgYXNpbih5ICogc2luKGMpIC8gKDEuMjQxMDQgKiAwLjkwNjMxICogcCkpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgd2FnbmVyNyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24od2FnbmVyN1JhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNzIuNjMyKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHdpZWNoZWxSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLCBzaW5QaGkgPSBjb3MobGFtYmRhKSAqIGNvc1BoaSwgc2luMV9QaGkgPSAxIC0gc2luUGhpLCBjb3NMYW1iZGEgPSBjb3MobGFtYmRhID0gYXRhbjIoc2luKGxhbWJkYSkgKiBjb3NQaGksIC1zaW4ocGhpKSkpLCBzaW5MYW1iZGEgPSBzaW4obGFtYmRhKTtcbiAgICAgICAgY29zUGhpID0gc3FydCgxIC0gc2luUGhpICogc2luUGhpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHNpbkxhbWJkYSAqIGNvc1BoaSAtIGNvc0xhbWJkYSAqIHNpbjFfUGhpLFxuICAgICAgICAgICAgLWNvc0xhbWJkYSAqIGNvc1BoaSAtIHNpbkxhbWJkYSAqIHNpbjFfUGhpXG4gICAgICAgIF07XG4gICAgfVxuICAgIHdpZWNoZWxSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHcgPSAoeCAqIHggKyB5ICogeSkgLyAtMiwgayA9IHNxcnQoLXcgKiAoMiArIHcpKSwgYiA9IHkgKiB3ICsgeCAqIGssIGEgPSB4ICogdyAtIHkgKiBrLCBEID0gc3FydChhICogYSArIGIgKiBiKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGF0YW4yKGsgKiBiLCBEICogKDEgKyB3KSksXG4gICAgICAgICAgICBEID8gLWFzaW4oayAqIGEgLyBEKSA6IDBcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIHZhciB3aWVjaGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbih3aWVjaGVsUmF3KVxuICAgICAgICAgICAgLnJvdGF0ZShbMCwgLTkwLCA0NV0pXG4gICAgICAgICAgICAuc2NhbGUoMTI0Ljc1KVxuICAgICAgICAgICAgLmNsaXBBbmdsZSgxODAgLSAxZS0zKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHdpbmtlbDNSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gYWl0b2ZmUmF3KGxhbWJkYSwgcGhpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIChjb29yZGluYXRlc1swXSArIGxhbWJkYSAvIGhhbGZQaSkgLyAyLFxuICAgICAgICAgICAgKGNvb3JkaW5hdGVzWzFdICsgcGhpKSAvIDJcbiAgICAgICAgXTtcbiAgICB9XG4gICAgd2lua2VsM1Jhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgbGFtYmRhID0geCwgcGhpID0geSwgaSA9IDI1O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgY29zcGhpID0gY29zKHBoaSksIHNpbnBoaSA9IHNpbihwaGkpLCBzaW5fMnBoaSA9IHNpbigyICogcGhpKSwgc2luMnBoaSA9IHNpbnBoaSAqIHNpbnBoaSwgY29zMnBoaSA9IGNvc3BoaSAqIGNvc3BoaSwgc2lubGFtYmRhID0gc2luKGxhbWJkYSksIGNvc2xhbWJkYV8yID0gY29zKGxhbWJkYSAvIDIpLCBzaW5sYW1iZGFfMiA9IHNpbihsYW1iZGEgLyAyKSwgc2luMmxhbWJkYV8yID0gc2lubGFtYmRhXzIgKiBzaW5sYW1iZGFfMiwgQyA9IDEgLSBjb3MycGhpICogY29zbGFtYmRhXzIgKiBjb3NsYW1iZGFfMiwgRSA9IEMgPyBhY29zKGNvc3BoaSAqIGNvc2xhbWJkYV8yKSAqIHNxcnQoRiA9IDEgLyBDKSA6IEYgPSAwLCBGLCBmeCA9IDAuNSAqICgyICogRSAqIGNvc3BoaSAqIHNpbmxhbWJkYV8yICsgbGFtYmRhIC8gaGFsZlBpKSAtIHgsIGZ5ID0gMC41ICogKEUgKiBzaW5waGkgKyBwaGkpIC0geSwgZHhkbGFtYmRhID0gMC41ICogRiAqIChjb3MycGhpICogc2luMmxhbWJkYV8yICsgRSAqIGNvc3BoaSAqIGNvc2xhbWJkYV8yICogc2luMnBoaSkgKyAwLjUgLyBoYWxmUGksIGR4ZHBoaSA9IEYgKiAoc2lubGFtYmRhICogc2luXzJwaGkgLyA0IC0gRSAqIHNpbnBoaSAqIHNpbmxhbWJkYV8yKSwgZHlkbGFtYmRhID0gMC4xMjUgKiBGICogKHNpbl8ycGhpICogc2lubGFtYmRhXzIgLSBFICogc2lucGhpICogY29zMnBoaSAqIHNpbmxhbWJkYSksIGR5ZHBoaSA9IDAuNSAqIEYgKiAoc2luMnBoaSAqIGNvc2xhbWJkYV8yICsgRSAqIHNpbjJsYW1iZGFfMiAqIGNvc3BoaSkgKyAwLjUsIGRlbm9taW5hdG9yID0gZHhkcGhpICogZHlkbGFtYmRhIC0gZHlkcGhpICogZHhkbGFtYmRhLCBkbGFtYmRhID0gKGZ5ICogZHhkcGhpIC0gZnggKiBkeWRwaGkpIC8gZGVub21pbmF0b3IsIGRwaGkgPSAoZnggKiBkeWRsYW1iZGEgLSBmeSAqIGR4ZGxhbWJkYSkgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgIGxhbWJkYSAtPSBkbGFtYmRhLCBwaGkgLT0gZHBoaTtcbiAgICAgICAgfSB3aGlsZSAoKGFicyhkbGFtYmRhKSA+IGVwc2lsb24gfHwgYWJzKGRwaGkpID4gZXBzaWxvbikgJiYgLS1pID4gMCk7XG4gICAgICAgIHJldHVybiBbbGFtYmRhLCBwaGldO1xuICAgIH07XG4gICAgdmFyIHdpbmtlbDMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKHdpbmtlbDNSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTU4LjgzNyk7XG4gICAgfTtcbiAgICBleHBvcnRzLmdlb0FpcnkgPSBhaXJ5O1xuICAgIGV4cG9ydHMuZ2VvQWlyeVJhdyA9IGFpcnlSYXc7XG4gICAgZXhwb3J0cy5nZW9BaXRvZmYgPSBhaXRvZmY7XG4gICAgZXhwb3J0cy5nZW9BaXRvZmZSYXcgPSBhaXRvZmZSYXc7XG4gICAgZXhwb3J0cy5nZW9Bcm1hZGlsbG8gPSBhcm1hZGlsbG87XG4gICAgZXhwb3J0cy5nZW9Bcm1hZGlsbG9SYXcgPSBhcm1hZGlsbG9SYXc7XG4gICAgZXhwb3J0cy5nZW9BdWd1c3QgPSBhdWd1c3Q7XG4gICAgZXhwb3J0cy5nZW9BdWd1c3RSYXcgPSBhdWd1c3RSYXc7XG4gICAgZXhwb3J0cy5nZW9CYWtlciA9IGJha2VyO1xuICAgIGV4cG9ydHMuZ2VvQmFrZXJSYXcgPSBiYWtlclJhdztcbiAgICBleHBvcnRzLmdlb0JlcmdoYXVzID0gYmVyZ2hhdXM7XG4gICAgZXhwb3J0cy5nZW9CZXJnaGF1c1JhdyA9IGJlcmdoYXVzUmF3O1xuICAgIGV4cG9ydHMuZ2VvQm9nZ3MgPSBib2dncztcbiAgICBleHBvcnRzLmdlb0JvZ2dzUmF3ID0gYm9nZ3NSYXc7XG4gICAgZXhwb3J0cy5nZW9Cb25uZSA9IGJvbm5lO1xuICAgIGV4cG9ydHMuZ2VvQm9ubmVSYXcgPSBib25uZVJhdztcbiAgICBleHBvcnRzLmdlb0JvdHRvbWxleSA9IGJvdHRvbWxleTtcbiAgICBleHBvcnRzLmdlb0JvdHRvbWxleVJhdyA9IGJvdHRvbWxleVJhdztcbiAgICBleHBvcnRzLmdlb0Jyb21sZXkgPSBicm9tbGV5O1xuICAgIGV4cG9ydHMuZ2VvQnJvbWxleVJhdyA9IGJyb21sZXlSYXc7XG4gICAgZXhwb3J0cy5nZW9DaGFtYmVybGluID0gY2hhbWJlcmxpbjtcbiAgICBleHBvcnRzLmdlb0NoYW1iZXJsaW5SYXcgPSBjaGFtYmVybGluUmF3O1xuICAgIGV4cG9ydHMuZ2VvQ2hhbWJlcmxpbkFmcmljYSA9IGNoYW1iZXJsaW5BZnJpY2E7XG4gICAgZXhwb3J0cy5nZW9Db2xsaWdub24gPSBjb2xsaWdub247XG4gICAgZXhwb3J0cy5nZW9Db2xsaWdub25SYXcgPSBjb2xsaWdub25SYXc7XG4gICAgZXhwb3J0cy5nZW9DcmFpZyA9IGNyYWlnO1xuICAgIGV4cG9ydHMuZ2VvQ3JhaWdSYXcgPSBjcmFpZ1JhdztcbiAgICBleHBvcnRzLmdlb0NyYXN0ZXIgPSBjcmFzdGVyO1xuICAgIGV4cG9ydHMuZ2VvQ3Jhc3RlclJhdyA9IGNyYXN0ZXJSYXc7XG4gICAgZXhwb3J0cy5nZW9DeWxpbmRyaWNhbEVxdWFsQXJlYSA9IGN5bGluZHJpY2FsRXF1YWxBcmVhO1xuICAgIGV4cG9ydHMuZ2VvQ3lsaW5kcmljYWxFcXVhbEFyZWFSYXcgPSBjeWxpbmRyaWNhbEVxdWFsQXJlYVJhdztcbiAgICBleHBvcnRzLmdlb0N5bGluZHJpY2FsU3RlcmVvZ3JhcGhpYyA9IGN5bGluZHJpY2FsU3RlcmVvZ3JhcGhpYztcbiAgICBleHBvcnRzLmdlb0N5bGluZHJpY2FsU3RlcmVvZ3JhcGhpY1JhdyA9IGN5bGluZHJpY2FsU3RlcmVvZ3JhcGhpY1JhdztcbiAgICBleHBvcnRzLmdlb0Vja2VydDEgPSBlY2tlcnQxO1xuICAgIGV4cG9ydHMuZ2VvRWNrZXJ0MVJhdyA9IGVja2VydDFSYXc7XG4gICAgZXhwb3J0cy5nZW9FY2tlcnQyID0gZWNrZXJ0MjtcbiAgICBleHBvcnRzLmdlb0Vja2VydDJSYXcgPSBlY2tlcnQyUmF3O1xuICAgIGV4cG9ydHMuZ2VvRWNrZXJ0MyA9IGVja2VydDM7XG4gICAgZXhwb3J0cy5nZW9FY2tlcnQzUmF3ID0gZWNrZXJ0M1JhdztcbiAgICBleHBvcnRzLmdlb0Vja2VydDQgPSBlY2tlcnQ0O1xuICAgIGV4cG9ydHMuZ2VvRWNrZXJ0NFJhdyA9IGVja2VydDRSYXc7XG4gICAgZXhwb3J0cy5nZW9FY2tlcnQ1ID0gZWNrZXJ0NTtcbiAgICBleHBvcnRzLmdlb0Vja2VydDVSYXcgPSBlY2tlcnQ1UmF3O1xuICAgIGV4cG9ydHMuZ2VvRWNrZXJ0NiA9IGVja2VydDY7XG4gICAgZXhwb3J0cy5nZW9FY2tlcnQ2UmF3ID0gZWNrZXJ0NlJhdztcbiAgICBleHBvcnRzLmdlb0Vpc2VubG9ociA9IGVpc2VubG9ocjtcbiAgICBleHBvcnRzLmdlb0Vpc2VubG9oclJhdyA9IGVpc2VubG9oclJhdztcbiAgICBleHBvcnRzLmdlb0ZhaGV5ID0gZmFoZXk7XG4gICAgZXhwb3J0cy5nZW9GYWhleVJhdyA9IGZhaGV5UmF3O1xuICAgIGV4cG9ydHMuZ2VvRm91Y2F1dCA9IGZvdWNhdXQ7XG4gICAgZXhwb3J0cy5nZW9Gb3VjYXV0UmF3ID0gZm91Y2F1dFJhdztcbiAgICBleHBvcnRzLmdlb0dpbGJlcnQgPSBnaWxiZXJ0O1xuICAgIGV4cG9ydHMuZ2VvR2luZ2VyeSA9IGdpbmdlcnk7XG4gICAgZXhwb3J0cy5nZW9HaW5nZXJ5UmF3ID0gZ2luZ2VyeVJhdztcbiAgICBleHBvcnRzLmdlb0dpbnpidXJnNCA9IGdpbnpidXJnNDtcbiAgICBleHBvcnRzLmdlb0dpbnpidXJnNFJhdyA9IGdpbnpidXJnNFJhdztcbiAgICBleHBvcnRzLmdlb0dpbnpidXJnNSA9IGdpbnpidXJnNTtcbiAgICBleHBvcnRzLmdlb0dpbnpidXJnNVJhdyA9IGdpbnpidXJnNVJhdztcbiAgICBleHBvcnRzLmdlb0dpbnpidXJnNiA9IGdpbnpidXJnNjtcbiAgICBleHBvcnRzLmdlb0dpbnpidXJnNlJhdyA9IGdpbnpidXJnNlJhdztcbiAgICBleHBvcnRzLmdlb0dpbnpidXJnOCA9IGdpbnpidXJnODtcbiAgICBleHBvcnRzLmdlb0dpbnpidXJnOFJhdyA9IGdpbnpidXJnOFJhdztcbiAgICBleHBvcnRzLmdlb0dpbnpidXJnOSA9IGdpbnpidXJnOTtcbiAgICBleHBvcnRzLmdlb0dpbnpidXJnOVJhdyA9IGdpbnpidXJnOVJhdztcbiAgICBleHBvcnRzLmdlb0dyaW5nb3J0ZW4gPSBncmluZ29ydGVuO1xuICAgIGV4cG9ydHMuZ2VvR3JpbmdvcnRlblJhdyA9IGdyaW5nb3J0ZW5SYXc7XG4gICAgZXhwb3J0cy5nZW9HdXlvdSA9IGd1eW91O1xuICAgIGV4cG9ydHMuZ2VvR3V5b3VSYXcgPSBndXlvdVJhdztcbiAgICBleHBvcnRzLmdlb0hhbW1lciA9IGhhbW1lcjtcbiAgICBleHBvcnRzLmdlb0hhbW1lclJhdyA9IGhhbW1lclJhdztcbiAgICBleHBvcnRzLmdlb0hhbW1lclJldHJvYXppbXV0aGFsID0gaGFtbWVyUmV0cm9hemltdXRoYWw7XG4gICAgZXhwb3J0cy5nZW9IYW1tZXJSZXRyb2F6aW11dGhhbFJhdyA9IGhhbW1lclJldHJvYXppbXV0aGFsUmF3O1xuICAgIGV4cG9ydHMuZ2VvSGVhbHBpeCA9IGhlYWxwaXg7XG4gICAgZXhwb3J0cy5nZW9IZWFscGl4UmF3ID0gaGVhbHBpeFJhdztcbiAgICBleHBvcnRzLmdlb0hpbGwgPSBoaWxsO1xuICAgIGV4cG9ydHMuZ2VvSGlsbFJhdyA9IGhpbGxSYXc7XG4gICAgZXhwb3J0cy5nZW9Ib21vbG9zaW5lID0gaG9tb2xvc2luZTtcbiAgICBleHBvcnRzLmdlb0hvbW9sb3NpbmVSYXcgPSBob21vbG9zaW5lUmF3O1xuICAgIGV4cG9ydHMuZ2VvSW50ZXJydXB0ID0gaW50ZXJydXB0O1xuICAgIGV4cG9ydHMuZ2VvSW50ZXJydXB0ZWRCb2dncyA9IGJvZ2dzJDE7XG4gICAgZXhwb3J0cy5nZW9JbnRlcnJ1cHRlZEhvbW9sb3NpbmUgPSBob21vbG9zaW5lJDE7XG4gICAgZXhwb3J0cy5nZW9JbnRlcnJ1cHRlZE1vbGx3ZWlkZSA9IG1vbGx3ZWlkZSQxO1xuICAgIGV4cG9ydHMuZ2VvSW50ZXJydXB0ZWRNb2xsd2VpZGVIZW1pc3BoZXJlcyA9IG1vbGx3ZWlkZUhlbWlzcGhlcmVzO1xuICAgIGV4cG9ydHMuZ2VvSW50ZXJydXB0ZWRTaW51TW9sbHdlaWRlID0gc2ludU1vbGx3ZWlkZSQxO1xuICAgIGV4cG9ydHMuZ2VvSW50ZXJydXB0ZWRTaW51c29pZGFsID0gc2ludXNvaWRhbCQxO1xuICAgIGV4cG9ydHMuZ2VvS2F2cmF5c2tpeTcgPSBrYXZyYXlza2l5NztcbiAgICBleHBvcnRzLmdlb0thdnJheXNraXk3UmF3ID0ga2F2cmF5c2tpeTdSYXc7XG4gICAgZXhwb3J0cy5nZW9MYWdyYW5nZSA9IGxhZ3JhbmdlO1xuICAgIGV4cG9ydHMuZ2VvTGFncmFuZ2VSYXcgPSBsYWdyYW5nZVJhdztcbiAgICBleHBvcnRzLmdlb0xhcnJpdmVlID0gbGFycml2ZWU7XG4gICAgZXhwb3J0cy5nZW9MYXJyaXZlZVJhdyA9IGxhcnJpdmVlUmF3O1xuICAgIGV4cG9ydHMuZ2VvTGFza293c2tpID0gbGFza293c2tpO1xuICAgIGV4cG9ydHMuZ2VvTGFza293c2tpUmF3ID0gbGFza293c2tpUmF3O1xuICAgIGV4cG9ydHMuZ2VvTGl0dHJvdyA9IGxpdHRyb3c7XG4gICAgZXhwb3J0cy5nZW9MaXR0cm93UmF3ID0gbGl0dHJvd1JhdztcbiAgICBleHBvcnRzLmdlb0xveGltdXRoYWwgPSBsb3hpbXV0aGFsO1xuICAgIGV4cG9ydHMuZ2VvTG94aW11dGhhbFJhdyA9IGxveGltdXRoYWxSYXc7XG4gICAgZXhwb3J0cy5nZW9NaWxsZXIgPSBtaWxsZXI7XG4gICAgZXhwb3J0cy5nZW9NaWxsZXJSYXcgPSBtaWxsZXJSYXc7XG4gICAgZXhwb3J0cy5nZW9Nb2RpZmllZFN0ZXJlb2dyYXBoaWMgPSBtb2RpZmllZFN0ZXJlb2dyYXBoaWM7XG4gICAgZXhwb3J0cy5nZW9Nb2RpZmllZFN0ZXJlb2dyYXBoaWNSYXcgPSBtb2RpZmllZFN0ZXJlb2dyYXBoaWNSYXc7XG4gICAgZXhwb3J0cy5nZW9Nb2RpZmllZFN0ZXJlb2dyYXBoaWNBbGFza2EgPSBtb2RpZmllZFN0ZXJlb2dyYXBoaWNBbGFza2E7XG4gICAgZXhwb3J0cy5nZW9Nb2RpZmllZFN0ZXJlb2dyYXBoaWNHczQ4ID0gbW9kaWZpZWRTdGVyZW9ncmFwaGljR3M0ODtcbiAgICBleHBvcnRzLmdlb01vZGlmaWVkU3RlcmVvZ3JhcGhpY0dzNTAgPSBtb2RpZmllZFN0ZXJlb2dyYXBoaWNHczUwO1xuICAgIGV4cG9ydHMuZ2VvTW9kaWZpZWRTdGVyZW9ncmFwaGljTWlsbGVyID0gbW9kaWZpZWRTdGVyZW9ncmFwaGljTWlsbGVyO1xuICAgIGV4cG9ydHMuZ2VvTW9kaWZpZWRTdGVyZW9ncmFwaGljTGVlID0gbW9kaWZpZWRTdGVyZW9ncmFwaGljTGVlO1xuICAgIGV4cG9ydHMuZ2VvTW9sbHdlaWRlID0gbW9sbHdlaWRlO1xuICAgIGV4cG9ydHMuZ2VvTW9sbHdlaWRlUmF3ID0gbW9sbHdlaWRlUmF3O1xuICAgIGV4cG9ydHMuZ2VvTXRGbGF0UG9sYXJQYXJhYm9saWMgPSBtdEZsYXRQb2xhclBhcmFib2xpYztcbiAgICBleHBvcnRzLmdlb010RmxhdFBvbGFyUGFyYWJvbGljUmF3ID0gbXRGbGF0UG9sYXJQYXJhYm9saWNSYXc7XG4gICAgZXhwb3J0cy5nZW9NdEZsYXRQb2xhclF1YXJ0aWMgPSBtdEZsYXRQb2xhclF1YXJ0aWM7XG4gICAgZXhwb3J0cy5nZW9NdEZsYXRQb2xhclF1YXJ0aWNSYXcgPSBtdEZsYXRQb2xhclF1YXJ0aWNSYXc7XG4gICAgZXhwb3J0cy5nZW9NdEZsYXRQb2xhclNpbnVzb2lkYWwgPSBtdEZsYXRQb2xhclNpbnVzb2lkYWw7XG4gICAgZXhwb3J0cy5nZW9NdEZsYXRQb2xhclNpbnVzb2lkYWxSYXcgPSBtdEZsYXRQb2xhclNpbnVzb2lkYWxSYXc7XG4gICAgZXhwb3J0cy5nZW9OYXR1cmFsRWFydGggPSBuYXR1cmFsRWFydGg7XG4gICAgZXhwb3J0cy5nZW9OYXR1cmFsRWFydGhSYXcgPSBuYXR1cmFsRWFydGhSYXc7XG4gICAgZXhwb3J0cy5nZW9OYXR1cmFsRWFydGgyID0gbmF0dXJhbEVhcnRoMjtcbiAgICBleHBvcnRzLmdlb05hdHVyYWxFYXJ0aDJSYXcgPSBuYXR1cmFsRWFydGgyUmF3O1xuICAgIGV4cG9ydHMuZ2VvTmVsbEhhbW1lciA9IG5lbGxIYW1tZXI7XG4gICAgZXhwb3J0cy5nZW9OZWxsSGFtbWVyUmF3ID0gbmVsbEhhbW1lclJhdztcbiAgICBleHBvcnRzLmdlb1BhdHRlcnNvbiA9IHBhdHRlcnNvbjtcbiAgICBleHBvcnRzLmdlb1BhdHRlcnNvblJhdyA9IHBhdHRlcnNvblJhdztcbiAgICBleHBvcnRzLmdlb1BvbHljb25pYyA9IHBvbHljb25pYztcbiAgICBleHBvcnRzLmdlb1BvbHljb25pY1JhdyA9IHBvbHljb25pY1JhdztcbiAgICBleHBvcnRzLmdlb1BvbHloZWRyYWwgPSBwb2x5aGVkcmFsO1xuICAgIGV4cG9ydHMuZ2VvUG9seWhlZHJhbEJ1dHRlcmZseSA9IGJ1dHRlcmZseTtcbiAgICBleHBvcnRzLmdlb1BvbHloZWRyYWxDb2xsaWdub24gPSBjb2xsaWdub24kMTtcbiAgICBleHBvcnRzLmdlb1BvbHloZWRyYWxXYXRlcm1hbiA9IHdhdGVybWFuO1xuICAgIGV4cG9ydHMuZ2VvUHJvamVjdCA9IGluZGV4O1xuICAgIGV4cG9ydHMuZ2VvR3JpbmdvcnRlblF1aW5jdW5jaWFsID0gZ3JpbmdvcnRlbiQxO1xuICAgIGV4cG9ydHMuZ2VvUGVpcmNlUXVpbmN1bmNpYWwgPSBwZWlyY2U7XG4gICAgZXhwb3J0cy5nZW9QaWVyY2VRdWluY3VuY2lhbCA9IHBlaXJjZTtcbiAgICBleHBvcnRzLmdlb1F1YW50aXplID0gcXVhbnRpemU7XG4gICAgZXhwb3J0cy5nZW9RdWluY3VuY2lhbCA9IHF1aW5jdW5jaWFsO1xuICAgIGV4cG9ydHMuZ2VvUmVjdGFuZ3VsYXJQb2x5Y29uaWMgPSByZWN0YW5ndWxhclBvbHljb25pYztcbiAgICBleHBvcnRzLmdlb1JlY3Rhbmd1bGFyUG9seWNvbmljUmF3ID0gcmVjdGFuZ3VsYXJQb2x5Y29uaWNSYXc7XG4gICAgZXhwb3J0cy5nZW9Sb2JpbnNvbiA9IHJvYmluc29uO1xuICAgIGV4cG9ydHMuZ2VvUm9iaW5zb25SYXcgPSByb2JpbnNvblJhdztcbiAgICBleHBvcnRzLmdlb1NhdGVsbGl0ZSA9IHNhdGVsbGl0ZTtcbiAgICBleHBvcnRzLmdlb1NhdGVsbGl0ZVJhdyA9IHNhdGVsbGl0ZVJhdztcbiAgICBleHBvcnRzLmdlb1NpbnVNb2xsd2VpZGUgPSBzaW51TW9sbHdlaWRlO1xuICAgIGV4cG9ydHMuZ2VvU2ludU1vbGx3ZWlkZVJhdyA9IHNpbnVNb2xsd2VpZGVSYXc7XG4gICAgZXhwb3J0cy5nZW9TaW51c29pZGFsID0gc2ludXNvaWRhbDtcbiAgICBleHBvcnRzLmdlb1NpbnVzb2lkYWxSYXcgPSBzaW51c29pZGFsUmF3O1xuICAgIGV4cG9ydHMuZ2VvU3RpdGNoID0gc3RpdGNoO1xuICAgIGV4cG9ydHMuZ2VvVGltZXMgPSB0aW1lcztcbiAgICBleHBvcnRzLmdlb1RpbWVzUmF3ID0gdGltZXNSYXc7XG4gICAgZXhwb3J0cy5nZW9Ud29Qb2ludEF6aW11dGhhbCA9IHR3b1BvaW50QXppbXV0aGFsO1xuICAgIGV4cG9ydHMuZ2VvVHdvUG9pbnRBemltdXRoYWxSYXcgPSB0d29Qb2ludEF6aW11dGhhbFJhdztcbiAgICBleHBvcnRzLmdlb1R3b1BvaW50QXppbXV0aGFsVXNhID0gdHdvUG9pbnRBemltdXRoYWxVc2E7XG4gICAgZXhwb3J0cy5nZW9Ud29Qb2ludEVxdWlkaXN0YW50ID0gdHdvUG9pbnRFcXVpZGlzdGFudDtcbiAgICBleHBvcnRzLmdlb1R3b1BvaW50RXF1aWRpc3RhbnRSYXcgPSB0d29Qb2ludEVxdWlkaXN0YW50UmF3O1xuICAgIGV4cG9ydHMuZ2VvVHdvUG9pbnRFcXVpZGlzdGFudFVzYSA9IHR3b1BvaW50RXF1aWRpc3RhbnRVc2E7XG4gICAgZXhwb3J0cy5nZW9WYW5EZXJHcmludGVuID0gdmFuRGVyR3JpbnRlbjtcbiAgICBleHBvcnRzLmdlb1ZhbkRlckdyaW50ZW5SYXcgPSB2YW5EZXJHcmludGVuUmF3O1xuICAgIGV4cG9ydHMuZ2VvVmFuRGVyR3JpbnRlbjIgPSB2YW5EZXJHcmludGVuMjtcbiAgICBleHBvcnRzLmdlb1ZhbkRlckdyaW50ZW4yUmF3ID0gdmFuRGVyR3JpbnRlbjJSYXc7XG4gICAgZXhwb3J0cy5nZW9WYW5EZXJHcmludGVuMyA9IHZhbkRlckdyaW50ZW4zO1xuICAgIGV4cG9ydHMuZ2VvVmFuRGVyR3JpbnRlbjNSYXcgPSB2YW5EZXJHcmludGVuM1JhdztcbiAgICBleHBvcnRzLmdlb1ZhbkRlckdyaW50ZW40ID0gdmFuRGVyR3JpbnRlbjQ7XG4gICAgZXhwb3J0cy5nZW9WYW5EZXJHcmludGVuNFJhdyA9IHZhbkRlckdyaW50ZW40UmF3O1xuICAgIGV4cG9ydHMuZ2VvV2FnbmVyNCA9IHdhZ25lcjQ7XG4gICAgZXhwb3J0cy5nZW9XYWduZXI0UmF3ID0gd2FnbmVyNFJhdztcbiAgICBleHBvcnRzLmdlb1dhZ25lcjYgPSB3YWduZXI2O1xuICAgIGV4cG9ydHMuZ2VvV2FnbmVyNlJhdyA9IHdhZ25lcjZSYXc7XG4gICAgZXhwb3J0cy5nZW9XYWduZXI3ID0gd2FnbmVyNztcbiAgICBleHBvcnRzLmdlb1dhZ25lcjdSYXcgPSB3YWduZXI3UmF3O1xuICAgIGV4cG9ydHMuZ2VvV2llY2hlbCA9IHdpZWNoZWw7XG4gICAgZXhwb3J0cy5nZW9XaWVjaGVsUmF3ID0gd2llY2hlbFJhdztcbiAgICBleHBvcnRzLmdlb1dpbmtlbDMgPSB3aW5rZWwzO1xuICAgIGV4cG9ydHMuZ2VvV2lua2VsM1JhdyA9IHdpbmtlbDNSYXc7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn0pKSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWdlb0AxLjExLjlAZDMtZ2VvL2Rpc3QvZDMtZ2VvLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZDMtZ2VvQDEuMTEuOUBkMy1nZW8vZGlzdC9kMy1nZW8uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtZ2VvLyB2MS4xMS45IENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICAgdHJ1ZSA/IGZhY3RvcnkoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtYXJyYXlAMS4yLjRAZDMtYXJyYXkvZGlzdC9kMy1hcnJheS5qc1wiKSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLCBkM0FycmF5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIEFkZHMgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyB3aXRoIHR3aWNlIHRoZSBub3JtYWwgcHJlY2lzaW9uLlxuICAgIC8vIFJlZmVyZW5jZTogSi4gUi4gU2hld2NodWssIEFkYXB0aXZlIFByZWNpc2lvbiBGbG9hdGluZy1Qb2ludCBBcml0aG1ldGljIGFuZFxuICAgIC8vIEZhc3QgUm9idXN0IEdlb21ldHJpYyBQcmVkaWNhdGVzLCBEaXNjcmV0ZSAmIENvbXB1dGF0aW9uYWwgR2VvbWV0cnkgMTgoMylcbiAgICAvLyAzMDXigJMzNjMgKDE5OTcpLlxuICAgIC8vIENvZGUgYWRhcHRlZCBmcm9tIEdlb2dyYXBoaWNMaWIgYnkgQ2hhcmxlcyBGLiBGLiBLYXJuZXksXG4gICAgLy8gaHR0cDovL2dlb2dyYXBoaWNsaWIuc291cmNlZm9yZ2UubmV0L1xuICAgIGZ1bmN0aW9uIGFkZGVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFkZGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBBZGRlcigpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICBBZGRlci5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBBZGRlcixcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucyA9IC8vIHJvdW5kZWQgdmFsdWVcbiAgICAgICAgICAgICAgICB0aGlzLnQgPSAwOyAvLyBleGFjdCBlcnJvclxuICAgICAgICB9LFxuICAgICAgICBhZGQ6IGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICBhZGQodGVtcCwgeSwgdGhpcy50KTtcbiAgICAgICAgICAgIGFkZCh0aGlzLCB0ZW1wLnMsIHRoaXMucyk7XG4gICAgICAgICAgICBpZiAodGhpcy5zKVxuICAgICAgICAgICAgICAgIHRoaXMudCArPSB0ZW1wLnQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5zID0gdGVtcC50O1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZU9mOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgdGVtcCA9IG5ldyBBZGRlcjtcbiAgICBmdW5jdGlvbiBhZGQoYWRkZXIsIGEsIGIpIHtcbiAgICAgICAgdmFyIHggPSBhZGRlci5zID0gYSArIGIsIGJ2ID0geCAtIGEsIGF2ID0geCAtIGJ2O1xuICAgICAgICBhZGRlci50ID0gKGEgLSBhdikgKyAoYiAtIGJ2KTtcbiAgICB9XG4gICAgdmFyIGVwc2lsb24gPSAxZS02O1xuICAgIHZhciBlcHNpbG9uMiA9IDFlLTEyO1xuICAgIHZhciBwaSA9IE1hdGguUEk7XG4gICAgdmFyIGhhbGZQaSA9IHBpIC8gMjtcbiAgICB2YXIgcXVhcnRlclBpID0gcGkgLyA0O1xuICAgIHZhciB0YXUgPSBwaSAqIDI7XG4gICAgdmFyIGRlZ3JlZXMgPSAxODAgLyBwaTtcbiAgICB2YXIgcmFkaWFucyA9IHBpIC8gMTgwO1xuICAgIHZhciBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgYXRhbiA9IE1hdGguYXRhbjtcbiAgICB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgY2VpbCA9IE1hdGguY2VpbDtcbiAgICB2YXIgZXhwID0gTWF0aC5leHA7XG4gICAgdmFyIGxvZyA9IE1hdGgubG9nO1xuICAgIHZhciBwb3cgPSBNYXRoLnBvdztcbiAgICB2YXIgc2luID0gTWF0aC5zaW47XG4gICAgdmFyIHNpZ24gPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPiAwID8gMSA6IHggPCAwID8gLTEgOiAwOyB9O1xuICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciB0YW4gPSBNYXRoLnRhbjtcbiAgICBmdW5jdGlvbiBhY29zKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc2luKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPiAxID8gaGFsZlBpIDogeCA8IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGF2ZXJzaW4oeCkge1xuICAgICAgICByZXR1cm4gKHggPSBzaW4oeCAvIDIpKSAqIHg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7IH1cbiAgICBmdW5jdGlvbiBzdHJlYW1HZW9tZXRyeShnZW9tZXRyeSwgc3RyZWFtKSB7XG4gICAgICAgIGlmIChnZW9tZXRyeSAmJiBzdHJlYW1HZW9tZXRyeVR5cGUuaGFzT3duUHJvcGVydHkoZ2VvbWV0cnkudHlwZSkpIHtcbiAgICAgICAgICAgIHN0cmVhbUdlb21ldHJ5VHlwZVtnZW9tZXRyeS50eXBlXShnZW9tZXRyeSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3RyZWFtT2JqZWN0VHlwZSA9IHtcbiAgICAgICAgRmVhdHVyZTogZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICBzdHJlYW1HZW9tZXRyeShvYmplY3QuZ2VvbWV0cnksIHN0cmVhbSk7XG4gICAgICAgIH0sXG4gICAgICAgIEZlYXR1cmVDb2xsZWN0aW9uOiBmdW5jdGlvbiAob2JqZWN0LCBzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IG9iamVjdC5mZWF0dXJlcywgaSA9IC0xLCBuID0gZmVhdHVyZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtR2VvbWV0cnkoZmVhdHVyZXNbaV0uZ2VvbWV0cnksIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdHJlYW1HZW9tZXRyeVR5cGUgPSB7XG4gICAgICAgIFNwaGVyZTogZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICBzdHJlYW0uc3BoZXJlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFBvaW50OiBmdW5jdGlvbiAob2JqZWN0LCBzdHJlYW0pIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5jb29yZGluYXRlcztcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChvYmplY3RbMF0sIG9iamVjdFsxXSwgb2JqZWN0WzJdKTtcbiAgICAgICAgfSxcbiAgICAgICAgTXVsdGlQb2ludDogZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIG9iamVjdCA9IGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0ucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gICAgICAgIH0sXG4gICAgICAgIExpbmVTdHJpbmc6IGZ1bmN0aW9uIChvYmplY3QsIHN0cmVhbSkge1xuICAgICAgICAgICAgc3RyZWFtTGluZShvYmplY3QuY29vcmRpbmF0ZXMsIHN0cmVhbSwgMCk7XG4gICAgICAgIH0sXG4gICAgICAgIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSwgMCk7XG4gICAgICAgIH0sXG4gICAgICAgIFBvbHlnb246IGZ1bmN0aW9uIChvYmplY3QsIHN0cmVhbSkge1xuICAgICAgICAgICAgc3RyZWFtUG9seWdvbihvYmplY3QuY29vcmRpbmF0ZXMsIHN0cmVhbSk7XG4gICAgICAgIH0sXG4gICAgICAgIE11bHRpUG9seWdvbjogZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbVBvbHlnb24oY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSk7XG4gICAgICAgIH0sXG4gICAgICAgIEdlb21ldHJ5Q29sbGVjdGlvbjogZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cmllcyA9IG9iamVjdC5nZW9tZXRyaWVzLCBpID0gLTEsIG4gPSBnZW9tZXRyaWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbUdlb21ldHJ5KGdlb21ldHJpZXNbaV0sIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXMsIHN0cmVhbSwgY2xvc2VkKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGggLSBjbG9zZWQsIGNvb3JkaW5hdGU7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV0sIHN0cmVhbS5wb2ludChjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCBjb29yZGluYXRlWzJdKTtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyZWFtUG9seWdvbihjb29yZGluYXRlcywgc3RyZWFtKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0sIDEpO1xuICAgICAgICBzdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZW9TdHJlYW0ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICAgICAgaWYgKG9iamVjdCAmJiBzdHJlYW1PYmplY3RUeXBlLmhhc093blByb3BlcnR5KG9iamVjdC50eXBlKSkge1xuICAgICAgICAgICAgc3RyZWFtT2JqZWN0VHlwZVtvYmplY3QudHlwZV0ob2JqZWN0LCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtR2VvbWV0cnkob2JqZWN0LCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBhcmVhUmluZ1N1bSA9IGFkZGVyKCk7XG4gICAgdmFyIGFyZWFTdW0gPSBhZGRlcigpLCBsYW1iZGEwMCwgcGhpMDAsIGxhbWJkYTAsIGNvc1BoaTAsIHNpblBoaTA7XG4gICAgdmFyIGFyZWFTdHJlYW0gPSB7XG4gICAgICAgIHBvaW50OiBub29wLFxuICAgICAgICBsaW5lU3RhcnQ6IG5vb3AsXG4gICAgICAgIGxpbmVFbmQ6IG5vb3AsXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXJlYVJpbmdTdW0ucmVzZXQoKTtcbiAgICAgICAgICAgIGFyZWFTdHJlYW0ubGluZVN0YXJ0ID0gYXJlYVJpbmdTdGFydDtcbiAgICAgICAgICAgIGFyZWFTdHJlYW0ubGluZUVuZCA9IGFyZWFSaW5nRW5kO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJlYVJpbmcgPSArYXJlYVJpbmdTdW07XG4gICAgICAgICAgICBhcmVhU3VtLmFkZChhcmVhUmluZyA8IDAgPyB0YXUgKyBhcmVhUmluZyA6IGFyZWFSaW5nKTtcbiAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5saW5lRW5kID0gdGhpcy5wb2ludCA9IG5vb3A7XG4gICAgICAgIH0sXG4gICAgICAgIHNwaGVyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXJlYVN1bS5hZGQodGF1KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gYXJlYVJpbmdTdGFydCgpIHtcbiAgICAgICAgYXJlYVN0cmVhbS5wb2ludCA9IGFyZWFQb2ludEZpcnN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmVhUmluZ0VuZCgpIHtcbiAgICAgICAgYXJlYVBvaW50KGxhbWJkYTAwLCBwaGkwMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZWFQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGFyZWFTdHJlYW0ucG9pbnQgPSBhcmVhUG9pbnQ7XG4gICAgICAgIGxhbWJkYTAwID0gbGFtYmRhLCBwaGkwMCA9IHBoaTtcbiAgICAgICAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICAgICAgICBsYW1iZGEwID0gbGFtYmRhLCBjb3NQaGkwID0gY29zKHBoaSA9IHBoaSAvIDIgKyBxdWFydGVyUGkpLCBzaW5QaGkwID0gc2luKHBoaSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZWFQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gICAgICAgIHBoaSA9IHBoaSAvIDIgKyBxdWFydGVyUGk7IC8vIGhhbGYgdGhlIGFuZ3VsYXIgZGlzdGFuY2UgZnJvbSBzb3V0aCBwb2xlXG4gICAgICAgIC8vIFNwaGVyaWNhbCBleGNlc3MgRSBmb3IgYSBzcGhlcmljYWwgdHJpYW5nbGUgd2l0aCB2ZXJ0aWNlczogc291dGggcG9sZSxcbiAgICAgICAgLy8gcHJldmlvdXMgcG9pbnQsIGN1cnJlbnQgcG9pbnQuICBVc2VzIGEgZm9ybXVsYSBkZXJpdmVkIGZyb20gQ2Fnbm9saeKAmXNcbiAgICAgICAgLy8gdGhlb3JlbS4gIFNlZSBUb2RodW50ZXIsIFNwaGVyaWNhbCBUcmlnLiAoMTg3MSksIFNlYy4gMTAzLCBFcS4gKDIpLlxuICAgICAgICB2YXIgZExhbWJkYSA9IGxhbWJkYSAtIGxhbWJkYTAsIHNkTGFtYmRhID0gZExhbWJkYSA+PSAwID8gMSA6IC0xLCBhZExhbWJkYSA9IHNkTGFtYmRhICogZExhbWJkYSwgY29zUGhpID0gY29zKHBoaSksIHNpblBoaSA9IHNpbihwaGkpLCBrID0gc2luUGhpMCAqIHNpblBoaSwgdSA9IGNvc1BoaTAgKiBjb3NQaGkgKyBrICogY29zKGFkTGFtYmRhKSwgdiA9IGsgKiBzZExhbWJkYSAqIHNpbihhZExhbWJkYSk7XG4gICAgICAgIGFyZWFSaW5nU3VtLmFkZChhdGFuMih2LCB1KSk7XG4gICAgICAgIC8vIEFkdmFuY2UgdGhlIHByZXZpb3VzIHBvaW50cy5cbiAgICAgICAgbGFtYmRhMCA9IGxhbWJkYSwgY29zUGhpMCA9IGNvc1BoaSwgc2luUGhpMCA9IHNpblBoaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJlYShvYmplY3QpIHtcbiAgICAgICAgYXJlYVN1bS5yZXNldCgpO1xuICAgICAgICBnZW9TdHJlYW0ob2JqZWN0LCBhcmVhU3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIGFyZWFTdW0gKiAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcGhlcmljYWwoY2FydGVzaWFuKSB7XG4gICAgICAgIHJldHVybiBbYXRhbjIoY2FydGVzaWFuWzFdLCBjYXJ0ZXNpYW5bMF0pLCBhc2luKGNhcnRlc2lhblsyXSldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYXJ0ZXNpYW4oc3BoZXJpY2FsKSB7XG4gICAgICAgIHZhciBsYW1iZGEgPSBzcGhlcmljYWxbMF0sIHBoaSA9IHNwaGVyaWNhbFsxXSwgY29zUGhpID0gY29zKHBoaSk7XG4gICAgICAgIHJldHVybiBbY29zUGhpICogY29zKGxhbWJkYSksIGNvc1BoaSAqIHNpbihsYW1iZGEpLCBzaW4ocGhpKV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhcnRlc2lhbkRvdChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhcnRlc2lhbkNyb3NzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIFthWzFdICogYlsyXSAtIGFbMl0gKiBiWzFdLCBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdLCBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdXTtcbiAgICB9XG4gICAgLy8gVE9ETyByZXR1cm4gYVxuICAgIGZ1bmN0aW9uIGNhcnRlc2lhbkFkZEluUGxhY2UoYSwgYikge1xuICAgICAgICBhWzBdICs9IGJbMF0sIGFbMV0gKz0gYlsxXSwgYVsyXSArPSBiWzJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYXJ0ZXNpYW5TY2FsZSh2ZWN0b3IsIGspIHtcbiAgICAgICAgcmV0dXJuIFt2ZWN0b3JbMF0gKiBrLCB2ZWN0b3JbMV0gKiBrLCB2ZWN0b3JbMl0gKiBrXTtcbiAgICB9XG4gICAgLy8gVE9ETyByZXR1cm4gZFxuICAgIGZ1bmN0aW9uIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoZCkge1xuICAgICAgICB2YXIgbCA9IHNxcnQoZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXSArIGRbMl0gKiBkWzJdKTtcbiAgICAgICAgZFswXSAvPSBsLCBkWzFdIC89IGwsIGRbMl0gLz0gbDtcbiAgICB9XG4gICAgdmFyIGxhbWJkYTAkMSwgcGhpMCwgbGFtYmRhMSwgcGhpMSwgLy8gYm91bmRzXG4gICAgbGFtYmRhMiwgLy8gcHJldmlvdXMgbGFtYmRhLWNvb3JkaW5hdGVcbiAgICBsYW1iZGEwMCQxLCBwaGkwMCQxLCAvLyBmaXJzdCBwb2ludFxuICAgIHAwLCAvLyBwcmV2aW91cyAzRCBwb2ludFxuICAgIGRlbHRhU3VtID0gYWRkZXIoKSwgcmFuZ2VzLCByYW5nZTtcbiAgICB2YXIgYm91bmRzU3RyZWFtID0ge1xuICAgICAgICBwb2ludDogYm91bmRzUG9pbnQsXG4gICAgICAgIGxpbmVTdGFydDogYm91bmRzTGluZVN0YXJ0LFxuICAgICAgICBsaW5lRW5kOiBib3VuZHNMaW5lRW5kLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGJvdW5kc1N0cmVhbS5wb2ludCA9IGJvdW5kc1JpbmdQb2ludDtcbiAgICAgICAgICAgIGJvdW5kc1N0cmVhbS5saW5lU3RhcnQgPSBib3VuZHNSaW5nU3RhcnQ7XG4gICAgICAgICAgICBib3VuZHNTdHJlYW0ubGluZUVuZCA9IGJvdW5kc1JpbmdFbmQ7XG4gICAgICAgICAgICBkZWx0YVN1bS5yZXNldCgpO1xuICAgICAgICAgICAgYXJlYVN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXJlYVN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgICBib3VuZHNTdHJlYW0ucG9pbnQgPSBib3VuZHNQb2ludDtcbiAgICAgICAgICAgIGJvdW5kc1N0cmVhbS5saW5lU3RhcnQgPSBib3VuZHNMaW5lU3RhcnQ7XG4gICAgICAgICAgICBib3VuZHNTdHJlYW0ubGluZUVuZCA9IGJvdW5kc0xpbmVFbmQ7XG4gICAgICAgICAgICBpZiAoYXJlYVJpbmdTdW0gPCAwKVxuICAgICAgICAgICAgICAgIGxhbWJkYTAkMSA9IC0obGFtYmRhMSA9IDE4MCksIHBoaTAgPSAtKHBoaTEgPSA5MCk7XG4gICAgICAgICAgICBlbHNlIGlmIChkZWx0YVN1bSA+IGVwc2lsb24pXG4gICAgICAgICAgICAgICAgcGhpMSA9IDkwO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGVsdGFTdW0gPCAtZXBzaWxvbilcbiAgICAgICAgICAgICAgICBwaGkwID0gLTkwO1xuICAgICAgICAgICAgcmFuZ2VbMF0gPSBsYW1iZGEwJDEsIHJhbmdlWzFdID0gbGFtYmRhMTtcbiAgICAgICAgfSxcbiAgICAgICAgc3BoZXJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsYW1iZGEwJDEgPSAtKGxhbWJkYTEgPSAxODApLCBwaGkwID0gLShwaGkxID0gOTApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBib3VuZHNQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgICByYW5nZXMucHVzaChyYW5nZSA9IFtsYW1iZGEwJDEgPSBsYW1iZGEsIGxhbWJkYTEgPSBsYW1iZGFdKTtcbiAgICAgICAgaWYgKHBoaSA8IHBoaTApXG4gICAgICAgICAgICBwaGkwID0gcGhpO1xuICAgICAgICBpZiAocGhpID4gcGhpMSlcbiAgICAgICAgICAgIHBoaTEgPSBwaGk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgcCA9IGNhcnRlc2lhbihbbGFtYmRhICogcmFkaWFucywgcGhpICogcmFkaWFuc10pO1xuICAgICAgICBpZiAocDApIHtcbiAgICAgICAgICAgIHZhciBub3JtYWwgPSBjYXJ0ZXNpYW5Dcm9zcyhwMCwgcCksIGVxdWF0b3JpYWwgPSBbbm9ybWFsWzFdLCAtbm9ybWFsWzBdLCAwXSwgaW5mbGVjdGlvbiA9IGNhcnRlc2lhbkNyb3NzKGVxdWF0b3JpYWwsIG5vcm1hbCk7XG4gICAgICAgICAgICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGluZmxlY3Rpb24pO1xuICAgICAgICAgICAgaW5mbGVjdGlvbiA9IHNwaGVyaWNhbChpbmZsZWN0aW9uKTtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGxhbWJkYSAtIGxhbWJkYTIsIHNpZ24gPSBkZWx0YSA+IDAgPyAxIDogLTEsIGxhbWJkYWkgPSBpbmZsZWN0aW9uWzBdICogZGVncmVlcyAqIHNpZ24sIHBoaWksIGFudGltZXJpZGlhbiA9IGFicyhkZWx0YSkgPiAxODA7XG4gICAgICAgICAgICBpZiAoYW50aW1lcmlkaWFuIF4gKHNpZ24gKiBsYW1iZGEyIDwgbGFtYmRhaSAmJiBsYW1iZGFpIDwgc2lnbiAqIGxhbWJkYSkpIHtcbiAgICAgICAgICAgICAgICBwaGlpID0gaW5mbGVjdGlvblsxXSAqIGRlZ3JlZXM7XG4gICAgICAgICAgICAgICAgaWYgKHBoaWkgPiBwaGkxKVxuICAgICAgICAgICAgICAgICAgICBwaGkxID0gcGhpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbWJkYWkgPSAobGFtYmRhaSArIDM2MCkgJSAzNjAgLSAxODAsIGFudGltZXJpZGlhbiBeIChzaWduICogbGFtYmRhMiA8IGxhbWJkYWkgJiYgbGFtYmRhaSA8IHNpZ24gKiBsYW1iZGEpKSB7XG4gICAgICAgICAgICAgICAgcGhpaSA9IC1pbmZsZWN0aW9uWzFdICogZGVncmVlcztcbiAgICAgICAgICAgICAgICBpZiAocGhpaSA8IHBoaTApXG4gICAgICAgICAgICAgICAgICAgIHBoaTAgPSBwaGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHBoaSA8IHBoaTApXG4gICAgICAgICAgICAgICAgICAgIHBoaTAgPSBwaGk7XG4gICAgICAgICAgICAgICAgaWYgKHBoaSA+IHBoaTEpXG4gICAgICAgICAgICAgICAgICAgIHBoaTEgPSBwaGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW50aW1lcmlkaWFuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhbWJkYSA8IGxhbWJkYTIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhKSA+IGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW1iZGExID0gbGFtYmRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYSwgbGFtYmRhMSkgPiBhbmdsZShsYW1iZGEwJDEsIGxhbWJkYTEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFtYmRhMCQxID0gbGFtYmRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsYW1iZGExID49IGxhbWJkYTAkMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFtYmRhIDwgbGFtYmRhMCQxKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFtYmRhMCQxID0gbGFtYmRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFtYmRhID4gbGFtYmRhMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbWJkYTEgPSBsYW1iZGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFtYmRhID4gbGFtYmRhMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhKSA+IGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFtYmRhMSA9IGxhbWJkYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmdsZShsYW1iZGEsIGxhbWJkYTEpID4gYW5nbGUobGFtYmRhMCQxLCBsYW1iZGExKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW1iZGEwJDEgPSBsYW1iZGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByYW5nZXMucHVzaChyYW5nZSA9IFtsYW1iZGEwJDEgPSBsYW1iZGEsIGxhbWJkYTEgPSBsYW1iZGFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGhpIDwgcGhpMClcbiAgICAgICAgICAgIHBoaTAgPSBwaGk7XG4gICAgICAgIGlmIChwaGkgPiBwaGkxKVxuICAgICAgICAgICAgcGhpMSA9IHBoaTtcbiAgICAgICAgcDAgPSBwLCBsYW1iZGEyID0gbGFtYmRhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBib3VuZHNMaW5lU3RhcnQoKSB7XG4gICAgICAgIGJvdW5kc1N0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm91bmRzTGluZUVuZCgpIHtcbiAgICAgICAgcmFuZ2VbMF0gPSBsYW1iZGEwJDEsIHJhbmdlWzFdID0gbGFtYmRhMTtcbiAgICAgICAgYm91bmRzU3RyZWFtLnBvaW50ID0gYm91bmRzUG9pbnQ7XG4gICAgICAgIHAwID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm91bmRzUmluZ1BvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGlmIChwMCkge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gbGFtYmRhIC0gbGFtYmRhMjtcbiAgICAgICAgICAgIGRlbHRhU3VtLmFkZChhYnMoZGVsdGEpID4gMTgwID8gZGVsdGEgKyAoZGVsdGEgPiAwID8gMzYwIDogLTM2MCkgOiBkZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYW1iZGEwMCQxID0gbGFtYmRhLCBwaGkwMCQxID0gcGhpO1xuICAgICAgICB9XG4gICAgICAgIGFyZWFTdHJlYW0ucG9pbnQobGFtYmRhLCBwaGkpO1xuICAgICAgICBsaW5lUG9pbnQobGFtYmRhLCBwaGkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBib3VuZHNSaW5nU3RhcnQoKSB7XG4gICAgICAgIGFyZWFTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJvdW5kc1JpbmdFbmQoKSB7XG4gICAgICAgIGJvdW5kc1JpbmdQb2ludChsYW1iZGEwMCQxLCBwaGkwMCQxKTtcbiAgICAgICAgYXJlYVN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIGlmIChhYnMoZGVsdGFTdW0pID4gZXBzaWxvbilcbiAgICAgICAgICAgIGxhbWJkYTAkMSA9IC0obGFtYmRhMSA9IDE4MCk7XG4gICAgICAgIHJhbmdlWzBdID0gbGFtYmRhMCQxLCByYW5nZVsxXSA9IGxhbWJkYTE7XG4gICAgICAgIHAwID0gbnVsbDtcbiAgICB9XG4gICAgLy8gRmluZHMgdGhlIGxlZnQtcmlnaHQgZGlzdGFuY2UgYmV0d2VlbiB0d28gbG9uZ2l0dWRlcy5cbiAgICAvLyBUaGlzIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyAobGFtYmRhMSAtIGxhbWJkYTAgKyAzNjDCsCkgJSAzNjDCsCwgZXhjZXB0IHRoYXQgd2Ugd2FudFxuICAgIC8vIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIMKxMTgwwrAgdG8gYmUgMzYwwrAuXG4gICAgZnVuY3Rpb24gYW5nbGUobGFtYmRhMCwgbGFtYmRhMSkge1xuICAgICAgICByZXR1cm4gKGxhbWJkYTEgLT0gbGFtYmRhMCkgPCAwID8gbGFtYmRhMSArIDM2MCA6IGxhbWJkYTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhbmdlQ29tcGFyZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFuZ2VDb250YWlucyhyYW5nZSwgeCkge1xuICAgICAgICByZXR1cm4gcmFuZ2VbMF0gPD0gcmFuZ2VbMV0gPyByYW5nZVswXSA8PSB4ICYmIHggPD0gcmFuZ2VbMV0gOiB4IDwgcmFuZ2VbMF0gfHwgcmFuZ2VbMV0gPCB4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBib3VuZHMoZmVhdHVyZSkge1xuICAgICAgICB2YXIgaSwgbiwgYSwgYiwgbWVyZ2VkLCBkZWx0YU1heCwgZGVsdGE7XG4gICAgICAgIHBoaTEgPSBsYW1iZGExID0gLShsYW1iZGEwJDEgPSBwaGkwID0gSW5maW5pdHkpO1xuICAgICAgICByYW5nZXMgPSBbXTtcbiAgICAgICAgZ2VvU3RyZWFtKGZlYXR1cmUsIGJvdW5kc1N0cmVhbSk7XG4gICAgICAgIC8vIEZpcnN0LCBzb3J0IHJhbmdlcyBieSB0aGVpciBtaW5pbXVtIGxvbmdpdHVkZXMuXG4gICAgICAgIGlmIChuID0gcmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmFuZ2VzLnNvcnQocmFuZ2VDb21wYXJlKTtcbiAgICAgICAgICAgIC8vIFRoZW4sIG1lcmdlIGFueSByYW5nZXMgdGhhdCBvdmVybGFwLlxuICAgICAgICAgICAgZm9yIChpID0gMSwgYSA9IHJhbmdlc1swXSwgbWVyZ2VkID0gW2FdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgYiA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VDb250YWlucyhhLCBiWzBdKSB8fCByYW5nZUNvbnRhaW5zKGEsIGJbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmdsZShhWzBdLCBiWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgYVsxXSA9IGJbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmdsZShiWzBdLCBhWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgYVswXSA9IGJbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChhID0gYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluYWxseSwgZmluZCB0aGUgbGFyZ2VzdCBnYXAgYmV0d2VlbiB0aGUgbWVyZ2VkIHJhbmdlcy5cbiAgICAgICAgICAgIC8vIFRoZSBmaW5hbCBib3VuZGluZyBib3ggd2lsbCBiZSB0aGUgaW52ZXJzZSBvZiB0aGlzIGdhcC5cbiAgICAgICAgICAgIGZvciAoZGVsdGFNYXggPSAtSW5maW5pdHksIG4gPSBtZXJnZWQubGVuZ3RoIC0gMSwgaSA9IDAsIGEgPSBtZXJnZWRbbl07IGkgPD0gbjsgYSA9IGIsICsraSkge1xuICAgICAgICAgICAgICAgIGIgPSBtZXJnZWRbaV07XG4gICAgICAgICAgICAgICAgaWYgKChkZWx0YSA9IGFuZ2xlKGFbMV0sIGJbMF0pKSA+IGRlbHRhTWF4KVxuICAgICAgICAgICAgICAgICAgICBkZWx0YU1heCA9IGRlbHRhLCBsYW1iZGEwJDEgPSBiWzBdLCBsYW1iZGExID0gYVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByYW5nZXMgPSByYW5nZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBsYW1iZGEwJDEgPT09IEluZmluaXR5IHx8IHBoaTAgPT09IEluZmluaXR5XG4gICAgICAgICAgICA/IFtbTmFOLCBOYU5dLCBbTmFOLCBOYU5dXVxuICAgICAgICAgICAgOiBbW2xhbWJkYTAkMSwgcGhpMF0sIFtsYW1iZGExLCBwaGkxXV07XG4gICAgfVxuICAgIHZhciBXMCwgVzEsIFgwLCBZMCwgWjAsIFgxLCBZMSwgWjEsIFgyLCBZMiwgWjIsIGxhbWJkYTAwJDIsIHBoaTAwJDIsIC8vIGZpcnN0IHBvaW50XG4gICAgeDAsIHkwLCB6MDsgLy8gcHJldmlvdXMgcG9pbnRcbiAgICB2YXIgY2VudHJvaWRTdHJlYW0gPSB7XG4gICAgICAgIHNwaGVyZTogbm9vcCxcbiAgICAgICAgcG9pbnQ6IGNlbnRyb2lkUG9pbnQsXG4gICAgICAgIGxpbmVTdGFydDogY2VudHJvaWRMaW5lU3RhcnQsXG4gICAgICAgIGxpbmVFbmQ6IGNlbnRyb2lkTGluZUVuZCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZFJpbmdTdGFydDtcbiAgICAgICAgICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVFbmQgPSBjZW50cm9pZFJpbmdFbmQ7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVTdGFydCA9IGNlbnRyb2lkTGluZVN0YXJ0O1xuICAgICAgICAgICAgY2VudHJvaWRTdHJlYW0ubGluZUVuZCA9IGNlbnRyb2lkTGluZUVuZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQXJpdGhtZXRpYyBtZWFuIG9mIENhcnRlc2lhbiB2ZWN0b3JzLlxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICAgICAgICB2YXIgY29zUGhpID0gY29zKHBoaSk7XG4gICAgICAgIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oY29zUGhpICogY29zKGxhbWJkYSksIGNvc1BoaSAqIHNpbihsYW1iZGEpLCBzaW4ocGhpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeCwgeSwgeikge1xuICAgICAgICArK1cwO1xuICAgICAgICBYMCArPSAoeCAtIFgwKSAvIFcwO1xuICAgICAgICBZMCArPSAoeSAtIFkwKSAvIFcwO1xuICAgICAgICBaMCArPSAoeiAtIFowKSAvIFcwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZExpbmVTdGFydCgpIHtcbiAgICAgICAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZExpbmVQb2ludEZpcnN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZExpbmVQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgICAgICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpO1xuICAgICAgICB4MCA9IGNvc1BoaSAqIGNvcyhsYW1iZGEpO1xuICAgICAgICB5MCA9IGNvc1BoaSAqIHNpbihsYW1iZGEpO1xuICAgICAgICB6MCA9IHNpbihwaGkpO1xuICAgICAgICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkTGluZVBvaW50O1xuICAgICAgICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZExpbmVQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gICAgICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKSwgeCA9IGNvc1BoaSAqIGNvcyhsYW1iZGEpLCB5ID0gY29zUGhpICogc2luKGxhbWJkYSksIHogPSBzaW4ocGhpKSwgdyA9IGF0YW4yKHNxcnQoKHcgPSB5MCAqIHogLSB6MCAqIHkpICogdyArICh3ID0gejAgKiB4IC0geDAgKiB6KSAqIHcgKyAodyA9IHgwICogeSAtIHkwICogeCkgKiB3KSwgeDAgKiB4ICsgeTAgKiB5ICsgejAgKiB6KTtcbiAgICAgICAgVzEgKz0gdztcbiAgICAgICAgWDEgKz0gdyAqICh4MCArICh4MCA9IHgpKTtcbiAgICAgICAgWTEgKz0gdyAqICh5MCArICh5MCA9IHkpKTtcbiAgICAgICAgWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgICAgICAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRMaW5lRW5kKCkge1xuICAgICAgICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnQ7XG4gICAgfVxuICAgIC8vIFNlZSBKLiBFLiBCcm9jaywgVGhlIEluZXJ0aWEgVGVuc29yIGZvciBhIFNwaGVyaWNhbCBUcmlhbmdsZSxcbiAgICAvLyBKLiBBcHBsaWVkIE1lY2hhbmljcyA0MiwgMjM5ICgxOTc1KS5cbiAgICBmdW5jdGlvbiBjZW50cm9pZFJpbmdTdGFydCgpIHtcbiAgICAgICAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFJpbmdQb2ludEZpcnN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZFJpbmdFbmQoKSB7XG4gICAgICAgIGNlbnRyb2lkUmluZ1BvaW50KGxhbWJkYTAwJDIsIHBoaTAwJDIpO1xuICAgICAgICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkUmluZ1BvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgbGFtYmRhMDAkMiA9IGxhbWJkYSwgcGhpMDAkMiA9IHBoaTtcbiAgICAgICAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICAgICAgICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUmluZ1BvaW50O1xuICAgICAgICB2YXIgY29zUGhpID0gY29zKHBoaSk7XG4gICAgICAgIHgwID0gY29zUGhpICogY29zKGxhbWJkYSk7XG4gICAgICAgIHkwID0gY29zUGhpICogc2luKGxhbWJkYSk7XG4gICAgICAgIHowID0gc2luKHBoaSk7XG4gICAgICAgIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkUmluZ1BvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgICAgICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLCB4ID0gY29zUGhpICogY29zKGxhbWJkYSksIHkgPSBjb3NQaGkgKiBzaW4obGFtYmRhKSwgeiA9IHNpbihwaGkpLCBjeCA9IHkwICogeiAtIHowICogeSwgY3kgPSB6MCAqIHggLSB4MCAqIHosIGN6ID0geDAgKiB5IC0geTAgKiB4LCBtID0gc3FydChjeCAqIGN4ICsgY3kgKiBjeSArIGN6ICogY3opLCB3ID0gYXNpbihtKSwgLy8gbGluZSB3ZWlnaHQgPSBhbmdsZVxuICAgICAgICB2ID0gbSAmJiAtdyAvIG07IC8vIGFyZWEgd2VpZ2h0IG11bHRpcGxpZXJcbiAgICAgICAgWDIgKz0gdiAqIGN4O1xuICAgICAgICBZMiArPSB2ICogY3k7XG4gICAgICAgIFoyICs9IHYgKiBjejtcbiAgICAgICAgVzEgKz0gdztcbiAgICAgICAgWDEgKz0gdyAqICh4MCArICh4MCA9IHgpKTtcbiAgICAgICAgWTEgKz0gdyAqICh5MCArICh5MCA9IHkpKTtcbiAgICAgICAgWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgICAgICAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWQob2JqZWN0KSB7XG4gICAgICAgIFcwID0gVzEgPVxuICAgICAgICAgICAgWDAgPSBZMCA9IFowID1cbiAgICAgICAgICAgICAgICBYMSA9IFkxID0gWjEgPVxuICAgICAgICAgICAgICAgICAgICBYMiA9IFkyID0gWjIgPSAwO1xuICAgICAgICBnZW9TdHJlYW0ob2JqZWN0LCBjZW50cm9pZFN0cmVhbSk7XG4gICAgICAgIHZhciB4ID0gWDIsIHkgPSBZMiwgeiA9IFoyLCBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICAgICAgICAvLyBJZiB0aGUgYXJlYS13ZWlnaHRlZCBjY2VudHJvaWQgaXMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbGVuZ3RoLXdlaWdodGVkIGNjZW50cm9pZC5cbiAgICAgICAgaWYgKG0gPCBlcHNpbG9uMikge1xuICAgICAgICAgICAgeCA9IFgxLCB5ID0gWTEsIHogPSBaMTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmZWF0dXJlIGhhcyB6ZXJvIGxlbmd0aCwgZmFsbCBiYWNrIHRvIGFyaXRobWV0aWMgbWVhbiBvZiBwb2ludCB2ZWN0b3JzLlxuICAgICAgICAgICAgaWYgKFcxIDwgZXBzaWxvbilcbiAgICAgICAgICAgICAgICB4ID0gWDAsIHkgPSBZMCwgeiA9IFowO1xuICAgICAgICAgICAgbSA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmZWF0dXJlIHN0aWxsIGhhcyBhbiB1bmRlZmluZWQgY2NlbnRyb2lkLCB0aGVuIHJldHVybi5cbiAgICAgICAgICAgIGlmIChtIDwgZXBzaWxvbjIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtOYU4sIE5hTl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFthdGFuMih5LCB4KSAqIGRlZ3JlZXMsIGFzaW4oeiAvIHNxcnQobSkpICogZGVncmVlc107XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wb3NlKGEsIGIpIHtcbiAgICAgICAgZnVuY3Rpb24gY29tcG9zZSh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geCA9IGEoeCwgeSksIGIoeFswXSwgeFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEuaW52ZXJ0ICYmIGIuaW52ZXJ0KVxuICAgICAgICAgICAgY29tcG9zZS5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4ID0gYi5pbnZlcnQoeCwgeSksIHggJiYgYS5pbnZlcnQoeFswXSwgeFsxXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY29tcG9zZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcm90YXRpb25JZGVudGl0eShsYW1iZGEsIHBoaSkge1xuICAgICAgICByZXR1cm4gW2FicyhsYW1iZGEpID4gcGkgPyBsYW1iZGEgKyBNYXRoLnJvdW5kKC1sYW1iZGEgLyB0YXUpICogdGF1IDogbGFtYmRhLCBwaGldO1xuICAgIH1cbiAgICByb3RhdGlvbklkZW50aXR5LmludmVydCA9IHJvdGF0aW9uSWRlbnRpdHk7XG4gICAgZnVuY3Rpb24gcm90YXRlUmFkaWFucyhkZWx0YUxhbWJkYSwgZGVsdGFQaGksIGRlbHRhR2FtbWEpIHtcbiAgICAgICAgcmV0dXJuIChkZWx0YUxhbWJkYSAlPSB0YXUpID8gKGRlbHRhUGhpIHx8IGRlbHRhR2FtbWEgPyBjb21wb3NlKHJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSwgcm90YXRpb25QaGlHYW1tYShkZWx0YVBoaSwgZGVsdGFHYW1tYSkpXG4gICAgICAgICAgICA6IHJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSlcbiAgICAgICAgICAgIDogKGRlbHRhUGhpIHx8IGRlbHRhR2FtbWEgPyByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKVxuICAgICAgICAgICAgICAgIDogcm90YXRpb25JZGVudGl0eSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcndhcmRSb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFtYmRhICs9IGRlbHRhTGFtYmRhLCBbbGFtYmRhID4gcGkgPyBsYW1iZGEgLSB0YXUgOiBsYW1iZGEgPCAtcGkgPyBsYW1iZGEgKyB0YXUgOiBsYW1iZGEsIHBoaV07XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSB7XG4gICAgICAgIHZhciByb3RhdGlvbiA9IGZvcndhcmRSb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSk7XG4gICAgICAgIHJvdGF0aW9uLmludmVydCA9IGZvcndhcmRSb3RhdGlvbkxhbWJkYSgtZGVsdGFMYW1iZGEpO1xuICAgICAgICByZXR1cm4gcm90YXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpIHtcbiAgICAgICAgdmFyIGNvc0RlbHRhUGhpID0gY29zKGRlbHRhUGhpKSwgc2luRGVsdGFQaGkgPSBzaW4oZGVsdGFQaGkpLCBjb3NEZWx0YUdhbW1hID0gY29zKGRlbHRhR2FtbWEpLCBzaW5EZWx0YUdhbW1hID0gc2luKGRlbHRhR2FtbWEpO1xuICAgICAgICBmdW5jdGlvbiByb3RhdGlvbihsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLCB4ID0gY29zKGxhbWJkYSkgKiBjb3NQaGksIHkgPSBzaW4obGFtYmRhKSAqIGNvc1BoaSwgeiA9IHNpbihwaGkpLCBrID0geiAqIGNvc0RlbHRhUGhpICsgeCAqIHNpbkRlbHRhUGhpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBhdGFuMih5ICogY29zRGVsdGFHYW1tYSAtIGsgKiBzaW5EZWx0YUdhbW1hLCB4ICogY29zRGVsdGFQaGkgLSB6ICogc2luRGVsdGFQaGkpLFxuICAgICAgICAgICAgICAgIGFzaW4oayAqIGNvc0RlbHRhR2FtbWEgKyB5ICogc2luRGVsdGFHYW1tYSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcm90YXRpb24uaW52ZXJ0ID0gZnVuY3Rpb24gKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICB2YXIgY29zUGhpID0gY29zKHBoaSksIHggPSBjb3MobGFtYmRhKSAqIGNvc1BoaSwgeSA9IHNpbihsYW1iZGEpICogY29zUGhpLCB6ID0gc2luKHBoaSksIGsgPSB6ICogY29zRGVsdGFHYW1tYSAtIHkgKiBzaW5EZWx0YUdhbW1hO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBhdGFuMih5ICogY29zRGVsdGFHYW1tYSArIHogKiBzaW5EZWx0YUdhbW1hLCB4ICogY29zRGVsdGFQaGkgKyBrICogc2luRGVsdGFQaGkpLFxuICAgICAgICAgICAgICAgIGFzaW4oayAqIGNvc0RlbHRhUGhpIC0geCAqIHNpbkRlbHRhUGhpKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJvdGF0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiByb3RhdGlvbihyb3RhdGUpIHtcbiAgICAgICAgcm90YXRlID0gcm90YXRlUmFkaWFucyhyb3RhdGVbMF0gKiByYWRpYW5zLCByb3RhdGVbMV0gKiByYWRpYW5zLCByb3RhdGUubGVuZ3RoID4gMiA/IHJvdGF0ZVsyXSAqIHJhZGlhbnMgOiAwKTtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChjb29yZGluYXRlcykge1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMgPSByb3RhdGUoY29vcmRpbmF0ZXNbMF0gKiByYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIHJhZGlhbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICBjb29yZGluYXRlcyA9IHJvdGF0ZS5pbnZlcnQoY29vcmRpbmF0ZXNbMF0gKiByYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIHJhZGlhbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9XG4gICAgLy8gR2VuZXJhdGVzIGEgY2lyY2xlIGNlbnRlcmVkIGF0IFswwrAsIDDCsF0sIHdpdGggYSBnaXZlbiByYWRpdXMgYW5kIHByZWNpc2lvbi5cbiAgICBmdW5jdGlvbiBjaXJjbGVTdHJlYW0oc3RyZWFtLCByYWRpdXMsIGRlbHRhLCBkaXJlY3Rpb24sIHQwLCB0MSkge1xuICAgICAgICBpZiAoIWRlbHRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgY29zUmFkaXVzID0gY29zKHJhZGl1cyksIHNpblJhZGl1cyA9IHNpbihyYWRpdXMpLCBzdGVwID0gZGlyZWN0aW9uICogZGVsdGE7XG4gICAgICAgIGlmICh0MCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0MCA9IHJhZGl1cyArIGRpcmVjdGlvbiAqIHRhdTtcbiAgICAgICAgICAgIHQxID0gcmFkaXVzIC0gc3RlcCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0MCA9IGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHQwKTtcbiAgICAgICAgICAgIHQxID0gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgdDEpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDAgPyB0MCA8IHQxIDogdDAgPiB0MSlcbiAgICAgICAgICAgICAgICB0MCArPSBkaXJlY3Rpb24gKiB0YXU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgcG9pbnQsIHQgPSB0MDsgZGlyZWN0aW9uID4gMCA/IHQgPiB0MSA6IHQgPCB0MTsgdCAtPSBzdGVwKSB7XG4gICAgICAgICAgICBwb2ludCA9IHNwaGVyaWNhbChbY29zUmFkaXVzLCAtc2luUmFkaXVzICogY29zKHQpLCAtc2luUmFkaXVzICogc2luKHQpXSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnRbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBzaWduZWQgYW5nbGUgb2YgYSBjYXJ0ZXNpYW4gcG9pbnQgcmVsYXRpdmUgdG8gW2Nvc1JhZGl1cywgMCwgMF0uXG4gICAgZnVuY3Rpb24gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgcG9pbnQpIHtcbiAgICAgICAgcG9pbnQgPSBjYXJ0ZXNpYW4ocG9pbnQpLCBwb2ludFswXSAtPSBjb3NSYWRpdXM7XG4gICAgICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UocG9pbnQpO1xuICAgICAgICB2YXIgcmFkaXVzID0gYWNvcygtcG9pbnRbMV0pO1xuICAgICAgICByZXR1cm4gKCgtcG9pbnRbMl0gPCAwID8gLXJhZGl1cyA6IHJhZGl1cykgKyB0YXUgLSBlcHNpbG9uKSAlIHRhdTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2lyY2xlKCkge1xuICAgICAgICB2YXIgY2VudGVyID0gY29uc3RhbnQoWzAsIDBdKSwgcmFkaXVzID0gY29uc3RhbnQoOTApLCBwcmVjaXNpb24gPSBjb25zdGFudCg2KSwgcmluZywgcm90YXRlLCBzdHJlYW0gPSB7IHBvaW50OiBwb2ludCB9O1xuICAgICAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICAgICAgICByaW5nLnB1c2goeCA9IHJvdGF0ZSh4LCB5KSk7XG4gICAgICAgICAgICB4WzBdICo9IGRlZ3JlZXMsIHhbMV0gKj0gZGVncmVlcztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaXJjbGUoKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGNlbnRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCByID0gcmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiByYWRpYW5zLCBwID0gcHJlY2lzaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiByYWRpYW5zO1xuICAgICAgICAgICAgcmluZyA9IFtdO1xuICAgICAgICAgICAgcm90YXRlID0gcm90YXRlUmFkaWFucygtY1swXSAqIHJhZGlhbnMsIC1jWzFdICogcmFkaWFucywgMCkuaW52ZXJ0O1xuICAgICAgICAgICAgY2lyY2xlU3RyZWFtKHN0cmVhbSwgciwgcCwgMSk7XG4gICAgICAgICAgICBjID0geyB0eXBlOiBcIlBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IFtyaW5nXSB9O1xuICAgICAgICAgICAgcmluZyA9IHJvdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfVxuICAgICAgICBjaXJjbGUuY2VudGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNlbnRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoWytfWzBdLCArX1sxXV0pLCBjaXJjbGUpIDogY2VudGVyO1xuICAgICAgICB9O1xuICAgICAgICBjaXJjbGUucmFkaXVzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBjaXJjbGUpIDogcmFkaXVzO1xuICAgICAgICB9O1xuICAgICAgICBjaXJjbGUucHJlY2lzaW9uID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByZWNpc2lvbiA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBjaXJjbGUpIDogcHJlY2lzaW9uO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGlwQnVmZmVyKCkge1xuICAgICAgICB2YXIgbGluZXMgPSBbXSwgbGluZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIGxpbmUucHVzaChbeCwgeV0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSA9IFtdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lRW5kOiBub29wLFxuICAgICAgICAgICAgcmVqb2luOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZXMucG9wKCkuY29uY2F0KGxpbmVzLnNoaWZ0KCkpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbGluZXM7XG4gICAgICAgICAgICAgICAgbGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBsaW5lID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludEVxdWFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFicyhhWzBdIC0gYlswXSkgPCBlcHNpbG9uICYmIGFicyhhWzFdIC0gYlsxXSkgPCBlcHNpbG9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJbnRlcnNlY3Rpb24ocG9pbnQsIHBvaW50cywgb3RoZXIsIGVudHJ5KSB7XG4gICAgICAgIHRoaXMueCA9IHBvaW50O1xuICAgICAgICB0aGlzLnogPSBwb2ludHM7XG4gICAgICAgIHRoaXMubyA9IG90aGVyOyAvLyBhbm90aGVyIGludGVyc2VjdGlvblxuICAgICAgICB0aGlzLmUgPSBlbnRyeTsgLy8gaXMgYW4gZW50cnk/XG4gICAgICAgIHRoaXMudiA9IGZhbHNlOyAvLyB2aXNpdGVkXG4gICAgICAgIHRoaXMubiA9IHRoaXMucCA9IG51bGw7IC8vIG5leHQgJiBwcmV2aW91c1xuICAgIH1cbiAgICAvLyBBIGdlbmVyYWxpemVkIHBvbHlnb24gY2xpcHBpbmcgYWxnb3JpdGhtOiBnaXZlbiBhIHBvbHlnb24gdGhhdCBoYXMgYmVlbiBjdXRcbiAgICAvLyBpbnRvIGl0cyB2aXNpYmxlIGxpbmUgc2VnbWVudHMsIGFuZCByZWpvaW5zIHRoZSBzZWdtZW50cyBieSBpbnRlcnBvbGF0aW5nXG4gICAgLy8gYWxvbmcgdGhlIGNsaXAgZWRnZS5cbiAgICBmdW5jdGlvbiBjbGlwUmVqb2luKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHN0cmVhbSkge1xuICAgICAgICB2YXIgc3ViamVjdCA9IFtdLCBjbGlwID0gW10sIGksIG47XG4gICAgICAgIHNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgICAgICAgIGlmICgobiA9IHNlZ21lbnQubGVuZ3RoIC0gMSkgPD0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbiwgcDAgPSBzZWdtZW50WzBdLCBwMSA9IHNlZ21lbnRbbl0sIHg7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnRzIG9mIGEgc2VnbWVudCBhcmUgY29pbmNpZGVudCwgdGhlbiB0cmVhdCBhcyBhXG4gICAgICAgICAgICAvLyBjbG9zZWQgcmluZy4gVE9ETyBpZiBhbGwgcmluZ3MgYXJlIGNsb3NlZCwgdGhlbiB0aGUgd2luZGluZyBvcmRlciBvZiB0aGVcbiAgICAgICAgICAgIC8vIGV4dGVyaW9yIHJpbmcgc2hvdWxkIGJlIGNoZWNrZWQuXG4gICAgICAgICAgICBpZiAocG9pbnRFcXVhbChwMCwgcDEpKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludCgocDAgPSBzZWdtZW50W2ldKVswXSwgcDBbMV0pO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViamVjdC5wdXNoKHggPSBuZXcgSW50ZXJzZWN0aW9uKHAwLCBzZWdtZW50LCBudWxsLCB0cnVlKSk7XG4gICAgICAgICAgICBjbGlwLnB1c2goeC5vID0gbmV3IEludGVyc2VjdGlvbihwMCwgbnVsbCwgeCwgZmFsc2UpKTtcbiAgICAgICAgICAgIHN1YmplY3QucHVzaCh4ID0gbmV3IEludGVyc2VjdGlvbihwMSwgc2VnbWVudCwgbnVsbCwgZmFsc2UpKTtcbiAgICAgICAgICAgIGNsaXAucHVzaCh4Lm8gPSBuZXcgSW50ZXJzZWN0aW9uKHAxLCBudWxsLCB4LCB0cnVlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXN1YmplY3QubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjbGlwLnNvcnQoY29tcGFyZUludGVyc2VjdGlvbik7XG4gICAgICAgIGxpbmsoc3ViamVjdCk7XG4gICAgICAgIGxpbmsoY2xpcCk7XG4gICAgICAgIGZvciAoaSA9IDAsIG4gPSBjbGlwLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgY2xpcFtpXS5lID0gc3RhcnRJbnNpZGUgPSAhc3RhcnRJbnNpZGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gc3ViamVjdFswXSwgcG9pbnRzLCBwb2ludDtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgZmlyc3QgdW52aXNpdGVkIGludGVyc2VjdGlvbi5cbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gc3RhcnQsIGlzU3ViamVjdCA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudC52KVxuICAgICAgICAgICAgICAgIGlmICgoY3VycmVudCA9IGN1cnJlbnQubikgPT09IHN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY3VycmVudC52ID0gY3VycmVudC5vLnYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBuOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5uLngsIDEsIHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N1YmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IGN1cnJlbnQucC56O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQucC54LCAtMSwgc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5vO1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IGN1cnJlbnQuejtcbiAgICAgICAgICAgICAgICBpc1N1YmplY3QgPSAhaXNTdWJqZWN0O1xuICAgICAgICAgICAgfSB3aGlsZSAoIWN1cnJlbnQudik7XG4gICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmsoYXJyYXkpIHtcbiAgICAgICAgaWYgKCEobiA9IGFycmF5Lmxlbmd0aCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBuLCBpID0gMCwgYSA9IGFycmF5WzBdLCBiO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgYS5uID0gYiA9IGFycmF5W2ldO1xuICAgICAgICAgICAgYi5wID0gYTtcbiAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICB9XG4gICAgICAgIGEubiA9IGIgPSBhcnJheVswXTtcbiAgICAgICAgYi5wID0gYTtcbiAgICB9XG4gICAgdmFyIHN1bSA9IGFkZGVyKCk7XG4gICAgZnVuY3Rpb24gbG9uZ2l0dWRlKHBvaW50KSB7XG4gICAgICAgIGlmIChhYnMocG9pbnRbMF0pIDw9IHBpKVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50WzBdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gc2lnbihwb2ludFswXSkgKiAoKGFicyhwb2ludFswXSkgKyBwaSkgJSB0YXUgLSBwaSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvbHlnb25Db250YWlucyhwb2x5Z29uLCBwb2ludCkge1xuICAgICAgICB2YXIgbGFtYmRhID0gbG9uZ2l0dWRlKHBvaW50KSwgcGhpID0gcG9pbnRbMV0sIHNpblBoaSA9IHNpbihwaGkpLCBub3JtYWwgPSBbc2luKGxhbWJkYSksIC1jb3MobGFtYmRhKSwgMF0sIGFuZ2xlID0gMCwgd2luZGluZyA9IDA7XG4gICAgICAgIHN1bS5yZXNldCgpO1xuICAgICAgICBpZiAoc2luUGhpID09PSAxKVxuICAgICAgICAgICAgcGhpID0gaGFsZlBpICsgZXBzaWxvbjtcbiAgICAgICAgZWxzZSBpZiAoc2luUGhpID09PSAtMSlcbiAgICAgICAgICAgIHBoaSA9IC1oYWxmUGkgLSBlcHNpbG9uO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIShtID0gKHJpbmcgPSBwb2x5Z29uW2ldKS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHJpbmcsIG0sIHBvaW50MCA9IHJpbmdbbSAtIDFdLCBsYW1iZGEwID0gbG9uZ2l0dWRlKHBvaW50MCksIHBoaTAgPSBwb2ludDBbMV0gLyAyICsgcXVhcnRlclBpLCBzaW5QaGkwID0gc2luKHBoaTApLCBjb3NQaGkwID0gY29zKHBoaTApO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtOyArK2osIGxhbWJkYTAgPSBsYW1iZGExLCBzaW5QaGkwID0gc2luUGhpMSwgY29zUGhpMCA9IGNvc1BoaTEsIHBvaW50MCA9IHBvaW50MSkge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludDEgPSByaW5nW2pdLCBsYW1iZGExID0gbG9uZ2l0dWRlKHBvaW50MSksIHBoaTEgPSBwb2ludDFbMV0gLyAyICsgcXVhcnRlclBpLCBzaW5QaGkxID0gc2luKHBoaTEpLCBjb3NQaGkxID0gY29zKHBoaTEpLCBkZWx0YSA9IGxhbWJkYTEgLSBsYW1iZGEwLCBzaWduID0gZGVsdGEgPj0gMCA/IDEgOiAtMSwgYWJzRGVsdGEgPSBzaWduICogZGVsdGEsIGFudGltZXJpZGlhbiA9IGFic0RlbHRhID4gcGksIGsgPSBzaW5QaGkwICogc2luUGhpMTtcbiAgICAgICAgICAgICAgICBzdW0uYWRkKGF0YW4yKGsgKiBzaWduICogc2luKGFic0RlbHRhKSwgY29zUGhpMCAqIGNvc1BoaTEgKyBrICogY29zKGFic0RlbHRhKSkpO1xuICAgICAgICAgICAgICAgIGFuZ2xlICs9IGFudGltZXJpZGlhbiA/IGRlbHRhICsgc2lnbiAqIHRhdSA6IGRlbHRhO1xuICAgICAgICAgICAgICAgIC8vIEFyZSB0aGUgbG9uZ2l0dWRlcyBlaXRoZXIgc2lkZSBvZiB0aGUgcG9pbnTigJlzIG1lcmlkaWFuIChsYW1iZGEpLFxuICAgICAgICAgICAgICAgIC8vIGFuZCBhcmUgdGhlIGxhdGl0dWRlcyBzbWFsbGVyIHRoYW4gdGhlIHBhcmFsbGVsIChwaGkpP1xuICAgICAgICAgICAgICAgIGlmIChhbnRpbWVyaWRpYW4gXiBsYW1iZGEwID49IGxhbWJkYSBeIGxhbWJkYTEgPj0gbGFtYmRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmMgPSBjYXJ0ZXNpYW5Dcm9zcyhjYXJ0ZXNpYW4ocG9pbnQwKSwgY2FydGVzaWFuKHBvaW50MSkpO1xuICAgICAgICAgICAgICAgICAgICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGFyYyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBjYXJ0ZXNpYW5Dcm9zcyhub3JtYWwsIGFyYyk7XG4gICAgICAgICAgICAgICAgICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBoaUFyYyA9IChhbnRpbWVyaWRpYW4gXiBkZWx0YSA+PSAwID8gLTEgOiAxKSAqIGFzaW4oaW50ZXJzZWN0aW9uWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBoaSA+IHBoaUFyYyB8fCBwaGkgPT09IHBoaUFyYyAmJiAoYXJjWzBdIHx8IGFyY1sxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRpbmcgKz0gYW50aW1lcmlkaWFuIF4gZGVsdGEgPj0gMCA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJzdCwgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIFNvdXRoIHBvbGUgaXMgaW5zaWRlIG9yIG91dHNpZGU6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEl0IGlzIGluc2lkZSBpZjpcbiAgICAgICAgLy8gKiB0aGUgcG9seWdvbiB3aW5kcyBhcm91bmQgaXQgaW4gYSBjbG9ja3dpc2UgZGlyZWN0aW9uLlxuICAgICAgICAvLyAqIHRoZSBwb2x5Z29uIGRvZXMgbm90IChjdW11bGF0aXZlbHkpIHdpbmQgYXJvdW5kIGl0LCBidXQgaGFzIGEgbmVnYXRpdmVcbiAgICAgICAgLy8gICAoY291bnRlci1jbG9ja3dpc2UpIGFyZWEuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNlY29uZCwgY291bnQgdGhlIChzaWduZWQpIG51bWJlciBvZiB0aW1lcyBhIHNlZ21lbnQgY3Jvc3NlcyBhIGxhbWJkYVxuICAgICAgICAvLyBmcm9tIHRoZSBwb2ludCB0byB0aGUgU291dGggcG9sZS4gIElmIGl0IGlzIHplcm8sIHRoZW4gdGhlIHBvaW50IGlzIHRoZVxuICAgICAgICAvLyBzYW1lIHNpZGUgYXMgdGhlIFNvdXRoIHBvbGUuXG4gICAgICAgIHJldHVybiAoYW5nbGUgPCAtZXBzaWxvbiB8fCBhbmdsZSA8IGVwc2lsb24gJiYgc3VtIDwgLWVwc2lsb24pIF4gKHdpbmRpbmcgJiAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xpcChwb2ludFZpc2libGUsIGNsaXBMaW5lLCBpbnRlcnBvbGF0ZSwgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzaW5rKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGNsaXBMaW5lKHNpbmspLCByaW5nQnVmZmVyID0gY2xpcEJ1ZmZlcigpLCByaW5nU2luayA9IGNsaXBMaW5lKHJpbmdCdWZmZXIpLCBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlLCBwb2x5Z29uLCBzZWdtZW50cywgcmluZztcbiAgICAgICAgICAgIHZhciBjbGlwID0ge1xuICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgICAgICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnRSaW5nO1xuICAgICAgICAgICAgICAgICAgICBjbGlwLmxpbmVTdGFydCA9IHJpbmdTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgY2xpcC5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbiA9IFtdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIGNsaXAubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBjbGlwLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cyA9IGQzQXJyYXkubWVyZ2Uoc2VnbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbnNpZGUgPSBwb2x5Z29uQ29udGFpbnMocG9seWdvbiwgc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbmsucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBSZWpvaW4oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc2luayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRJbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2luay5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHNpbmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2luay5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvbHlnb25TdGFydGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2luay5wb2x5Z29uRW5kKCksIHBvbHlnb25TdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzID0gcG9seWdvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2luay5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2luay5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgc2luayk7XG4gICAgICAgICAgICAgICAgICAgIHNpbmsubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICBzaW5rLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZnVuY3Rpb24gcG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRWaXNpYmxlKGxhbWJkYSwgcGhpKSlcbiAgICAgICAgICAgICAgICAgICAgc2luay5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwb2ludExpbmUobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgICAgICBsaW5lLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgICAgICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnRMaW5lO1xuICAgICAgICAgICAgICAgIGxpbmUubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgICAgICAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgICAgICAgICAgICBsaW5lLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBvaW50UmluZyhsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgICAgIHJpbmcucHVzaChbbGFtYmRhLCBwaGldKTtcbiAgICAgICAgICAgICAgICByaW5nU2luay5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICAgICAgICAgICAgcmluZ1NpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgcmluZyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgICAgICAgICAgICBwb2ludFJpbmcocmluZ1swXVswXSwgcmluZ1swXVsxXSk7XG4gICAgICAgICAgICAgICAgcmluZ1NpbmsubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgIHZhciBjbGVhbiA9IHJpbmdTaW5rLmNsZWFuKCksIHJpbmdTZWdtZW50cyA9IHJpbmdCdWZmZXIucmVzdWx0KCksIGksIG4gPSByaW5nU2VnbWVudHMubGVuZ3RoLCBtLCBzZWdtZW50LCBwb2ludDtcbiAgICAgICAgICAgICAgICByaW5nLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBvbHlnb24ucHVzaChyaW5nKTtcbiAgICAgICAgICAgICAgICByaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBObyBpbnRlcnNlY3Rpb25zLlxuICAgICAgICAgICAgICAgIGlmIChjbGVhbiAmIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudCA9IHJpbmdTZWdtZW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChtID0gc2VnbWVudC5sZW5ndGggLSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2luay5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luay5wb2ludCgocG9pbnQgPSBzZWdtZW50W2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2luay5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWpvaW4gY29ubmVjdGVkIHNlZ21lbnRzLlxuICAgICAgICAgICAgICAgIC8vIFRPRE8gcmV1c2UgcmluZ0J1ZmZlci5yZWpvaW4oKT9cbiAgICAgICAgICAgICAgICBpZiAobiA+IDEgJiYgY2xlYW4gJiAyKVxuICAgICAgICAgICAgICAgICAgICByaW5nU2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMucG9wKCkuY29uY2F0KHJpbmdTZWdtZW50cy5zaGlmdCgpKSk7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMuZmlsdGVyKHZhbGlkU2VnbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsaXA7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkU2VnbWVudChzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBzZWdtZW50Lmxlbmd0aCA+IDE7XG4gICAgfVxuICAgIC8vIEludGVyc2VjdGlvbnMgYXJlIHNvcnRlZCBhbG9uZyB0aGUgY2xpcCBlZGdlLiBGb3IgYm90aCBhbnRpbWVyaWRpYW4gY3V0dGluZ1xuICAgIC8vIGFuZCBjaXJjbGUgY2xpcHBpbmcsIHRoZSBzYW1lIGNvbXBhcmlzb24gaXMgdXNlZC5cbiAgICBmdW5jdGlvbiBjb21wYXJlSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICgoYSA9IGEueClbMF0gPCAwID8gYVsxXSAtIGhhbGZQaSAtIGVwc2lsb24gOiBoYWxmUGkgLSBhWzFdKVxuICAgICAgICAgICAgLSAoKGIgPSBiLngpWzBdIDwgMCA/IGJbMV0gLSBoYWxmUGkgLSBlcHNpbG9uIDogaGFsZlBpIC0gYlsxXSk7XG4gICAgfVxuICAgIHZhciBjbGlwQW50aW1lcmlkaWFuID0gY2xpcChmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LCBjbGlwQW50aW1lcmlkaWFuTGluZSwgY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlLCBbLXBpLCAtaGFsZlBpXSk7XG4gICAgLy8gVGFrZXMgYSBsaW5lIGFuZCBjdXRzIGludG8gdmlzaWJsZSBzZWdtZW50cy4gUmV0dXJuIHZhbHVlczogMCAtIHRoZXJlIHdlcmVcbiAgICAvLyBpbnRlcnNlY3Rpb25zIG9yIHRoZSBsaW5lIHdhcyBlbXB0eTsgMSAtIG5vIGludGVyc2VjdGlvbnM7IDIgLSB0aGVyZSB3ZXJlXG4gICAgLy8gaW50ZXJzZWN0aW9ucywgYW5kIHRoZSBmaXJzdCBhbmQgbGFzdCBzZWdtZW50cyBzaG91bGQgYmUgcmVqb2luZWQuXG4gICAgZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkxpbmUoc3RyZWFtKSB7XG4gICAgICAgIHZhciBsYW1iZGEwID0gTmFOLCBwaGkwID0gTmFOLCBzaWduMCA9IE5hTiwgY2xlYW47IC8vIG5vIGludGVyc2VjdGlvbnNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICBjbGVhbiA9IDE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uIChsYW1iZGExLCBwaGkxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpZ24xID0gbGFtYmRhMSA+IDAgPyBwaSA6IC1waSwgZGVsdGEgPSBhYnMobGFtYmRhMSAtIGxhbWJkYTApO1xuICAgICAgICAgICAgICAgIGlmIChhYnMoZGVsdGEgLSBwaSkgPCBlcHNpbG9uKSB7IC8vIGxpbmUgY3Jvc3NlcyBhIHBvbGVcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KGxhbWJkYTAsIHBoaTAgPSAocGhpMCArIHBoaTEpIC8gMiA+IDAgPyBoYWxmUGkgOiAtaGFsZlBpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24wLCBwaGkwKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjEsIHBoaTApO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMSwgcGhpMCk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2lnbjAgIT09IHNpZ24xICYmIGRlbHRhID49IHBpKSB7IC8vIGxpbmUgY3Jvc3NlcyBhbnRpbWVyaWRpYW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFicyhsYW1iZGEwIC0gc2lnbjApIDwgZXBzaWxvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbWJkYTAgLT0gc2lnbjAgKiBlcHNpbG9uOyAvLyBoYW5kbGUgZGVnZW5lcmFjaWVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChhYnMobGFtYmRhMSAtIHNpZ24xKSA8IGVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW1iZGExIC09IHNpZ24xICogZXBzaWxvbjtcbiAgICAgICAgICAgICAgICAgICAgcGhpMCA9IGNsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QobGFtYmRhMCwgcGhpMCwgbGFtYmRhMSwgcGhpMSk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludChzaWduMCwgcGhpMCk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24xLCBwaGkwKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMCA9IGxhbWJkYTEsIHBoaTAgPSBwaGkxKTtcbiAgICAgICAgICAgICAgICBzaWduMCA9IHNpZ24xO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgIGxhbWJkYTAgPSBwaGkwID0gTmFOO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsZWFuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLSBjbGVhbjsgLy8gaWYgaW50ZXJzZWN0aW9ucywgcmVqb2luIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QobGFtYmRhMCwgcGhpMCwgbGFtYmRhMSwgcGhpMSkge1xuICAgICAgICB2YXIgY29zUGhpMCwgY29zUGhpMSwgc2luTGFtYmRhMExhbWJkYTEgPSBzaW4obGFtYmRhMCAtIGxhbWJkYTEpO1xuICAgICAgICByZXR1cm4gYWJzKHNpbkxhbWJkYTBMYW1iZGExKSA+IGVwc2lsb25cbiAgICAgICAgICAgID8gYXRhbigoc2luKHBoaTApICogKGNvc1BoaTEgPSBjb3MocGhpMSkpICogc2luKGxhbWJkYTEpXG4gICAgICAgICAgICAgICAgLSBzaW4ocGhpMSkgKiAoY29zUGhpMCA9IGNvcyhwaGkwKSkgKiBzaW4obGFtYmRhMCkpXG4gICAgICAgICAgICAgICAgLyAoY29zUGhpMCAqIGNvc1BoaTEgKiBzaW5MYW1iZGEwTGFtYmRhMSkpXG4gICAgICAgICAgICA6IChwaGkwICsgcGhpMSkgLyAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGlwQW50aW1lcmlkaWFuSW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgICAgIHZhciBwaGk7XG4gICAgICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgIHBoaSA9IGRpcmVjdGlvbiAqIGhhbGZQaTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludCgtcGksIHBoaSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQoMCwgcGhpKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwaSwgcGhpKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwaSwgMCk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQocGksIC1waGkpO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KDAsIC1waGkpO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KC1waSwgLXBoaSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQoLXBpLCAwKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludCgtcGksIHBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWJzKGZyb21bMF0gLSB0b1swXSkgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICB2YXIgbGFtYmRhID0gZnJvbVswXSA8IHRvWzBdID8gcGkgOiAtcGk7XG4gICAgICAgICAgICBwaGkgPSBkaXJlY3Rpb24gKiBsYW1iZGEgLyAyO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KC1sYW1iZGEsIHBoaSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQoMCwgcGhpKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjbGlwQ2lyY2xlKHJhZGl1cykge1xuICAgICAgICB2YXIgY3IgPSBjb3MocmFkaXVzKSwgZGVsdGEgPSA2ICogcmFkaWFucywgc21hbGxSYWRpdXMgPSBjciA+IDAsIG5vdEhlbWlzcGhlcmUgPSBhYnMoY3IpID4gZXBzaWxvbjsgLy8gVE9ETyBvcHRpbWlzZSBmb3IgdGhpcyBjb21tb24gY2FzZVxuICAgICAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcbiAgICAgICAgICAgIGNpcmNsZVN0cmVhbShzdHJlYW0sIHJhZGl1cywgZGVsdGEsIGRpcmVjdGlvbiwgZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZpc2libGUobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3MobGFtYmRhKSAqIGNvcyhwaGkpID4gY3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGFrZXMgYSBsaW5lIGFuZCBjdXRzIGludG8gdmlzaWJsZSBzZWdtZW50cy4gUmV0dXJuIHZhbHVlcyB1c2VkIGZvciBwb2x5Z29uXG4gICAgICAgIC8vIGNsaXBwaW5nOiAwIC0gdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zIG9yIHRoZSBsaW5lIHdhcyBlbXB0eTsgMSAtIG5vXG4gICAgICAgIC8vIGludGVyc2VjdGlvbnMgMiAtIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucywgYW5kIHRoZSBmaXJzdCBhbmQgbGFzdCBzZWdtZW50c1xuICAgICAgICAvLyBzaG91bGQgYmUgcmVqb2luZWQuXG4gICAgICAgIGZ1bmN0aW9uIGNsaXBMaW5lKHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIHBvaW50MCwgLy8gcHJldmlvdXMgcG9pbnRcbiAgICAgICAgICAgIGMwLCAvLyBjb2RlIGZvciBwcmV2aW91cyBwb2ludFxuICAgICAgICAgICAgdjAsIC8vIHZpc2liaWxpdHkgb2YgcHJldmlvdXMgcG9pbnRcbiAgICAgICAgICAgIHYwMCwgLy8gdmlzaWJpbGl0eSBvZiBmaXJzdCBwb2ludFxuICAgICAgICAgICAgY2xlYW47IC8vIG5vIGludGVyc2VjdGlvbnNcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHYwMCA9IHYwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuID0gMTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50MSA9IFtsYW1iZGEsIHBoaV0sIHBvaW50MiwgdiA9IHZpc2libGUobGFtYmRhLCBwaGkpLCBjID0gc21hbGxSYWRpdXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdiA/IDAgOiBjb2RlKGxhbWJkYSwgcGhpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2ID8gY29kZShsYW1iZGEgKyAobGFtYmRhIDwgMCA/IHBpIDogLXBpKSwgcGhpKSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcG9pbnQwICYmICh2MDAgPSB2MCA9IHYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZGVnZW5lcmFjaWVzLlxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGlnbm9yZSBpZiBub3QgY2xpcHBpbmcgcG9seWdvbnMuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB2MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MCwgcG9pbnQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcG9pbnQyIHx8IHBvaW50RXF1YWwocG9pbnQwLCBwb2ludDIpIHx8IHBvaW50RXF1YWwocG9pbnQxLCBwb2ludDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQxWzBdICs9IGVwc2lsb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQxWzFdICs9IGVwc2lsb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHZpc2libGUocG9pbnQxWzBdLCBwb2ludDFbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB2MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXRzaWRlIGdvaW5nIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHBvaW50MlswXSwgcG9pbnQyWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2lkZSBnb2luZyBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50MCA9IHBvaW50MjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub3RIZW1pc3BoZXJlICYmIHBvaW50MCAmJiBzbWFsbFJhZGl1cyBeIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNvZGVzIGZvciB0d28gcG9pbnRzIGFyZSBkaWZmZXJlbnQsIG9yIGFyZSBib3RoIHplcm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlcmUgdGhpcyBzZWdtZW50IGludGVyc2VjdHMgd2l0aCB0aGUgc21hbGwgY2lyY2xlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYyAmIGMwKSAmJiAodCA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbWFsbFJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzBdWzBdLCB0WzBdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMV1bMF0sIHRbMV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMV1bMF0sIHRbMV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzBdWzBdLCB0WzBdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgJiYgKCFwb2ludDAgfHwgIXBvaW50RXF1YWwocG9pbnQwLCBwb2ludDEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHBvaW50MVswXSwgcG9pbnQxWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb2ludDAgPSBwb2ludDEsIHYwID0gdiwgYzAgPSBjO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodjApXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gUmVqb2luIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzIGlmIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucyBhbmQgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgLy8gYW5kIGxhc3QgcG9pbnRzIHdlcmUgdmlzaWJsZS5cbiAgICAgICAgICAgICAgICBjbGVhbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xlYW4gfCAoKHYwMCAmJiB2MCkgPDwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnRlcnNlY3RzIHRoZSBncmVhdCBjaXJjbGUgYmV0d2VlbiBhIGFuZCBiIHdpdGggdGhlIGNsaXAgY2lyY2xlLlxuICAgICAgICBmdW5jdGlvbiBpbnRlcnNlY3QoYSwgYiwgdHdvKSB7XG4gICAgICAgICAgICB2YXIgcGEgPSBjYXJ0ZXNpYW4oYSksIHBiID0gY2FydGVzaWFuKGIpO1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0d28gcGxhbmVzLCBuMS5wID0gZDEgYW5kIG4yLnAgPSBkMi5cbiAgICAgICAgICAgIC8vIEZpbmQgaW50ZXJzZWN0aW9uIGxpbmUgcCh0KSA9IGMxIG4xICsgYzIgbjIgKyB0IChuMSDiqK8gbjIpLlxuICAgICAgICAgICAgdmFyIG4xID0gWzEsIDAsIDBdLCAvLyBub3JtYWxcbiAgICAgICAgICAgIG4yID0gY2FydGVzaWFuQ3Jvc3MocGEsIHBiKSwgbjJuMiA9IGNhcnRlc2lhbkRvdChuMiwgbjIpLCBuMW4yID0gbjJbMF0sIC8vIGNhcnRlc2lhbkRvdChuMSwgbjIpLFxuICAgICAgICAgICAgZGV0ZXJtaW5hbnQgPSBuMm4yIC0gbjFuMiAqIG4xbjI7XG4gICAgICAgICAgICAvLyBUd28gcG9sYXIgcG9pbnRzLlxuICAgICAgICAgICAgaWYgKCFkZXRlcm1pbmFudClcbiAgICAgICAgICAgICAgICByZXR1cm4gIXR3byAmJiBhO1xuICAgICAgICAgICAgdmFyIGMxID0gY3IgKiBuMm4yIC8gZGV0ZXJtaW5hbnQsIGMyID0gLWNyICogbjFuMiAvIGRldGVybWluYW50LCBuMXhuMiA9IGNhcnRlc2lhbkNyb3NzKG4xLCBuMiksIEEgPSBjYXJ0ZXNpYW5TY2FsZShuMSwgYzEpLCBCID0gY2FydGVzaWFuU2NhbGUobjIsIGMyKTtcbiAgICAgICAgICAgIGNhcnRlc2lhbkFkZEluUGxhY2UoQSwgQik7XG4gICAgICAgICAgICAvLyBTb2x2ZSB8cCh0KXxeMiA9IDEuXG4gICAgICAgICAgICB2YXIgdSA9IG4xeG4yLCB3ID0gY2FydGVzaWFuRG90KEEsIHUpLCB1dSA9IGNhcnRlc2lhbkRvdCh1LCB1KSwgdDIgPSB3ICogdyAtIHV1ICogKGNhcnRlc2lhbkRvdChBLCBBKSAtIDEpO1xuICAgICAgICAgICAgaWYgKHQyIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdCA9IHNxcnQodDIpLCBxID0gY2FydGVzaWFuU2NhbGUodSwgKC13IC0gdCkgLyB1dSk7XG4gICAgICAgICAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKHEsIEEpO1xuICAgICAgICAgICAgcSA9IHNwaGVyaWNhbChxKTtcbiAgICAgICAgICAgIGlmICghdHdvKVxuICAgICAgICAgICAgICAgIHJldHVybiBxO1xuICAgICAgICAgICAgLy8gVHdvIGludGVyc2VjdGlvbiBwb2ludHMuXG4gICAgICAgICAgICB2YXIgbGFtYmRhMCA9IGFbMF0sIGxhbWJkYTEgPSBiWzBdLCBwaGkwID0gYVsxXSwgcGhpMSA9IGJbMV0sIHo7XG4gICAgICAgICAgICBpZiAobGFtYmRhMSA8IGxhbWJkYTApXG4gICAgICAgICAgICAgICAgeiA9IGxhbWJkYTAsIGxhbWJkYTAgPSBsYW1iZGExLCBsYW1iZGExID0gejtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGxhbWJkYTEgLSBsYW1iZGEwLCBwb2xhciA9IGFicyhkZWx0YSAtIHBpKSA8IGVwc2lsb24sIG1lcmlkaWFuID0gcG9sYXIgfHwgZGVsdGEgPCBlcHNpbG9uO1xuICAgICAgICAgICAgaWYgKCFwb2xhciAmJiBwaGkxIDwgcGhpMClcbiAgICAgICAgICAgICAgICB6ID0gcGhpMCwgcGhpMCA9IHBoaTEsIHBoaTEgPSB6O1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgZmlyc3QgcG9pbnQgaXMgYmV0d2VlbiBhIGFuZCBiLlxuICAgICAgICAgICAgaWYgKG1lcmlkaWFuXG4gICAgICAgICAgICAgICAgPyBwb2xhclxuICAgICAgICAgICAgICAgICAgICA/IHBoaTAgKyBwaGkxID4gMCBeIHFbMV0gPCAoYWJzKHFbMF0gLSBsYW1iZGEwKSA8IGVwc2lsb24gPyBwaGkwIDogcGhpMSlcbiAgICAgICAgICAgICAgICAgICAgOiBwaGkwIDw9IHFbMV0gJiYgcVsxXSA8PSBwaGkxXG4gICAgICAgICAgICAgICAgOiBkZWx0YSA+IHBpIF4gKGxhbWJkYTAgPD0gcVswXSAmJiBxWzBdIDw9IGxhbWJkYTEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHExID0gY2FydGVzaWFuU2NhbGUodSwgKC13ICsgdCkgLyB1dSk7XG4gICAgICAgICAgICAgICAgY2FydGVzaWFuQWRkSW5QbGFjZShxMSwgQSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtxLCBzcGhlcmljYWwocTEpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBHZW5lcmF0ZXMgYSA0LWJpdCB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiBvZiBhIHBvaW50IHJlbGF0aXZlIHRvXG4gICAgICAgIC8vIHRoZSBzbWFsbCBjaXJjbGUncyBib3VuZGluZyBib3guXG4gICAgICAgIGZ1bmN0aW9uIGNvZGUobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciByID0gc21hbGxSYWRpdXMgPyByYWRpdXMgOiBwaSAtIHJhZGl1cywgY29kZSA9IDA7XG4gICAgICAgICAgICBpZiAobGFtYmRhIDwgLXIpXG4gICAgICAgICAgICAgICAgY29kZSB8PSAxOyAvLyBsZWZ0XG4gICAgICAgICAgICBlbHNlIGlmIChsYW1iZGEgPiByKVxuICAgICAgICAgICAgICAgIGNvZGUgfD0gMjsgLy8gcmlnaHRcbiAgICAgICAgICAgIGlmIChwaGkgPCAtcilcbiAgICAgICAgICAgICAgICBjb2RlIHw9IDQ7IC8vIGJlbG93XG4gICAgICAgICAgICBlbHNlIGlmIChwaGkgPiByKVxuICAgICAgICAgICAgICAgIGNvZGUgfD0gODsgLy8gYWJvdmVcbiAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGlwKHZpc2libGUsIGNsaXBMaW5lLCBpbnRlcnBvbGF0ZSwgc21hbGxSYWRpdXMgPyBbMCwgLXJhZGl1c10gOiBbLXBpLCByYWRpdXMgLSBwaV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGlwTGluZShhLCBiLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCB0MCA9IDAsIHQxID0gMSwgZHggPSBieCAtIGF4LCBkeSA9IGJ5IC0gYXksIHI7XG4gICAgICAgIHIgPSB4MCAtIGF4O1xuICAgICAgICBpZiAoIWR4ICYmIHIgPiAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByIC89IGR4O1xuICAgICAgICBpZiAoZHggPCAwKSB7XG4gICAgICAgICAgICBpZiAociA8IHQwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyIDwgdDEpXG4gICAgICAgICAgICAgICAgdDEgPSByO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgICAgICAgaWYgKHIgPiB0MSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAociA+IHQwKVxuICAgICAgICAgICAgICAgIHQwID0gcjtcbiAgICAgICAgfVxuICAgICAgICByID0geDEgLSBheDtcbiAgICAgICAgaWYgKCFkeCAmJiByIDwgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgciAvPSBkeDtcbiAgICAgICAgaWYgKGR4IDwgMCkge1xuICAgICAgICAgICAgaWYgKHIgPiB0MSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAociA+IHQwKVxuICAgICAgICAgICAgICAgIHQwID0gcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkeCA+IDApIHtcbiAgICAgICAgICAgIGlmIChyIDwgdDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHIgPCB0MSlcbiAgICAgICAgICAgICAgICB0MSA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgciA9IHkwIC0gYXk7XG4gICAgICAgIGlmICghZHkgJiYgciA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHIgLz0gZHk7XG4gICAgICAgIGlmIChkeSA8IDApIHtcbiAgICAgICAgICAgIGlmIChyIDwgdDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHIgPCB0MSlcbiAgICAgICAgICAgICAgICB0MSA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgICAgICAgICBpZiAociA+IHQxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyID4gdDApXG4gICAgICAgICAgICAgICAgdDAgPSByO1xuICAgICAgICB9XG4gICAgICAgIHIgPSB5MSAtIGF5O1xuICAgICAgICBpZiAoIWR5ICYmIHIgPCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByIC89IGR5O1xuICAgICAgICBpZiAoZHkgPCAwKSB7XG4gICAgICAgICAgICBpZiAociA+IHQxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyID4gdDApXG4gICAgICAgICAgICAgICAgdDAgPSByO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR5ID4gMCkge1xuICAgICAgICAgICAgaWYgKHIgPCB0MClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAociA8IHQxKVxuICAgICAgICAgICAgICAgIHQxID0gcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodDAgPiAwKVxuICAgICAgICAgICAgYVswXSA9IGF4ICsgdDAgKiBkeCwgYVsxXSA9IGF5ICsgdDAgKiBkeTtcbiAgICAgICAgaWYgKHQxIDwgMSlcbiAgICAgICAgICAgIGJbMF0gPSBheCArIHQxICogZHgsIGJbMV0gPSBheSArIHQxICogZHk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgY2xpcE1heCA9IDFlOSwgY2xpcE1pbiA9IC1jbGlwTWF4O1xuICAgIC8vIFRPRE8gVXNlIGQzLXBvbHlnb27igJlzIHBvbHlnb25Db250YWlucyBoZXJlIGZvciB0aGUgcmluZyBjaGVjaz9cbiAgICAvLyBUT0RPIEVsaW1pbmF0ZSBkdXBsaWNhdGUgYnVmZmVyaW5nIGluIGNsaXBCdWZmZXIgYW5kIHBvbHlnb24ucHVzaD9cbiAgICBmdW5jdGlvbiBjbGlwUmVjdGFuZ2xlKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgIGZ1bmN0aW9uIHZpc2libGUoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHgwIDw9IHggJiYgeCA8PSB4MSAmJiB5MCA8PSB5ICYmIHkgPD0geTE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgYSA9IDAsIGExID0gMDtcbiAgICAgICAgICAgIGlmIChmcm9tID09IG51bGxcbiAgICAgICAgICAgICAgICB8fCAoYSA9IGNvcm5lcihmcm9tLCBkaXJlY3Rpb24pKSAhPT0gKGExID0gY29ybmVyKHRvLCBkaXJlY3Rpb24pKVxuICAgICAgICAgICAgICAgIHx8IGNvbXBhcmVQb2ludChmcm9tLCB0bykgPCAwIF4gZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludChhID09PSAwIHx8IGEgPT09IDMgPyB4MCA6IHgxLCBhID4gMSA/IHkxIDogeTApO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoYSA9IChhICsgZGlyZWN0aW9uICsgNCkgJSA0KSAhPT0gYTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRvWzBdLCB0b1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29ybmVyKHAsIGRpcmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGFicyhwWzBdIC0geDApIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAwIDogM1xuICAgICAgICAgICAgICAgIDogYWJzKHBbMF0gLSB4MSkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDIgOiAxXG4gICAgICAgICAgICAgICAgICAgIDogYWJzKHBbMV0gLSB5MCkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDEgOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRpcmVjdGlvbiA+IDAgPyAzIDogMjsgLy8gYWJzKHBbMV0gLSB5MSkgPCBlcHNpbG9uXG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZUludGVyc2VjdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVBvaW50KGEueCwgYi54KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlUG9pbnQoYSwgYikge1xuICAgICAgICAgICAgdmFyIGNhID0gY29ybmVyKGEsIDEpLCBjYiA9IGNvcm5lcihiLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBjYSAhPT0gY2IgPyBjYSAtIGNiXG4gICAgICAgICAgICAgICAgOiBjYSA9PT0gMCA/IGJbMV0gLSBhWzFdXG4gICAgICAgICAgICAgICAgICAgIDogY2EgPT09IDEgPyBhWzBdIC0gYlswXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjYSA9PT0gMiA/IGFbMV0gLSBiWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBiWzBdIC0gYVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIGFjdGl2ZVN0cmVhbSA9IHN0cmVhbSwgYnVmZmVyU3RyZWFtID0gY2xpcEJ1ZmZlcigpLCBzZWdtZW50cywgcG9seWdvbiwgcmluZywgeF9fLCB5X18sIHZfXywgLy8gZmlyc3QgcG9pbnRcbiAgICAgICAgICAgIHhfLCB5Xywgdl8sIC8vIHByZXZpb3VzIHBvaW50XG4gICAgICAgICAgICBmaXJzdCwgY2xlYW47XG4gICAgICAgICAgICB2YXIgY2xpcFN0cmVhbSA9IHtcbiAgICAgICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgICAgICAgICAgICBwb2x5Z29uU3RhcnQ6IHBvbHlnb25TdGFydCxcbiAgICAgICAgICAgICAgICBwb2x5Z29uRW5kOiBwb2x5Z29uRW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgICAgICAgICAgIGlmICh2aXNpYmxlKHgsIHkpKVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwb2x5Z29uSW5zaWRlKCkge1xuICAgICAgICAgICAgICAgIHZhciB3aW5kaW5nID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHJpbmcgPSBwb2x5Z29uW2ldLCBqID0gMSwgbSA9IHJpbmcubGVuZ3RoLCBwb2ludCA9IHJpbmdbMF0sIGEwLCBhMSwgYjAgPSBwb2ludFswXSwgYjEgPSBwb2ludFsxXTsgaiA8IG07ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYTAgPSBiMCwgYTEgPSBiMSwgcG9pbnQgPSByaW5nW2pdLCBiMCA9IHBvaW50WzBdLCBiMSA9IHBvaW50WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGExIDw9IHkxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIxID4geTEgJiYgKGIwIC0gYTApICogKHkxIC0gYTEpID4gKGIxIC0gYTEpICogKHgwIC0gYTApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3dpbmRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYjEgPD0geTEgJiYgKGIwIC0gYTApICogKHkxIC0gYTEpIDwgKGIxIC0gYTEpICogKHgwIC0gYTApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLXdpbmRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWZmZXIgZ2VvbWV0cnkgd2l0aGluIGEgcG9seWdvbiBhbmQgdGhlbiBjbGlwIGl0IGVuIG1hc3NlLlxuICAgICAgICAgICAgZnVuY3Rpb24gcG9seWdvblN0YXJ0KCkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbSA9IGJ1ZmZlclN0cmVhbSwgc2VnbWVudHMgPSBbXSwgcG9seWdvbiA9IFtdLCBjbGVhbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwb2x5Z29uRW5kKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEluc2lkZSA9IHBvbHlnb25JbnNpZGUoKSwgY2xlYW5JbnNpZGUgPSBjbGVhbiAmJiBzdGFydEluc2lkZSwgdmlzaWJsZSA9IChzZWdtZW50cyA9IGQzQXJyYXkubWVyZ2Uoc2VnbWVudHMpKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNsZWFuSW5zaWRlIHx8IHZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xlYW5JbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwUmVqb2luKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtID0gc3RyZWFtLCBzZWdtZW50cyA9IHBvbHlnb24gPSByaW5nID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgICAgICAgICAgICBjbGlwU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uKVxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLnB1c2gocmluZyA9IFtdKTtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdl8gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB4XyA9IHlfID0gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETyByYXRoZXIgdGhhbiBzcGVjaWFsLWNhc2UgcG9seWdvbnMsIHNpbXBseSBoYW5kbGUgdGhlbSBzZXBhcmF0ZWx5LlxuICAgICAgICAgICAgLy8gSWRlYWxseSwgY29pbmNpZGVudCBpbnRlcnNlY3Rpb24gcG9pbnRzIHNob3VsZCBiZSBqaXR0ZXJlZCB0byBhdm9pZFxuICAgICAgICAgICAgLy8gY2xpcHBpbmcgaXNzdWVzLlxuICAgICAgICAgICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZVBvaW50KHhfXywgeV9fKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZfXyAmJiB2XylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlclN0cmVhbS5yZWpvaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChidWZmZXJTdHJlYW0ucmVzdWx0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGlwU3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHZfKVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbGluZVBvaW50KHgsIHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHZpc2libGUoeCwgeSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvbHlnb24pXG4gICAgICAgICAgICAgICAgICAgIHJpbmcucHVzaChbeCwgeV0pO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICB4X18gPSB4LCB5X18gPSB5LCB2X18gPSB2O1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAmJiB2XylcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IFt4XyA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHhfKSksIHlfID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeV8pKV0sIGIgPSBbeCA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHgpKSwgeSA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHkpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xpcExpbmUoYSwgYiwgeDAsIHkwLCB4MSwgeTEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2Xykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludChhWzBdLCBhWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KGJbMF0sIGJbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4XyA9IHgsIHlfID0geSwgdl8gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsaXBTdHJlYW07XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4dGVudCgpIHtcbiAgICAgICAgdmFyIHgwID0gMCwgeTAgPSAwLCB4MSA9IDk2MCwgeTEgPSA1MDAsIGNhY2hlLCBjYWNoZVN0cmVhbSwgY2xpcDtcbiAgICAgICAgcmV0dXJuIGNsaXAgPSB7XG4gICAgICAgICAgICBzdHJlYW06IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBjbGlwUmVjdGFuZ2xlKHgwLCB5MCwgeDEsIHkxKShjYWNoZVN0cmVhbSA9IHN0cmVhbSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXh0ZW50OiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0sIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsLCBjbGlwKSA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoU3VtID0gYWRkZXIoKSwgbGFtYmRhMCQyLCBzaW5QaGkwJDEsIGNvc1BoaTAkMTtcbiAgICB2YXIgbGVuZ3RoU3RyZWFtID0ge1xuICAgICAgICBzcGhlcmU6IG5vb3AsXG4gICAgICAgIHBvaW50OiBub29wLFxuICAgICAgICBsaW5lU3RhcnQ6IGxlbmd0aExpbmVTdGFydCxcbiAgICAgICAgbGluZUVuZDogbm9vcCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBub29wLFxuICAgICAgICBwb2x5Z29uRW5kOiBub29wXG4gICAgfTtcbiAgICBmdW5jdGlvbiBsZW5ndGhMaW5lU3RhcnQoKSB7XG4gICAgICAgIGxlbmd0aFN0cmVhbS5wb2ludCA9IGxlbmd0aFBvaW50Rmlyc3Q7XG4gICAgICAgIGxlbmd0aFN0cmVhbS5saW5lRW5kID0gbGVuZ3RoTGluZUVuZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGVuZ3RoTGluZUVuZCgpIHtcbiAgICAgICAgbGVuZ3RoU3RyZWFtLnBvaW50ID0gbGVuZ3RoU3RyZWFtLmxpbmVFbmQgPSBub29wO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZW5ndGhQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgICAgICAgbGFtYmRhMCQyID0gbGFtYmRhLCBzaW5QaGkwJDEgPSBzaW4ocGhpKSwgY29zUGhpMCQxID0gY29zKHBoaSk7XG4gICAgICAgIGxlbmd0aFN0cmVhbS5wb2ludCA9IGxlbmd0aFBvaW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZW5ndGhQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gICAgICAgIHZhciBzaW5QaGkgPSBzaW4ocGhpKSwgY29zUGhpID0gY29zKHBoaSksIGRlbHRhID0gYWJzKGxhbWJkYSAtIGxhbWJkYTAkMiksIGNvc0RlbHRhID0gY29zKGRlbHRhKSwgc2luRGVsdGEgPSBzaW4oZGVsdGEpLCB4ID0gY29zUGhpICogc2luRGVsdGEsIHkgPSBjb3NQaGkwJDEgKiBzaW5QaGkgLSBzaW5QaGkwJDEgKiBjb3NQaGkgKiBjb3NEZWx0YSwgeiA9IHNpblBoaTAkMSAqIHNpblBoaSArIGNvc1BoaTAkMSAqIGNvc1BoaSAqIGNvc0RlbHRhO1xuICAgICAgICBsZW5ndGhTdW0uYWRkKGF0YW4yKHNxcnQoeCAqIHggKyB5ICogeSksIHopKTtcbiAgICAgICAgbGFtYmRhMCQyID0gbGFtYmRhLCBzaW5QaGkwJDEgPSBzaW5QaGksIGNvc1BoaTAkMSA9IGNvc1BoaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGVuZ3RoKG9iamVjdCkge1xuICAgICAgICBsZW5ndGhTdW0ucmVzZXQoKTtcbiAgICAgICAgZ2VvU3RyZWFtKG9iamVjdCwgbGVuZ3RoU3RyZWFtKTtcbiAgICAgICAgcmV0dXJuICtsZW5ndGhTdW07XG4gICAgfVxuICAgIHZhciBjb29yZGluYXRlcyA9IFtudWxsLCBudWxsXSwgb2JqZWN0ID0geyB0eXBlOiBcIkxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzIH07XG4gICAgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgICAgICBjb29yZGluYXRlc1swXSA9IGE7XG4gICAgICAgIGNvb3JkaW5hdGVzWzFdID0gYjtcbiAgICAgICAgcmV0dXJuIGxlbmd0aChvYmplY3QpO1xuICAgIH1cbiAgICB2YXIgY29udGFpbnNPYmplY3RUeXBlID0ge1xuICAgICAgICBGZWF0dXJlOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zR2VvbWV0cnkob2JqZWN0Lmdlb21ldHJ5LCBwb2ludCk7XG4gICAgICAgIH0sXG4gICAgICAgIEZlYXR1cmVDb2xsZWN0aW9uOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludCkge1xuICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gb2JqZWN0LmZlYXR1cmVzLCBpID0gLTEsIG4gPSBmZWF0dXJlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNHZW9tZXRyeShmZWF0dXJlc1tpXS5nZW9tZXRyeSwgcG9pbnQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNvbnRhaW5zR2VvbWV0cnlUeXBlID0ge1xuICAgICAgICBTcGhlcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBQb2ludDogZnVuY3Rpb24gKG9iamVjdCwgcG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluc1BvaW50KG9iamVjdC5jb29yZGluYXRlcywgcG9pbnQpO1xuICAgICAgICB9LFxuICAgICAgICBNdWx0aVBvaW50OiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludCkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNQb2ludChjb29yZGluYXRlc1tpXSwgcG9pbnQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgTGluZVN0cmluZzogZnVuY3Rpb24gKG9iamVjdCwgcG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluc0xpbmUob2JqZWN0LmNvb3JkaW5hdGVzLCBwb2ludCk7XG4gICAgICAgIH0sXG4gICAgICAgIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24gKG9iamVjdCwgcG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zTGluZShjb29yZGluYXRlc1tpXSwgcG9pbnQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgUG9seWdvbjogZnVuY3Rpb24gKG9iamVjdCwgcG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluc1BvbHlnb24ob2JqZWN0LmNvb3JkaW5hdGVzLCBwb2ludCk7XG4gICAgICAgIH0sXG4gICAgICAgIE11bHRpUG9seWdvbjogZnVuY3Rpb24gKG9iamVjdCwgcG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zUG9seWdvbihjb29yZGluYXRlc1tpXSwgcG9pbnQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludCkge1xuICAgICAgICAgICAgdmFyIGdlb21ldHJpZXMgPSBvYmplY3QuZ2VvbWV0cmllcywgaSA9IC0xLCBuID0gZ2VvbWV0cmllcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNHZW9tZXRyeShnZW9tZXRyaWVzW2ldLCBwb2ludCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjb250YWluc0dlb21ldHJ5KGdlb21ldHJ5LCBwb2ludCkge1xuICAgICAgICByZXR1cm4gZ2VvbWV0cnkgJiYgY29udGFpbnNHZW9tZXRyeVR5cGUuaGFzT3duUHJvcGVydHkoZ2VvbWV0cnkudHlwZSlcbiAgICAgICAgICAgID8gY29udGFpbnNHZW9tZXRyeVR5cGVbZ2VvbWV0cnkudHlwZV0oZ2VvbWV0cnksIHBvaW50KVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGFpbnNQb2ludChjb29yZGluYXRlcywgcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlKGNvb3JkaW5hdGVzLCBwb2ludCkgPT09IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zTGluZShjb29yZGluYXRlcywgcG9pbnQpIHtcbiAgICAgICAgdmFyIGFvLCBibywgYWI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBibyA9IGRpc3RhbmNlKGNvb3JkaW5hdGVzW2ldLCBwb2ludCk7XG4gICAgICAgICAgICBpZiAoYm8gPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBhYiA9IGRpc3RhbmNlKGNvb3JkaW5hdGVzW2ldLCBjb29yZGluYXRlc1tpIC0gMV0pO1xuICAgICAgICAgICAgICAgIGlmIChhYiA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgYW8gPD0gYWIgJiZcbiAgICAgICAgICAgICAgICAgICAgYm8gPD0gYWIgJiZcbiAgICAgICAgICAgICAgICAgICAgKGFvICsgYm8gLSBhYikgKiAoMSAtIE1hdGgucG93KChhbyAtIGJvKSAvIGFiLCAyKSkgPCBlcHNpbG9uMiAqIGFiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFvID0gYm87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250YWluc1BvbHlnb24oY29vcmRpbmF0ZXMsIHBvaW50KSB7XG4gICAgICAgIHJldHVybiAhIXBvbHlnb25Db250YWlucyhjb29yZGluYXRlcy5tYXAocmluZ1JhZGlhbnMpLCBwb2ludFJhZGlhbnMocG9pbnQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmluZ1JhZGlhbnMocmluZykge1xuICAgICAgICByZXR1cm4gcmluZyA9IHJpbmcubWFwKHBvaW50UmFkaWFucyksIHJpbmcucG9wKCksIHJpbmc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50UmFkaWFucyhwb2ludCkge1xuICAgICAgICByZXR1cm4gW3BvaW50WzBdICogcmFkaWFucywgcG9pbnRbMV0gKiByYWRpYW5zXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGFpbnMob2JqZWN0LCBwb2ludCkge1xuICAgICAgICByZXR1cm4gKG9iamVjdCAmJiBjb250YWluc09iamVjdFR5cGUuaGFzT3duUHJvcGVydHkob2JqZWN0LnR5cGUpXG4gICAgICAgICAgICA/IGNvbnRhaW5zT2JqZWN0VHlwZVtvYmplY3QudHlwZV1cbiAgICAgICAgICAgIDogY29udGFpbnNHZW9tZXRyeSkob2JqZWN0LCBwb2ludCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdyYXRpY3VsZVgoeTAsIHkxLCBkeSkge1xuICAgICAgICB2YXIgeSA9IGQzQXJyYXkucmFuZ2UoeTAsIHkxIC0gZXBzaWxvbiwgZHkpLmNvbmNhdCh5MSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geS5tYXAoZnVuY3Rpb24gKHkpIHsgcmV0dXJuIFt4LCB5XTsgfSk7IH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdyYXRpY3VsZVkoeDAsIHgxLCBkeCkge1xuICAgICAgICB2YXIgeCA9IGQzQXJyYXkucmFuZ2UoeDAsIHgxIC0gZXBzaWxvbiwgZHgpLmNvbmNhdCh4MSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoeSkgeyByZXR1cm4geC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIFt4LCB5XTsgfSk7IH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdyYXRpY3VsZSgpIHtcbiAgICAgICAgdmFyIHgxLCB4MCwgWDEsIFgwLCB5MSwgeTAsIFkxLCBZMCwgZHggPSAxMCwgZHkgPSBkeCwgRFggPSA5MCwgRFkgPSAzNjAsIHgsIHksIFgsIFksIHByZWNpc2lvbiA9IDIuNTtcbiAgICAgICAgZnVuY3Rpb24gZ3JhdGljdWxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IGxpbmVzKCkgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsaW5lcygpIHtcbiAgICAgICAgICAgIHJldHVybiBkM0FycmF5LnJhbmdlKGNlaWwoWDAgLyBEWCkgKiBEWCwgWDEsIERYKS5tYXAoWClcbiAgICAgICAgICAgICAgICAuY29uY2F0KGQzQXJyYXkucmFuZ2UoY2VpbChZMCAvIERZKSAqIERZLCBZMSwgRFkpLm1hcChZKSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KGQzQXJyYXkucmFuZ2UoY2VpbCh4MCAvIGR4KSAqIGR4LCB4MSwgZHgpLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4gYWJzKHggJSBEWCkgPiBlcHNpbG9uOyB9KS5tYXAoeCkpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChkM0FycmF5LnJhbmdlKGNlaWwoeTAgLyBkeSkgKiBkeSwgeTEsIGR5KS5maWx0ZXIoZnVuY3Rpb24gKHkpIHsgcmV0dXJuIGFicyh5ICUgRFkpID4gZXBzaWxvbjsgfSkubWFwKHkpKTtcbiAgICAgICAgfVxuICAgICAgICBncmF0aWN1bGUubGluZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZXMoKS5tYXAoZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7IHJldHVybiB7IHR5cGU6IFwiTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogY29vcmRpbmF0ZXMgfTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGdyYXRpY3VsZS5vdXRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICBYKFgwKS5jb25jYXQoWShZMSkuc2xpY2UoMSksIFgoWDEpLnJldmVyc2UoKS5zbGljZSgxKSwgWShZMCkucmV2ZXJzZSgpLnNsaWNlKDEpKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGdyYXRpY3VsZS5leHRlbnQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBncmF0aWN1bGUuZXh0ZW50TWlub3IoKTtcbiAgICAgICAgICAgIHJldHVybiBncmF0aWN1bGUuZXh0ZW50TWFqb3IoXykuZXh0ZW50TWlub3IoXyk7XG4gICAgICAgIH07XG4gICAgICAgIGdyYXRpY3VsZS5leHRlbnRNYWpvciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtbWDAsIFkwXSwgW1gxLCBZMV1dO1xuICAgICAgICAgICAgWDAgPSArX1swXVswXSwgWDEgPSArX1sxXVswXTtcbiAgICAgICAgICAgIFkwID0gK19bMF1bMV0sIFkxID0gK19bMV1bMV07XG4gICAgICAgICAgICBpZiAoWDAgPiBYMSlcbiAgICAgICAgICAgICAgICBfID0gWDAsIFgwID0gWDEsIFgxID0gXztcbiAgICAgICAgICAgIGlmIChZMCA+IFkxKVxuICAgICAgICAgICAgICAgIF8gPSBZMCwgWTAgPSBZMSwgWTEgPSBfO1xuICAgICAgICAgICAgcmV0dXJuIGdyYXRpY3VsZS5wcmVjaXNpb24ocHJlY2lzaW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgZ3JhdGljdWxlLmV4dGVudE1pbm9yID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgICAgICAgICB4MCA9ICtfWzBdWzBdLCB4MSA9ICtfWzFdWzBdO1xuICAgICAgICAgICAgeTAgPSArX1swXVsxXSwgeTEgPSArX1sxXVsxXTtcbiAgICAgICAgICAgIGlmICh4MCA+IHgxKVxuICAgICAgICAgICAgICAgIF8gPSB4MCwgeDAgPSB4MSwgeDEgPSBfO1xuICAgICAgICAgICAgaWYgKHkwID4geTEpXG4gICAgICAgICAgICAgICAgXyA9IHkwLCB5MCA9IHkxLCB5MSA9IF87XG4gICAgICAgICAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICAgICAgICB9O1xuICAgICAgICBncmF0aWN1bGUuc3RlcCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyYXRpY3VsZS5zdGVwTWlub3IoKTtcbiAgICAgICAgICAgIHJldHVybiBncmF0aWN1bGUuc3RlcE1ham9yKF8pLnN0ZXBNaW5vcihfKTtcbiAgICAgICAgfTtcbiAgICAgICAgZ3JhdGljdWxlLnN0ZXBNYWpvciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtEWCwgRFldO1xuICAgICAgICAgICAgRFggPSArX1swXSwgRFkgPSArX1sxXTtcbiAgICAgICAgICAgIHJldHVybiBncmF0aWN1bGU7XG4gICAgICAgIH07XG4gICAgICAgIGdyYXRpY3VsZS5zdGVwTWlub3IgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBbZHgsIGR5XTtcbiAgICAgICAgICAgIGR4ID0gK19bMF0sIGR5ID0gK19bMV07XG4gICAgICAgICAgICByZXR1cm4gZ3JhdGljdWxlO1xuICAgICAgICB9O1xuICAgICAgICBncmF0aWN1bGUucHJlY2lzaW9uID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlY2lzaW9uO1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gK187XG4gICAgICAgICAgICB4ID0gZ3JhdGljdWxlWCh5MCwgeTEsIDkwKTtcbiAgICAgICAgICAgIHkgPSBncmF0aWN1bGVZKHgwLCB4MSwgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIFggPSBncmF0aWN1bGVYKFkwLCBZMSwgOTApO1xuICAgICAgICAgICAgWSA9IGdyYXRpY3VsZVkoWDAsIFgxLCBwcmVjaXNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGdyYXRpY3VsZVxuICAgICAgICAgICAgLmV4dGVudE1ham9yKFtbLTE4MCwgLTkwICsgZXBzaWxvbl0sIFsxODAsIDkwIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgLmV4dGVudE1pbm9yKFtbLTE4MCwgLTgwIC0gZXBzaWxvbl0sIFsxODAsIDgwICsgZXBzaWxvbl1dKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ3JhdGljdWxlMTAoKSB7XG4gICAgICAgIHJldHVybiBncmF0aWN1bGUoKSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShhLCBiKSB7XG4gICAgICAgIHZhciB4MCA9IGFbMF0gKiByYWRpYW5zLCB5MCA9IGFbMV0gKiByYWRpYW5zLCB4MSA9IGJbMF0gKiByYWRpYW5zLCB5MSA9IGJbMV0gKiByYWRpYW5zLCBjeTAgPSBjb3MoeTApLCBzeTAgPSBzaW4oeTApLCBjeTEgPSBjb3MoeTEpLCBzeTEgPSBzaW4oeTEpLCBreDAgPSBjeTAgKiBjb3MoeDApLCBreTAgPSBjeTAgKiBzaW4oeDApLCBreDEgPSBjeTEgKiBjb3MoeDEpLCBreTEgPSBjeTEgKiBzaW4oeDEpLCBkID0gMiAqIGFzaW4oc3FydChoYXZlcnNpbih5MSAtIHkwKSArIGN5MCAqIGN5MSAqIGhhdmVyc2luKHgxIC0geDApKSksIGsgPSBzaW4oZCk7XG4gICAgICAgIHZhciBpbnRlcnBvbGF0ZSA9IGQgPyBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIEIgPSBzaW4odCAqPSBkKSAvIGssIEEgPSBzaW4oZCAtIHQpIC8gaywgeCA9IEEgKiBreDAgKyBCICoga3gxLCB5ID0gQSAqIGt5MCArIEIgKiBreTEsIHogPSBBICogc3kwICsgQiAqIHN5MTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYXRhbjIoeSwgeCkgKiBkZWdyZWVzLFxuICAgICAgICAgICAgICAgIGF0YW4yKHosIHNxcnQoeCAqIHggKyB5ICogeSkpICogZGVncmVlc1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbeDAgKiBkZWdyZWVzLCB5MCAqIGRlZ3JlZXNdO1xuICAgICAgICB9O1xuICAgICAgICBpbnRlcnBvbGF0ZS5kaXN0YW5jZSA9IGQ7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgdmFyIGFyZWFTdW0kMSA9IGFkZGVyKCksIGFyZWFSaW5nU3VtJDEgPSBhZGRlcigpLCB4MDAsIHkwMCwgeDAkMSwgeTAkMTtcbiAgICB2YXIgYXJlYVN0cmVhbSQxID0ge1xuICAgICAgICBwb2ludDogbm9vcCxcbiAgICAgICAgbGluZVN0YXJ0OiBub29wLFxuICAgICAgICBsaW5lRW5kOiBub29wLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFyZWFTdHJlYW0kMS5saW5lU3RhcnQgPSBhcmVhUmluZ1N0YXJ0JDE7XG4gICAgICAgICAgICBhcmVhU3RyZWFtJDEubGluZUVuZCA9IGFyZWFSaW5nRW5kJDE7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFyZWFTdHJlYW0kMS5saW5lU3RhcnQgPSBhcmVhU3RyZWFtJDEubGluZUVuZCA9IGFyZWFTdHJlYW0kMS5wb2ludCA9IG5vb3A7XG4gICAgICAgICAgICBhcmVhU3VtJDEuYWRkKGFicyhhcmVhUmluZ1N1bSQxKSk7XG4gICAgICAgICAgICBhcmVhUmluZ1N1bSQxLnJlc2V0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZWEgPSBhcmVhU3VtJDEgLyAyO1xuICAgICAgICAgICAgYXJlYVN1bSQxLnJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gYXJlYTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gYXJlYVJpbmdTdGFydCQxKCkge1xuICAgICAgICBhcmVhU3RyZWFtJDEucG9pbnQgPSBhcmVhUG9pbnRGaXJzdCQxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmVhUG9pbnRGaXJzdCQxKHgsIHkpIHtcbiAgICAgICAgYXJlYVN0cmVhbSQxLnBvaW50ID0gYXJlYVBvaW50JDE7XG4gICAgICAgIHgwMCA9IHgwJDEgPSB4LCB5MDAgPSB5MCQxID0geTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJlYVBvaW50JDEoeCwgeSkge1xuICAgICAgICBhcmVhUmluZ1N1bSQxLmFkZCh5MCQxICogeCAtIHgwJDEgKiB5KTtcbiAgICAgICAgeDAkMSA9IHgsIHkwJDEgPSB5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmVhUmluZ0VuZCQxKCkge1xuICAgICAgICBhcmVhUG9pbnQkMSh4MDAsIHkwMCk7XG4gICAgfVxuICAgIHZhciB4MCQyID0gSW5maW5pdHksIHkwJDIgPSB4MCQyLCB4MSA9IC14MCQyLCB5MSA9IHgxO1xuICAgIHZhciBib3VuZHNTdHJlYW0kMSA9IHtcbiAgICAgICAgcG9pbnQ6IGJvdW5kc1BvaW50JDEsXG4gICAgICAgIGxpbmVTdGFydDogbm9vcCxcbiAgICAgICAgbGluZUVuZDogbm9vcCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBub29wLFxuICAgICAgICBwb2x5Z29uRW5kOiBub29wLFxuICAgICAgICByZXN1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSBbW3gwJDIsIHkwJDJdLCBbeDEsIHkxXV07XG4gICAgICAgICAgICB4MSA9IHkxID0gLSh5MCQyID0geDAkMiA9IEluZmluaXR5KTtcbiAgICAgICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGJvdW5kc1BvaW50JDEoeCwgeSkge1xuICAgICAgICBpZiAoeCA8IHgwJDIpXG4gICAgICAgICAgICB4MCQyID0geDtcbiAgICAgICAgaWYgKHggPiB4MSlcbiAgICAgICAgICAgIHgxID0geDtcbiAgICAgICAgaWYgKHkgPCB5MCQyKVxuICAgICAgICAgICAgeTAkMiA9IHk7XG4gICAgICAgIGlmICh5ID4geTEpXG4gICAgICAgICAgICB5MSA9IHk7XG4gICAgfVxuICAgIC8vIFRPRE8gRW5mb3JjZSBwb3NpdGl2ZSBhcmVhIGZvciBleHRlcmlvciwgbmVnYXRpdmUgYXJlYSBmb3IgaW50ZXJpb3I/XG4gICAgdmFyIFgwJDEgPSAwLCBZMCQxID0gMCwgWjAkMSA9IDAsIFgxJDEgPSAwLCBZMSQxID0gMCwgWjEkMSA9IDAsIFgyJDEgPSAwLCBZMiQxID0gMCwgWjIkMSA9IDAsIHgwMCQxLCB5MDAkMSwgeDAkMywgeTAkMztcbiAgICB2YXIgY2VudHJvaWRTdHJlYW0kMSA9IHtcbiAgICAgICAgcG9pbnQ6IGNlbnRyb2lkUG9pbnQkMSxcbiAgICAgICAgbGluZVN0YXJ0OiBjZW50cm9pZExpbmVTdGFydCQxLFxuICAgICAgICBsaW5lRW5kOiBjZW50cm9pZExpbmVFbmQkMSxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjZW50cm9pZFN0cmVhbSQxLmxpbmVTdGFydCA9IGNlbnRyb2lkUmluZ1N0YXJ0JDE7XG4gICAgICAgICAgICBjZW50cm9pZFN0cmVhbSQxLmxpbmVFbmQgPSBjZW50cm9pZFJpbmdFbmQkMTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnQkMTtcbiAgICAgICAgICAgIGNlbnRyb2lkU3RyZWFtJDEubGluZVN0YXJ0ID0gY2VudHJvaWRMaW5lU3RhcnQkMTtcbiAgICAgICAgICAgIGNlbnRyb2lkU3RyZWFtJDEubGluZUVuZCA9IGNlbnRyb2lkTGluZUVuZCQxO1xuICAgICAgICB9LFxuICAgICAgICByZXN1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjZW50cm9pZCA9IFoyJDEgPyBbWDIkMSAvIFoyJDEsIFkyJDEgLyBaMiQxXVxuICAgICAgICAgICAgICAgIDogWjEkMSA/IFtYMSQxIC8gWjEkMSwgWTEkMSAvIFoxJDFdXG4gICAgICAgICAgICAgICAgICAgIDogWjAkMSA/IFtYMCQxIC8gWjAkMSwgWTAkMSAvIFowJDFdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtOYU4sIE5hTl07XG4gICAgICAgICAgICBYMCQxID0gWTAkMSA9IFowJDEgPVxuICAgICAgICAgICAgICAgIFgxJDEgPSBZMSQxID0gWjEkMSA9XG4gICAgICAgICAgICAgICAgICAgIFgyJDEgPSBZMiQxID0gWjIkMSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gY2VudHJvaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNlbnRyb2lkUG9pbnQkMSh4LCB5KSB7XG4gICAgICAgIFgwJDEgKz0geDtcbiAgICAgICAgWTAkMSArPSB5O1xuICAgICAgICArK1owJDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkTGluZVN0YXJ0JDEoKSB7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50Rmlyc3RMaW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZFBvaW50Rmlyc3RMaW5lKHgsIHkpIHtcbiAgICAgICAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnRMaW5lO1xuICAgICAgICBjZW50cm9pZFBvaW50JDEoeDAkMyA9IHgsIHkwJDMgPSB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRQb2ludExpbmUoeCwgeSkge1xuICAgICAgICB2YXIgZHggPSB4IC0geDAkMywgZHkgPSB5IC0geTAkMywgeiA9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICBYMSQxICs9IHogKiAoeDAkMyArIHgpIC8gMjtcbiAgICAgICAgWTEkMSArPSB6ICogKHkwJDMgKyB5KSAvIDI7XG4gICAgICAgIFoxJDEgKz0gejtcbiAgICAgICAgY2VudHJvaWRQb2ludCQxKHgwJDMgPSB4LCB5MCQzID0geSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkTGluZUVuZCQxKCkge1xuICAgICAgICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludCQxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZFJpbmdTdGFydCQxKCkge1xuICAgICAgICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludEZpcnN0UmluZztcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRSaW5nRW5kJDEoKSB7XG4gICAgICAgIGNlbnRyb2lkUG9pbnRSaW5nKHgwMCQxLCB5MDAkMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRGaXJzdFJpbmcoeCwgeSkge1xuICAgICAgICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludFJpbmc7XG4gICAgICAgIGNlbnRyb2lkUG9pbnQkMSh4MDAkMSA9IHgwJDMgPSB4LCB5MDAkMSA9IHkwJDMgPSB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRQb2ludFJpbmcoeCwgeSkge1xuICAgICAgICB2YXIgZHggPSB4IC0geDAkMywgZHkgPSB5IC0geTAkMywgeiA9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICBYMSQxICs9IHogKiAoeDAkMyArIHgpIC8gMjtcbiAgICAgICAgWTEkMSArPSB6ICogKHkwJDMgKyB5KSAvIDI7XG4gICAgICAgIFoxJDEgKz0gejtcbiAgICAgICAgeiA9IHkwJDMgKiB4IC0geDAkMyAqIHk7XG4gICAgICAgIFgyJDEgKz0geiAqICh4MCQzICsgeCk7XG4gICAgICAgIFkyJDEgKz0geiAqICh5MCQzICsgeSk7XG4gICAgICAgIFoyJDEgKz0geiAqIDM7XG4gICAgICAgIGNlbnRyb2lkUG9pbnQkMSh4MCQzID0geCwgeTAkMyA9IHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBQYXRoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICBQYXRoQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9yYWRpdXM6IDQuNSxcbiAgICAgICAgcG9pbnRSYWRpdXM6IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzID0gXywgdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2ludCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5lID09PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB0aGlzLl9wb2ludCA9IE5hTjtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHggKyB0aGlzLl9yYWRpdXMsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmFyYyh4LCB5LCB0aGlzLl9yYWRpdXMsIDAsIHRhdSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0OiBub29wXG4gICAgfTtcbiAgICB2YXIgbGVuZ3RoU3VtJDEgPSBhZGRlcigpLCBsZW5ndGhSaW5nLCB4MDAkMiwgeTAwJDIsIHgwJDQsIHkwJDQ7XG4gICAgdmFyIGxlbmd0aFN0cmVhbSQxID0ge1xuICAgICAgICBwb2ludDogbm9vcCxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZW5ndGhTdHJlYW0kMS5wb2ludCA9IGxlbmd0aFBvaW50Rmlyc3QkMTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGxlbmd0aFJpbmcpXG4gICAgICAgICAgICAgICAgbGVuZ3RoUG9pbnQkMSh4MDAkMiwgeTAwJDIpO1xuICAgICAgICAgICAgbGVuZ3RoU3RyZWFtJDEucG9pbnQgPSBub29wO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxlbmd0aFJpbmcgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZW5ndGhSaW5nID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gK2xlbmd0aFN1bSQxO1xuICAgICAgICAgICAgbGVuZ3RoU3VtJDEucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxlbmd0aFBvaW50Rmlyc3QkMSh4LCB5KSB7XG4gICAgICAgIGxlbmd0aFN0cmVhbSQxLnBvaW50ID0gbGVuZ3RoUG9pbnQkMTtcbiAgICAgICAgeDAwJDIgPSB4MCQ0ID0geCwgeTAwJDIgPSB5MCQ0ID0geTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGVuZ3RoUG9pbnQkMSh4LCB5KSB7XG4gICAgICAgIHgwJDQgLT0geCwgeTAkNCAtPSB5O1xuICAgICAgICBsZW5ndGhTdW0kMS5hZGQoc3FydCh4MCQ0ICogeDAkNCArIHkwJDQgKiB5MCQ0KSk7XG4gICAgICAgIHgwJDQgPSB4LCB5MCQ0ID0geTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUGF0aFN0cmluZygpIHtcbiAgICAgICAgdGhpcy5fc3RyaW5nID0gW107XG4gICAgfVxuICAgIFBhdGhTdHJpbmcucHJvdG90eXBlID0ge1xuICAgICAgICBfcmFkaXVzOiA0LjUsXG4gICAgICAgIF9jaXJjbGU6IGNpcmNsZSQxKDQuNSksXG4gICAgICAgIHBvaW50UmFkaXVzOiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKChfID0gK18pICE9PSB0aGlzLl9yYWRpdXMpXG4gICAgICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gXywgdGhpcy5fY2lyY2xlID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gTmFOO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmUgPT09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyaW5nLnB1c2goXCJaXCIpO1xuICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSBOYU47XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIk1cIiwgeCwgXCIsXCIsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RyaW5nLnB1c2goXCJMXCIsIHgsIFwiLFwiLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NpcmNsZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlID0gY2lyY2xlJDEodGhpcy5fcmFkaXVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RyaW5nLnB1c2goXCJNXCIsIHgsIFwiLFwiLCB5LCB0aGlzLl9jaXJjbGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fc3RyaW5nLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyaW5nID0gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjaXJjbGUkMShyYWRpdXMpIHtcbiAgICAgICAgcmV0dXJuIFwibTAsXCIgKyByYWRpdXNcbiAgICAgICAgICAgICsgXCJhXCIgKyByYWRpdXMgKyBcIixcIiArIHJhZGl1cyArIFwiIDAgMSwxIDAsXCIgKyAtMiAqIHJhZGl1c1xuICAgICAgICAgICAgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIDIgKiByYWRpdXNcbiAgICAgICAgICAgICsgXCJ6XCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluZGV4KHByb2plY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHBvaW50UmFkaXVzID0gNC41LCBwcm9qZWN0aW9uU3RyZWFtLCBjb250ZXh0U3RyZWFtO1xuICAgICAgICBmdW5jdGlvbiBwYXRoKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrcG9pbnRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShjb250ZXh0U3RyZWFtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dFN0cmVhbS5yZXN1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoLmFyZWEgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGFyZWFTdHJlYW0kMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFyZWFTdHJlYW0kMS5yZXN1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcGF0aC5tZWFzdXJlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgICAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShsZW5ndGhTdHJlYW0kMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aFN0cmVhbSQxLnJlc3VsdCgpO1xuICAgICAgICB9O1xuICAgICAgICBwYXRoLmJvdW5kcyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0oYm91bmRzU3RyZWFtJDEpKTtcbiAgICAgICAgICAgIHJldHVybiBib3VuZHNTdHJlYW0kMS5yZXN1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcGF0aC5jZW50cm9pZCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0oY2VudHJvaWRTdHJlYW0kMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGNlbnRyb2lkU3RyZWFtJDEucmVzdWx0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHBhdGgucHJvamVjdGlvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcm9qZWN0aW9uU3RyZWFtID0gXyA9PSBudWxsID8gKHByb2plY3Rpb24gPSBudWxsLCBpZGVudGl0eSkgOiAocHJvamVjdGlvbiA9IF8pLnN0cmVhbSwgcGF0aCkgOiBwcm9qZWN0aW9uO1xuICAgICAgICB9O1xuICAgICAgICBwYXRoLmNvbnRleHQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICAgICAgY29udGV4dFN0cmVhbSA9IF8gPT0gbnVsbCA/IChjb250ZXh0ID0gbnVsbCwgbmV3IFBhdGhTdHJpbmcpIDogbmV3IFBhdGhDb250ZXh0KGNvbnRleHQgPSBfKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKHBvaW50UmFkaXVzKTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9O1xuICAgICAgICBwYXRoLnBvaW50UmFkaXVzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRSYWRpdXM7XG4gICAgICAgICAgICBwb2ludFJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogKGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK18pLCArXyk7XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhdGgucHJvamVjdGlvbihwcm9qZWN0aW9uKS5jb250ZXh0KGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0obWV0aG9kcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RyZWFtOiB0cmFuc2Zvcm1lcihtZXRob2RzKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1lcihtZXRob2RzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgcyA9IG5ldyBUcmFuc2Zvcm1TdHJlYW07XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcylcbiAgICAgICAgICAgICAgICBzW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgICAgICAgICBzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW0oKSB7IH1cbiAgICBUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogVHJhbnNmb3JtU3RyZWFtLFxuICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgdGhpcy5zdHJlYW0ucG9pbnQoeCwgeSk7IH0sXG4gICAgICAgIHNwaGVyZTogZnVuY3Rpb24gKCkgeyB0aGlzLnN0cmVhbS5zcGhlcmUoKTsgfSxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuc3RyZWFtLmxpbmVTdGFydCgpOyB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHRoaXMuc3RyZWFtLmxpbmVFbmQoKTsgfSxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IHRoaXMuc3RyZWFtLnBvbHlnb25TdGFydCgpOyB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IHRoaXMuc3RyZWFtLnBvbHlnb25FbmQoKTsgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gZml0KHByb2plY3Rpb24sIGZpdEJvdW5kcywgb2JqZWN0KSB7XG4gICAgICAgIHZhciBjbGlwID0gcHJvamVjdGlvbi5jbGlwRXh0ZW50ICYmIHByb2plY3Rpb24uY2xpcEV4dGVudCgpO1xuICAgICAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCkudHJhbnNsYXRlKFswLCAwXSk7XG4gICAgICAgIGlmIChjbGlwICE9IG51bGwpXG4gICAgICAgICAgICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQobnVsbCk7XG4gICAgICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb24uc3RyZWFtKGJvdW5kc1N0cmVhbSQxKSk7XG4gICAgICAgIGZpdEJvdW5kcyhib3VuZHNTdHJlYW0kMS5yZXN1bHQoKSk7XG4gICAgICAgIGlmIChjbGlwICE9IG51bGwpXG4gICAgICAgICAgICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQoY2xpcCk7XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZpdChwcm9qZWN0aW9uLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgdmFyIHcgPSBleHRlbnRbMV1bMF0gLSBleHRlbnRbMF1bMF0sIGggPSBleHRlbnRbMV1bMV0gLSBleHRlbnRbMF1bMV0sIGsgPSBNYXRoLm1pbih3IC8gKGJbMV1bMF0gLSBiWzBdWzBdKSwgaCAvIChiWzFdWzFdIC0gYlswXVsxXSkpLCB4ID0gK2V4dGVudFswXVswXSArICh3IC0gayAqIChiWzFdWzBdICsgYlswXVswXSkpIC8gMiwgeSA9ICtleHRlbnRbMF1bMV0gKyAoaCAtIGsgKiAoYlsxXVsxXSArIGJbMF1bMV0pKSAvIDI7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICAgICAgICB9LCBvYmplY3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaXRTaXplKHByb2plY3Rpb24sIHNpemUsIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIFtbMCwgMF0sIHNpemVdLCBvYmplY3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaXRXaWR0aChwcm9qZWN0aW9uLCB3aWR0aCwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBmaXQocHJvamVjdGlvbiwgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIHZhciB3ID0gK3dpZHRoLCBrID0gdyAvIChiWzFdWzBdIC0gYlswXVswXSksIHggPSAodyAtIGsgKiAoYlsxXVswXSArIGJbMF1bMF0pKSAvIDIsIHkgPSAtayAqIGJbMF1bMV07XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICAgICAgICB9LCBvYmplY3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaXRIZWlnaHQocHJvamVjdGlvbiwgaGVpZ2h0LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZpdChwcm9qZWN0aW9uLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgdmFyIGggPSAraGVpZ2h0LCBrID0gaCAvIChiWzFdWzFdIC0gYlswXVsxXSksIHggPSAtayAqIGJbMF1bMF0sIHkgPSAoaCAtIGsgKiAoYlsxXVsxXSArIGJbMF1bMV0pKSAvIDI7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICAgICAgICB9LCBvYmplY3QpO1xuICAgIH1cbiAgICB2YXIgbWF4RGVwdGggPSAxNiwgLy8gbWF4aW11bSBkZXB0aCBvZiBzdWJkaXZpc2lvblxuICAgIGNvc01pbkRpc3RhbmNlID0gY29zKDMwICogcmFkaWFucyk7IC8vIGNvcyhtaW5pbXVtIGFuZ3VsYXIgZGlzdGFuY2UpXG4gICAgZnVuY3Rpb24gcmVzYW1wbGUocHJvamVjdCwgZGVsdGEyKSB7XG4gICAgICAgIHJldHVybiArZGVsdGEyID8gcmVzYW1wbGUkMShwcm9qZWN0LCBkZWx0YTIpIDogcmVzYW1wbGVOb25lKHByb2plY3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNhbXBsZU5vbmUocHJvamVjdCkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIoe1xuICAgICAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucG9pbnQoeFswXSwgeFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNhbXBsZSQxKHByb2plY3QsIGRlbHRhMikge1xuICAgICAgICBmdW5jdGlvbiByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgxLCB5MSwgbGFtYmRhMSwgYTEsIGIxLCBjMSwgZGVwdGgsIHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIGR4ID0geDEgLSB4MCwgZHkgPSB5MSAtIHkwLCBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICAgICAgaWYgKGQyID4gNCAqIGRlbHRhMiAmJiBkZXB0aC0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBhMCArIGExLCBiID0gYjAgKyBiMSwgYyA9IGMwICsgYzEsIG0gPSBzcXJ0KGEgKiBhICsgYiAqIGIgKyBjICogYyksIHBoaTIgPSBhc2luKGMgLz0gbSksIGxhbWJkYTIgPSBhYnMoYWJzKGMpIC0gMSkgPCBlcHNpbG9uIHx8IGFicyhsYW1iZGEwIC0gbGFtYmRhMSkgPCBlcHNpbG9uID8gKGxhbWJkYTAgKyBsYW1iZGExKSAvIDIgOiBhdGFuMihiLCBhKSwgcCA9IHByb2plY3QobGFtYmRhMiwgcGhpMiksIHgyID0gcFswXSwgeTIgPSBwWzFdLCBkeDIgPSB4MiAtIHgwLCBkeTIgPSB5MiAtIHkwLCBkeiA9IGR5ICogZHgyIC0gZHggKiBkeTI7XG4gICAgICAgICAgICAgICAgaWYgKGR6ICogZHogLyBkMiA+IGRlbHRhMiAvLyBwZXJwZW5kaWN1bGFyIHByb2plY3RlZCBkaXN0YW5jZVxuICAgICAgICAgICAgICAgICAgICB8fCBhYnMoKGR4ICogZHgyICsgZHkgKiBkeTIpIC8gZDIgLSAwLjUpID4gMC4zIC8vIG1pZHBvaW50IGNsb3NlIHRvIGFuIGVuZFxuICAgICAgICAgICAgICAgICAgICB8fCBhMCAqIGExICsgYjAgKiBiMSArIGMwICogYzEgPCBjb3NNaW5EaXN0YW5jZSkgeyAvLyBhbmd1bGFyIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDIsIHkyLCBsYW1iZGEyLCBhIC89IG0sIGIgLz0gbSwgYywgZGVwdGgsIHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh4MiwgeTIpO1xuICAgICAgICAgICAgICAgICAgICByZXNhbXBsZUxpbmVUbyh4MiwgeTIsIGxhbWJkYTIsIGEsIGIsIGMsIHgxLCB5MSwgbGFtYmRhMSwgYTEsIGIxLCBjMSwgZGVwdGgsIHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgbGFtYmRhMDAsIHgwMCwgeTAwLCBhMDAsIGIwMCwgYzAwLCAvLyBmaXJzdCBwb2ludFxuICAgICAgICAgICAgbGFtYmRhMCwgeDAsIHkwLCBhMCwgYjAsIGMwOyAvLyBwcmV2aW91cyBwb2ludFxuICAgICAgICAgICAgdmFyIHJlc2FtcGxlU3RyZWFtID0ge1xuICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgICAgICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkgeyBzdHJlYW0ucG9seWdvblN0YXJ0KCk7IHJlc2FtcGxlU3RyZWFtLmxpbmVTdGFydCA9IHJpbmdTdGFydDsgfSxcbiAgICAgICAgICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IHN0cmVhbS5wb2x5Z29uRW5kKCk7IHJlc2FtcGxlU3RyZWFtLmxpbmVTdGFydCA9IGxpbmVTdGFydDsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgICAgICAgICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQoeFswXSwgeFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICAgICAgICAgICAgeDAgPSBOYU47XG4gICAgICAgICAgICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBjYXJ0ZXNpYW4oW2xhbWJkYSwgcGhpXSksIHAgPSBwcm9qZWN0KGxhbWJkYSwgcGhpKTtcbiAgICAgICAgICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgwID0gcFswXSwgeTAgPSBwWzFdLCBsYW1iZGEwID0gbGFtYmRhLCBhMCA9IGNbMF0sIGIwID0gY1sxXSwgYzAgPSBjWzJdLCBtYXhEZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQoeDAsIHkwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICAgICAgICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIHJlc2FtcGxlU3RyZWFtLnBvaW50ID0gcmluZ1BvaW50O1xuICAgICAgICAgICAgICAgIHJlc2FtcGxlU3RyZWFtLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmluZ1BvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICAgICAgbGluZVBvaW50KGxhbWJkYTAwID0gbGFtYmRhLCBwaGkpLCB4MDAgPSB4MCwgeTAwID0geTAsIGEwMCA9IGEwLCBiMDAgPSBiMCwgYzAwID0gYzA7XG4gICAgICAgICAgICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgICAgICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDAwLCB5MDAsIGxhbWJkYTAwLCBhMDAsIGIwMCwgYzAwLCBtYXhEZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgICAgICAgICByZXNhbXBsZVN0cmVhbS5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgICAgICAgICBsaW5lRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzYW1wbGVTdHJlYW07XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciB0cmFuc2Zvcm1SYWRpYW5zID0gdHJhbnNmb3JtZXIoe1xuICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHggKiByYWRpYW5zLCB5ICogcmFkaWFucyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1Sb3RhdGUocm90YXRlKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcih7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHJvdGF0ZSh4LCB5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucG9pbnQoclswXSwgclsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZShrLCBkeCwgZHkpIHtcbiAgICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBbZHggKyBrICogeCwgZHkgLSBrICogeV07XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNmb3JtLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gWyh4IC0gZHgpIC8gaywgKGR5IC0geSkgLyBrXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGVUcmFuc2xhdGVSb3RhdGUoaywgZHgsIGR5LCBhbHBoYSkge1xuICAgICAgICB2YXIgY29zQWxwaGEgPSBjb3MoYWxwaGEpLCBzaW5BbHBoYSA9IHNpbihhbHBoYSksIGEgPSBjb3NBbHBoYSAqIGssIGIgPSBzaW5BbHBoYSAqIGssIGFpID0gY29zQWxwaGEgLyBrLCBiaSA9IHNpbkFscGhhIC8gaywgY2kgPSAoc2luQWxwaGEgKiBkeSAtIGNvc0FscGhhICogZHgpIC8gaywgZmkgPSAoc2luQWxwaGEgKiBkeCArIGNvc0FscGhhICogZHkpIC8gaztcbiAgICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBbYSAqIHggLSBiICogeSArIGR4LCBkeSAtIGIgKiB4IC0gYSAqIHldO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zZm9ybS5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIFthaSAqIHggLSBiaSAqIHkgKyBjaSwgZmkgLSBiaSAqIHggLSBhaSAqIHldO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9qZWN0aW9uKHByb2plY3QpIHtcbiAgICAgICAgcmV0dXJuIHByb2plY3Rpb25NdXRhdG9yKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb2plY3Q7IH0pKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2plY3Rpb25NdXRhdG9yKHByb2plY3RBdCkge1xuICAgICAgICB2YXIgcHJvamVjdCwgayA9IDE1MCwgLy8gc2NhbGVcbiAgICAgICAgeCA9IDQ4MCwgeSA9IDI1MCwgLy8gdHJhbnNsYXRlXG4gICAgICAgIGxhbWJkYSA9IDAsIHBoaSA9IDAsIC8vIGNlbnRlclxuICAgICAgICBkZWx0YUxhbWJkYSA9IDAsIGRlbHRhUGhpID0gMCwgZGVsdGFHYW1tYSA9IDAsIHJvdGF0ZSwgLy8gcHJlLXJvdGF0ZVxuICAgICAgICBhbHBoYSA9IDAsIC8vIHBvc3Qtcm90YXRlXG4gICAgICAgIHRoZXRhID0gbnVsbCwgcHJlY2xpcCA9IGNsaXBBbnRpbWVyaWRpYW4sIC8vIHByZS1jbGlwIGFuZ2xlXG4gICAgICAgIHgwID0gbnVsbCwgeTAsIHgxLCB5MSwgcG9zdGNsaXAgPSBpZGVudGl0eSwgLy8gcG9zdC1jbGlwIGV4dGVudFxuICAgICAgICBkZWx0YTIgPSAwLjUsIC8vIHByZWNpc2lvblxuICAgICAgICBwcm9qZWN0UmVzYW1wbGUsIHByb2plY3RUcmFuc2Zvcm0sIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0sIGNhY2hlLCBjYWNoZVN0cmVhbTtcbiAgICAgICAgZnVuY3Rpb24gcHJvamVjdGlvbihwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0ocG9pbnRbMF0gKiByYWRpYW5zLCBwb2ludFsxXSAqIHJhZGlhbnMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGludmVydChwb2ludCkge1xuICAgICAgICAgICAgcG9pbnQgPSBwcm9qZWN0Um90YXRlVHJhbnNmb3JtLmludmVydChwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50ICYmIFtwb2ludFswXSAqIGRlZ3JlZXMsIHBvaW50WzFdICogZGVncmVlc107XG4gICAgICAgIH1cbiAgICAgICAgcHJvamVjdGlvbi5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSB0cmFuc2Zvcm1SYWRpYW5zKHRyYW5zZm9ybVJvdGF0ZShyb3RhdGUpKHByZWNsaXAocHJvamVjdFJlc2FtcGxlKHBvc3RjbGlwKGNhY2hlU3RyZWFtID0gc3RyZWFtKSkpKSk7XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3Rpb24ucHJlY2xpcCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjbGlwID0gXywgdGhldGEgPSB1bmRlZmluZWQsIHJlc2V0KCkpIDogcHJlY2xpcDtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5wb3N0Y2xpcCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8sIHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgcmVzZXQoKSkgOiBwb3N0Y2xpcDtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5jbGlwQW5nbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2xpcCA9ICtfID8gY2xpcENpcmNsZSh0aGV0YSA9IF8gKiByYWRpYW5zKSA6ICh0aGV0YSA9IG51bGwsIGNsaXBBbnRpbWVyaWRpYW4pLCByZXNldCgpKSA6IHRoZXRhICogZGVncmVlcztcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5jbGlwRXh0ZW50ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXyA9PSBudWxsID8gKHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgaWRlbnRpdHkpIDogY2xpcFJlY3RhbmdsZSh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdKSwgcmVzZXQoKSkgOiB4MCA9PSBudWxsID8gbnVsbCA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgICAgICB9O1xuICAgICAgICBwcm9qZWN0aW9uLnNjYWxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGsgPSArXywgcmVjZW50ZXIoKSkgOiBrO1xuICAgICAgICB9O1xuICAgICAgICBwcm9qZWN0aW9uLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK19bMF0sIHkgPSArX1sxXSwgcmVjZW50ZXIoKSkgOiBbeCwgeV07XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3Rpb24uY2VudGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGxhbWJkYSA9IF9bMF0gJSAzNjAgKiByYWRpYW5zLCBwaGkgPSBfWzFdICUgMzYwICogcmFkaWFucywgcmVjZW50ZXIoKSkgOiBbbGFtYmRhICogZGVncmVlcywgcGhpICogZGVncmVlc107XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3Rpb24ucm90YXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlbHRhTGFtYmRhID0gX1swXSAlIDM2MCAqIHJhZGlhbnMsIGRlbHRhUGhpID0gX1sxXSAlIDM2MCAqIHJhZGlhbnMsIGRlbHRhR2FtbWEgPSBfLmxlbmd0aCA+IDIgPyBfWzJdICUgMzYwICogcmFkaWFucyA6IDAsIHJlY2VudGVyKCkpIDogW2RlbHRhTGFtYmRhICogZGVncmVlcywgZGVsdGFQaGkgKiBkZWdyZWVzLCBkZWx0YUdhbW1hICogZGVncmVlc107XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3Rpb24uYW5nbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGEgPSBfICUgMzYwICogcmFkaWFucywgcmVjZW50ZXIoKSkgOiBhbHBoYSAqIGRlZ3JlZXM7XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3Rpb24ucHJlY2lzaW9uID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByb2plY3RSZXNhbXBsZSA9IHJlc2FtcGxlKHByb2plY3RUcmFuc2Zvcm0sIGRlbHRhMiA9IF8gKiBfKSwgcmVzZXQoKSkgOiBzcXJ0KGRlbHRhMik7XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3Rpb24uZml0RXh0ZW50ID0gZnVuY3Rpb24gKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5maXRTaXplID0gZnVuY3Rpb24gKHNpemUsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5maXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0V2lkdGgocHJvamVjdGlvbiwgd2lkdGgsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3Rpb24uZml0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gcmVjZW50ZXIoKSB7XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gc2NhbGVUcmFuc2xhdGVSb3RhdGUoaywgMCwgMCwgYWxwaGEpLmFwcGx5KG51bGwsIHByb2plY3QobGFtYmRhLCBwaGkpKSwgdHJhbnNmb3JtID0gKGFscGhhID8gc2NhbGVUcmFuc2xhdGVSb3RhdGUgOiBzY2FsZVRyYW5zbGF0ZSkoaywgeCAtIGNlbnRlclswXSwgeSAtIGNlbnRlclsxXSwgYWxwaGEpO1xuICAgICAgICAgICAgcm90YXRlID0gcm90YXRlUmFkaWFucyhkZWx0YUxhbWJkYSwgZGVsdGFQaGksIGRlbHRhR2FtbWEpO1xuICAgICAgICAgICAgcHJvamVjdFRyYW5zZm9ybSA9IGNvbXBvc2UocHJvamVjdCwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0gPSBjb21wb3NlKHJvdGF0ZSwgcHJvamVjdFRyYW5zZm9ybSk7XG4gICAgICAgICAgICBwcm9qZWN0UmVzYW1wbGUgPSByZXNhbXBsZShwcm9qZWN0VHJhbnNmb3JtLCBkZWx0YTIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcm9qZWN0ID0gcHJvamVjdEF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLmludmVydCA9IHByb2plY3QuaW52ZXJ0ICYmIGludmVydDtcbiAgICAgICAgICAgIHJldHVybiByZWNlbnRlcigpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb25pY1Byb2plY3Rpb24ocHJvamVjdEF0KSB7XG4gICAgICAgIHZhciBwaGkwID0gMCwgcGhpMSA9IHBpIC8gMywgbSA9IHByb2plY3Rpb25NdXRhdG9yKHByb2plY3RBdCksIHAgPSBtKHBoaTAsIHBoaTEpO1xuICAgICAgICBwLnBhcmFsbGVscyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IG0ocGhpMCA9IF9bMF0gKiByYWRpYW5zLCBwaGkxID0gX1sxXSAqIHJhZGlhbnMpIDogW3BoaTAgKiBkZWdyZWVzLCBwaGkxICogZGVncmVlc107XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjeWxpbmRyaWNhbEVxdWFsQXJlYVJhdyhwaGkwKSB7XG4gICAgICAgIHZhciBjb3NQaGkwID0gY29zKHBoaTApO1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2xhbWJkYSAqIGNvc1BoaTAsIHNpbihwaGkpIC8gY29zUGhpMF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIFt4IC8gY29zUGhpMCwgYXNpbih5ICogY29zUGhpMCldO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uaWNFcXVhbEFyZWFSYXcoeTAsIHkxKSB7XG4gICAgICAgIHZhciBzeTAgPSBzaW4oeTApLCBuID0gKHN5MCArIHNpbih5MSkpIC8gMjtcbiAgICAgICAgLy8gQXJlIHRoZSBwYXJhbGxlbHMgc3ltbWV0cmljYWwgYXJvdW5kIHRoZSBFcXVhdG9yP1xuICAgICAgICBpZiAoYWJzKG4pIDwgZXBzaWxvbilcbiAgICAgICAgICAgIHJldHVybiBjeWxpbmRyaWNhbEVxdWFsQXJlYVJhdyh5MCk7XG4gICAgICAgIHZhciBjID0gMSArIHN5MCAqICgyICogbiAtIHN5MCksIHIwID0gc3FydChjKSAvIG47XG4gICAgICAgIGZ1bmN0aW9uIHByb2plY3QoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHIgPSBzcXJ0KGMgLSAyICogbiAqIHNpbih5KSkgLyBuO1xuICAgICAgICAgICAgcmV0dXJuIFtyICogc2luKHggKj0gbiksIHIwIC0gciAqIGNvcyh4KV07XG4gICAgICAgIH1cbiAgICAgICAgcHJvamVjdC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHIweSA9IHIwIC0geTtcbiAgICAgICAgICAgIHJldHVybiBbYXRhbjIoeCwgYWJzKHIweSkpIC8gbiAqIHNpZ24ocjB5KSwgYXNpbigoYyAtICh4ICogeCArIHIweSAqIHIweSkgKiBuICogbikgLyAoMiAqIG4pKV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcm9qZWN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb25pY0VxdWFsQXJlYSgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmljUHJvamVjdGlvbihjb25pY0VxdWFsQXJlYVJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNTUuNDI0KVxuICAgICAgICAgICAgLmNlbnRlcihbMCwgMzMuNjQ0Ml0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhbGJlcnMoKSB7XG4gICAgICAgIHJldHVybiBjb25pY0VxdWFsQXJlYSgpXG4gICAgICAgICAgICAucGFyYWxsZWxzKFsyOS41LCA0NS41XSlcbiAgICAgICAgICAgIC5zY2FsZSgxMDcwKVxuICAgICAgICAgICAgLnRyYW5zbGF0ZShbNDgwLCAyNTBdKVxuICAgICAgICAgICAgLnJvdGF0ZShbOTYsIDBdKVxuICAgICAgICAgICAgLmNlbnRlcihbLTAuNiwgMzguN10pO1xuICAgIH1cbiAgICAvLyBUaGUgcHJvamVjdGlvbnMgbXVzdCBoYXZlIG11dHVhbGx5IGV4Y2x1c2l2ZSBjbGlwIHJlZ2lvbnMgb24gdGhlIHNwaGVyZSxcbiAgICAvLyBhcyB0aGlzIHdpbGwgYXZvaWQgZW1pdHRpbmcgaW50ZXJsZWF2aW5nIGxpbmVzIGFuZCBwb2x5Z29ucy5cbiAgICBmdW5jdGlvbiBtdWx0aXBsZXgoc3RyZWFtcykge1xuICAgICAgICB2YXIgbiA9IHN0cmVhbXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9pbnQoeCwgeSk7IH0sXG4gICAgICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5zcGhlcmUoKTsgfSxcbiAgICAgICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLmxpbmVTdGFydCgpOyB9LFxuICAgICAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLmxpbmVFbmQoKTsgfSxcbiAgICAgICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvbHlnb25TdGFydCgpOyB9LFxuICAgICAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvbHlnb25FbmQoKTsgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBIGNvbXBvc2l0ZSBwcm9qZWN0aW9uIGZvciB0aGUgVW5pdGVkIFN0YXRlcywgY29uZmlndXJlZCBieSBkZWZhdWx0IGZvclxuICAgIC8vIDk2MMOXNTAwLiBUaGUgcHJvamVjdGlvbiBhbHNvIHdvcmtzIHF1aXRlIHdlbGwgYXQgOTYww5c2MDAgaWYgeW91IGNoYW5nZSB0aGVcbiAgICAvLyBzY2FsZSB0byAxMjg1IGFuZCBhZGp1c3QgdGhlIHRyYW5zbGF0ZSBhY2NvcmRpbmdseS4gVGhlIHNldCBvZiBzdGFuZGFyZFxuICAgIC8vIHBhcmFsbGVscyBmb3IgZWFjaCByZWdpb24gY29tZXMgZnJvbSBVU0dTLCB3aGljaCBpcyBwdWJsaXNoZWQgaGVyZTpcbiAgICAvLyBodHRwOi8vZWdzYy51c2dzLmdvdi9pc2IvcHVicy9NYXBQcm9qZWN0aW9ucy9wcm9qZWN0aW9ucy5odG1sI2FsYmVyc1xuICAgIGZ1bmN0aW9uIGFsYmVyc1VzYSgpIHtcbiAgICAgICAgdmFyIGNhY2hlLCBjYWNoZVN0cmVhbSwgbG93ZXI0OCA9IGFsYmVycygpLCBsb3dlcjQ4UG9pbnQsIGFsYXNrYSA9IGNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsxNTQsIDBdKS5jZW50ZXIoWy0yLCA1OC41XSkucGFyYWxsZWxzKFs1NSwgNjVdKSwgYWxhc2thUG9pbnQsIC8vIEVQU0c6MzMzOFxuICAgICAgICBoYXdhaWkgPSBjb25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbMTU3LCAwXSkuY2VudGVyKFstMywgMTkuOV0pLnBhcmFsbGVscyhbOCwgMThdKSwgaGF3YWlpUG9pbnQsIC8vIEVTUkk6MTAyMDA3XG4gICAgICAgIHBvaW50LCBwb2ludFN0cmVhbSA9IHsgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7IHBvaW50ID0gW3gsIHldOyB9IH07XG4gICAgICAgIGZ1bmN0aW9uIGFsYmVyc1VzYShjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIHggPSBjb29yZGluYXRlc1swXSwgeSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50ID0gbnVsbCxcbiAgICAgICAgICAgICAgICAobG93ZXI0OFBvaW50LnBvaW50KHgsIHkpLCBwb2ludClcbiAgICAgICAgICAgICAgICAgICAgfHwgKGFsYXNrYVBvaW50LnBvaW50KHgsIHkpLCBwb2ludClcbiAgICAgICAgICAgICAgICAgICAgfHwgKGhhd2FpaVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgYWxiZXJzVXNhLmludmVydCA9IGZ1bmN0aW9uIChjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIGsgPSBsb3dlcjQ4LnNjYWxlKCksIHQgPSBsb3dlcjQ4LnRyYW5zbGF0ZSgpLCB4ID0gKGNvb3JkaW5hdGVzWzBdIC0gdFswXSkgLyBrLCB5ID0gKGNvb3JkaW5hdGVzWzFdIC0gdFsxXSkgLyBrO1xuICAgICAgICAgICAgcmV0dXJuICh5ID49IDAuMTIwICYmIHkgPCAwLjIzNCAmJiB4ID49IC0wLjQyNSAmJiB4IDwgLTAuMjE0ID8gYWxhc2thXG4gICAgICAgICAgICAgICAgOiB5ID49IDAuMTY2ICYmIHkgPCAwLjIzNCAmJiB4ID49IC0wLjIxNCAmJiB4IDwgLTAuMTE1ID8gaGF3YWlpXG4gICAgICAgICAgICAgICAgICAgIDogbG93ZXI0OCkuaW52ZXJ0KGNvb3JkaW5hdGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLnN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IG11bHRpcGxleChbbG93ZXI0OC5zdHJlYW0oY2FjaGVTdHJlYW0gPSBzdHJlYW0pLCBhbGFza2Euc3RyZWFtKHN0cmVhbSksIGhhd2FpaS5zdHJlYW0oc3RyZWFtKV0pO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2EucHJlY2lzaW9uID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbG93ZXI0OC5wcmVjaXNpb24oKTtcbiAgICAgICAgICAgIGxvd2VyNDgucHJlY2lzaW9uKF8pLCBhbGFza2EucHJlY2lzaW9uKF8pLCBoYXdhaWkucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5zY2FsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvd2VyNDguc2NhbGUoKTtcbiAgICAgICAgICAgIGxvd2VyNDguc2NhbGUoXyksIGFsYXNrYS5zY2FsZShfICogMC4zNSksIGhhd2FpaS5zY2FsZShfKTtcbiAgICAgICAgICAgIHJldHVybiBhbGJlcnNVc2EudHJhbnNsYXRlKGxvd2VyNDgudHJhbnNsYXRlKCkpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2EudHJhbnNsYXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbG93ZXI0OC50cmFuc2xhdGUoKTtcbiAgICAgICAgICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLCB4ID0gK19bMF0sIHkgPSArX1sxXTtcbiAgICAgICAgICAgIGxvd2VyNDhQb2ludCA9IGxvd2VyNDhcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKF8pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC40NTUgKiBrLCB5IC0gMC4yMzggKiBrXSwgW3ggKyAwLjQ1NSAqIGssIHkgKyAwLjIzOCAqIGtdXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIGFsYXNrYVBvaW50ID0gYWxhc2thXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMzA3ICogaywgeSArIDAuMjAxICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC40MjUgKiBrICsgZXBzaWxvbiwgeSArIDAuMTIwICogayArIGVwc2lsb25dLCBbeCAtIDAuMjE0ICogayAtIGVwc2lsb24sIHkgKyAwLjIzNCAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBoYXdhaWlQb2ludCA9IGhhd2FpaVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjIwNSAqIGssIHkgKyAwLjIxMiAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMjE0ICogayArIGVwc2lsb24sIHkgKyAwLjE2NiAqIGsgKyBlcHNpbG9uXSwgW3ggLSAwLjExNSAqIGsgLSBlcHNpbG9uLCB5ICsgMC4yMzQgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5maXRFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRFeHRlbnQoYWxiZXJzVXNhLCBleHRlbnQsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5maXRTaXplID0gZnVuY3Rpb24gKHNpemUsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdFNpemUoYWxiZXJzVXNhLCBzaXplLCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2EuZml0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdFdpZHRoKGFsYmVyc1VzYSwgd2lkdGgsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5maXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRIZWlnaHQoYWxiZXJzVXNhLCBoZWlnaHQsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gYWxiZXJzVXNhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGJlcnNVc2Euc2NhbGUoMTA3MCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF6aW11dGhhbFJhdyhzY2FsZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBjeCA9IGNvcyh4KSwgY3kgPSBjb3MoeSksIGsgPSBzY2FsZShjeCAqIGN5KTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgayAqIGN5ICogc2luKHgpLFxuICAgICAgICAgICAgICAgIGsgKiBzaW4oeSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF6aW11dGhhbEludmVydChhbmdsZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciB6ID0gc3FydCh4ICogeCArIHkgKiB5KSwgYyA9IGFuZ2xlKHopLCBzYyA9IHNpbihjKSwgY2MgPSBjb3MoYyk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGF0YW4yKHggKiBzYywgeiAqIGNjKSxcbiAgICAgICAgICAgICAgICBhc2luKHogJiYgeSAqIHNjIC8geilcbiAgICAgICAgICAgIF07XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBhemltdXRoYWxFcXVhbEFyZWFSYXcgPSBhemltdXRoYWxSYXcoZnVuY3Rpb24gKGN4Y3kpIHtcbiAgICAgICAgcmV0dXJuIHNxcnQoMiAvICgxICsgY3hjeSkpO1xuICAgIH0pO1xuICAgIGF6aW11dGhhbEVxdWFsQXJlYVJhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoZnVuY3Rpb24gKHopIHtcbiAgICAgICAgcmV0dXJuIDIgKiBhc2luKHogLyAyKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBhemltdXRoYWxFcXVhbEFyZWEoKSB7XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uKGF6aW11dGhhbEVxdWFsQXJlYVJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxMjQuNzUpXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDE4MCAtIDFlLTMpO1xuICAgIH1cbiAgICB2YXIgYXppbXV0aGFsRXF1aWRpc3RhbnRSYXcgPSBhemltdXRoYWxSYXcoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIChjID0gYWNvcyhjKSkgJiYgYyAvIHNpbihjKTtcbiAgICB9KTtcbiAgICBhemltdXRoYWxFcXVpZGlzdGFudFJhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoZnVuY3Rpb24gKHopIHtcbiAgICAgICAgcmV0dXJuIHo7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gYXppbXV0aGFsRXF1aWRpc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uKGF6aW11dGhhbEVxdWlkaXN0YW50UmF3KVxuICAgICAgICAgICAgLnNjYWxlKDc5LjQxODgpXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDE4MCAtIDFlLTMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJjYXRvclJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICByZXR1cm4gW2xhbWJkYSwgbG9nKHRhbigoaGFsZlBpICsgcGhpKSAvIDIpKV07XG4gICAgfVxuICAgIG1lcmNhdG9yUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiBbeCwgMiAqIGF0YW4oZXhwKHkpKSAtIGhhbGZQaV07XG4gICAgfTtcbiAgICBmdW5jdGlvbiBtZXJjYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIG1lcmNhdG9yUHJvamVjdGlvbihtZXJjYXRvclJhdylcbiAgICAgICAgICAgIC5zY2FsZSg5NjEgLyB0YXUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJjYXRvclByb2plY3Rpb24ocHJvamVjdCkge1xuICAgICAgICB2YXIgbSA9IHByb2plY3Rpb24ocHJvamVjdCksIGNlbnRlciA9IG0uY2VudGVyLCBzY2FsZSA9IG0uc2NhbGUsIHRyYW5zbGF0ZSA9IG0udHJhbnNsYXRlLCBjbGlwRXh0ZW50ID0gbS5jbGlwRXh0ZW50LCB4MCA9IG51bGwsIHkwLCB4MSwgeTE7IC8vIGNsaXAgZXh0ZW50XG4gICAgICAgIG0uc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2NhbGUoXyksIHJlY2xpcCgpKSA6IHNjYWxlKCk7XG4gICAgICAgIH07XG4gICAgICAgIG0udHJhbnNsYXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zbGF0ZShfKSwgcmVjbGlwKCkpIDogdHJhbnNsYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIG0uY2VudGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNlbnRlcihfKSwgcmVjbGlwKCkpIDogY2VudGVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIG0uY2xpcEV4dGVudCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoXyA9PSBudWxsID8geDAgPSB5MCA9IHgxID0geTEgPSBudWxsIDogKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pKSwgcmVjbGlwKCkpIDogeDAgPT0gbnVsbCA/IG51bGwgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gcmVjbGlwKCkge1xuICAgICAgICAgICAgdmFyIGsgPSBwaSAqIHNjYWxlKCksIHQgPSBtKHJvdGF0aW9uKG0ucm90YXRlKCkpLmludmVydChbMCwgMF0pKTtcbiAgICAgICAgICAgIHJldHVybiBjbGlwRXh0ZW50KHgwID09IG51bGxcbiAgICAgICAgICAgICAgICA/IFtbdFswXSAtIGssIHRbMV0gLSBrXSwgW3RbMF0gKyBrLCB0WzFdICsga11dIDogcHJvamVjdCA9PT0gbWVyY2F0b3JSYXdcbiAgICAgICAgICAgICAgICA/IFtbTWF0aC5tYXgodFswXSAtIGssIHgwKSwgeTBdLCBbTWF0aC5taW4odFswXSArIGssIHgxKSwgeTFdXVxuICAgICAgICAgICAgICAgIDogW1t4MCwgTWF0aC5tYXgodFsxXSAtIGssIHkwKV0sIFt4MSwgTWF0aC5taW4odFsxXSArIGssIHkxKV1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjbGlwKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRhbnkoeSkge1xuICAgICAgICByZXR1cm4gdGFuKChoYWxmUGkgKyB5KSAvIDIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb25pY0NvbmZvcm1hbFJhdyh5MCwgeTEpIHtcbiAgICAgICAgdmFyIGN5MCA9IGNvcyh5MCksIG4gPSB5MCA9PT0geTEgPyBzaW4oeTApIDogbG9nKGN5MCAvIGNvcyh5MSkpIC8gbG9nKHRhbnkoeTEpIC8gdGFueSh5MCkpLCBmID0gY3kwICogcG93KHRhbnkoeTApLCBuKSAvIG47XG4gICAgICAgIGlmICghbilcbiAgICAgICAgICAgIHJldHVybiBtZXJjYXRvclJhdztcbiAgICAgICAgZnVuY3Rpb24gcHJvamVjdCh4LCB5KSB7XG4gICAgICAgICAgICBpZiAoZiA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoeSA8IC1oYWxmUGkgKyBlcHNpbG9uKVxuICAgICAgICAgICAgICAgICAgICB5ID0gLWhhbGZQaSArIGVwc2lsb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoeSA+IGhhbGZQaSAtIGVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgIHkgPSBoYWxmUGkgLSBlcHNpbG9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHIgPSBmIC8gcG93KHRhbnkoeSksIG4pO1xuICAgICAgICAgICAgcmV0dXJuIFtyICogc2luKG4gKiB4KSwgZiAtIHIgKiBjb3MobiAqIHgpXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9qZWN0LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgZnkgPSBmIC0geSwgciA9IHNpZ24obikgKiBzcXJ0KHggKiB4ICsgZnkgKiBmeSk7XG4gICAgICAgICAgICByZXR1cm4gW2F0YW4yKHgsIGFicyhmeSkpIC8gbiAqIHNpZ24oZnkpLCAyICogYXRhbihwb3coZiAvIHIsIDEgLyBuKSkgLSBoYWxmUGldO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJvamVjdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uaWNDb25mb3JtYWwoKSB7XG4gICAgICAgIHJldHVybiBjb25pY1Byb2plY3Rpb24oY29uaWNDb25mb3JtYWxSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTA5LjUpXG4gICAgICAgICAgICAucGFyYWxsZWxzKFszMCwgMzBdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXF1aXJlY3Rhbmd1bGFyUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJldHVybiBbbGFtYmRhLCBwaGldO1xuICAgIH1cbiAgICBlcXVpcmVjdGFuZ3VsYXJSYXcuaW52ZXJ0ID0gZXF1aXJlY3Rhbmd1bGFyUmF3O1xuICAgIGZ1bmN0aW9uIGVxdWlyZWN0YW5ndWxhcigpIHtcbiAgICAgICAgcmV0dXJuIHByb2plY3Rpb24oZXF1aXJlY3Rhbmd1bGFyUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE1Mi42Myk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbmljRXF1aWRpc3RhbnRSYXcoeTAsIHkxKSB7XG4gICAgICAgIHZhciBjeTAgPSBjb3MoeTApLCBuID0geTAgPT09IHkxID8gc2luKHkwKSA6IChjeTAgLSBjb3MoeTEpKSAvICh5MSAtIHkwKSwgZyA9IGN5MCAvIG4gKyB5MDtcbiAgICAgICAgaWYgKGFicyhuKSA8IGVwc2lsb24pXG4gICAgICAgICAgICByZXR1cm4gZXF1aXJlY3Rhbmd1bGFyUmF3O1xuICAgICAgICBmdW5jdGlvbiBwcm9qZWN0KHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBneSA9IGcgLSB5LCBueCA9IG4gKiB4O1xuICAgICAgICAgICAgcmV0dXJuIFtneSAqIHNpbihueCksIGcgLSBneSAqIGNvcyhueCldO1xuICAgICAgICB9XG4gICAgICAgIHByb2plY3QuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBneSA9IGcgLSB5O1xuICAgICAgICAgICAgcmV0dXJuIFthdGFuMih4LCBhYnMoZ3kpKSAvIG4gKiBzaWduKGd5KSwgZyAtIHNpZ24obikgKiBzcXJ0KHggKiB4ICsgZ3kgKiBneSldO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJvamVjdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uaWNFcXVpZGlzdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmljUHJvamVjdGlvbihjb25pY0VxdWlkaXN0YW50UmF3KVxuICAgICAgICAgICAgLnNjYWxlKDEzMS4xNTQpXG4gICAgICAgICAgICAuY2VudGVyKFswLCAxMy45Mzg5XSk7XG4gICAgfVxuICAgIHZhciBBMSA9IDEuMzQwMjY0LCBBMiA9IC0wLjA4MTEwNiwgQTMgPSAwLjAwMDg5MywgQTQgPSAwLjAwMzc5NiwgTSA9IHNxcnQoMykgLyAyLCBpdGVyYXRpb25zID0gMTI7XG4gICAgZnVuY3Rpb24gZXF1YWxFYXJ0aFJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgbCA9IGFzaW4oTSAqIHNpbihwaGkpKSwgbDIgPSBsICogbCwgbDYgPSBsMiAqIGwyICogbDI7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsYW1iZGEgKiBjb3MobCkgLyAoTSAqIChBMSArIDMgKiBBMiAqIGwyICsgbDYgKiAoNyAqIEEzICsgOSAqIEE0ICogbDIpKSksXG4gICAgICAgICAgICBsICogKEExICsgQTIgKiBsMiArIGw2ICogKEEzICsgQTQgKiBsMikpXG4gICAgICAgIF07XG4gICAgfVxuICAgIGVxdWFsRWFydGhSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIGwgPSB5LCBsMiA9IGwgKiBsLCBsNiA9IGwyICogbDIgKiBsMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGRlbHRhLCBmeSwgZnB5OyBpIDwgaXRlcmF0aW9uczsgKytpKSB7XG4gICAgICAgICAgICBmeSA9IGwgKiAoQTEgKyBBMiAqIGwyICsgbDYgKiAoQTMgKyBBNCAqIGwyKSkgLSB5O1xuICAgICAgICAgICAgZnB5ID0gQTEgKyAzICogQTIgKiBsMiArIGw2ICogKDcgKiBBMyArIDkgKiBBNCAqIGwyKTtcbiAgICAgICAgICAgIGwgLT0gZGVsdGEgPSBmeSAvIGZweSwgbDIgPSBsICogbCwgbDYgPSBsMiAqIGwyICogbDI7XG4gICAgICAgICAgICBpZiAoYWJzKGRlbHRhKSA8IGVwc2lsb24yKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBNICogeCAqIChBMSArIDMgKiBBMiAqIGwyICsgbDYgKiAoNyAqIEEzICsgOSAqIEE0ICogbDIpKSAvIGNvcyhsKSxcbiAgICAgICAgICAgIGFzaW4oc2luKGwpIC8gTSlcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGVxdWFsRWFydGgoKSB7XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uKGVxdWFsRWFydGhSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTc3LjE1OCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdub21vbmljUmF3KHgsIHkpIHtcbiAgICAgICAgdmFyIGN5ID0gY29zKHkpLCBrID0gY29zKHgpICogY3k7XG4gICAgICAgIHJldHVybiBbY3kgKiBzaW4oeCkgLyBrLCBzaW4oeSkgLyBrXTtcbiAgICB9XG4gICAgZ25vbW9uaWNSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGF0YW4pO1xuICAgIGZ1bmN0aW9uIGdub21vbmljKCkge1xuICAgICAgICByZXR1cm4gcHJvamVjdGlvbihnbm9tb25pY1JhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNDQuMDQ5KVxuICAgICAgICAgICAgLmNsaXBBbmdsZSg2MCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlVHJhbnNsYXRlJDEoa3gsIGt5LCB0eCwgdHkpIHtcbiAgICAgICAgcmV0dXJuIGt4ID09PSAxICYmIGt5ID09PSAxICYmIHR4ID09PSAwICYmIHR5ID09PSAwID8gaWRlbnRpdHkgOiB0cmFuc2Zvcm1lcih7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5wb2ludCh4ICoga3ggKyB0eCwgeSAqIGt5ICsgdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaWRlbnRpdHkkMSgpIHtcbiAgICAgICAgdmFyIGsgPSAxLCB0eCA9IDAsIHR5ID0gMCwgc3ggPSAxLCBzeSA9IDEsIHRyYW5zZm9ybSA9IGlkZW50aXR5LCAvLyBzY2FsZSwgdHJhbnNsYXRlIGFuZCByZWZsZWN0XG4gICAgICAgIHgwID0gbnVsbCwgeTAsIHgxLCB5MSwgLy8gY2xpcCBleHRlbnRcbiAgICAgICAgcG9zdGNsaXAgPSBpZGVudGl0eSwgY2FjaGUsIGNhY2hlU3RyZWFtLCBwcm9qZWN0aW9uO1xuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHByb2plY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2plY3Rpb24gPSB7XG4gICAgICAgICAgICBzdHJlYW06IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSB0cmFuc2Zvcm0ocG9zdGNsaXAoY2FjaGVTdHJlYW0gPSBzdHJlYW0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3N0Y2xpcDogZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8sIHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgcmVzZXQoKSkgOiBwb3N0Y2xpcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGlwRXh0ZW50OiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXyA9PSBudWxsID8gKHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgaWRlbnRpdHkpIDogY2xpcFJlY3RhbmdsZSh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdKSwgcmVzZXQoKSkgOiB4MCA9PSBudWxsID8gbnVsbCA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjYWxlOiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zZm9ybSA9IHNjYWxlVHJhbnNsYXRlJDEoKGsgPSArXykgKiBzeCwgayAqIHN5LCB0eCwgdHkpLCByZXNldCgpKSA6IGs7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zZm9ybSA9IHNjYWxlVHJhbnNsYXRlJDEoayAqIHN4LCBrICogc3ksIHR4ID0gK19bMF0sIHR5ID0gK19bMV0pLCByZXNldCgpKSA6IFt0eCwgdHldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZmxlY3RYOiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zZm9ybSA9IHNjYWxlVHJhbnNsYXRlJDEoayAqIChzeCA9IF8gPyAtMSA6IDEpLCBrICogc3ksIHR4LCB0eSksIHJlc2V0KCkpIDogc3ggPCAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZmxlY3RZOiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zZm9ybSA9IHNjYWxlVHJhbnNsYXRlJDEoayAqIHN4LCBrICogKHN5ID0gXyA/IC0xIDogMSksIHR4LCB0eSksIHJlc2V0KCkpIDogc3kgPCAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpdEV4dGVudDogZnVuY3Rpb24gKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpdEV4dGVudChwcm9qZWN0aW9uLCBleHRlbnQsIG9iamVjdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml0U2l6ZTogZnVuY3Rpb24gKHNpemUsIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXRTaXplKHByb2plY3Rpb24sIHNpemUsIG9iamVjdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml0V2lkdGg6IGZ1bmN0aW9uICh3aWR0aCwgb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpdFdpZHRoKHByb2plY3Rpb24sIHdpZHRoLCBvYmplY3QpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpdEhlaWdodDogZnVuY3Rpb24gKGhlaWdodCwgb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpdEhlaWdodChwcm9qZWN0aW9uLCBoZWlnaHQsIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5hdHVyYWxFYXJ0aDFSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIHBoaTIgPSBwaGkgKiBwaGksIHBoaTQgPSBwaGkyICogcGhpMjtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGxhbWJkYSAqICgwLjg3MDcgLSAwLjEzMTk3OSAqIHBoaTIgKyBwaGk0ICogKC0wLjAxMzc5MSArIHBoaTQgKiAoMC4wMDM5NzEgKiBwaGkyIC0gMC4wMDE1MjkgKiBwaGk0KSkpLFxuICAgICAgICAgICAgcGhpICogKDEuMDA3MjI2ICsgcGhpMiAqICgwLjAxNTA4NSArIHBoaTQgKiAoLTAuMDQ0NDc1ICsgMC4wMjg4NzQgKiBwaGkyIC0gMC4wMDU5MTYgKiBwaGk0KSkpXG4gICAgICAgIF07XG4gICAgfVxuICAgIG5hdHVyYWxFYXJ0aDFSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHBoaSA9IHksIGkgPSAyNSwgZGVsdGE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBwaGkyID0gcGhpICogcGhpLCBwaGk0ID0gcGhpMiAqIHBoaTI7XG4gICAgICAgICAgICBwaGkgLT0gZGVsdGEgPSAocGhpICogKDEuMDA3MjI2ICsgcGhpMiAqICgwLjAxNTA4NSArIHBoaTQgKiAoLTAuMDQ0NDc1ICsgMC4wMjg4NzQgKiBwaGkyIC0gMC4wMDU5MTYgKiBwaGk0KSkpIC0geSkgL1xuICAgICAgICAgICAgICAgICgxLjAwNzIyNiArIHBoaTIgKiAoMC4wMTUwODUgKiAzICsgcGhpNCAqICgtMC4wNDQ0NzUgKiA3ICsgMC4wMjg4NzQgKiA5ICogcGhpMiAtIDAuMDA1OTE2ICogMTEgKiBwaGk0KSkpO1xuICAgICAgICB9IHdoaWxlIChhYnMoZGVsdGEpID4gZXBzaWxvbiAmJiAtLWkgPiAwKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHggLyAoMC44NzA3ICsgKHBoaTIgPSBwaGkgKiBwaGkpICogKC0wLjEzMTk3OSArIHBoaTIgKiAoLTAuMDEzNzkxICsgcGhpMiAqIHBoaTIgKiBwaGkyICogKDAuMDAzOTcxIC0gMC4wMDE1MjkgKiBwaGkyKSkpKSxcbiAgICAgICAgICAgIHBoaVxuICAgICAgICBdO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmF0dXJhbEVhcnRoMSgpIHtcbiAgICAgICAgcmV0dXJuIHByb2plY3Rpb24obmF0dXJhbEVhcnRoMVJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNzUuMjk1KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb3J0aG9ncmFwaGljUmF3KHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIFtjb3MoeSkgKiBzaW4oeCksIHNpbih5KV07XG4gICAgfVxuICAgIG9ydGhvZ3JhcGhpY1Jhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoYXNpbik7XG4gICAgZnVuY3Rpb24gb3J0aG9ncmFwaGljKCkge1xuICAgICAgICByZXR1cm4gcHJvamVjdGlvbihvcnRob2dyYXBoaWNSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMjQ5LjUpXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDkwICsgZXBzaWxvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXJlb2dyYXBoaWNSYXcoeCwgeSkge1xuICAgICAgICB2YXIgY3kgPSBjb3MoeSksIGsgPSAxICsgY29zKHgpICogY3k7XG4gICAgICAgIHJldHVybiBbY3kgKiBzaW4oeCkgLyBrLCBzaW4oeSkgLyBrXTtcbiAgICB9XG4gICAgc3RlcmVvZ3JhcGhpY1Jhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoZnVuY3Rpb24gKHopIHtcbiAgICAgICAgcmV0dXJuIDIgKiBhdGFuKHopO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHN0ZXJlb2dyYXBoaWMoKSB7XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uKHN0ZXJlb2dyYXBoaWNSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMjUwKVxuICAgICAgICAgICAgLmNsaXBBbmdsZSgxNDIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc3ZlcnNlTWVyY2F0b3JSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgcmV0dXJuIFtsb2codGFuKChoYWxmUGkgKyBwaGkpIC8gMikpLCAtbGFtYmRhXTtcbiAgICB9XG4gICAgdHJhbnN2ZXJzZU1lcmNhdG9yUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiBbLXksIDIgKiBhdGFuKGV4cCh4KSkgLSBoYWxmUGldO1xuICAgIH07XG4gICAgZnVuY3Rpb24gdHJhbnN2ZXJzZU1lcmNhdG9yKCkge1xuICAgICAgICB2YXIgbSA9IG1lcmNhdG9yUHJvamVjdGlvbih0cmFuc3ZlcnNlTWVyY2F0b3JSYXcpLCBjZW50ZXIgPSBtLmNlbnRlciwgcm90YXRlID0gbS5yb3RhdGU7XG4gICAgICAgIG0uY2VudGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gY2VudGVyKFstX1sxXSwgX1swXV0pIDogKF8gPSBjZW50ZXIoKSwgW19bMV0sIC1fWzBdXSk7XG4gICAgICAgIH07XG4gICAgICAgIG0ucm90YXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gcm90YXRlKFtfWzBdLCBfWzFdLCBfLmxlbmd0aCA+IDIgPyBfWzJdICsgOTAgOiA5MF0pIDogKF8gPSByb3RhdGUoKSwgW19bMF0sIF9bMV0sIF9bMl0gLSA5MF0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcm90YXRlKFswLCAwLCA5MF0pXG4gICAgICAgICAgICAuc2NhbGUoMTU5LjE1NSk7XG4gICAgfVxuICAgIGV4cG9ydHMuZ2VvQWxiZXJzID0gYWxiZXJzO1xuICAgIGV4cG9ydHMuZ2VvQWxiZXJzVXNhID0gYWxiZXJzVXNhO1xuICAgIGV4cG9ydHMuZ2VvQXJlYSA9IGFyZWE7XG4gICAgZXhwb3J0cy5nZW9BemltdXRoYWxFcXVhbEFyZWEgPSBhemltdXRoYWxFcXVhbEFyZWE7XG4gICAgZXhwb3J0cy5nZW9BemltdXRoYWxFcXVhbEFyZWFSYXcgPSBhemltdXRoYWxFcXVhbEFyZWFSYXc7XG4gICAgZXhwb3J0cy5nZW9BemltdXRoYWxFcXVpZGlzdGFudCA9IGF6aW11dGhhbEVxdWlkaXN0YW50O1xuICAgIGV4cG9ydHMuZ2VvQXppbXV0aGFsRXF1aWRpc3RhbnRSYXcgPSBhemltdXRoYWxFcXVpZGlzdGFudFJhdztcbiAgICBleHBvcnRzLmdlb0JvdW5kcyA9IGJvdW5kcztcbiAgICBleHBvcnRzLmdlb0NlbnRyb2lkID0gY2VudHJvaWQ7XG4gICAgZXhwb3J0cy5nZW9DaXJjbGUgPSBjaXJjbGU7XG4gICAgZXhwb3J0cy5nZW9DbGlwQW50aW1lcmlkaWFuID0gY2xpcEFudGltZXJpZGlhbjtcbiAgICBleHBvcnRzLmdlb0NsaXBDaXJjbGUgPSBjbGlwQ2lyY2xlO1xuICAgIGV4cG9ydHMuZ2VvQ2xpcEV4dGVudCA9IGV4dGVudDtcbiAgICBleHBvcnRzLmdlb0NsaXBSZWN0YW5nbGUgPSBjbGlwUmVjdGFuZ2xlO1xuICAgIGV4cG9ydHMuZ2VvQ29uaWNDb25mb3JtYWwgPSBjb25pY0NvbmZvcm1hbDtcbiAgICBleHBvcnRzLmdlb0NvbmljQ29uZm9ybWFsUmF3ID0gY29uaWNDb25mb3JtYWxSYXc7XG4gICAgZXhwb3J0cy5nZW9Db25pY0VxdWFsQXJlYSA9IGNvbmljRXF1YWxBcmVhO1xuICAgIGV4cG9ydHMuZ2VvQ29uaWNFcXVhbEFyZWFSYXcgPSBjb25pY0VxdWFsQXJlYVJhdztcbiAgICBleHBvcnRzLmdlb0NvbmljRXF1aWRpc3RhbnQgPSBjb25pY0VxdWlkaXN0YW50O1xuICAgIGV4cG9ydHMuZ2VvQ29uaWNFcXVpZGlzdGFudFJhdyA9IGNvbmljRXF1aWRpc3RhbnRSYXc7XG4gICAgZXhwb3J0cy5nZW9Db250YWlucyA9IGNvbnRhaW5zO1xuICAgIGV4cG9ydHMuZ2VvRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICBleHBvcnRzLmdlb0VxdWFsRWFydGggPSBlcXVhbEVhcnRoO1xuICAgIGV4cG9ydHMuZ2VvRXF1YWxFYXJ0aFJhdyA9IGVxdWFsRWFydGhSYXc7XG4gICAgZXhwb3J0cy5nZW9FcXVpcmVjdGFuZ3VsYXIgPSBlcXVpcmVjdGFuZ3VsYXI7XG4gICAgZXhwb3J0cy5nZW9FcXVpcmVjdGFuZ3VsYXJSYXcgPSBlcXVpcmVjdGFuZ3VsYXJSYXc7XG4gICAgZXhwb3J0cy5nZW9Hbm9tb25pYyA9IGdub21vbmljO1xuICAgIGV4cG9ydHMuZ2VvR25vbW9uaWNSYXcgPSBnbm9tb25pY1JhdztcbiAgICBleHBvcnRzLmdlb0dyYXRpY3VsZSA9IGdyYXRpY3VsZTtcbiAgICBleHBvcnRzLmdlb0dyYXRpY3VsZTEwID0gZ3JhdGljdWxlMTA7XG4gICAgZXhwb3J0cy5nZW9JZGVudGl0eSA9IGlkZW50aXR5JDE7XG4gICAgZXhwb3J0cy5nZW9JbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlO1xuICAgIGV4cG9ydHMuZ2VvTGVuZ3RoID0gbGVuZ3RoO1xuICAgIGV4cG9ydHMuZ2VvTWVyY2F0b3IgPSBtZXJjYXRvcjtcbiAgICBleHBvcnRzLmdlb01lcmNhdG9yUmF3ID0gbWVyY2F0b3JSYXc7XG4gICAgZXhwb3J0cy5nZW9OYXR1cmFsRWFydGgxID0gbmF0dXJhbEVhcnRoMTtcbiAgICBleHBvcnRzLmdlb05hdHVyYWxFYXJ0aDFSYXcgPSBuYXR1cmFsRWFydGgxUmF3O1xuICAgIGV4cG9ydHMuZ2VvT3J0aG9ncmFwaGljID0gb3J0aG9ncmFwaGljO1xuICAgIGV4cG9ydHMuZ2VvT3J0aG9ncmFwaGljUmF3ID0gb3J0aG9ncmFwaGljUmF3O1xuICAgIGV4cG9ydHMuZ2VvUGF0aCA9IGluZGV4O1xuICAgIGV4cG9ydHMuZ2VvUHJvamVjdGlvbiA9IHByb2plY3Rpb247XG4gICAgZXhwb3J0cy5nZW9Qcm9qZWN0aW9uTXV0YXRvciA9IHByb2plY3Rpb25NdXRhdG9yO1xuICAgIGV4cG9ydHMuZ2VvUm90YXRpb24gPSByb3RhdGlvbjtcbiAgICBleHBvcnRzLmdlb1N0ZXJlb2dyYXBoaWMgPSBzdGVyZW9ncmFwaGljO1xuICAgIGV4cG9ydHMuZ2VvU3RlcmVvZ3JhcGhpY1JhdyA9IHN0ZXJlb2dyYXBoaWNSYXc7XG4gICAgZXhwb3J0cy5nZW9TdHJlYW0gPSBnZW9TdHJlYW07XG4gICAgZXhwb3J0cy5nZW9UcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgZXhwb3J0cy5nZW9UcmFuc3ZlcnNlTWVyY2F0b3IgPSB0cmFuc3ZlcnNlTWVyY2F0b3I7XG4gICAgZXhwb3J0cy5nZW9UcmFuc3ZlcnNlTWVyY2F0b3JSYXcgPSB0cmFuc3ZlcnNlTWVyY2F0b3JSYXc7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn0pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtZ2VvQDEuNi40QGQzLWdlby9idWlsZC9kMy1nZW8uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kMy1nZW9AMS42LjRAZDMtZ2VvL2J1aWxkL2QzLWdlby5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1nZW8vIFZlcnNpb24gMS42LjQuIENvcHlyaWdodCAyMDE3IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgIHRydWUgPyBmYWN0b3J5KGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWFycmF5QDEuMi40QGQzLWFycmF5L2Rpc3QvZDMtYXJyYXkuanNcIikpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIGQzQXJyYXkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gQWRkcyBmbG9hdGluZyBwb2ludCBudW1iZXJzIHdpdGggdHdpY2UgdGhlIG5vcm1hbCBwcmVjaXNpb24uXG4gICAgLy8gUmVmZXJlbmNlOiBKLiBSLiBTaGV3Y2h1aywgQWRhcHRpdmUgUHJlY2lzaW9uIEZsb2F0aW5nLVBvaW50IEFyaXRobWV0aWMgYW5kXG4gICAgLy8gRmFzdCBSb2J1c3QgR2VvbWV0cmljIFByZWRpY2F0ZXMsIERpc2NyZXRlICYgQ29tcHV0YXRpb25hbCBHZW9tZXRyeSAxOCgzKVxuICAgIC8vIDMwNeKAkzM2MyAoMTk5NykuXG4gICAgLy8gQ29kZSBhZGFwdGVkIGZyb20gR2VvZ3JhcGhpY0xpYiBieSBDaGFybGVzIEYuIEYuIEthcm5leSxcbiAgICAvLyBodHRwOi8vZ2VvZ3JhcGhpY2xpYi5zb3VyY2Vmb3JnZS5uZXQvXG4gICAgdmFyIGFkZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFkZGVyO1xuICAgIH07XG4gICAgZnVuY3Rpb24gQWRkZXIoKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgQWRkZXIucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogQWRkZXIsXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnMgPSAvLyByb3VuZGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgdGhpcy50ID0gMDsgLy8gZXhhY3QgZXJyb3JcbiAgICAgICAgfSxcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgYWRkKHRlbXAsIHksIHRoaXMudCk7XG4gICAgICAgICAgICBhZGQodGhpcywgdGVtcC5zLCB0aGlzLnMpO1xuICAgICAgICAgICAgaWYgKHRoaXMucylcbiAgICAgICAgICAgICAgICB0aGlzLnQgKz0gdGVtcC50O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucyA9IHRlbXAudDtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWVPZjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucztcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHRlbXAgPSBuZXcgQWRkZXI7XG4gICAgZnVuY3Rpb24gYWRkKGFkZGVyLCBhLCBiKSB7XG4gICAgICAgIHZhciB4ID0gYWRkZXIucyA9IGEgKyBiLCBidiA9IHggLSBhLCBhdiA9IHggLSBidjtcbiAgICAgICAgYWRkZXIudCA9IChhIC0gYXYpICsgKGIgLSBidik7XG4gICAgfVxuICAgIHZhciBlcHNpbG9uID0gMWUtNjtcbiAgICB2YXIgZXBzaWxvbjIgPSAxZS0xMjtcbiAgICB2YXIgcGkgPSBNYXRoLlBJO1xuICAgIHZhciBoYWxmUGkgPSBwaSAvIDI7XG4gICAgdmFyIHF1YXJ0ZXJQaSA9IHBpIC8gNDtcbiAgICB2YXIgdGF1ID0gcGkgKiAyO1xuICAgIHZhciBkZWdyZWVzID0gMTgwIC8gcGk7XG4gICAgdmFyIHJhZGlhbnMgPSBwaSAvIDE4MDtcbiAgICB2YXIgYWJzID0gTWF0aC5hYnM7XG4gICAgdmFyIGF0YW4gPSBNYXRoLmF0YW47XG4gICAgdmFyIGF0YW4yID0gTWF0aC5hdGFuMjtcbiAgICB2YXIgY29zID0gTWF0aC5jb3M7XG4gICAgdmFyIGNlaWwgPSBNYXRoLmNlaWw7XG4gICAgdmFyIGV4cCA9IE1hdGguZXhwO1xuICAgIHZhciBsb2cgPSBNYXRoLmxvZztcbiAgICB2YXIgcG93ID0gTWF0aC5wb3c7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luO1xuICAgIHZhciBzaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ID4gMCA/IDEgOiB4IDwgMCA/IC0xIDogMDsgfTtcbiAgICB2YXIgc3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgdGFuID0gTWF0aC50YW47XG4gICAgZnVuY3Rpb24gYWNvcyh4KSB7XG4gICAgICAgIHJldHVybiB4ID4gMSA/IDAgOiB4IDwgLTEgPyBwaSA6IE1hdGguYWNvcyh4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNpbih4KSB7XG4gICAgICAgIHJldHVybiB4ID4gMSA/IGhhbGZQaSA6IHggPCAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhdmVyc2luKHgpIHtcbiAgICAgICAgcmV0dXJuICh4ID0gc2luKHggLyAyKSkgKiB4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wKCkgeyB9XG4gICAgZnVuY3Rpb24gc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cnksIHN0cmVhbSkge1xuICAgICAgICBpZiAoZ2VvbWV0cnkgJiYgc3RyZWFtR2VvbWV0cnlUeXBlLmhhc093blByb3BlcnR5KGdlb21ldHJ5LnR5cGUpKSB7XG4gICAgICAgICAgICBzdHJlYW1HZW9tZXRyeVR5cGVbZ2VvbWV0cnkudHlwZV0oZ2VvbWV0cnksIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0cmVhbU9iamVjdFR5cGUgPSB7XG4gICAgICAgIEZlYXR1cmU6IGZ1bmN0aW9uIChvYmplY3QsIHN0cmVhbSkge1xuICAgICAgICAgICAgc3RyZWFtR2VvbWV0cnkob2JqZWN0Lmdlb21ldHJ5LCBzdHJlYW0pO1xuICAgICAgICB9LFxuICAgICAgICBGZWF0dXJlQ29sbGVjdGlvbjogZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBvYmplY3QuZmVhdHVyZXMsIGkgPSAtMSwgbiA9IGZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbUdlb21ldHJ5KGZlYXR1cmVzW2ldLmdlb21ldHJ5LCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RyZWFtR2VvbWV0cnlUeXBlID0ge1xuICAgICAgICBTcGhlcmU6IGZ1bmN0aW9uIChvYmplY3QsIHN0cmVhbSkge1xuICAgICAgICAgICAgc3RyZWFtLnNwaGVyZSgpO1xuICAgICAgICB9LFxuICAgICAgICBQb2ludDogZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICBvYmplY3QgPSBvYmplY3QuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gICAgICAgIH0sXG4gICAgICAgIE11bHRpUG9pbnQ6IGZ1bmN0aW9uIChvYmplY3QsIHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBjb29yZGluYXRlc1tpXSwgc3RyZWFtLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICAgICAgICB9LFxuICAgICAgICBMaW5lU3RyaW5nOiBmdW5jdGlvbiAob2JqZWN0LCBzdHJlYW0pIHtcbiAgICAgICAgICAgIHN0cmVhbUxpbmUob2JqZWN0LmNvb3JkaW5hdGVzLCBzdHJlYW0sIDApO1xuICAgICAgICB9LFxuICAgICAgICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uIChvYmplY3QsIHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0sIDApO1xuICAgICAgICB9LFxuICAgICAgICBQb2x5Z29uOiBmdW5jdGlvbiAob2JqZWN0LCBzdHJlYW0pIHtcbiAgICAgICAgICAgIHN0cmVhbVBvbHlnb24ob2JqZWN0LmNvb3JkaW5hdGVzLCBzdHJlYW0pO1xuICAgICAgICB9LFxuICAgICAgICBNdWx0aVBvbHlnb246IGZ1bmN0aW9uIChvYmplY3QsIHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1Qb2x5Z29uKGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0pO1xuICAgICAgICB9LFxuICAgICAgICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uIChvYmplY3QsIHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIGdlb21ldHJpZXMgPSBvYmplY3QuZ2VvbWV0cmllcywgaSA9IC0xLCBuID0gZ2VvbWV0cmllcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1HZW9tZXRyeShnZW9tZXRyaWVzW2ldLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzLCBzdHJlYW0sIGNsb3NlZCkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gY2xvc2VkLCBjb29yZGluYXRlO1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0ucG9pbnQoY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgY29vcmRpbmF0ZVsyXSk7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmVhbVBvbHlnb24oY29vcmRpbmF0ZXMsIHN0cmVhbSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgc3RyZWFtLCAxKTtcbiAgICAgICAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICB9XG4gICAgdmFyIGdlb1N0cmVhbSA9IGZ1bmN0aW9uIChvYmplY3QsIHN0cmVhbSkge1xuICAgICAgICBpZiAob2JqZWN0ICYmIHN0cmVhbU9iamVjdFR5cGUuaGFzT3duUHJvcGVydHkob2JqZWN0LnR5cGUpKSB7XG4gICAgICAgICAgICBzdHJlYW1PYmplY3RUeXBlW29iamVjdC50eXBlXShvYmplY3QsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW1HZW9tZXRyeShvYmplY3QsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBhcmVhUmluZ1N1bSA9IGFkZGVyKCk7XG4gICAgdmFyIGFyZWFTdW0gPSBhZGRlcigpO1xuICAgIHZhciBsYW1iZGEwMDtcbiAgICB2YXIgcGhpMDA7XG4gICAgdmFyIGxhbWJkYTA7XG4gICAgdmFyIGNvc1BoaTA7XG4gICAgdmFyIHNpblBoaTA7XG4gICAgdmFyIGFyZWFTdHJlYW0gPSB7XG4gICAgICAgIHBvaW50OiBub29wLFxuICAgICAgICBsaW5lU3RhcnQ6IG5vb3AsXG4gICAgICAgIGxpbmVFbmQ6IG5vb3AsXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXJlYVJpbmdTdW0ucmVzZXQoKTtcbiAgICAgICAgICAgIGFyZWFTdHJlYW0ubGluZVN0YXJ0ID0gYXJlYVJpbmdTdGFydDtcbiAgICAgICAgICAgIGFyZWFTdHJlYW0ubGluZUVuZCA9IGFyZWFSaW5nRW5kO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJlYVJpbmcgPSArYXJlYVJpbmdTdW07XG4gICAgICAgICAgICBhcmVhU3VtLmFkZChhcmVhUmluZyA8IDAgPyB0YXUgKyBhcmVhUmluZyA6IGFyZWFSaW5nKTtcbiAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5saW5lRW5kID0gdGhpcy5wb2ludCA9IG5vb3A7XG4gICAgICAgIH0sXG4gICAgICAgIHNwaGVyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXJlYVN1bS5hZGQodGF1KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gYXJlYVJpbmdTdGFydCgpIHtcbiAgICAgICAgYXJlYVN0cmVhbS5wb2ludCA9IGFyZWFQb2ludEZpcnN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmVhUmluZ0VuZCgpIHtcbiAgICAgICAgYXJlYVBvaW50KGxhbWJkYTAwLCBwaGkwMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZWFQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGFyZWFTdHJlYW0ucG9pbnQgPSBhcmVhUG9pbnQ7XG4gICAgICAgIGxhbWJkYTAwID0gbGFtYmRhLCBwaGkwMCA9IHBoaTtcbiAgICAgICAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICAgICAgICBsYW1iZGEwID0gbGFtYmRhLCBjb3NQaGkwID0gY29zKHBoaSA9IHBoaSAvIDIgKyBxdWFydGVyUGkpLCBzaW5QaGkwID0gc2luKHBoaSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZWFQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gICAgICAgIHBoaSA9IHBoaSAvIDIgKyBxdWFydGVyUGk7IC8vIGhhbGYgdGhlIGFuZ3VsYXIgZGlzdGFuY2UgZnJvbSBzb3V0aCBwb2xlXG4gICAgICAgIC8vIFNwaGVyaWNhbCBleGNlc3MgRSBmb3IgYSBzcGhlcmljYWwgdHJpYW5nbGUgd2l0aCB2ZXJ0aWNlczogc291dGggcG9sZSxcbiAgICAgICAgLy8gcHJldmlvdXMgcG9pbnQsIGN1cnJlbnQgcG9pbnQuICBVc2VzIGEgZm9ybXVsYSBkZXJpdmVkIGZyb20gQ2Fnbm9saeKAmXNcbiAgICAgICAgLy8gdGhlb3JlbS4gIFNlZSBUb2RodW50ZXIsIFNwaGVyaWNhbCBUcmlnLiAoMTg3MSksIFNlYy4gMTAzLCBFcS4gKDIpLlxuICAgICAgICB2YXIgZExhbWJkYSA9IGxhbWJkYSAtIGxhbWJkYTAsIHNkTGFtYmRhID0gZExhbWJkYSA+PSAwID8gMSA6IC0xLCBhZExhbWJkYSA9IHNkTGFtYmRhICogZExhbWJkYSwgY29zUGhpID0gY29zKHBoaSksIHNpblBoaSA9IHNpbihwaGkpLCBrID0gc2luUGhpMCAqIHNpblBoaSwgdSA9IGNvc1BoaTAgKiBjb3NQaGkgKyBrICogY29zKGFkTGFtYmRhKSwgdiA9IGsgKiBzZExhbWJkYSAqIHNpbihhZExhbWJkYSk7XG4gICAgICAgIGFyZWFSaW5nU3VtLmFkZChhdGFuMih2LCB1KSk7XG4gICAgICAgIC8vIEFkdmFuY2UgdGhlIHByZXZpb3VzIHBvaW50cy5cbiAgICAgICAgbGFtYmRhMCA9IGxhbWJkYSwgY29zUGhpMCA9IGNvc1BoaSwgc2luUGhpMCA9IHNpblBoaTtcbiAgICB9XG4gICAgdmFyIGFyZWEgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIGFyZWFTdW0ucmVzZXQoKTtcbiAgICAgICAgZ2VvU3RyZWFtKG9iamVjdCwgYXJlYVN0cmVhbSk7XG4gICAgICAgIHJldHVybiBhcmVhU3VtICogMjtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHNwaGVyaWNhbChjYXJ0ZXNpYW4pIHtcbiAgICAgICAgcmV0dXJuIFthdGFuMihjYXJ0ZXNpYW5bMV0sIGNhcnRlc2lhblswXSksIGFzaW4oY2FydGVzaWFuWzJdKV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhcnRlc2lhbihzcGhlcmljYWwpIHtcbiAgICAgICAgdmFyIGxhbWJkYSA9IHNwaGVyaWNhbFswXSwgcGhpID0gc3BoZXJpY2FsWzFdLCBjb3NQaGkgPSBjb3MocGhpKTtcbiAgICAgICAgcmV0dXJuIFtjb3NQaGkgKiBjb3MobGFtYmRhKSwgY29zUGhpICogc2luKGxhbWJkYSksIHNpbihwaGkpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FydGVzaWFuRG90KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FydGVzaWFuQ3Jvc3MoYSwgYikge1xuICAgICAgICByZXR1cm4gW2FbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV0sIGFbMl0gKiBiWzBdIC0gYVswXSAqIGJbMl0sIGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF1dO1xuICAgIH1cbiAgICAvLyBUT0RPIHJldHVybiBhXG4gICAgZnVuY3Rpb24gY2FydGVzaWFuQWRkSW5QbGFjZShhLCBiKSB7XG4gICAgICAgIGFbMF0gKz0gYlswXSwgYVsxXSArPSBiWzFdLCBhWzJdICs9IGJbMl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhcnRlc2lhblNjYWxlKHZlY3Rvciwgaykge1xuICAgICAgICByZXR1cm4gW3ZlY3RvclswXSAqIGssIHZlY3RvclsxXSAqIGssIHZlY3RvclsyXSAqIGtdO1xuICAgIH1cbiAgICAvLyBUT0RPIHJldHVybiBkXG4gICAgZnVuY3Rpb24gY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShkKSB7XG4gICAgICAgIHZhciBsID0gc3FydChkWzBdICogZFswXSArIGRbMV0gKiBkWzFdICsgZFsyXSAqIGRbMl0pO1xuICAgICAgICBkWzBdIC89IGwsIGRbMV0gLz0gbCwgZFsyXSAvPSBsO1xuICAgIH1cbiAgICB2YXIgbGFtYmRhMCQxO1xuICAgIHZhciBwaGkwO1xuICAgIHZhciBsYW1iZGExO1xuICAgIHZhciBwaGkxO1xuICAgIHZhciBsYW1iZGEyO1xuICAgIHZhciBsYW1iZGEwMCQxO1xuICAgIHZhciBwaGkwMCQxO1xuICAgIHZhciBwMDtcbiAgICB2YXIgZGVsdGFTdW0gPSBhZGRlcigpO1xuICAgIHZhciByYW5nZXM7XG4gICAgdmFyIHJhbmdlJDE7XG4gICAgdmFyIGJvdW5kc1N0cmVhbSA9IHtcbiAgICAgICAgcG9pbnQ6IGJvdW5kc1BvaW50LFxuICAgICAgICBsaW5lU3RhcnQ6IGJvdW5kc0xpbmVTdGFydCxcbiAgICAgICAgbGluZUVuZDogYm91bmRzTGluZUVuZCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBib3VuZHNTdHJlYW0ucG9pbnQgPSBib3VuZHNSaW5nUG9pbnQ7XG4gICAgICAgICAgICBib3VuZHNTdHJlYW0ubGluZVN0YXJ0ID0gYm91bmRzUmluZ1N0YXJ0O1xuICAgICAgICAgICAgYm91bmRzU3RyZWFtLmxpbmVFbmQgPSBib3VuZHNSaW5nRW5kO1xuICAgICAgICAgICAgZGVsdGFTdW0ucmVzZXQoKTtcbiAgICAgICAgICAgIGFyZWFTdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFyZWFTdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgYm91bmRzU3RyZWFtLnBvaW50ID0gYm91bmRzUG9pbnQ7XG4gICAgICAgICAgICBib3VuZHNTdHJlYW0ubGluZVN0YXJ0ID0gYm91bmRzTGluZVN0YXJ0O1xuICAgICAgICAgICAgYm91bmRzU3RyZWFtLmxpbmVFbmQgPSBib3VuZHNMaW5lRW5kO1xuICAgICAgICAgICAgaWYgKGFyZWFSaW5nU3VtIDwgMClcbiAgICAgICAgICAgICAgICBsYW1iZGEwJDEgPSAtKGxhbWJkYTEgPSAxODApLCBwaGkwID0gLShwaGkxID0gOTApO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGVsdGFTdW0gPiBlcHNpbG9uKVxuICAgICAgICAgICAgICAgIHBoaTEgPSA5MDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGRlbHRhU3VtIDwgLWVwc2lsb24pXG4gICAgICAgICAgICAgICAgcGhpMCA9IC05MDtcbiAgICAgICAgICAgIHJhbmdlJDFbMF0gPSBsYW1iZGEwJDEsIHJhbmdlJDFbMV0gPSBsYW1iZGExO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBib3VuZHNQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgICByYW5nZXMucHVzaChyYW5nZSQxID0gW2xhbWJkYTAkMSA9IGxhbWJkYSwgbGFtYmRhMSA9IGxhbWJkYV0pO1xuICAgICAgICBpZiAocGhpIDwgcGhpMClcbiAgICAgICAgICAgIHBoaTAgPSBwaGk7XG4gICAgICAgIGlmIChwaGkgPiBwaGkxKVxuICAgICAgICAgICAgcGhpMSA9IHBoaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBwID0gY2FydGVzaWFuKFtsYW1iZGEgKiByYWRpYW5zLCBwaGkgKiByYWRpYW5zXSk7XG4gICAgICAgIGlmIChwMCkge1xuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IGNhcnRlc2lhbkNyb3NzKHAwLCBwKSwgZXF1YXRvcmlhbCA9IFtub3JtYWxbMV0sIC1ub3JtYWxbMF0sIDBdLCBpbmZsZWN0aW9uID0gY2FydGVzaWFuQ3Jvc3MoZXF1YXRvcmlhbCwgbm9ybWFsKTtcbiAgICAgICAgICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoaW5mbGVjdGlvbik7XG4gICAgICAgICAgICBpbmZsZWN0aW9uID0gc3BoZXJpY2FsKGluZmxlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gbGFtYmRhIC0gbGFtYmRhMiwgc2lnbiQkMSA9IGRlbHRhID4gMCA/IDEgOiAtMSwgbGFtYmRhaSA9IGluZmxlY3Rpb25bMF0gKiBkZWdyZWVzICogc2lnbiQkMSwgcGhpaSwgYW50aW1lcmlkaWFuID0gYWJzKGRlbHRhKSA+IDE4MDtcbiAgICAgICAgICAgIGlmIChhbnRpbWVyaWRpYW4gXiAoc2lnbiQkMSAqIGxhbWJkYTIgPCBsYW1iZGFpICYmIGxhbWJkYWkgPCBzaWduJCQxICogbGFtYmRhKSkge1xuICAgICAgICAgICAgICAgIHBoaWkgPSBpbmZsZWN0aW9uWzFdICogZGVncmVlcztcbiAgICAgICAgICAgICAgICBpZiAocGhpaSA+IHBoaTEpXG4gICAgICAgICAgICAgICAgICAgIHBoaTEgPSBwaGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGFtYmRhaSA9IChsYW1iZGFpICsgMzYwKSAlIDM2MCAtIDE4MCwgYW50aW1lcmlkaWFuIF4gKHNpZ24kJDEgKiBsYW1iZGEyIDwgbGFtYmRhaSAmJiBsYW1iZGFpIDwgc2lnbiQkMSAqIGxhbWJkYSkpIHtcbiAgICAgICAgICAgICAgICBwaGlpID0gLWluZmxlY3Rpb25bMV0gKiBkZWdyZWVzO1xuICAgICAgICAgICAgICAgIGlmIChwaGlpIDwgcGhpMClcbiAgICAgICAgICAgICAgICAgICAgcGhpMCA9IHBoaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGhpIDwgcGhpMClcbiAgICAgICAgICAgICAgICAgICAgcGhpMCA9IHBoaTtcbiAgICAgICAgICAgICAgICBpZiAocGhpID4gcGhpMSlcbiAgICAgICAgICAgICAgICAgICAgcGhpMSA9IHBoaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbnRpbWVyaWRpYW4pIHtcbiAgICAgICAgICAgICAgICBpZiAobGFtYmRhIDwgbGFtYmRhMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUobGFtYmRhMCQxLCBsYW1iZGEpID4gYW5nbGUobGFtYmRhMCQxLCBsYW1iZGExKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbWJkYTEgPSBsYW1iZGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUobGFtYmRhLCBsYW1iZGExKSA+IGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW1iZGEwJDEgPSBsYW1iZGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhbWJkYTEgPj0gbGFtYmRhMCQxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW1iZGEgPCBsYW1iZGEwJDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW1iZGEwJDEgPSBsYW1iZGE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW1iZGEgPiBsYW1iZGExKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFtYmRhMSA9IGxhbWJkYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW1iZGEgPiBsYW1iZGEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUobGFtYmRhMCQxLCBsYW1iZGEpID4gYW5nbGUobGFtYmRhMCQxLCBsYW1iZGExKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW1iZGExID0gbGFtYmRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYSwgbGFtYmRhMSkgPiBhbmdsZShsYW1iZGEwJDEsIGxhbWJkYTEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbWJkYTAkMSA9IGxhbWJkYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlJDEgPSBbbGFtYmRhMCQxID0gbGFtYmRhLCBsYW1iZGExID0gbGFtYmRhXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBoaSA8IHBoaTApXG4gICAgICAgICAgICBwaGkwID0gcGhpO1xuICAgICAgICBpZiAocGhpID4gcGhpMSlcbiAgICAgICAgICAgIHBoaTEgPSBwaGk7XG4gICAgICAgIHAwID0gcCwgbGFtYmRhMiA9IGxhbWJkYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm91bmRzTGluZVN0YXJ0KCkge1xuICAgICAgICBib3VuZHNTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJvdW5kc0xpbmVFbmQoKSB7XG4gICAgICAgIHJhbmdlJDFbMF0gPSBsYW1iZGEwJDEsIHJhbmdlJDFbMV0gPSBsYW1iZGExO1xuICAgICAgICBib3VuZHNTdHJlYW0ucG9pbnQgPSBib3VuZHNQb2ludDtcbiAgICAgICAgcDAgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBib3VuZHNSaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgaWYgKHAwKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBsYW1iZGEgLSBsYW1iZGEyO1xuICAgICAgICAgICAgZGVsdGFTdW0uYWRkKGFicyhkZWx0YSkgPiAxODAgPyBkZWx0YSArIChkZWx0YSA+IDAgPyAzNjAgOiAtMzYwKSA6IGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhbWJkYTAwJDEgPSBsYW1iZGEsIHBoaTAwJDEgPSBwaGk7XG4gICAgICAgIH1cbiAgICAgICAgYXJlYVN0cmVhbS5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgICAgIGxpbmVQb2ludChsYW1iZGEsIHBoaSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJvdW5kc1JpbmdTdGFydCgpIHtcbiAgICAgICAgYXJlYVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm91bmRzUmluZ0VuZCgpIHtcbiAgICAgICAgYm91bmRzUmluZ1BvaW50KGxhbWJkYTAwJDEsIHBoaTAwJDEpO1xuICAgICAgICBhcmVhU3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgaWYgKGFicyhkZWx0YVN1bSkgPiBlcHNpbG9uKVxuICAgICAgICAgICAgbGFtYmRhMCQxID0gLShsYW1iZGExID0gMTgwKTtcbiAgICAgICAgcmFuZ2UkMVswXSA9IGxhbWJkYTAkMSwgcmFuZ2UkMVsxXSA9IGxhbWJkYTE7XG4gICAgICAgIHAwID0gbnVsbDtcbiAgICB9XG4gICAgLy8gRmluZHMgdGhlIGxlZnQtcmlnaHQgZGlzdGFuY2UgYmV0d2VlbiB0d28gbG9uZ2l0dWRlcy5cbiAgICAvLyBUaGlzIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyAobGFtYmRhMSAtIGxhbWJkYTAgKyAzNjDCsCkgJSAzNjDCsCwgZXhjZXB0IHRoYXQgd2Ugd2FudFxuICAgIC8vIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIMKxMTgwwrAgdG8gYmUgMzYwwrAuXG4gICAgZnVuY3Rpb24gYW5nbGUobGFtYmRhMCwgbGFtYmRhMSkge1xuICAgICAgICByZXR1cm4gKGxhbWJkYTEgLT0gbGFtYmRhMCkgPCAwID8gbGFtYmRhMSArIDM2MCA6IGxhbWJkYTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhbmdlQ29tcGFyZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFuZ2VDb250YWlucyhyYW5nZSQkMSwgeCkge1xuICAgICAgICByZXR1cm4gcmFuZ2UkJDFbMF0gPD0gcmFuZ2UkJDFbMV0gPyByYW5nZSQkMVswXSA8PSB4ICYmIHggPD0gcmFuZ2UkJDFbMV0gOiB4IDwgcmFuZ2UkJDFbMF0gfHwgcmFuZ2UkJDFbMV0gPCB4O1xuICAgIH1cbiAgICB2YXIgYm91bmRzID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgdmFyIGksIG4sIGEsIGIsIG1lcmdlZCwgZGVsdGFNYXgsIGRlbHRhO1xuICAgICAgICBwaGkxID0gbGFtYmRhMSA9IC0obGFtYmRhMCQxID0gcGhpMCA9IEluZmluaXR5KTtcbiAgICAgICAgcmFuZ2VzID0gW107XG4gICAgICAgIGdlb1N0cmVhbShmZWF0dXJlLCBib3VuZHNTdHJlYW0pO1xuICAgICAgICAvLyBGaXJzdCwgc29ydCByYW5nZXMgYnkgdGhlaXIgbWluaW11bSBsb25naXR1ZGVzLlxuICAgICAgICBpZiAobiA9IHJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJhbmdlcy5zb3J0KHJhbmdlQ29tcGFyZSk7XG4gICAgICAgICAgICAvLyBUaGVuLCBtZXJnZSBhbnkgcmFuZ2VzIHRoYXQgb3ZlcmxhcC5cbiAgICAgICAgICAgIGZvciAoaSA9IDEsIGEgPSByYW5nZXNbMF0sIG1lcmdlZCA9IFthXTsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIGIgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlQ29udGFpbnMoYSwgYlswXSkgfHwgcmFuZ2VDb250YWlucyhhLCBiWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUoYVswXSwgYlsxXSkgPiBhbmdsZShhWzBdLCBhWzFdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFbMV0gPSBiWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUoYlswXSwgYVsxXSkgPiBhbmdsZShhWzBdLCBhWzFdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFbMF0gPSBiWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkLnB1c2goYSA9IGIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmFsbHksIGZpbmQgdGhlIGxhcmdlc3QgZ2FwIGJldHdlZW4gdGhlIG1lcmdlZCByYW5nZXMuXG4gICAgICAgICAgICAvLyBUaGUgZmluYWwgYm91bmRpbmcgYm94IHdpbGwgYmUgdGhlIGludmVyc2Ugb2YgdGhpcyBnYXAuXG4gICAgICAgICAgICBmb3IgKGRlbHRhTWF4ID0gLUluZmluaXR5LCBuID0gbWVyZ2VkLmxlbmd0aCAtIDEsIGkgPSAwLCBhID0gbWVyZ2VkW25dOyBpIDw9IG47IGEgPSBiLCArK2kpIHtcbiAgICAgICAgICAgICAgICBiID0gbWVyZ2VkW2ldO1xuICAgICAgICAgICAgICAgIGlmICgoZGVsdGEgPSBhbmdsZShhWzFdLCBiWzBdKSkgPiBkZWx0YU1heClcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFNYXggPSBkZWx0YSwgbGFtYmRhMCQxID0gYlswXSwgbGFtYmRhMSA9IGFbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2VzID0gcmFuZ2UkMSA9IG51bGw7XG4gICAgICAgIHJldHVybiBsYW1iZGEwJDEgPT09IEluZmluaXR5IHx8IHBoaTAgPT09IEluZmluaXR5XG4gICAgICAgICAgICA/IFtbTmFOLCBOYU5dLCBbTmFOLCBOYU5dXVxuICAgICAgICAgICAgOiBbW2xhbWJkYTAkMSwgcGhpMF0sIFtsYW1iZGExLCBwaGkxXV07XG4gICAgfTtcbiAgICB2YXIgVzA7XG4gICAgdmFyIFcxO1xuICAgIHZhciBYMDtcbiAgICB2YXIgWTA7XG4gICAgdmFyIFowO1xuICAgIHZhciBYMTtcbiAgICB2YXIgWTE7XG4gICAgdmFyIFoxO1xuICAgIHZhciBYMjtcbiAgICB2YXIgWTI7XG4gICAgdmFyIFoyO1xuICAgIHZhciBsYW1iZGEwMCQyO1xuICAgIHZhciBwaGkwMCQyO1xuICAgIHZhciB4MDtcbiAgICB2YXIgeTA7XG4gICAgdmFyIHowOyAvLyBwcmV2aW91cyBwb2ludFxuICAgIHZhciBjZW50cm9pZFN0cmVhbSA9IHtcbiAgICAgICAgc3BoZXJlOiBub29wLFxuICAgICAgICBwb2ludDogY2VudHJvaWRQb2ludCxcbiAgICAgICAgbGluZVN0YXJ0OiBjZW50cm9pZExpbmVTdGFydCxcbiAgICAgICAgbGluZUVuZDogY2VudHJvaWRMaW5lRW5kLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVTdGFydCA9IGNlbnRyb2lkUmluZ1N0YXJ0O1xuICAgICAgICAgICAgY2VudHJvaWRTdHJlYW0ubGluZUVuZCA9IGNlbnRyb2lkUmluZ0VuZDtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2VudHJvaWRTdHJlYW0ubGluZVN0YXJ0ID0gY2VudHJvaWRMaW5lU3RhcnQ7XG4gICAgICAgICAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRMaW5lRW5kO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBBcml0aG1ldGljIG1lYW4gb2YgQ2FydGVzaWFuIHZlY3RvcnMuXG4gICAgZnVuY3Rpb24gY2VudHJvaWRQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gICAgICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgICAgICAgY2VudHJvaWRQb2ludENhcnRlc2lhbihjb3NQaGkgKiBjb3MobGFtYmRhKSwgY29zUGhpICogc2luKGxhbWJkYSksIHNpbihwaGkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRQb2ludENhcnRlc2lhbih4LCB5LCB6KSB7XG4gICAgICAgICsrVzA7XG4gICAgICAgIFgwICs9ICh4IC0gWDApIC8gVzA7XG4gICAgICAgIFkwICs9ICh5IC0gWTApIC8gVzA7XG4gICAgICAgIFowICs9ICh6IC0gWjApIC8gVzA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkTGluZVN0YXJ0KCkge1xuICAgICAgICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkTGluZVBvaW50Rmlyc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkTGluZVBvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICAgICAgICB2YXIgY29zUGhpID0gY29zKHBoaSk7XG4gICAgICAgIHgwID0gY29zUGhpICogY29zKGxhbWJkYSk7XG4gICAgICAgIHkwID0gY29zUGhpICogc2luKGxhbWJkYSk7XG4gICAgICAgIHowID0gc2luKHBoaSk7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRMaW5lUG9pbnQ7XG4gICAgICAgIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkTGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgICAgICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLCB4ID0gY29zUGhpICogY29zKGxhbWJkYSksIHkgPSBjb3NQaGkgKiBzaW4obGFtYmRhKSwgeiA9IHNpbihwaGkpLCB3ID0gYXRhbjIoc3FydCgodyA9IHkwICogeiAtIHowICogeSkgKiB3ICsgKHcgPSB6MCAqIHggLSB4MCAqIHopICogdyArICh3ID0geDAgKiB5IC0geTAgKiB4KSAqIHcpLCB4MCAqIHggKyB5MCAqIHkgKyB6MCAqIHopO1xuICAgICAgICBXMSArPSB3O1xuICAgICAgICBYMSArPSB3ICogKHgwICsgKHgwID0geCkpO1xuICAgICAgICBZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICAgICAgICBaMSArPSB3ICogKHowICsgKHowID0geikpO1xuICAgICAgICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZExpbmVFbmQoKSB7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbiAgICB9XG4gICAgLy8gU2VlIEouIEUuIEJyb2NrLCBUaGUgSW5lcnRpYSBUZW5zb3IgZm9yIGEgU3BoZXJpY2FsIFRyaWFuZ2xlLFxuICAgIC8vIEouIEFwcGxpZWQgTWVjaGFuaWNzIDQyLCAyMzkgKDE5NzUpLlxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkUmluZ1N0YXJ0KCkge1xuICAgICAgICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUmluZ1BvaW50Rmlyc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkUmluZ0VuZCgpIHtcbiAgICAgICAgY2VudHJvaWRSaW5nUG9pbnQobGFtYmRhMDAkMiwgcGhpMDAkMik7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRSaW5nUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xuICAgICAgICBsYW1iZGEwMCQyID0gbGFtYmRhLCBwaGkwMCQyID0gcGhpO1xuICAgICAgICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRSaW5nUG9pbnQ7XG4gICAgICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgICAgICAgeDAgPSBjb3NQaGkgKiBjb3MobGFtYmRhKTtcbiAgICAgICAgeTAgPSBjb3NQaGkgKiBzaW4obGFtYmRhKTtcbiAgICAgICAgejAgPSBzaW4ocGhpKTtcbiAgICAgICAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRSaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICAgICAgICB2YXIgY29zUGhpID0gY29zKHBoaSksIHggPSBjb3NQaGkgKiBjb3MobGFtYmRhKSwgeSA9IGNvc1BoaSAqIHNpbihsYW1iZGEpLCB6ID0gc2luKHBoaSksIGN4ID0geTAgKiB6IC0gejAgKiB5LCBjeSA9IHowICogeCAtIHgwICogeiwgY3ogPSB4MCAqIHkgLSB5MCAqIHgsIG0gPSBzcXJ0KGN4ICogY3ggKyBjeSAqIGN5ICsgY3ogKiBjeiksIHcgPSBhc2luKG0pLCAvLyBsaW5lIHdlaWdodCA9IGFuZ2xlXG4gICAgICAgIHYgPSBtICYmIC13IC8gbTsgLy8gYXJlYSB3ZWlnaHQgbXVsdGlwbGllclxuICAgICAgICBYMiArPSB2ICogY3g7XG4gICAgICAgIFkyICs9IHYgKiBjeTtcbiAgICAgICAgWjIgKz0gdiAqIGN6O1xuICAgICAgICBXMSArPSB3O1xuICAgICAgICBYMSArPSB3ICogKHgwICsgKHgwID0geCkpO1xuICAgICAgICBZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICAgICAgICBaMSArPSB3ICogKHowICsgKHowID0geikpO1xuICAgICAgICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xuICAgIH1cbiAgICB2YXIgY2VudHJvaWQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIFcwID0gVzEgPVxuICAgICAgICAgICAgWDAgPSBZMCA9IFowID1cbiAgICAgICAgICAgICAgICBYMSA9IFkxID0gWjEgPVxuICAgICAgICAgICAgICAgICAgICBYMiA9IFkyID0gWjIgPSAwO1xuICAgICAgICBnZW9TdHJlYW0ob2JqZWN0LCBjZW50cm9pZFN0cmVhbSk7XG4gICAgICAgIHZhciB4ID0gWDIsIHkgPSBZMiwgeiA9IFoyLCBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICAgICAgICAvLyBJZiB0aGUgYXJlYS13ZWlnaHRlZCBjY2VudHJvaWQgaXMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbGVuZ3RoLXdlaWdodGVkIGNjZW50cm9pZC5cbiAgICAgICAgaWYgKG0gPCBlcHNpbG9uMikge1xuICAgICAgICAgICAgeCA9IFgxLCB5ID0gWTEsIHogPSBaMTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmZWF0dXJlIGhhcyB6ZXJvIGxlbmd0aCwgZmFsbCBiYWNrIHRvIGFyaXRobWV0aWMgbWVhbiBvZiBwb2ludCB2ZWN0b3JzLlxuICAgICAgICAgICAgaWYgKFcxIDwgZXBzaWxvbilcbiAgICAgICAgICAgICAgICB4ID0gWDAsIHkgPSBZMCwgeiA9IFowO1xuICAgICAgICAgICAgbSA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmZWF0dXJlIHN0aWxsIGhhcyBhbiB1bmRlZmluZWQgY2NlbnRyb2lkLCB0aGVuIHJldHVybi5cbiAgICAgICAgICAgIGlmIChtIDwgZXBzaWxvbjIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtOYU4sIE5hTl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFthdGFuMih5LCB4KSAqIGRlZ3JlZXMsIGFzaW4oeiAvIHNxcnQobSkpICogZGVncmVlc107XG4gICAgfTtcbiAgICB2YXIgY29uc3RhbnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgY29tcG9zZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBvc2UoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHggPSBhKHgsIHkpLCBiKHhbMF0sIHhbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmludmVydCAmJiBiLmludmVydClcbiAgICAgICAgICAgIGNvbXBvc2UuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geCA9IGIuaW52ZXJ0KHgsIHkpLCB4ICYmIGEuaW52ZXJ0KHhbMF0sIHhbMV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2U7XG4gICAgfTtcbiAgICBmdW5jdGlvbiByb3RhdGlvbklkZW50aXR5KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJldHVybiBbbGFtYmRhID4gcGkgPyBsYW1iZGEgLSB0YXUgOiBsYW1iZGEgPCAtcGkgPyBsYW1iZGEgKyB0YXUgOiBsYW1iZGEsIHBoaV07XG4gICAgfVxuICAgIHJvdGF0aW9uSWRlbnRpdHkuaW52ZXJ0ID0gcm90YXRpb25JZGVudGl0eTtcbiAgICBmdW5jdGlvbiByb3RhdGVSYWRpYW5zKGRlbHRhTGFtYmRhLCBkZWx0YVBoaSwgZGVsdGFHYW1tYSkge1xuICAgICAgICByZXR1cm4gKGRlbHRhTGFtYmRhICU9IHRhdSkgPyAoZGVsdGFQaGkgfHwgZGVsdGFHYW1tYSA/IGNvbXBvc2Uocm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpLCByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKSlcbiAgICAgICAgICAgIDogcm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpKVxuICAgICAgICAgICAgOiAoZGVsdGFQaGkgfHwgZGVsdGFHYW1tYSA/IHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpXG4gICAgICAgICAgICAgICAgOiByb3RhdGlvbklkZW50aXR5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW1iZGEgKz0gZGVsdGFMYW1iZGEsIFtsYW1iZGEgPiBwaSA/IGxhbWJkYSAtIHRhdSA6IGxhbWJkYSA8IC1waSA/IGxhbWJkYSArIHRhdSA6IGxhbWJkYSwgcGhpXTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKTtcbiAgICAgICAgcm90YXRpb24uaW52ZXJ0ID0gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKC1kZWx0YUxhbWJkYSk7XG4gICAgICAgIHJldHVybiByb3RhdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcm90YXRpb25QaGlHYW1tYShkZWx0YVBoaSwgZGVsdGFHYW1tYSkge1xuICAgICAgICB2YXIgY29zRGVsdGFQaGkgPSBjb3MoZGVsdGFQaGkpLCBzaW5EZWx0YVBoaSA9IHNpbihkZWx0YVBoaSksIGNvc0RlbHRhR2FtbWEgPSBjb3MoZGVsdGFHYW1tYSksIHNpbkRlbHRhR2FtbWEgPSBzaW4oZGVsdGFHYW1tYSk7XG4gICAgICAgIGZ1bmN0aW9uIHJvdGF0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICB2YXIgY29zUGhpID0gY29zKHBoaSksIHggPSBjb3MobGFtYmRhKSAqIGNvc1BoaSwgeSA9IHNpbihsYW1iZGEpICogY29zUGhpLCB6ID0gc2luKHBoaSksIGsgPSB6ICogY29zRGVsdGFQaGkgKyB4ICogc2luRGVsdGFQaGk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGF0YW4yKHkgKiBjb3NEZWx0YUdhbW1hIC0gayAqIHNpbkRlbHRhR2FtbWEsIHggKiBjb3NEZWx0YVBoaSAtIHogKiBzaW5EZWx0YVBoaSksXG4gICAgICAgICAgICAgICAgYXNpbihrICogY29zRGVsdGFHYW1tYSArIHkgKiBzaW5EZWx0YUdhbW1hKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByb3RhdGlvbi5pbnZlcnQgPSBmdW5jdGlvbiAobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKSwgeCA9IGNvcyhsYW1iZGEpICogY29zUGhpLCB5ID0gc2luKGxhbWJkYSkgKiBjb3NQaGksIHogPSBzaW4ocGhpKSwgayA9IHogKiBjb3NEZWx0YUdhbW1hIC0geSAqIHNpbkRlbHRhR2FtbWE7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGF0YW4yKHkgKiBjb3NEZWx0YUdhbW1hICsgeiAqIHNpbkRlbHRhR2FtbWEsIHggKiBjb3NEZWx0YVBoaSArIGsgKiBzaW5EZWx0YVBoaSksXG4gICAgICAgICAgICAgICAgYXNpbihrICogY29zRGVsdGFQaGkgLSB4ICogc2luRGVsdGFQaGkpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcm90YXRpb247XG4gICAgfVxuICAgIHZhciByb3RhdGlvbiA9IGZ1bmN0aW9uIChyb3RhdGUpIHtcbiAgICAgICAgcm90YXRlID0gcm90YXRlUmFkaWFucyhyb3RhdGVbMF0gKiByYWRpYW5zLCByb3RhdGVbMV0gKiByYWRpYW5zLCByb3RhdGUubGVuZ3RoID4gMiA/IHJvdGF0ZVsyXSAqIHJhZGlhbnMgOiAwKTtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChjb29yZGluYXRlcykge1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMgPSByb3RhdGUoY29vcmRpbmF0ZXNbMF0gKiByYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIHJhZGlhbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICBjb29yZGluYXRlcyA9IHJvdGF0ZS5pbnZlcnQoY29vcmRpbmF0ZXNbMF0gKiByYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIHJhZGlhbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9O1xuICAgIC8vIEdlbmVyYXRlcyBhIGNpcmNsZSBjZW50ZXJlZCBhdCBbMMKwLCAwwrBdLCB3aXRoIGEgZ2l2ZW4gcmFkaXVzIGFuZCBwcmVjaXNpb24uXG4gICAgZnVuY3Rpb24gY2lyY2xlU3RyZWFtKHN0cmVhbSwgcmFkaXVzLCBkZWx0YSwgZGlyZWN0aW9uLCB0MCwgdDEpIHtcbiAgICAgICAgaWYgKCFkZWx0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGNvc1JhZGl1cyA9IGNvcyhyYWRpdXMpLCBzaW5SYWRpdXMgPSBzaW4ocmFkaXVzKSwgc3RlcCA9IGRpcmVjdGlvbiAqIGRlbHRhO1xuICAgICAgICBpZiAodDAgPT0gbnVsbCkge1xuICAgICAgICAgICAgdDAgPSByYWRpdXMgKyBkaXJlY3Rpb24gKiB0YXU7XG4gICAgICAgICAgICB0MSA9IHJhZGl1cyAtIHN0ZXAgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdDAgPSBjaXJjbGVSYWRpdXMoY29zUmFkaXVzLCB0MCk7XG4gICAgICAgICAgICB0MSA9IGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHQxKTtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPiAwID8gdDAgPCB0MSA6IHQwID4gdDEpXG4gICAgICAgICAgICAgICAgdDAgKz0gZGlyZWN0aW9uICogdGF1O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHBvaW50LCB0ID0gdDA7IGRpcmVjdGlvbiA+IDAgPyB0ID4gdDEgOiB0IDwgdDE7IHQgLT0gc3RlcCkge1xuICAgICAgICAgICAgcG9pbnQgPSBzcGhlcmljYWwoW2Nvc1JhZGl1cywgLXNpblJhZGl1cyAqIGNvcyh0KSwgLXNpblJhZGl1cyAqIHNpbih0KV0pO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgc2lnbmVkIGFuZ2xlIG9mIGEgY2FydGVzaWFuIHBvaW50IHJlbGF0aXZlIHRvIFtjb3NSYWRpdXMsIDAsIDBdLlxuICAgIGZ1bmN0aW9uIGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHBvaW50KSB7XG4gICAgICAgIHBvaW50ID0gY2FydGVzaWFuKHBvaW50KSwgcG9pbnRbMF0gLT0gY29zUmFkaXVzO1xuICAgICAgICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKHBvaW50KTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IGFjb3MoLXBvaW50WzFdKTtcbiAgICAgICAgcmV0dXJuICgoLXBvaW50WzJdIDwgMCA/IC1yYWRpdXMgOiByYWRpdXMpICsgdGF1IC0gZXBzaWxvbikgJSB0YXU7XG4gICAgfVxuICAgIHZhciBjaXJjbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSBjb25zdGFudChbMCwgMF0pLCByYWRpdXMgPSBjb25zdGFudCg5MCksIHByZWNpc2lvbiA9IGNvbnN0YW50KDYpLCByaW5nLCByb3RhdGUsIHN0cmVhbSA9IHsgcG9pbnQ6IHBvaW50IH07XG4gICAgICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgICAgICAgIHJpbmcucHVzaCh4ID0gcm90YXRlKHgsIHkpKTtcbiAgICAgICAgICAgIHhbMF0gKj0gZGVncmVlcywgeFsxXSAqPSBkZWdyZWVzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNpcmNsZSgpIHtcbiAgICAgICAgICAgIHZhciBjID0gY2VudGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHIgPSByYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIHJhZGlhbnMsIHAgPSBwcmVjaXNpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIHJhZGlhbnM7XG4gICAgICAgICAgICByaW5nID0gW107XG4gICAgICAgICAgICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKC1jWzBdICogcmFkaWFucywgLWNbMV0gKiByYWRpYW5zLCAwKS5pbnZlcnQ7XG4gICAgICAgICAgICBjaXJjbGVTdHJlYW0oc3RyZWFtLCByLCBwLCAxKTtcbiAgICAgICAgICAgIGMgPSB7IHR5cGU6IFwiUG9seWdvblwiLCBjb29yZGluYXRlczogW3JpbmddIH07XG4gICAgICAgICAgICByaW5nID0gcm90YXRlID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9XG4gICAgICAgIGNpcmNsZS5jZW50ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2VudGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbK19bMF0sICtfWzFdXSksIGNpcmNsZSkgOiBjZW50ZXI7XG4gICAgICAgIH07XG4gICAgICAgIGNpcmNsZS5yYWRpdXMgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGNpcmNsZSkgOiByYWRpdXM7XG4gICAgICAgIH07XG4gICAgICAgIGNpcmNsZS5wcmVjaXNpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2lzaW9uID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGNpcmNsZSkgOiBwcmVjaXNpb247XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgfTtcbiAgICB2YXIgY2xpcEJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gW10sIGxpbmU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICBsaW5lLnB1c2goW3gsIHldKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUgPSBbXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZUVuZDogbm9vcCxcbiAgICAgICAgICAgIHJlam9pbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmVzLnBvcCgpLmNvbmNhdChsaW5lcy5zaGlmdCgpKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGxpbmVzO1xuICAgICAgICAgICAgICAgIGxpbmVzID0gW107XG4gICAgICAgICAgICAgICAgbGluZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBjbGlwTGluZSA9IGZ1bmN0aW9uIChhLCBiLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCB0MCA9IDAsIHQxID0gMSwgZHggPSBieCAtIGF4LCBkeSA9IGJ5IC0gYXksIHI7XG4gICAgICAgIHIgPSB4MCAtIGF4O1xuICAgICAgICBpZiAoIWR4ICYmIHIgPiAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByIC89IGR4O1xuICAgICAgICBpZiAoZHggPCAwKSB7XG4gICAgICAgICAgICBpZiAociA8IHQwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyIDwgdDEpXG4gICAgICAgICAgICAgICAgdDEgPSByO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgICAgICAgaWYgKHIgPiB0MSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAociA+IHQwKVxuICAgICAgICAgICAgICAgIHQwID0gcjtcbiAgICAgICAgfVxuICAgICAgICByID0geDEgLSBheDtcbiAgICAgICAgaWYgKCFkeCAmJiByIDwgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgciAvPSBkeDtcbiAgICAgICAgaWYgKGR4IDwgMCkge1xuICAgICAgICAgICAgaWYgKHIgPiB0MSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAociA+IHQwKVxuICAgICAgICAgICAgICAgIHQwID0gcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkeCA+IDApIHtcbiAgICAgICAgICAgIGlmIChyIDwgdDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHIgPCB0MSlcbiAgICAgICAgICAgICAgICB0MSA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgciA9IHkwIC0gYXk7XG4gICAgICAgIGlmICghZHkgJiYgciA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHIgLz0gZHk7XG4gICAgICAgIGlmIChkeSA8IDApIHtcbiAgICAgICAgICAgIGlmIChyIDwgdDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHIgPCB0MSlcbiAgICAgICAgICAgICAgICB0MSA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgICAgICAgICBpZiAociA+IHQxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyID4gdDApXG4gICAgICAgICAgICAgICAgdDAgPSByO1xuICAgICAgICB9XG4gICAgICAgIHIgPSB5MSAtIGF5O1xuICAgICAgICBpZiAoIWR5ICYmIHIgPCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByIC89IGR5O1xuICAgICAgICBpZiAoZHkgPCAwKSB7XG4gICAgICAgICAgICBpZiAociA+IHQxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyID4gdDApXG4gICAgICAgICAgICAgICAgdDAgPSByO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR5ID4gMCkge1xuICAgICAgICAgICAgaWYgKHIgPCB0MClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAociA8IHQxKVxuICAgICAgICAgICAgICAgIHQxID0gcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodDAgPiAwKVxuICAgICAgICAgICAgYVswXSA9IGF4ICsgdDAgKiBkeCwgYVsxXSA9IGF5ICsgdDAgKiBkeTtcbiAgICAgICAgaWYgKHQxIDwgMSlcbiAgICAgICAgICAgIGJbMF0gPSBheCArIHQxICogZHgsIGJbMV0gPSBheSArIHQxICogZHk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgdmFyIHBvaW50RXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYWJzKGFbMF0gLSBiWzBdKSA8IGVwc2lsb24gJiYgYWJzKGFbMV0gLSBiWzFdKSA8IGVwc2lsb247XG4gICAgfTtcbiAgICBmdW5jdGlvbiBJbnRlcnNlY3Rpb24ocG9pbnQsIHBvaW50cywgb3RoZXIsIGVudHJ5KSB7XG4gICAgICAgIHRoaXMueCA9IHBvaW50O1xuICAgICAgICB0aGlzLnogPSBwb2ludHM7XG4gICAgICAgIHRoaXMubyA9IG90aGVyOyAvLyBhbm90aGVyIGludGVyc2VjdGlvblxuICAgICAgICB0aGlzLmUgPSBlbnRyeTsgLy8gaXMgYW4gZW50cnk/XG4gICAgICAgIHRoaXMudiA9IGZhbHNlOyAvLyB2aXNpdGVkXG4gICAgICAgIHRoaXMubiA9IHRoaXMucCA9IG51bGw7IC8vIG5leHQgJiBwcmV2aW91c1xuICAgIH1cbiAgICAvLyBBIGdlbmVyYWxpemVkIHBvbHlnb24gY2xpcHBpbmcgYWxnb3JpdGhtOiBnaXZlbiBhIHBvbHlnb24gdGhhdCBoYXMgYmVlbiBjdXRcbiAgICAvLyBpbnRvIGl0cyB2aXNpYmxlIGxpbmUgc2VnbWVudHMsIGFuZCByZWpvaW5zIHRoZSBzZWdtZW50cyBieSBpbnRlcnBvbGF0aW5nXG4gICAgLy8gYWxvbmcgdGhlIGNsaXAgZWRnZS5cbiAgICB2YXIgY2xpcFBvbHlnb24gPSBmdW5jdGlvbiAoc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc3RyZWFtKSB7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gW10sIGNsaXAgPSBbXSwgaSwgbjtcbiAgICAgICAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgICAgICAgaWYgKChuID0gc2VnbWVudC5sZW5ndGggLSAxKSA8PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBuLCBwMCA9IHNlZ21lbnRbMF0sIHAxID0gc2VnbWVudFtuXSwgeDtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHMgb2YgYSBzZWdtZW50IGFyZSBjb2luY2lkZW50LCB0aGVuIHRyZWF0IGFzIGFcbiAgICAgICAgICAgIC8vIGNsb3NlZCByaW5nLiBUT0RPIGlmIGFsbCByaW5ncyBhcmUgY2xvc2VkLCB0aGVuIHRoZSB3aW5kaW5nIG9yZGVyIG9mIHRoZVxuICAgICAgICAgICAgLy8gZXh0ZXJpb3IgcmluZyBzaG91bGQgYmUgY2hlY2tlZC5cbiAgICAgICAgICAgIGlmIChwb2ludEVxdWFsKHAwLCBwMSkpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSlcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KChwMCA9IHNlZ21lbnRbaV0pWzBdLCBwMFsxXSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJqZWN0LnB1c2goeCA9IG5ldyBJbnRlcnNlY3Rpb24ocDAsIHNlZ21lbnQsIG51bGwsIHRydWUpKTtcbiAgICAgICAgICAgIGNsaXAucHVzaCh4Lm8gPSBuZXcgSW50ZXJzZWN0aW9uKHAwLCBudWxsLCB4LCBmYWxzZSkpO1xuICAgICAgICAgICAgc3ViamVjdC5wdXNoKHggPSBuZXcgSW50ZXJzZWN0aW9uKHAxLCBzZWdtZW50LCBudWxsLCBmYWxzZSkpO1xuICAgICAgICAgICAgY2xpcC5wdXNoKHgubyA9IG5ldyBJbnRlcnNlY3Rpb24ocDEsIG51bGwsIHgsIHRydWUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc3ViamVjdC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNsaXAuc29ydChjb21wYXJlSW50ZXJzZWN0aW9uKTtcbiAgICAgICAgbGluayhzdWJqZWN0KTtcbiAgICAgICAgbGluayhjbGlwKTtcbiAgICAgICAgZm9yIChpID0gMCwgbiA9IGNsaXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBjbGlwW2ldLmUgPSBzdGFydEluc2lkZSA9ICFzdGFydEluc2lkZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSBzdWJqZWN0WzBdLCBwb2ludHMsIHBvaW50O1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgLy8gRmluZCBmaXJzdCB1bnZpc2l0ZWQgaW50ZXJzZWN0aW9uLlxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBzdGFydCwgaXNTdWJqZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50LnYpXG4gICAgICAgICAgICAgICAgaWYgKChjdXJyZW50ID0gY3VycmVudC5uKSA9PT0gc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHBvaW50cyA9IGN1cnJlbnQuejtcbiAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnYgPSBjdXJyZW50Lm8udiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aDsgaSA8IG47ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50Lm4ueCwgMSwgc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gY3VycmVudC5wLno7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5wLngsIC0xLCBzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm87XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgICAgICAgICAgICAgIGlzU3ViamVjdCA9ICFpc1N1YmplY3Q7XG4gICAgICAgICAgICB9IHdoaWxlICghY3VycmVudC52KTtcbiAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxpbmsoYXJyYXkpIHtcbiAgICAgICAgaWYgKCEobiA9IGFycmF5Lmxlbmd0aCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBuLCBpID0gMCwgYSA9IGFycmF5WzBdLCBiO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgYS5uID0gYiA9IGFycmF5W2ldO1xuICAgICAgICAgICAgYi5wID0gYTtcbiAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICB9XG4gICAgICAgIGEubiA9IGIgPSBhcnJheVswXTtcbiAgICAgICAgYi5wID0gYTtcbiAgICB9XG4gICAgdmFyIGNsaXBNYXggPSAxZTk7XG4gICAgdmFyIGNsaXBNaW4gPSAtY2xpcE1heDtcbiAgICAvLyBUT0RPIFVzZSBkMy1wb2x5Z29u4oCZcyBwb2x5Z29uQ29udGFpbnMgaGVyZSBmb3IgdGhlIHJpbmcgY2hlY2s/XG4gICAgLy8gVE9ETyBFbGltaW5hdGUgZHVwbGljYXRlIGJ1ZmZlcmluZyBpbiBjbGlwQnVmZmVyIGFuZCBwb2x5Z29uLnB1c2g/XG4gICAgZnVuY3Rpb24gY2xpcEV4dGVudCh4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgICBmdW5jdGlvbiB2aXNpYmxlKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB4MCA8PSB4ICYmIHggPD0geDEgJiYgeTAgPD0geSAmJiB5IDw9IHkxO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIGEgPSAwLCBhMSA9IDA7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PSBudWxsXG4gICAgICAgICAgICAgICAgfHwgKGEgPSBjb3JuZXIoZnJvbSwgZGlyZWN0aW9uKSkgIT09IChhMSA9IGNvcm5lcih0bywgZGlyZWN0aW9uKSlcbiAgICAgICAgICAgICAgICB8fCBjb21wYXJlUG9pbnQoZnJvbSwgdG8pIDwgMCBeIGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQoYSA9PT0gMCB8fCBhID09PSAzID8geDAgOiB4MSwgYSA+IDEgPyB5MSA6IHkwKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGEgPSAoYSArIGRpcmVjdGlvbiArIDQpICUgNCkgIT09IGExKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0b1swXSwgdG9bMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvcm5lcihwLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBhYnMocFswXSAtIHgwKSA8IGVwc2lsb24gPyBkaXJlY3Rpb24gPiAwID8gMCA6IDNcbiAgICAgICAgICAgICAgICA6IGFicyhwWzBdIC0geDEpIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAyIDogMVxuICAgICAgICAgICAgICAgICAgICA6IGFicyhwWzFdIC0geTApIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAxIDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBkaXJlY3Rpb24gPiAwID8gMyA6IDI7IC8vIGFicyhwWzFdIC0geTEpIDwgZXBzaWxvblxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBhcmVJbnRlcnNlY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVQb2ludChhLngsIGIueCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZVBvaW50KGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBjYSA9IGNvcm5lcihhLCAxKSwgY2IgPSBjb3JuZXIoYiwgMSk7XG4gICAgICAgICAgICByZXR1cm4gY2EgIT09IGNiID8gY2EgLSBjYlxuICAgICAgICAgICAgICAgIDogY2EgPT09IDAgPyBiWzFdIC0gYVsxXVxuICAgICAgICAgICAgICAgICAgICA6IGNhID09PSAxID8gYVswXSAtIGJbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogY2EgPT09IDIgPyBhWzFdIC0gYlsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYlswXSAtIGFbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBhY3RpdmVTdHJlYW0gPSBzdHJlYW0sIGJ1ZmZlclN0cmVhbSA9IGNsaXBCdWZmZXIoKSwgc2VnbWVudHMsIHBvbHlnb24sIHJpbmcsIHhfXywgeV9fLCB2X18sIC8vIGZpcnN0IHBvaW50XG4gICAgICAgICAgICB4XywgeV8sIHZfLCAvLyBwcmV2aW91cyBwb2ludFxuICAgICAgICAgICAgZmlyc3QsIGNsZWFuO1xuICAgICAgICAgICAgdmFyIGNsaXBTdHJlYW0gPSB7XG4gICAgICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICAgICAgICAgICAgcG9seWdvblN0YXJ0OiBwb2x5Z29uU3RhcnQsXG4gICAgICAgICAgICAgICAgcG9seWdvbkVuZDogcG9seWdvbkVuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlzaWJsZSh4LCB5KSlcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcG9seWdvbkluc2lkZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2luZGluZyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByaW5nID0gcG9seWdvbltpXSwgaiA9IDEsIG0gPSByaW5nLmxlbmd0aCwgcG9pbnQgPSByaW5nWzBdLCBhMCwgYTEsIGIwID0gcG9pbnRbMF0sIGIxID0gcG9pbnRbMV07IGogPCBtOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEwID0gYjAsIGExID0gYjEsIHBvaW50ID0gcmluZ1tqXSwgYjAgPSBwb2ludFswXSwgYjEgPSBwb2ludFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhMSA8PSB5MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiMSA+IHkxICYmIChiMCAtIGEwKSAqICh5MSAtIGExKSA+IChiMSAtIGExKSAqICh4MCAtIGEwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt3aW5kaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIxIDw9IHkxICYmIChiMCAtIGEwKSAqICh5MSAtIGExKSA8IChiMSAtIGExKSAqICh4MCAtIGEwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS13aW5kaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQnVmZmVyIGdlb21ldHJ5IHdpdGhpbiBhIHBvbHlnb24gYW5kIHRoZW4gY2xpcCBpdCBlbiBtYXNzZS5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBvbHlnb25TdGFydCgpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0gPSBidWZmZXJTdHJlYW0sIHNlZ21lbnRzID0gW10sIHBvbHlnb24gPSBbXSwgY2xlYW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcG9seWdvbkVuZCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbnNpZGUgPSBwb2x5Z29uSW5zaWRlKCksIGNsZWFuSW5zaWRlID0gY2xlYW4gJiYgc3RhcnRJbnNpZGUsIHZpc2libGUgPSAoc2VnbWVudHMgPSBkM0FycmF5Lm1lcmdlKHNlZ21lbnRzKSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjbGVhbkluc2lkZSB8fCB2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsZWFuSW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBvbHlnb24oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0gPSBzdHJlYW0sIHNlZ21lbnRzID0gcG9seWdvbiA9IHJpbmcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgICAgICAgICAgIGNsaXBTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvbHlnb24pXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb24ucHVzaChyaW5nID0gW10pO1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2XyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHhfID0geV8gPSBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPIHJhdGhlciB0aGFuIHNwZWNpYWwtY2FzZSBwb2x5Z29ucywgc2ltcGx5IGhhbmRsZSB0aGVtIHNlcGFyYXRlbHkuXG4gICAgICAgICAgICAvLyBJZGVhbGx5LCBjb2luY2lkZW50IGludGVyc2VjdGlvbiBwb2ludHMgc2hvdWxkIGJlIGppdHRlcmVkIHRvIGF2b2lkXG4gICAgICAgICAgICAvLyBjbGlwcGluZyBpc3N1ZXMuXG4gICAgICAgICAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lUG9pbnQoeF9fLCB5X18pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodl9fICYmIHZfKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyU3RyZWFtLnJlam9pbigpO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKGJ1ZmZlclN0cmVhbS5yZXN1bHQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsaXBTdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgICAgICAgICAgICBpZiAodl8pXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBsaW5lUG9pbnQoeCwgeSkge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gdmlzaWJsZSh4LCB5KTtcbiAgICAgICAgICAgICAgICBpZiAocG9seWdvbilcbiAgICAgICAgICAgICAgICAgICAgcmluZy5wdXNoKFt4LCB5XSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHhfXyA9IHgsIHlfXyA9IHksIHZfXyA9IHY7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICYmIHZfKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gW3hfID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeF8pKSwgeV8gPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB5XykpXSwgYiA9IFt4ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeCkpLCB5ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeSkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGlwTGluZShhLCBiLCB4MCwgeTAsIHgxLCB5MSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KGFbMF0sIGFbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoYlswXSwgYlsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHhfID0geCwgeV8gPSB5LCB2XyA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xpcFN0cmVhbTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGV4dGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHgwID0gMCwgeTAgPSAwLCB4MSA9IDk2MCwgeTEgPSA1MDAsIGNhY2hlLCBjYWNoZVN0cmVhbSwgY2xpcDtcbiAgICAgICAgcmV0dXJuIGNsaXAgPSB7XG4gICAgICAgICAgICBzdHJlYW06IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBjbGlwRXh0ZW50KHgwLCB5MCwgeDEsIHkxKShjYWNoZVN0cmVhbSA9IHN0cmVhbSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXh0ZW50OiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0sIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsLCBjbGlwKSA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIHN1bSA9IGFkZGVyKCk7XG4gICAgdmFyIHBvbHlnb25Db250YWlucyA9IGZ1bmN0aW9uIChwb2x5Z29uLCBwb2ludCkge1xuICAgICAgICB2YXIgbGFtYmRhID0gcG9pbnRbMF0sIHBoaSA9IHBvaW50WzFdLCBub3JtYWwgPSBbc2luKGxhbWJkYSksIC1jb3MobGFtYmRhKSwgMF0sIGFuZ2xlID0gMCwgd2luZGluZyA9IDA7XG4gICAgICAgIHN1bS5yZXNldCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIShtID0gKHJpbmcgPSBwb2x5Z29uW2ldKS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHJpbmcsIG0sIHBvaW50MCA9IHJpbmdbbSAtIDFdLCBsYW1iZGEwID0gcG9pbnQwWzBdLCBwaGkwID0gcG9pbnQwWzFdIC8gMiArIHF1YXJ0ZXJQaSwgc2luUGhpMCA9IHNpbihwaGkwKSwgY29zUGhpMCA9IGNvcyhwaGkwKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbTsgKytqLCBsYW1iZGEwID0gbGFtYmRhMSwgc2luUGhpMCA9IHNpblBoaTEsIGNvc1BoaTAgPSBjb3NQaGkxLCBwb2ludDAgPSBwb2ludDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQxID0gcmluZ1tqXSwgbGFtYmRhMSA9IHBvaW50MVswXSwgcGhpMSA9IHBvaW50MVsxXSAvIDIgKyBxdWFydGVyUGksIHNpblBoaTEgPSBzaW4ocGhpMSksIGNvc1BoaTEgPSBjb3MocGhpMSksIGRlbHRhID0gbGFtYmRhMSAtIGxhbWJkYTAsIHNpZ24kJDEgPSBkZWx0YSA+PSAwID8gMSA6IC0xLCBhYnNEZWx0YSA9IHNpZ24kJDEgKiBkZWx0YSwgYW50aW1lcmlkaWFuID0gYWJzRGVsdGEgPiBwaSwgayA9IHNpblBoaTAgKiBzaW5QaGkxO1xuICAgICAgICAgICAgICAgIHN1bS5hZGQoYXRhbjIoayAqIHNpZ24kJDEgKiBzaW4oYWJzRGVsdGEpLCBjb3NQaGkwICogY29zUGhpMSArIGsgKiBjb3MoYWJzRGVsdGEpKSk7XG4gICAgICAgICAgICAgICAgYW5nbGUgKz0gYW50aW1lcmlkaWFuID8gZGVsdGEgKyBzaWduJCQxICogdGF1IDogZGVsdGE7XG4gICAgICAgICAgICAgICAgLy8gQXJlIHRoZSBsb25naXR1ZGVzIGVpdGhlciBzaWRlIG9mIHRoZSBwb2ludOKAmXMgbWVyaWRpYW4gKGxhbWJkYSksXG4gICAgICAgICAgICAgICAgLy8gYW5kIGFyZSB0aGUgbGF0aXR1ZGVzIHNtYWxsZXIgdGhhbiB0aGUgcGFyYWxsZWwgKHBoaSk/XG4gICAgICAgICAgICAgICAgaWYgKGFudGltZXJpZGlhbiBeIGxhbWJkYTAgPj0gbGFtYmRhIF4gbGFtYmRhMSA+PSBsYW1iZGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyYyA9IGNhcnRlc2lhbkNyb3NzKGNhcnRlc2lhbihwb2ludDApLCBjYXJ0ZXNpYW4ocG9pbnQxKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoYXJjKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGNhcnRlc2lhbkNyb3NzKG5vcm1hbCwgYXJjKTtcbiAgICAgICAgICAgICAgICAgICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShpbnRlcnNlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGhpQXJjID0gKGFudGltZXJpZGlhbiBeIGRlbHRhID49IDAgPyAtMSA6IDEpICogYXNpbihpbnRlcnNlY3Rpb25bMl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGhpID4gcGhpQXJjIHx8IHBoaSA9PT0gcGhpQXJjICYmIChhcmNbMF0gfHwgYXJjWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZGluZyArPSBhbnRpbWVyaWRpYW4gXiBkZWx0YSA+PSAwID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpcnN0LCBkZXRlcm1pbmUgd2hldGhlciB0aGUgU291dGggcG9sZSBpcyBpbnNpZGUgb3Igb3V0c2lkZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSXQgaXMgaW5zaWRlIGlmOlxuICAgICAgICAvLyAqIHRoZSBwb2x5Z29uIHdpbmRzIGFyb3VuZCBpdCBpbiBhIGNsb2Nrd2lzZSBkaXJlY3Rpb24uXG4gICAgICAgIC8vICogdGhlIHBvbHlnb24gZG9lcyBub3QgKGN1bXVsYXRpdmVseSkgd2luZCBhcm91bmQgaXQsIGJ1dCBoYXMgYSBuZWdhdGl2ZVxuICAgICAgICAvLyAgIChjb3VudGVyLWNsb2Nrd2lzZSkgYXJlYS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2Vjb25kLCBjb3VudCB0aGUgKHNpZ25lZCkgbnVtYmVyIG9mIHRpbWVzIGEgc2VnbWVudCBjcm9zc2VzIGEgbGFtYmRhXG4gICAgICAgIC8vIGZyb20gdGhlIHBvaW50IHRvIHRoZSBTb3V0aCBwb2xlLiAgSWYgaXQgaXMgemVybywgdGhlbiB0aGUgcG9pbnQgaXMgdGhlXG4gICAgICAgIC8vIHNhbWUgc2lkZSBhcyB0aGUgU291dGggcG9sZS5cbiAgICAgICAgcmV0dXJuIChhbmdsZSA8IC1lcHNpbG9uIHx8IGFuZ2xlIDwgZXBzaWxvbiAmJiBzdW0gPCAtZXBzaWxvbikgXiAod2luZGluZyAmIDEpO1xuICAgIH07XG4gICAgdmFyIGxlbmd0aFN1bSA9IGFkZGVyKCk7XG4gICAgdmFyIGxhbWJkYTAkMjtcbiAgICB2YXIgc2luUGhpMCQxO1xuICAgIHZhciBjb3NQaGkwJDE7XG4gICAgdmFyIGxlbmd0aFN0cmVhbSA9IHtcbiAgICAgICAgc3BoZXJlOiBub29wLFxuICAgICAgICBwb2ludDogbm9vcCxcbiAgICAgICAgbGluZVN0YXJ0OiBsZW5ndGhMaW5lU3RhcnQsXG4gICAgICAgIGxpbmVFbmQ6IG5vb3AsXG4gICAgICAgIHBvbHlnb25TdGFydDogbm9vcCxcbiAgICAgICAgcG9seWdvbkVuZDogbm9vcFxuICAgIH07XG4gICAgZnVuY3Rpb24gbGVuZ3RoTGluZVN0YXJ0KCkge1xuICAgICAgICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhQb2ludEZpcnN0O1xuICAgICAgICBsZW5ndGhTdHJlYW0ubGluZUVuZCA9IGxlbmd0aExpbmVFbmQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxlbmd0aExpbmVFbmQoKSB7XG4gICAgICAgIGxlbmd0aFN0cmVhbS5wb2ludCA9IGxlbmd0aFN0cmVhbS5saW5lRW5kID0gbm9vcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGVuZ3RoUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xuICAgICAgICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gICAgICAgIGxhbWJkYTAkMiA9IGxhbWJkYSwgc2luUGhpMCQxID0gc2luKHBoaSksIGNvc1BoaTAkMSA9IGNvcyhwaGkpO1xuICAgICAgICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhQb2ludDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGVuZ3RoUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICAgICAgICB2YXIgc2luUGhpID0gc2luKHBoaSksIGNvc1BoaSA9IGNvcyhwaGkpLCBkZWx0YSA9IGFicyhsYW1iZGEgLSBsYW1iZGEwJDIpLCBjb3NEZWx0YSA9IGNvcyhkZWx0YSksIHNpbkRlbHRhID0gc2luKGRlbHRhKSwgeCA9IGNvc1BoaSAqIHNpbkRlbHRhLCB5ID0gY29zUGhpMCQxICogc2luUGhpIC0gc2luUGhpMCQxICogY29zUGhpICogY29zRGVsdGEsIHogPSBzaW5QaGkwJDEgKiBzaW5QaGkgKyBjb3NQaGkwJDEgKiBjb3NQaGkgKiBjb3NEZWx0YTtcbiAgICAgICAgbGVuZ3RoU3VtLmFkZChhdGFuMihzcXJ0KHggKiB4ICsgeSAqIHkpLCB6KSk7XG4gICAgICAgIGxhbWJkYTAkMiA9IGxhbWJkYSwgc2luUGhpMCQxID0gc2luUGhpLCBjb3NQaGkwJDEgPSBjb3NQaGk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIGxlbmd0aFN1bS5yZXNldCgpO1xuICAgICAgICBnZW9TdHJlYW0ob2JqZWN0LCBsZW5ndGhTdHJlYW0pO1xuICAgICAgICByZXR1cm4gK2xlbmd0aFN1bTtcbiAgICB9O1xuICAgIHZhciBjb29yZGluYXRlcyA9IFtudWxsLCBudWxsXTtcbiAgICB2YXIgb2JqZWN0ID0geyB0eXBlOiBcIkxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzIH07XG4gICAgdmFyIGRpc3RhbmNlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgY29vcmRpbmF0ZXNbMF0gPSBhO1xuICAgICAgICBjb29yZGluYXRlc1sxXSA9IGI7XG4gICAgICAgIHJldHVybiBsZW5ndGgob2JqZWN0KTtcbiAgICB9O1xuICAgIHZhciBjb250YWluc09iamVjdFR5cGUgPSB7XG4gICAgICAgIEZlYXR1cmU6IGZ1bmN0aW9uIChvYmplY3QsIHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbnNHZW9tZXRyeShvYmplY3QuZ2VvbWV0cnksIHBvaW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgRmVhdHVyZUNvbGxlY3Rpb246IGZ1bmN0aW9uIChvYmplY3QsIHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBvYmplY3QuZmVhdHVyZXMsIGkgPSAtMSwgbiA9IGZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIGlmIChjb250YWluc0dlb21ldHJ5KGZlYXR1cmVzW2ldLmdlb21ldHJ5LCBwb2ludCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY29udGFpbnNHZW9tZXRyeVR5cGUgPSB7XG4gICAgICAgIFNwaGVyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIFBvaW50OiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zUG9pbnQob2JqZWN0LmNvb3JkaW5hdGVzLCBwb2ludCk7XG4gICAgICAgIH0sXG4gICAgICAgIE11bHRpUG9pbnQ6IGZ1bmN0aW9uIChvYmplY3QsIHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIGlmIChjb250YWluc1BvaW50KGNvb3JkaW5hdGVzW2ldLCBwb2ludCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBMaW5lU3RyaW5nOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zTGluZShvYmplY3QuY29vcmRpbmF0ZXMsIHBvaW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludCkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNMaW5lKGNvb3JkaW5hdGVzW2ldLCBwb2ludCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBQb2x5Z29uOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zUG9seWdvbihvYmplY3QuY29vcmRpbmF0ZXMsIHBvaW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludCkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNQb2x5Z29uKGNvb3JkaW5hdGVzW2ldLCBwb2ludCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uIChvYmplY3QsIHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cmllcyA9IG9iamVjdC5nZW9tZXRyaWVzLCBpID0gLTEsIG4gPSBnZW9tZXRyaWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIGlmIChjb250YWluc0dlb21ldHJ5KGdlb21ldHJpZXNbaV0sIHBvaW50KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zR2VvbWV0cnkoZ2VvbWV0cnksIHBvaW50KSB7XG4gICAgICAgIHJldHVybiBnZW9tZXRyeSAmJiBjb250YWluc0dlb21ldHJ5VHlwZS5oYXNPd25Qcm9wZXJ0eShnZW9tZXRyeS50eXBlKVxuICAgICAgICAgICAgPyBjb250YWluc0dlb21ldHJ5VHlwZVtnZW9tZXRyeS50eXBlXShnZW9tZXRyeSwgcG9pbnQpXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250YWluc1BvaW50KGNvb3JkaW5hdGVzLCBwb2ludCkge1xuICAgICAgICByZXR1cm4gZGlzdGFuY2UoY29vcmRpbmF0ZXMsIHBvaW50KSA9PT0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGFpbnNMaW5lKGNvb3JkaW5hdGVzLCBwb2ludCkge1xuICAgICAgICB2YXIgYWIgPSBkaXN0YW5jZShjb29yZGluYXRlc1swXSwgY29vcmRpbmF0ZXNbMV0pLCBhbyA9IGRpc3RhbmNlKGNvb3JkaW5hdGVzWzBdLCBwb2ludCksIG9iID0gZGlzdGFuY2UocG9pbnQsIGNvb3JkaW5hdGVzWzFdKTtcbiAgICAgICAgcmV0dXJuIGFvICsgb2IgPD0gYWIgKyBlcHNpbG9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250YWluc1BvbHlnb24oY29vcmRpbmF0ZXMsIHBvaW50KSB7XG4gICAgICAgIHJldHVybiAhIXBvbHlnb25Db250YWlucyhjb29yZGluYXRlcy5tYXAocmluZ1JhZGlhbnMpLCBwb2ludFJhZGlhbnMocG9pbnQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmluZ1JhZGlhbnMocmluZykge1xuICAgICAgICByZXR1cm4gcmluZyA9IHJpbmcubWFwKHBvaW50UmFkaWFucyksIHJpbmcucG9wKCksIHJpbmc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50UmFkaWFucyhwb2ludCkge1xuICAgICAgICByZXR1cm4gW3BvaW50WzBdICogcmFkaWFucywgcG9pbnRbMV0gKiByYWRpYW5zXTtcbiAgICB9XG4gICAgdmFyIGNvbnRhaW5zID0gZnVuY3Rpb24gKG9iamVjdCwgcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIChvYmplY3QgJiYgY29udGFpbnNPYmplY3RUeXBlLmhhc093blByb3BlcnR5KG9iamVjdC50eXBlKVxuICAgICAgICAgICAgPyBjb250YWluc09iamVjdFR5cGVbb2JqZWN0LnR5cGVdXG4gICAgICAgICAgICA6IGNvbnRhaW5zR2VvbWV0cnkpKG9iamVjdCwgcG9pbnQpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZ3JhdGljdWxlWCh5MCwgeTEsIGR5KSB7XG4gICAgICAgIHZhciB5ID0gZDNBcnJheS5yYW5nZSh5MCwgeTEgLSBlcHNpbG9uLCBkeSkuY29uY2F0KHkxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7IHJldHVybiB5Lm1hcChmdW5jdGlvbiAoeSkgeyByZXR1cm4gW3gsIHldOyB9KTsgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ3JhdGljdWxlWSh4MCwgeDEsIGR4KSB7XG4gICAgICAgIHZhciB4ID0gZDNBcnJheS5yYW5nZSh4MCwgeDEgLSBlcHNpbG9uLCBkeCkuY29uY2F0KHgxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh5KSB7IHJldHVybiB4Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gW3gsIHldOyB9KTsgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ3JhdGljdWxlKCkge1xuICAgICAgICB2YXIgeDEsIHgwLCBYMSwgWDAsIHkxLCB5MCwgWTEsIFkwLCBkeCA9IDEwLCBkeSA9IGR4LCBEWCA9IDkwLCBEWSA9IDM2MCwgeCwgeSwgWCwgWSwgcHJlY2lzaW9uID0gMi41O1xuICAgICAgICBmdW5jdGlvbiBncmF0aWN1bGUoKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIk11bHRpTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogbGluZXMoKSB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxpbmVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGQzQXJyYXkucmFuZ2UoY2VpbChYMCAvIERYKSAqIERYLCBYMSwgRFgpLm1hcChYKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoZDNBcnJheS5yYW5nZShjZWlsKFkwIC8gRFkpICogRFksIFkxLCBEWSkubWFwKFkpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoZDNBcnJheS5yYW5nZShjZWlsKHgwIC8gZHgpICogZHgsIHgxLCBkeCkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiBhYnMoeCAlIERYKSA+IGVwc2lsb247IH0pLm1hcCh4KSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KGQzQXJyYXkucmFuZ2UoY2VpbCh5MCAvIGR5KSAqIGR5LCB5MSwgZHkpLmZpbHRlcihmdW5jdGlvbiAoeSkgeyByZXR1cm4gYWJzKHkgJSBEWSkgPiBlcHNpbG9uOyB9KS5tYXAoeSkpO1xuICAgICAgICB9XG4gICAgICAgIGdyYXRpY3VsZS5saW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lcygpLm1hcChmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHsgcmV0dXJuIHsgdHlwZTogXCJMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlcyB9OyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZ3JhdGljdWxlLm91dGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIFgoWDApLmNvbmNhdChZKFkxKS5zbGljZSgxKSwgWChYMSkucmV2ZXJzZSgpLnNsaWNlKDEpLCBZKFkwKS5yZXZlcnNlKCkuc2xpY2UoMSkpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgZ3JhdGljdWxlLmV4dGVudCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyYXRpY3VsZS5leHRlbnRNaW5vcigpO1xuICAgICAgICAgICAgcmV0dXJuIGdyYXRpY3VsZS5leHRlbnRNYWpvcihfKS5leHRlbnRNaW5vcihfKTtcbiAgICAgICAgfTtcbiAgICAgICAgZ3JhdGljdWxlLmV4dGVudE1ham9yID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gW1tYMCwgWTBdLCBbWDEsIFkxXV07XG4gICAgICAgICAgICBYMCA9ICtfWzBdWzBdLCBYMSA9ICtfWzFdWzBdO1xuICAgICAgICAgICAgWTAgPSArX1swXVsxXSwgWTEgPSArX1sxXVsxXTtcbiAgICAgICAgICAgIGlmIChYMCA+IFgxKVxuICAgICAgICAgICAgICAgIF8gPSBYMCwgWDAgPSBYMSwgWDEgPSBfO1xuICAgICAgICAgICAgaWYgKFkwID4gWTEpXG4gICAgICAgICAgICAgICAgXyA9IFkwLCBZMCA9IFkxLCBZMSA9IF87XG4gICAgICAgICAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICAgICAgICB9O1xuICAgICAgICBncmF0aWN1bGUuZXh0ZW50TWlub3IgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICAgICAgICAgIHgwID0gK19bMF1bMF0sIHgxID0gK19bMV1bMF07XG4gICAgICAgICAgICB5MCA9ICtfWzBdWzFdLCB5MSA9ICtfWzFdWzFdO1xuICAgICAgICAgICAgaWYgKHgwID4geDEpXG4gICAgICAgICAgICAgICAgXyA9IHgwLCB4MCA9IHgxLCB4MSA9IF87XG4gICAgICAgICAgICBpZiAoeTAgPiB5MSlcbiAgICAgICAgICAgICAgICBfID0geTAsIHkwID0geTEsIHkxID0gXztcbiAgICAgICAgICAgIHJldHVybiBncmF0aWN1bGUucHJlY2lzaW9uKHByZWNpc2lvbik7XG4gICAgICAgIH07XG4gICAgICAgIGdyYXRpY3VsZS5zdGVwID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JhdGljdWxlLnN0ZXBNaW5vcigpO1xuICAgICAgICAgICAgcmV0dXJuIGdyYXRpY3VsZS5zdGVwTWFqb3IoXykuc3RlcE1pbm9yKF8pO1xuICAgICAgICB9O1xuICAgICAgICBncmF0aWN1bGUuc3RlcE1ham9yID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gW0RYLCBEWV07XG4gICAgICAgICAgICBEWCA9ICtfWzBdLCBEWSA9ICtfWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgICAgICAgfTtcbiAgICAgICAgZ3JhdGljdWxlLnN0ZXBNaW5vciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtkeCwgZHldO1xuICAgICAgICAgICAgZHggPSArX1swXSwgZHkgPSArX1sxXTtcbiAgICAgICAgICAgIHJldHVybiBncmF0aWN1bGU7XG4gICAgICAgIH07XG4gICAgICAgIGdyYXRpY3VsZS5wcmVjaXNpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVjaXNpb247XG4gICAgICAgICAgICBwcmVjaXNpb24gPSArXztcbiAgICAgICAgICAgIHggPSBncmF0aWN1bGVYKHkwLCB5MSwgOTApO1xuICAgICAgICAgICAgeSA9IGdyYXRpY3VsZVkoeDAsIHgxLCBwcmVjaXNpb24pO1xuICAgICAgICAgICAgWCA9IGdyYXRpY3VsZVgoWTAsIFkxLCA5MCk7XG4gICAgICAgICAgICBZID0gZ3JhdGljdWxlWShYMCwgWDEsIHByZWNpc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gZ3JhdGljdWxlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZ3JhdGljdWxlXG4gICAgICAgICAgICAuZXh0ZW50TWFqb3IoW1stMTgwLCAtOTAgKyBlcHNpbG9uXSwgWzE4MCwgOTAgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAuZXh0ZW50TWlub3IoW1stMTgwLCAtODAgLSBlcHNpbG9uXSwgWzE4MCwgODAgKyBlcHNpbG9uXV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBncmF0aWN1bGUxMCgpIHtcbiAgICAgICAgcmV0dXJuIGdyYXRpY3VsZSgpKCk7XG4gICAgfVxuICAgIHZhciBpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciB4MCA9IGFbMF0gKiByYWRpYW5zLCB5MCA9IGFbMV0gKiByYWRpYW5zLCB4MSA9IGJbMF0gKiByYWRpYW5zLCB5MSA9IGJbMV0gKiByYWRpYW5zLCBjeTAgPSBjb3MoeTApLCBzeTAgPSBzaW4oeTApLCBjeTEgPSBjb3MoeTEpLCBzeTEgPSBzaW4oeTEpLCBreDAgPSBjeTAgKiBjb3MoeDApLCBreTAgPSBjeTAgKiBzaW4oeDApLCBreDEgPSBjeTEgKiBjb3MoeDEpLCBreTEgPSBjeTEgKiBzaW4oeDEpLCBkID0gMiAqIGFzaW4oc3FydChoYXZlcnNpbih5MSAtIHkwKSArIGN5MCAqIGN5MSAqIGhhdmVyc2luKHgxIC0geDApKSksIGsgPSBzaW4oZCk7XG4gICAgICAgIHZhciBpbnRlcnBvbGF0ZSA9IGQgPyBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIEIgPSBzaW4odCAqPSBkKSAvIGssIEEgPSBzaW4oZCAtIHQpIC8gaywgeCA9IEEgKiBreDAgKyBCICoga3gxLCB5ID0gQSAqIGt5MCArIEIgKiBreTEsIHogPSBBICogc3kwICsgQiAqIHN5MTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYXRhbjIoeSwgeCkgKiBkZWdyZWVzLFxuICAgICAgICAgICAgICAgIGF0YW4yKHosIHNxcnQoeCAqIHggKyB5ICogeSkpICogZGVncmVlc1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbeDAgKiBkZWdyZWVzLCB5MCAqIGRlZ3JlZXNdO1xuICAgICAgICB9O1xuICAgICAgICBpbnRlcnBvbGF0ZS5kaXN0YW5jZSA9IGQ7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZTtcbiAgICB9O1xuICAgIHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgdmFyIGFyZWFTdW0kMSA9IGFkZGVyKCk7XG4gICAgdmFyIGFyZWFSaW5nU3VtJDEgPSBhZGRlcigpO1xuICAgIHZhciB4MDA7XG4gICAgdmFyIHkwMDtcbiAgICB2YXIgeDAkMTtcbiAgICB2YXIgeTAkMTtcbiAgICB2YXIgYXJlYVN0cmVhbSQxID0ge1xuICAgICAgICBwb2ludDogbm9vcCxcbiAgICAgICAgbGluZVN0YXJ0OiBub29wLFxuICAgICAgICBsaW5lRW5kOiBub29wLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFyZWFTdHJlYW0kMS5saW5lU3RhcnQgPSBhcmVhUmluZ1N0YXJ0JDE7XG4gICAgICAgICAgICBhcmVhU3RyZWFtJDEubGluZUVuZCA9IGFyZWFSaW5nRW5kJDE7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFyZWFTdHJlYW0kMS5saW5lU3RhcnQgPSBhcmVhU3RyZWFtJDEubGluZUVuZCA9IGFyZWFTdHJlYW0kMS5wb2ludCA9IG5vb3A7XG4gICAgICAgICAgICBhcmVhU3VtJDEuYWRkKGFicyhhcmVhUmluZ1N1bSQxKSk7XG4gICAgICAgICAgICBhcmVhUmluZ1N1bSQxLnJlc2V0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZWEgPSBhcmVhU3VtJDEgLyAyO1xuICAgICAgICAgICAgYXJlYVN1bSQxLnJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gYXJlYTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gYXJlYVJpbmdTdGFydCQxKCkge1xuICAgICAgICBhcmVhU3RyZWFtJDEucG9pbnQgPSBhcmVhUG9pbnRGaXJzdCQxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmVhUG9pbnRGaXJzdCQxKHgsIHkpIHtcbiAgICAgICAgYXJlYVN0cmVhbSQxLnBvaW50ID0gYXJlYVBvaW50JDE7XG4gICAgICAgIHgwMCA9IHgwJDEgPSB4LCB5MDAgPSB5MCQxID0geTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJlYVBvaW50JDEoeCwgeSkge1xuICAgICAgICBhcmVhUmluZ1N1bSQxLmFkZCh5MCQxICogeCAtIHgwJDEgKiB5KTtcbiAgICAgICAgeDAkMSA9IHgsIHkwJDEgPSB5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmVhUmluZ0VuZCQxKCkge1xuICAgICAgICBhcmVhUG9pbnQkMSh4MDAsIHkwMCk7XG4gICAgfVxuICAgIHZhciB4MCQyID0gSW5maW5pdHk7XG4gICAgdmFyIHkwJDIgPSB4MCQyO1xuICAgIHZhciB4MSA9IC14MCQyO1xuICAgIHZhciB5MSA9IHgxO1xuICAgIHZhciBib3VuZHNTdHJlYW0kMSA9IHtcbiAgICAgICAgcG9pbnQ6IGJvdW5kc1BvaW50JDEsXG4gICAgICAgIGxpbmVTdGFydDogbm9vcCxcbiAgICAgICAgbGluZUVuZDogbm9vcCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBub29wLFxuICAgICAgICBwb2x5Z29uRW5kOiBub29wLFxuICAgICAgICByZXN1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSBbW3gwJDIsIHkwJDJdLCBbeDEsIHkxXV07XG4gICAgICAgICAgICB4MSA9IHkxID0gLSh5MCQyID0geDAkMiA9IEluZmluaXR5KTtcbiAgICAgICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGJvdW5kc1BvaW50JDEoeCwgeSkge1xuICAgICAgICBpZiAoeCA8IHgwJDIpXG4gICAgICAgICAgICB4MCQyID0geDtcbiAgICAgICAgaWYgKHggPiB4MSlcbiAgICAgICAgICAgIHgxID0geDtcbiAgICAgICAgaWYgKHkgPCB5MCQyKVxuICAgICAgICAgICAgeTAkMiA9IHk7XG4gICAgICAgIGlmICh5ID4geTEpXG4gICAgICAgICAgICB5MSA9IHk7XG4gICAgfVxuICAgIC8vIFRPRE8gRW5mb3JjZSBwb3NpdGl2ZSBhcmVhIGZvciBleHRlcmlvciwgbmVnYXRpdmUgYXJlYSBmb3IgaW50ZXJpb3I/XG4gICAgdmFyIFgwJDEgPSAwO1xuICAgIHZhciBZMCQxID0gMDtcbiAgICB2YXIgWjAkMSA9IDA7XG4gICAgdmFyIFgxJDEgPSAwO1xuICAgIHZhciBZMSQxID0gMDtcbiAgICB2YXIgWjEkMSA9IDA7XG4gICAgdmFyIFgyJDEgPSAwO1xuICAgIHZhciBZMiQxID0gMDtcbiAgICB2YXIgWjIkMSA9IDA7XG4gICAgdmFyIHgwMCQxO1xuICAgIHZhciB5MDAkMTtcbiAgICB2YXIgeDAkMztcbiAgICB2YXIgeTAkMztcbiAgICB2YXIgY2VudHJvaWRTdHJlYW0kMSA9IHtcbiAgICAgICAgcG9pbnQ6IGNlbnRyb2lkUG9pbnQkMSxcbiAgICAgICAgbGluZVN0YXJ0OiBjZW50cm9pZExpbmVTdGFydCQxLFxuICAgICAgICBsaW5lRW5kOiBjZW50cm9pZExpbmVFbmQkMSxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjZW50cm9pZFN0cmVhbSQxLmxpbmVTdGFydCA9IGNlbnRyb2lkUmluZ1N0YXJ0JDE7XG4gICAgICAgICAgICBjZW50cm9pZFN0cmVhbSQxLmxpbmVFbmQgPSBjZW50cm9pZFJpbmdFbmQkMTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnQkMTtcbiAgICAgICAgICAgIGNlbnRyb2lkU3RyZWFtJDEubGluZVN0YXJ0ID0gY2VudHJvaWRMaW5lU3RhcnQkMTtcbiAgICAgICAgICAgIGNlbnRyb2lkU3RyZWFtJDEubGluZUVuZCA9IGNlbnRyb2lkTGluZUVuZCQxO1xuICAgICAgICB9LFxuICAgICAgICByZXN1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjZW50cm9pZCA9IFoyJDEgPyBbWDIkMSAvIFoyJDEsIFkyJDEgLyBaMiQxXVxuICAgICAgICAgICAgICAgIDogWjEkMSA/IFtYMSQxIC8gWjEkMSwgWTEkMSAvIFoxJDFdXG4gICAgICAgICAgICAgICAgICAgIDogWjAkMSA/IFtYMCQxIC8gWjAkMSwgWTAkMSAvIFowJDFdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtOYU4sIE5hTl07XG4gICAgICAgICAgICBYMCQxID0gWTAkMSA9IFowJDEgPVxuICAgICAgICAgICAgICAgIFgxJDEgPSBZMSQxID0gWjEkMSA9XG4gICAgICAgICAgICAgICAgICAgIFgyJDEgPSBZMiQxID0gWjIkMSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gY2VudHJvaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNlbnRyb2lkUG9pbnQkMSh4LCB5KSB7XG4gICAgICAgIFgwJDEgKz0geDtcbiAgICAgICAgWTAkMSArPSB5O1xuICAgICAgICArK1owJDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkTGluZVN0YXJ0JDEoKSB7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50Rmlyc3RMaW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZFBvaW50Rmlyc3RMaW5lKHgsIHkpIHtcbiAgICAgICAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnRMaW5lO1xuICAgICAgICBjZW50cm9pZFBvaW50JDEoeDAkMyA9IHgsIHkwJDMgPSB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRQb2ludExpbmUoeCwgeSkge1xuICAgICAgICB2YXIgZHggPSB4IC0geDAkMywgZHkgPSB5IC0geTAkMywgeiA9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICBYMSQxICs9IHogKiAoeDAkMyArIHgpIC8gMjtcbiAgICAgICAgWTEkMSArPSB6ICogKHkwJDMgKyB5KSAvIDI7XG4gICAgICAgIFoxJDEgKz0gejtcbiAgICAgICAgY2VudHJvaWRQb2ludCQxKHgwJDMgPSB4LCB5MCQzID0geSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkTGluZUVuZCQxKCkge1xuICAgICAgICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludCQxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZFJpbmdTdGFydCQxKCkge1xuICAgICAgICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludEZpcnN0UmluZztcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRSaW5nRW5kJDEoKSB7XG4gICAgICAgIGNlbnRyb2lkUG9pbnRSaW5nKHgwMCQxLCB5MDAkMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRGaXJzdFJpbmcoeCwgeSkge1xuICAgICAgICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludFJpbmc7XG4gICAgICAgIGNlbnRyb2lkUG9pbnQkMSh4MDAkMSA9IHgwJDMgPSB4LCB5MDAkMSA9IHkwJDMgPSB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRQb2ludFJpbmcoeCwgeSkge1xuICAgICAgICB2YXIgZHggPSB4IC0geDAkMywgZHkgPSB5IC0geTAkMywgeiA9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICBYMSQxICs9IHogKiAoeDAkMyArIHgpIC8gMjtcbiAgICAgICAgWTEkMSArPSB6ICogKHkwJDMgKyB5KSAvIDI7XG4gICAgICAgIFoxJDEgKz0gejtcbiAgICAgICAgeiA9IHkwJDMgKiB4IC0geDAkMyAqIHk7XG4gICAgICAgIFgyJDEgKz0geiAqICh4MCQzICsgeCk7XG4gICAgICAgIFkyJDEgKz0geiAqICh5MCQzICsgeSk7XG4gICAgICAgIFoyJDEgKz0geiAqIDM7XG4gICAgICAgIGNlbnRyb2lkUG9pbnQkMSh4MCQzID0geCwgeTAkMyA9IHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBQYXRoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICBQYXRoQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9yYWRpdXM6IDQuNSxcbiAgICAgICAgcG9pbnRSYWRpdXM6IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzID0gXywgdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2ludCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5lID09PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB0aGlzLl9wb2ludCA9IE5hTjtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHggKyB0aGlzLl9yYWRpdXMsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmFyYyh4LCB5LCB0aGlzLl9yYWRpdXMsIDAsIHRhdSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0OiBub29wXG4gICAgfTtcbiAgICB2YXIgbGVuZ3RoU3VtJDEgPSBhZGRlcigpO1xuICAgIHZhciBsZW5ndGhSaW5nO1xuICAgIHZhciB4MDAkMjtcbiAgICB2YXIgeTAwJDI7XG4gICAgdmFyIHgwJDQ7XG4gICAgdmFyIHkwJDQ7XG4gICAgdmFyIGxlbmd0aFN0cmVhbSQxID0ge1xuICAgICAgICBwb2ludDogbm9vcCxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZW5ndGhTdHJlYW0kMS5wb2ludCA9IGxlbmd0aFBvaW50Rmlyc3QkMTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGxlbmd0aFJpbmcpXG4gICAgICAgICAgICAgICAgbGVuZ3RoUG9pbnQkMSh4MDAkMiwgeTAwJDIpO1xuICAgICAgICAgICAgbGVuZ3RoU3RyZWFtJDEucG9pbnQgPSBub29wO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxlbmd0aFJpbmcgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZW5ndGhSaW5nID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gK2xlbmd0aFN1bSQxO1xuICAgICAgICAgICAgbGVuZ3RoU3VtJDEucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxlbmd0aFBvaW50Rmlyc3QkMSh4LCB5KSB7XG4gICAgICAgIGxlbmd0aFN0cmVhbSQxLnBvaW50ID0gbGVuZ3RoUG9pbnQkMTtcbiAgICAgICAgeDAwJDIgPSB4MCQ0ID0geCwgeTAwJDIgPSB5MCQ0ID0geTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGVuZ3RoUG9pbnQkMSh4LCB5KSB7XG4gICAgICAgIHgwJDQgLT0geCwgeTAkNCAtPSB5O1xuICAgICAgICBsZW5ndGhTdW0kMS5hZGQoc3FydCh4MCQ0ICogeDAkNCArIHkwJDQgKiB5MCQ0KSk7XG4gICAgICAgIHgwJDQgPSB4LCB5MCQ0ID0geTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUGF0aFN0cmluZygpIHtcbiAgICAgICAgdGhpcy5fc3RyaW5nID0gW107XG4gICAgfVxuICAgIFBhdGhTdHJpbmcucHJvdG90eXBlID0ge1xuICAgICAgICBfcmFkaXVzOiA0LjUsXG4gICAgICAgIF9jaXJjbGU6IGNpcmNsZSQxKDQuNSksXG4gICAgICAgIHBvaW50UmFkaXVzOiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKChfID0gK18pICE9PSB0aGlzLl9yYWRpdXMpXG4gICAgICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gXywgdGhpcy5fY2lyY2xlID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gTmFOO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmUgPT09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyaW5nLnB1c2goXCJaXCIpO1xuICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSBOYU47XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIk1cIiwgeCwgXCIsXCIsIHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RyaW5nLnB1c2goXCJMXCIsIHgsIFwiLFwiLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NpcmNsZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2lyY2xlID0gY2lyY2xlJDEodGhpcy5fcmFkaXVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RyaW5nLnB1c2goXCJNXCIsIHgsIFwiLFwiLCB5LCB0aGlzLl9jaXJjbGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fc3RyaW5nLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyaW5nID0gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjaXJjbGUkMShyYWRpdXMpIHtcbiAgICAgICAgcmV0dXJuIFwibTAsXCIgKyByYWRpdXNcbiAgICAgICAgICAgICsgXCJhXCIgKyByYWRpdXMgKyBcIixcIiArIHJhZGl1cyArIFwiIDAgMSwxIDAsXCIgKyAtMiAqIHJhZGl1c1xuICAgICAgICAgICAgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIDIgKiByYWRpdXNcbiAgICAgICAgICAgICsgXCJ6XCI7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGZ1bmN0aW9uIChwcm9qZWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBwb2ludFJhZGl1cyA9IDQuNSwgcHJvamVjdGlvblN0cmVhbSwgY29udGV4dFN0cmVhbTtcbiAgICAgICAgZnVuY3Rpb24gcGF0aChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50UmFkaXVzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK3BvaW50UmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0oY29udGV4dFN0cmVhbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRTdHJlYW0ucmVzdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aC5hcmVhID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgICAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShhcmVhU3RyZWFtJDEpKTtcbiAgICAgICAgICAgIHJldHVybiBhcmVhU3RyZWFtJDEucmVzdWx0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHBhdGgubWVhc3VyZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0obGVuZ3RoU3RyZWFtJDEpKTtcbiAgICAgICAgICAgIHJldHVybiBsZW5ndGhTdHJlYW0kMS5yZXN1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcGF0aC5ib3VuZHMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGJvdW5kc1N0cmVhbSQxKSk7XG4gICAgICAgICAgICByZXR1cm4gYm91bmRzU3RyZWFtJDEucmVzdWx0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHBhdGguY2VudHJvaWQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGNlbnRyb2lkU3RyZWFtJDEpKTtcbiAgICAgICAgICAgIHJldHVybiBjZW50cm9pZFN0cmVhbSQxLnJlc3VsdCgpO1xuICAgICAgICB9O1xuICAgICAgICBwYXRoLnByb2plY3Rpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJvamVjdGlvblN0cmVhbSA9IF8gPT0gbnVsbCA/IChwcm9qZWN0aW9uID0gbnVsbCwgaWRlbnRpdHkpIDogKHByb2plY3Rpb24gPSBfKS5zdHJlYW0sIHBhdGgpIDogcHJvamVjdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgcGF0aC5jb250ZXh0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgIGNvbnRleHRTdHJlYW0gPSBfID09IG51bGwgPyAoY29udGV4dCA9IG51bGwsIG5ldyBQYXRoU3RyaW5nKSA6IG5ldyBQYXRoQ29udGV4dChjb250ZXh0ID0gXyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50UmFkaXVzICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cyhwb2ludFJhZGl1cyk7XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfTtcbiAgICAgICAgcGF0aC5wb2ludFJhZGl1cyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50UmFkaXVzO1xuICAgICAgICAgICAgcG9pbnRSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IChjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKCtfKSwgK18pO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYXRoLnByb2plY3Rpb24ocHJvamVjdGlvbikuY29udGV4dChjb250ZXh0KTtcbiAgICB9O1xuICAgIHZhciBjbGlwID0gZnVuY3Rpb24gKHBvaW50VmlzaWJsZSwgY2xpcExpbmUsIGludGVycG9sYXRlLCBzdGFydCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJvdGF0ZSwgc2luaykge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBjbGlwTGluZShzaW5rKSwgcm90YXRlZFN0YXJ0ID0gcm90YXRlLmludmVydChzdGFydFswXSwgc3RhcnRbMV0pLCByaW5nQnVmZmVyID0gY2xpcEJ1ZmZlcigpLCByaW5nU2luayA9IGNsaXBMaW5lKHJpbmdCdWZmZXIpLCBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlLCBwb2x5Z29uLCBzZWdtZW50cywgcmluZztcbiAgICAgICAgICAgIHZhciBjbGlwID0ge1xuICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgICAgICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnRSaW5nO1xuICAgICAgICAgICAgICAgICAgICBjbGlwLmxpbmVTdGFydCA9IHJpbmdTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgY2xpcC5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbiA9IFtdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIGNsaXAubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBjbGlwLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cyA9IGQzQXJyYXkubWVyZ2Uoc2VnbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbnNpZGUgPSBwb2x5Z29uQ29udGFpbnMocG9seWdvbiwgcm90YXRlZFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9seWdvbihzZWdtZW50cywgY29tcGFyZUludGVyc2VjdGlvbiwgc3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBzaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydEluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgc2luayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9seWdvblN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5rLnBvbHlnb25FbmQoKSwgcG9seWdvblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMgPSBwb2x5Z29uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNwaGVyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzaW5rLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgc2luay5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHNpbmsucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmdW5jdGlvbiBwb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHJvdGF0ZShsYW1iZGEsIHBoaSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50VmlzaWJsZShsYW1iZGEgPSBwb2ludFswXSwgcGhpID0gcG9pbnRbMV0pKVxuICAgICAgICAgICAgICAgICAgICBzaW5rLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBvaW50TGluZShsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHJvdGF0ZShsYW1iZGEsIHBoaSk7XG4gICAgICAgICAgICAgICAgbGluZS5wb2ludChwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgICAgICAgICAgIGNsaXAucG9pbnQgPSBwb2ludExpbmU7XG4gICAgICAgICAgICAgICAgbGluZS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICAgICAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xuICAgICAgICAgICAgICAgIGxpbmUubGluZUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcG9pbnRSaW5nKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICAgICAgcmluZy5wdXNoKFtsYW1iZGEsIHBoaV0pO1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHJvdGF0ZShsYW1iZGEsIHBoaSk7XG4gICAgICAgICAgICAgICAgcmluZ1NpbmsucG9pbnQocG9pbnRbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgICAgICAgICAgICByaW5nU2luay5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICByaW5nID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgICAgICAgICAgIHBvaW50UmluZyhyaW5nWzBdWzBdLCByaW5nWzBdWzFdKTtcbiAgICAgICAgICAgICAgICByaW5nU2luay5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNsZWFuID0gcmluZ1NpbmsuY2xlYW4oKSwgcmluZ1NlZ21lbnRzID0gcmluZ0J1ZmZlci5yZXN1bHQoKSwgaSwgbiA9IHJpbmdTZWdtZW50cy5sZW5ndGgsIG0sIHNlZ21lbnQsIHBvaW50O1xuICAgICAgICAgICAgICAgIHJpbmcucG9wKCk7XG4gICAgICAgICAgICAgICAgcG9seWdvbi5wdXNoKHJpbmcpO1xuICAgICAgICAgICAgICAgIHJpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIE5vIGludGVyc2VjdGlvbnMuXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFuICYgMSkge1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50ID0gcmluZ1NlZ21lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKG0gPSBzZWdtZW50Lmxlbmd0aCAtIDEpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG07ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW5rLnBvaW50KChwb2ludCA9IHNlZ21lbnRbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlam9pbiBjb25uZWN0ZWQgc2VnbWVudHMuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyByZXVzZSByaW5nQnVmZmVyLnJlam9pbigpP1xuICAgICAgICAgICAgICAgIGlmIChuID4gMSAmJiBjbGVhbiAmIDIpXG4gICAgICAgICAgICAgICAgICAgIHJpbmdTZWdtZW50cy5wdXNoKHJpbmdTZWdtZW50cy5wb3AoKS5jb25jYXQocmluZ1NlZ21lbnRzLnNoaWZ0KCkpKTtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHJpbmdTZWdtZW50cy5maWx0ZXIodmFsaWRTZWdtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xpcDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHZhbGlkU2VnbWVudChzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBzZWdtZW50Lmxlbmd0aCA+IDE7XG4gICAgfVxuICAgIC8vIEludGVyc2VjdGlvbnMgYXJlIHNvcnRlZCBhbG9uZyB0aGUgY2xpcCBlZGdlLiBGb3IgYm90aCBhbnRpbWVyaWRpYW4gY3V0dGluZ1xuICAgIC8vIGFuZCBjaXJjbGUgY2xpcHBpbmcsIHRoZSBzYW1lIGNvbXBhcmlzb24gaXMgdXNlZC5cbiAgICBmdW5jdGlvbiBjb21wYXJlSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICgoYSA9IGEueClbMF0gPCAwID8gYVsxXSAtIGhhbGZQaSAtIGVwc2lsb24gOiBoYWxmUGkgLSBhWzFdKVxuICAgICAgICAgICAgLSAoKGIgPSBiLngpWzBdIDwgMCA/IGJbMV0gLSBoYWxmUGkgLSBlcHNpbG9uIDogaGFsZlBpIC0gYlsxXSk7XG4gICAgfVxuICAgIHZhciBjbGlwQW50aW1lcmlkaWFuID0gY2xpcChmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LCBjbGlwQW50aW1lcmlkaWFuTGluZSwgY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlLCBbLXBpLCAtaGFsZlBpXSk7XG4gICAgLy8gVGFrZXMgYSBsaW5lIGFuZCBjdXRzIGludG8gdmlzaWJsZSBzZWdtZW50cy4gUmV0dXJuIHZhbHVlczogMCAtIHRoZXJlIHdlcmVcbiAgICAvLyBpbnRlcnNlY3Rpb25zIG9yIHRoZSBsaW5lIHdhcyBlbXB0eTsgMSAtIG5vIGludGVyc2VjdGlvbnM7IDIgLSB0aGVyZSB3ZXJlXG4gICAgLy8gaW50ZXJzZWN0aW9ucywgYW5kIHRoZSBmaXJzdCBhbmQgbGFzdCBzZWdtZW50cyBzaG91bGQgYmUgcmVqb2luZWQuXG4gICAgZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkxpbmUoc3RyZWFtKSB7XG4gICAgICAgIHZhciBsYW1iZGEwID0gTmFOLCBwaGkwID0gTmFOLCBzaWduMCA9IE5hTiwgY2xlYW47IC8vIG5vIGludGVyc2VjdGlvbnNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICBjbGVhbiA9IDE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uIChsYW1iZGExLCBwaGkxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpZ24xID0gbGFtYmRhMSA+IDAgPyBwaSA6IC1waSwgZGVsdGEgPSBhYnMobGFtYmRhMSAtIGxhbWJkYTApO1xuICAgICAgICAgICAgICAgIGlmIChhYnMoZGVsdGEgLSBwaSkgPCBlcHNpbG9uKSB7IC8vIGxpbmUgY3Jvc3NlcyBhIHBvbGVcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KGxhbWJkYTAsIHBoaTAgPSAocGhpMCArIHBoaTEpIC8gMiA+IDAgPyBoYWxmUGkgOiAtaGFsZlBpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24wLCBwaGkwKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjEsIHBoaTApO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMSwgcGhpMCk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2lnbjAgIT09IHNpZ24xICYmIGRlbHRhID49IHBpKSB7IC8vIGxpbmUgY3Jvc3NlcyBhbnRpbWVyaWRpYW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFicyhsYW1iZGEwIC0gc2lnbjApIDwgZXBzaWxvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbWJkYTAgLT0gc2lnbjAgKiBlcHNpbG9uOyAvLyBoYW5kbGUgZGVnZW5lcmFjaWVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChhYnMobGFtYmRhMSAtIHNpZ24xKSA8IGVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW1iZGExIC09IHNpZ24xICogZXBzaWxvbjtcbiAgICAgICAgICAgICAgICAgICAgcGhpMCA9IGNsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QobGFtYmRhMCwgcGhpMCwgbGFtYmRhMSwgcGhpMSk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludChzaWduMCwgcGhpMCk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24xLCBwaGkwKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMCA9IGxhbWJkYTEsIHBoaTAgPSBwaGkxKTtcbiAgICAgICAgICAgICAgICBzaWduMCA9IHNpZ24xO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgIGxhbWJkYTAgPSBwaGkwID0gTmFOO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsZWFuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLSBjbGVhbjsgLy8gaWYgaW50ZXJzZWN0aW9ucywgcmVqb2luIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QobGFtYmRhMCwgcGhpMCwgbGFtYmRhMSwgcGhpMSkge1xuICAgICAgICB2YXIgY29zUGhpMCwgY29zUGhpMSwgc2luTGFtYmRhMExhbWJkYTEgPSBzaW4obGFtYmRhMCAtIGxhbWJkYTEpO1xuICAgICAgICByZXR1cm4gYWJzKHNpbkxhbWJkYTBMYW1iZGExKSA+IGVwc2lsb25cbiAgICAgICAgICAgID8gYXRhbigoc2luKHBoaTApICogKGNvc1BoaTEgPSBjb3MocGhpMSkpICogc2luKGxhbWJkYTEpXG4gICAgICAgICAgICAgICAgLSBzaW4ocGhpMSkgKiAoY29zUGhpMCA9IGNvcyhwaGkwKSkgKiBzaW4obGFtYmRhMCkpXG4gICAgICAgICAgICAgICAgLyAoY29zUGhpMCAqIGNvc1BoaTEgKiBzaW5MYW1iZGEwTGFtYmRhMSkpXG4gICAgICAgICAgICA6IChwaGkwICsgcGhpMSkgLyAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGlwQW50aW1lcmlkaWFuSW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgICAgIHZhciBwaGk7XG4gICAgICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgIHBoaSA9IGRpcmVjdGlvbiAqIGhhbGZQaTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludCgtcGksIHBoaSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQoMCwgcGhpKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwaSwgcGhpKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwaSwgMCk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQocGksIC1waGkpO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KDAsIC1waGkpO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KC1waSwgLXBoaSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQoLXBpLCAwKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludCgtcGksIHBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWJzKGZyb21bMF0gLSB0b1swXSkgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICB2YXIgbGFtYmRhID0gZnJvbVswXSA8IHRvWzBdID8gcGkgOiAtcGk7XG4gICAgICAgICAgICBwaGkgPSBkaXJlY3Rpb24gKiBsYW1iZGEgLyAyO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KC1sYW1iZGEsIHBoaSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQoMCwgcGhpKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2xpcENpcmNsZSA9IGZ1bmN0aW9uIChyYWRpdXMsIGRlbHRhKSB7XG4gICAgICAgIHZhciBjciA9IGNvcyhyYWRpdXMpLCBzbWFsbFJhZGl1cyA9IGNyID4gMCwgbm90SGVtaXNwaGVyZSA9IGFicyhjcikgPiBlcHNpbG9uOyAvLyBUT0RPIG9wdGltaXNlIGZvciB0aGlzIGNvbW1vbiBjYXNlXG4gICAgICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xuICAgICAgICAgICAgY2lyY2xlU3RyZWFtKHN0cmVhbSwgcmFkaXVzLCBkZWx0YSwgZGlyZWN0aW9uLCBmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmlzaWJsZShsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcyhsYW1iZGEpICogY29zKHBoaSkgPiBjcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUYWtlcyBhIGxpbmUgYW5kIGN1dHMgaW50byB2aXNpYmxlIHNlZ21lbnRzLiBSZXR1cm4gdmFsdWVzIHVzZWQgZm9yIHBvbHlnb25cbiAgICAgICAgLy8gY2xpcHBpbmc6IDAgLSB0aGVyZSB3ZXJlIGludGVyc2VjdGlvbnMgb3IgdGhlIGxpbmUgd2FzIGVtcHR5OyAxIC0gbm9cbiAgICAgICAgLy8gaW50ZXJzZWN0aW9ucyAyIC0gdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zLCBhbmQgdGhlIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzXG4gICAgICAgIC8vIHNob3VsZCBiZSByZWpvaW5lZC5cbiAgICAgICAgZnVuY3Rpb24gY2xpcExpbmUoc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQwLCAvLyBwcmV2aW91cyBwb2ludFxuICAgICAgICAgICAgYzAsIC8vIGNvZGUgZm9yIHByZXZpb3VzIHBvaW50XG4gICAgICAgICAgICB2MCwgLy8gdmlzaWJpbGl0eSBvZiBwcmV2aW91cyBwb2ludFxuICAgICAgICAgICAgdjAwLCAvLyB2aXNpYmlsaXR5IG9mIGZpcnN0IHBvaW50XG4gICAgICAgICAgICBjbGVhbjsgLy8gbm8gaW50ZXJzZWN0aW9uc1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdjAwID0gdjAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW4gPSAxO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uIChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQxID0gW2xhbWJkYSwgcGhpXSwgcG9pbnQyLCB2ID0gdmlzaWJsZShsYW1iZGEsIHBoaSksIGMgPSBzbWFsbFJhZGl1c1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB2ID8gMCA6IGNvZGUobGFtYmRhLCBwaGkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHYgPyBjb2RlKGxhbWJkYSArIChsYW1iZGEgPCAwID8gcGkgOiAtcGkpLCBwaGkpIDogMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwb2ludDAgJiYgKHYwMCA9IHYwID0gdikpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBkZWdlbmVyYWNpZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gaWdub3JlIGlmIG5vdCBjbGlwcGluZyBwb2x5Z29ucy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHYwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwb2ludDIgfHwgcG9pbnRFcXVhbChwb2ludDAsIHBvaW50MikgfHwgcG9pbnRFcXVhbChwb2ludDEsIHBvaW50MikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDFbMF0gKz0gZXBzaWxvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDFbMV0gKz0gZXBzaWxvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdmlzaWJsZShwb2ludDFbMF0sIHBvaW50MVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHYwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG91dHNpZGUgZ29pbmcgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQyWzBdLCBwb2ludDJbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zaWRlIGdvaW5nIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHBvaW50MlswXSwgcG9pbnQyWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQwID0gcG9pbnQyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vdEhlbWlzcGhlcmUgJiYgcG9pbnQwICYmIHNtYWxsUmFkaXVzIF4gdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY29kZXMgZm9yIHR3byBwb2ludHMgYXJlIGRpZmZlcmVudCwgb3IgYXJlIGJvdGggemVybyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGVyZSB0aGlzIHNlZ21lbnQgaW50ZXJzZWN0cyB3aXRoIHRoZSBzbWFsbCBjaXJjbGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjICYgYzApICYmICh0ID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwLCB0cnVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNtYWxsUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodiAmJiAoIXBvaW50MCB8fCAhcG9pbnRFcXVhbChwb2ludDAsIHBvaW50MSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQxWzBdLCBwb2ludDFbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvaW50MCA9IHBvaW50MSwgdjAgPSB2LCBjMCA9IGM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2MClcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBSZWpvaW4gZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHMgaWYgdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zIGFuZCB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICAvLyBhbmQgbGFzdCBwb2ludHMgd2VyZSB2aXNpYmxlLlxuICAgICAgICAgICAgICAgIGNsZWFuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGVhbiB8ICgodjAwICYmIHYwKSA8PCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEludGVyc2VjdHMgdGhlIGdyZWF0IGNpcmNsZSBiZXR3ZWVuIGEgYW5kIGIgd2l0aCB0aGUgY2xpcCBjaXJjbGUuXG4gICAgICAgIGZ1bmN0aW9uIGludGVyc2VjdChhLCBiLCB0d28pIHtcbiAgICAgICAgICAgIHZhciBwYSA9IGNhcnRlc2lhbihhKSwgcGIgPSBjYXJ0ZXNpYW4oYik7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHR3byBwbGFuZXMsIG4xLnAgPSBkMSBhbmQgbjIucCA9IGQyLlxuICAgICAgICAgICAgLy8gRmluZCBpbnRlcnNlY3Rpb24gbGluZSBwKHQpID0gYzEgbjEgKyBjMiBuMiArIHQgKG4xIOKoryBuMikuXG4gICAgICAgICAgICB2YXIgbjEgPSBbMSwgMCwgMF0sIC8vIG5vcm1hbFxuICAgICAgICAgICAgbjIgPSBjYXJ0ZXNpYW5Dcm9zcyhwYSwgcGIpLCBuMm4yID0gY2FydGVzaWFuRG90KG4yLCBuMiksIG4xbjIgPSBuMlswXSwgLy8gY2FydGVzaWFuRG90KG4xLCBuMiksXG4gICAgICAgICAgICBkZXRlcm1pbmFudCA9IG4ybjIgLSBuMW4yICogbjFuMjtcbiAgICAgICAgICAgIC8vIFR3byBwb2xhciBwb2ludHMuXG4gICAgICAgICAgICBpZiAoIWRldGVybWluYW50KVxuICAgICAgICAgICAgICAgIHJldHVybiAhdHdvICYmIGE7XG4gICAgICAgICAgICB2YXIgYzEgPSBjciAqIG4ybjIgLyBkZXRlcm1pbmFudCwgYzIgPSAtY3IgKiBuMW4yIC8gZGV0ZXJtaW5hbnQsIG4xeG4yID0gY2FydGVzaWFuQ3Jvc3MobjEsIG4yKSwgQSA9IGNhcnRlc2lhblNjYWxlKG4xLCBjMSksIEIgPSBjYXJ0ZXNpYW5TY2FsZShuMiwgYzIpO1xuICAgICAgICAgICAgY2FydGVzaWFuQWRkSW5QbGFjZShBLCBCKTtcbiAgICAgICAgICAgIC8vIFNvbHZlIHxwKHQpfF4yID0gMS5cbiAgICAgICAgICAgIHZhciB1ID0gbjF4bjIsIHcgPSBjYXJ0ZXNpYW5Eb3QoQSwgdSksIHV1ID0gY2FydGVzaWFuRG90KHUsIHUpLCB0MiA9IHcgKiB3IC0gdXUgKiAoY2FydGVzaWFuRG90KEEsIEEpIC0gMSk7XG4gICAgICAgICAgICBpZiAodDIgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciB0ID0gc3FydCh0MiksIHEgPSBjYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgLSB0KSAvIHV1KTtcbiAgICAgICAgICAgIGNhcnRlc2lhbkFkZEluUGxhY2UocSwgQSk7XG4gICAgICAgICAgICBxID0gc3BoZXJpY2FsKHEpO1xuICAgICAgICAgICAgaWYgKCF0d28pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHE7XG4gICAgICAgICAgICAvLyBUd28gaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgICAgICAgICAgIHZhciBsYW1iZGEwID0gYVswXSwgbGFtYmRhMSA9IGJbMF0sIHBoaTAgPSBhWzFdLCBwaGkxID0gYlsxXSwgejtcbiAgICAgICAgICAgIGlmIChsYW1iZGExIDwgbGFtYmRhMClcbiAgICAgICAgICAgICAgICB6ID0gbGFtYmRhMCwgbGFtYmRhMCA9IGxhbWJkYTEsIGxhbWJkYTEgPSB6O1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gbGFtYmRhMSAtIGxhbWJkYTAsIHBvbGFyID0gYWJzKGRlbHRhIC0gcGkpIDwgZXBzaWxvbiwgbWVyaWRpYW4gPSBwb2xhciB8fCBkZWx0YSA8IGVwc2lsb247XG4gICAgICAgICAgICBpZiAoIXBvbGFyICYmIHBoaTEgPCBwaGkwKVxuICAgICAgICAgICAgICAgIHogPSBwaGkwLCBwaGkwID0gcGhpMSwgcGhpMSA9IHo7XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBmaXJzdCBwb2ludCBpcyBiZXR3ZWVuIGEgYW5kIGIuXG4gICAgICAgICAgICBpZiAobWVyaWRpYW5cbiAgICAgICAgICAgICAgICA/IHBvbGFyXG4gICAgICAgICAgICAgICAgICAgID8gcGhpMCArIHBoaTEgPiAwIF4gcVsxXSA8IChhYnMocVswXSAtIGxhbWJkYTApIDwgZXBzaWxvbiA/IHBoaTAgOiBwaGkxKVxuICAgICAgICAgICAgICAgICAgICA6IHBoaTAgPD0gcVsxXSAmJiBxWzFdIDw9IHBoaTFcbiAgICAgICAgICAgICAgICA6IGRlbHRhID4gcGkgXiAobGFtYmRhMCA8PSBxWzBdICYmIHFbMF0gPD0gbGFtYmRhMSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcTEgPSBjYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgKyB0KSAvIHV1KTtcbiAgICAgICAgICAgICAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKHExLCBBKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3EsIHNwaGVyaWNhbChxMSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEdlbmVyYXRlcyBhIDQtYml0IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2F0aW9uIG9mIGEgcG9pbnQgcmVsYXRpdmUgdG9cbiAgICAgICAgLy8gdGhlIHNtYWxsIGNpcmNsZSdzIGJvdW5kaW5nIGJveC5cbiAgICAgICAgZnVuY3Rpb24gY29kZShsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIHIgPSBzbWFsbFJhZGl1cyA/IHJhZGl1cyA6IHBpIC0gcmFkaXVzLCBjb2RlID0gMDtcbiAgICAgICAgICAgIGlmIChsYW1iZGEgPCAtcilcbiAgICAgICAgICAgICAgICBjb2RlIHw9IDE7IC8vIGxlZnRcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbWJkYSA+IHIpXG4gICAgICAgICAgICAgICAgY29kZSB8PSAyOyAvLyByaWdodFxuICAgICAgICAgICAgaWYgKHBoaSA8IC1yKVxuICAgICAgICAgICAgICAgIGNvZGUgfD0gNDsgLy8gYmVsb3dcbiAgICAgICAgICAgIGVsc2UgaWYgKHBoaSA+IHIpXG4gICAgICAgICAgICAgICAgY29kZSB8PSA4OyAvLyBhYm92ZVxuICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsaXAodmlzaWJsZSwgY2xpcExpbmUsIGludGVycG9sYXRlLCBzbWFsbFJhZGl1cyA/IFswLCAtcmFkaXVzXSA6IFstcGksIHJhZGl1cyAtIHBpXSk7XG4gICAgfTtcbiAgICB2YXIgdHJhbnNmb3JtID0gZnVuY3Rpb24gKG1ldGhvZHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0cmVhbTogdHJhbnNmb3JtZXIobWV0aG9kcylcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybWVyKG1ldGhvZHMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBzID0gbmV3IFRyYW5zZm9ybVN0cmVhbTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKVxuICAgICAgICAgICAgICAgIHNba2V5XSA9IG1ldGhvZHNba2V5XTtcbiAgICAgICAgICAgIHMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbSgpIHsgfVxuICAgIFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm1TdHJlYW0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyB0aGlzLnN0cmVhbS5wb2ludCh4LCB5KTsgfSxcbiAgICAgICAgc3BoZXJlOiBmdW5jdGlvbiAoKSB7IHRoaXMuc3RyZWFtLnNwaGVyZSgpOyB9LFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5zdHJlYW0ubGluZVN0YXJ0KCk7IH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5zdHJlYW0ubGluZUVuZCgpOyB9LFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5zdHJlYW0ucG9seWdvblN0YXJ0KCk7IH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5zdHJlYW0ucG9seWdvbkVuZCgpOyB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgdmFyIHcgPSBleHRlbnRbMV1bMF0gLSBleHRlbnRbMF1bMF0sIGggPSBleHRlbnRbMV1bMV0gLSBleHRlbnRbMF1bMV0sIGNsaXAgPSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgJiYgcHJvamVjdGlvbi5jbGlwRXh0ZW50KCk7XG4gICAgICAgIHByb2plY3Rpb25cbiAgICAgICAgICAgIC5zY2FsZSgxNTApXG4gICAgICAgICAgICAudHJhbnNsYXRlKFswLCAwXSk7XG4gICAgICAgIGlmIChjbGlwICE9IG51bGwpXG4gICAgICAgICAgICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQobnVsbCk7XG4gICAgICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb24uc3RyZWFtKGJvdW5kc1N0cmVhbSQxKSk7XG4gICAgICAgIHZhciBiID0gYm91bmRzU3RyZWFtJDEucmVzdWx0KCksIGsgPSBNYXRoLm1pbih3IC8gKGJbMV1bMF0gLSBiWzBdWzBdKSwgaCAvIChiWzFdWzFdIC0gYlswXVsxXSkpLCB4ID0gK2V4dGVudFswXVswXSArICh3IC0gayAqIChiWzFdWzBdICsgYlswXVswXSkpIC8gMiwgeSA9ICtleHRlbnRbMF1bMV0gKyAoaCAtIGsgKiAoYlsxXVsxXSArIGJbMF1bMV0pKSAvIDI7XG4gICAgICAgIGlmIChjbGlwICE9IG51bGwpXG4gICAgICAgICAgICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQoY2xpcCk7XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uXG4gICAgICAgICAgICAuc2NhbGUoayAqIDE1MClcbiAgICAgICAgICAgIC50cmFuc2xhdGUoW3gsIHldKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZpdEV4dGVudChwcm9qZWN0aW9uLCBbWzAsIDBdLCBzaXplXSwgb2JqZWN0KTtcbiAgICB9XG4gICAgdmFyIG1heERlcHRoID0gMTY7XG4gICAgdmFyIGNvc01pbkRpc3RhbmNlID0gY29zKDMwICogcmFkaWFucyk7IC8vIGNvcyhtaW5pbXVtIGFuZ3VsYXIgZGlzdGFuY2UpXG4gICAgdmFyIHJlc2FtcGxlID0gZnVuY3Rpb24gKHByb2plY3QsIGRlbHRhMikge1xuICAgICAgICByZXR1cm4gK2RlbHRhMiA/IHJlc2FtcGxlJDEocHJvamVjdCwgZGVsdGEyKSA6IHJlc2FtcGxlTm9uZShwcm9qZWN0KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlc2FtcGxlTm9uZShwcm9qZWN0KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcih7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2FtcGxlJDEocHJvamVjdCwgZGVsdGEyKSB7XG4gICAgICAgIGZ1bmN0aW9uIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDEsIHkxLCBsYW1iZGExLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgZHggPSB4MSAtIHgwLCBkeSA9IHkxIC0geTAsIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgICAgICBpZiAoZDIgPiA0ICogZGVsdGEyICYmIGRlcHRoLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGEwICsgYTEsIGIgPSBiMCArIGIxLCBjID0gYzAgKyBjMSwgbSA9IHNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSwgcGhpMiA9IGFzaW4oYyAvPSBtKSwgbGFtYmRhMiA9IGFicyhhYnMoYykgLSAxKSA8IGVwc2lsb24gfHwgYWJzKGxhbWJkYTAgLSBsYW1iZGExKSA8IGVwc2lsb24gPyAobGFtYmRhMCArIGxhbWJkYTEpIC8gMiA6IGF0YW4yKGIsIGEpLCBwID0gcHJvamVjdChsYW1iZGEyLCBwaGkyKSwgeDIgPSBwWzBdLCB5MiA9IHBbMV0sIGR4MiA9IHgyIC0geDAsIGR5MiA9IHkyIC0geTAsIGR6ID0gZHkgKiBkeDIgLSBkeCAqIGR5MjtcbiAgICAgICAgICAgICAgICBpZiAoZHogKiBkeiAvIGQyID4gZGVsdGEyIC8vIHBlcnBlbmRpY3VsYXIgcHJvamVjdGVkIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIHx8IGFicygoZHggKiBkeDIgKyBkeSAqIGR5MikgLyBkMiAtIDAuNSkgPiAwLjMgLy8gbWlkcG9pbnQgY2xvc2UgdG8gYW4gZW5kXG4gICAgICAgICAgICAgICAgICAgIHx8IGEwICogYTEgKyBiMCAqIGIxICsgYzAgKiBjMSA8IGNvc01pbkRpc3RhbmNlKSB7IC8vIGFuZ3VsYXIgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MiwgeTIsIGxhbWJkYTIsIGEgLz0gbSwgYiAvPSBtLCBjLCBkZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHgyLCB5Mik7XG4gICAgICAgICAgICAgICAgICAgIHJlc2FtcGxlTGluZVRvKHgyLCB5MiwgbGFtYmRhMiwgYSwgYiwgYywgeDEsIHkxLCBsYW1iZGExLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBsYW1iZGEwMCwgeDAwLCB5MDAsIGEwMCwgYjAwLCBjMDAsIC8vIGZpcnN0IHBvaW50XG4gICAgICAgICAgICBsYW1iZGEwLCB4MCwgeTAsIGEwLCBiMCwgYzA7IC8vIHByZXZpb3VzIHBvaW50XG4gICAgICAgICAgICB2YXIgcmVzYW1wbGVTdHJlYW0gPSB7XG4gICAgICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICAgICAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IHN0cmVhbS5wb2x5Z29uU3RhcnQoKTsgcmVzYW1wbGVTdHJlYW0ubGluZVN0YXJ0ID0gcmluZ1N0YXJ0OyB9LFxuICAgICAgICAgICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgc3RyZWFtLnBvbHlnb25FbmQoKTsgcmVzYW1wbGVTdHJlYW0ubGluZVN0YXJ0ID0gbGluZVN0YXJ0OyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgICAgICAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgICAgICAgICAgICB4MCA9IE5hTjtcbiAgICAgICAgICAgICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBsaW5lUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGNhcnRlc2lhbihbbGFtYmRhLCBwaGldKSwgcCA9IHByb2plY3QobGFtYmRhLCBwaGkpO1xuICAgICAgICAgICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDAgPSBwWzBdLCB5MCA9IHBbMV0sIGxhbWJkYTAgPSBsYW1iZGEsIGEwID0gY1swXSwgYjAgPSBjWzFdLCBjMCA9IGNbMl0sIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh4MCwgeTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgICAgICAgICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSByaW5nUG9pbnQ7XG4gICAgICAgICAgICAgICAgcmVzYW1wbGVTdHJlYW0ubGluZUVuZCA9IHJpbmdFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiByaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgICAgICBsaW5lUG9pbnQobGFtYmRhMDAgPSBsYW1iZGEsIHBoaSksIHgwMCA9IHgwLCB5MDAgPSB5MCwgYTAwID0gYTAsIGIwMCA9IGIwLCBjMDAgPSBjMDtcbiAgICAgICAgICAgICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICAgICAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MDAsIHkwMCwgbGFtYmRhMDAsIGEwMCwgYjAwLCBjMDAsIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHJlc2FtcGxlU3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICAgICAgICAgIGxpbmVFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNhbXBsZVN0cmVhbTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHRyYW5zZm9ybVJhZGlhbnMgPSB0cmFuc2Zvcm1lcih7XG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ucG9pbnQoeCAqIHJhZGlhbnMsIHkgKiByYWRpYW5zKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHByb2plY3Rpb24ocHJvamVjdCkge1xuICAgICAgICByZXR1cm4gcHJvamVjdGlvbk11dGF0b3IoZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvamVjdDsgfSkoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSB7XG4gICAgICAgIHZhciBwcm9qZWN0LCBrID0gMTUwLCAvLyBzY2FsZVxuICAgICAgICB4ID0gNDgwLCB5ID0gMjUwLCAvLyB0cmFuc2xhdGVcbiAgICAgICAgZHgsIGR5LCBsYW1iZGEgPSAwLCBwaGkgPSAwLCAvLyBjZW50ZXJcbiAgICAgICAgZGVsdGFMYW1iZGEgPSAwLCBkZWx0YVBoaSA9IDAsIGRlbHRhR2FtbWEgPSAwLCByb3RhdGUsIHByb2plY3RSb3RhdGUsIC8vIHJvdGF0ZVxuICAgICAgICB0aGV0YSA9IG51bGwsIHByZWNsaXAgPSBjbGlwQW50aW1lcmlkaWFuLCAvLyBjbGlwIGFuZ2xlXG4gICAgICAgIHgwID0gbnVsbCwgeTAsIHgxLCB5MSwgcG9zdGNsaXAgPSBpZGVudGl0eSwgLy8gY2xpcCBleHRlbnRcbiAgICAgICAgZGVsdGEyID0gMC41LCBwcm9qZWN0UmVzYW1wbGUgPSByZXNhbXBsZShwcm9qZWN0VHJhbnNmb3JtLCBkZWx0YTIpLCAvLyBwcmVjaXNpb25cbiAgICAgICAgY2FjaGUsIGNhY2hlU3RyZWFtO1xuICAgICAgICBmdW5jdGlvbiBwcm9qZWN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICBwb2ludCA9IHByb2plY3RSb3RhdGUocG9pbnRbMF0gKiByYWRpYW5zLCBwb2ludFsxXSAqIHJhZGlhbnMpO1xuICAgICAgICAgICAgcmV0dXJuIFtwb2ludFswXSAqIGsgKyBkeCwgZHkgLSBwb2ludFsxXSAqIGtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGludmVydChwb2ludCkge1xuICAgICAgICAgICAgcG9pbnQgPSBwcm9qZWN0Um90YXRlLmludmVydCgocG9pbnRbMF0gLSBkeCkgLyBrLCAoZHkgLSBwb2ludFsxXSkgLyBrKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludCAmJiBbcG9pbnRbMF0gKiBkZWdyZWVzLCBwb2ludFsxXSAqIGRlZ3JlZXNdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByb2plY3RUcmFuc2Zvcm0oeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHggPSBwcm9qZWN0KHgsIHkpLCBbeFswXSAqIGsgKyBkeCwgZHkgLSB4WzFdICoga107XG4gICAgICAgIH1cbiAgICAgICAgcHJvamVjdGlvbi5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSB0cmFuc2Zvcm1SYWRpYW5zKHByZWNsaXAocm90YXRlLCBwcm9qZWN0UmVzYW1wbGUocG9zdGNsaXAoY2FjaGVTdHJlYW0gPSBzdHJlYW0pKSkpO1xuICAgICAgICB9O1xuICAgICAgICBwcm9qZWN0aW9uLmNsaXBBbmdsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjbGlwID0gK18gPyBjbGlwQ2lyY2xlKHRoZXRhID0gXyAqIHJhZGlhbnMsIDYgKiByYWRpYW5zKSA6ICh0aGV0YSA9IG51bGwsIGNsaXBBbnRpbWVyaWRpYW4pLCByZXNldCgpKSA6IHRoZXRhICogZGVncmVlcztcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5jbGlwRXh0ZW50ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXyA9PSBudWxsID8gKHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgaWRlbnRpdHkpIDogY2xpcEV4dGVudCh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdKSwgcmVzZXQoKSkgOiB4MCA9PSBudWxsID8gbnVsbCA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgICAgICB9O1xuICAgICAgICBwcm9qZWN0aW9uLnNjYWxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGsgPSArXywgcmVjZW50ZXIoKSkgOiBrO1xuICAgICAgICB9O1xuICAgICAgICBwcm9qZWN0aW9uLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK19bMF0sIHkgPSArX1sxXSwgcmVjZW50ZXIoKSkgOiBbeCwgeV07XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3Rpb24uY2VudGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGxhbWJkYSA9IF9bMF0gJSAzNjAgKiByYWRpYW5zLCBwaGkgPSBfWzFdICUgMzYwICogcmFkaWFucywgcmVjZW50ZXIoKSkgOiBbbGFtYmRhICogZGVncmVlcywgcGhpICogZGVncmVlc107XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3Rpb24ucm90YXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlbHRhTGFtYmRhID0gX1swXSAlIDM2MCAqIHJhZGlhbnMsIGRlbHRhUGhpID0gX1sxXSAlIDM2MCAqIHJhZGlhbnMsIGRlbHRhR2FtbWEgPSBfLmxlbmd0aCA+IDIgPyBfWzJdICUgMzYwICogcmFkaWFucyA6IDAsIHJlY2VudGVyKCkpIDogW2RlbHRhTGFtYmRhICogZGVncmVlcywgZGVsdGFQaGkgKiBkZWdyZWVzLCBkZWx0YUdhbW1hICogZGVncmVlc107XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3Rpb24ucHJlY2lzaW9uID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByb2plY3RSZXNhbXBsZSA9IHJlc2FtcGxlKHByb2plY3RUcmFuc2Zvcm0sIGRlbHRhMiA9IF8gKiBfKSwgcmVzZXQoKSkgOiBzcXJ0KGRlbHRhMik7XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3Rpb24uZml0RXh0ZW50ID0gZnVuY3Rpb24gKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5maXRTaXplID0gZnVuY3Rpb24gKHNpemUsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gcmVjZW50ZXIoKSB7XG4gICAgICAgICAgICBwcm9qZWN0Um90YXRlID0gY29tcG9zZShyb3RhdGUgPSByb3RhdGVSYWRpYW5zKGRlbHRhTGFtYmRhLCBkZWx0YVBoaSwgZGVsdGFHYW1tYSksIHByb2plY3QpO1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHByb2plY3QobGFtYmRhLCBwaGkpO1xuICAgICAgICAgICAgZHggPSB4IC0gY2VudGVyWzBdICogaztcbiAgICAgICAgICAgIGR5ID0geSArIGNlbnRlclsxXSAqIGs7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHByb2plY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2plY3QgPSBwcm9qZWN0QXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHByb2plY3Rpb24uaW52ZXJ0ID0gcHJvamVjdC5pbnZlcnQgJiYgaW52ZXJ0O1xuICAgICAgICAgICAgcmV0dXJuIHJlY2VudGVyKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbmljUHJvamVjdGlvbihwcm9qZWN0QXQpIHtcbiAgICAgICAgdmFyIHBoaTAgPSAwLCBwaGkxID0gcGkgLyAzLCBtID0gcHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSwgcCA9IG0ocGhpMCwgcGhpMSk7XG4gICAgICAgIHAucGFyYWxsZWxzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gbShwaGkwID0gX1swXSAqIHJhZGlhbnMsIHBoaTEgPSBfWzFdICogcmFkaWFucykgOiBbcGhpMCAqIGRlZ3JlZXMsIHBoaTEgKiBkZWdyZWVzXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN5bGluZHJpY2FsRXF1YWxBcmVhUmF3KHBoaTApIHtcbiAgICAgICAgdmFyIGNvc1BoaTAgPSBjb3MocGhpMCk7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHJldHVybiBbbGFtYmRhICogY29zUGhpMCwgc2luKHBoaSkgLyBjb3NQaGkwXTtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gW3ggLyBjb3NQaGkwLCBhc2luKHkgKiBjb3NQaGkwKV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb25pY0VxdWFsQXJlYVJhdyh5MCwgeTEpIHtcbiAgICAgICAgdmFyIHN5MCA9IHNpbih5MCksIG4gPSAoc3kwICsgc2luKHkxKSkgLyAyO1xuICAgICAgICAvLyBBcmUgdGhlIHBhcmFsbGVscyBzeW1tZXRyaWNhbCBhcm91bmQgdGhlIEVxdWF0b3I/XG4gICAgICAgIGlmIChhYnMobikgPCBlcHNpbG9uKVxuICAgICAgICAgICAgcmV0dXJuIGN5bGluZHJpY2FsRXF1YWxBcmVhUmF3KHkwKTtcbiAgICAgICAgdmFyIGMgPSAxICsgc3kwICogKDIgKiBuIC0gc3kwKSwgcjAgPSBzcXJ0KGMpIC8gbjtcbiAgICAgICAgZnVuY3Rpb24gcHJvamVjdCh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgciA9IHNxcnQoYyAtIDIgKiBuICogc2luKHkpKSAvIG47XG4gICAgICAgICAgICByZXR1cm4gW3IgKiBzaW4oeCAqPSBuKSwgcjAgLSByICogY29zKHgpXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9qZWN0LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgcjB5ID0gcjAgLSB5O1xuICAgICAgICAgICAgcmV0dXJuIFthdGFuMih4LCBhYnMocjB5KSkgLyBuICogc2lnbihyMHkpLCBhc2luKChjIC0gKHggKiB4ICsgcjB5ICogcjB5KSAqIG4gKiBuKSAvICgyICogbikpXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByb2plY3Q7XG4gICAgfVxuICAgIHZhciBjb25pY0VxdWFsQXJlYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmljUHJvamVjdGlvbihjb25pY0VxdWFsQXJlYVJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNTUuNDI0KVxuICAgICAgICAgICAgLmNlbnRlcihbMCwgMzMuNjQ0Ml0pO1xuICAgIH07XG4gICAgdmFyIGFsYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmljRXF1YWxBcmVhKClcbiAgICAgICAgICAgIC5wYXJhbGxlbHMoWzI5LjUsIDQ1LjVdKVxuICAgICAgICAgICAgLnNjYWxlKDEwNzApXG4gICAgICAgICAgICAudHJhbnNsYXRlKFs0ODAsIDI1MF0pXG4gICAgICAgICAgICAucm90YXRlKFs5NiwgMF0pXG4gICAgICAgICAgICAuY2VudGVyKFstMC42LCAzOC43XSk7XG4gICAgfTtcbiAgICAvLyBUaGUgcHJvamVjdGlvbnMgbXVzdCBoYXZlIG11dHVhbGx5IGV4Y2x1c2l2ZSBjbGlwIHJlZ2lvbnMgb24gdGhlIHNwaGVyZSxcbiAgICAvLyBhcyB0aGlzIHdpbGwgYXZvaWQgZW1pdHRpbmcgaW50ZXJsZWF2aW5nIGxpbmVzIGFuZCBwb2x5Z29ucy5cbiAgICBmdW5jdGlvbiBtdWx0aXBsZXgoc3RyZWFtcykge1xuICAgICAgICB2YXIgbiA9IHN0cmVhbXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9pbnQoeCwgeSk7IH0sXG4gICAgICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5zcGhlcmUoKTsgfSxcbiAgICAgICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLmxpbmVTdGFydCgpOyB9LFxuICAgICAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLmxpbmVFbmQoKTsgfSxcbiAgICAgICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvbHlnb25TdGFydCgpOyB9LFxuICAgICAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvbHlnb25FbmQoKTsgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBIGNvbXBvc2l0ZSBwcm9qZWN0aW9uIGZvciB0aGUgVW5pdGVkIFN0YXRlcywgY29uZmlndXJlZCBieSBkZWZhdWx0IGZvclxuICAgIC8vIDk2MMOXNTAwLiBUaGUgcHJvamVjdGlvbiBhbHNvIHdvcmtzIHF1aXRlIHdlbGwgYXQgOTYww5c2MDAgaWYgeW91IGNoYW5nZSB0aGVcbiAgICAvLyBzY2FsZSB0byAxMjg1IGFuZCBhZGp1c3QgdGhlIHRyYW5zbGF0ZSBhY2NvcmRpbmdseS4gVGhlIHNldCBvZiBzdGFuZGFyZFxuICAgIC8vIHBhcmFsbGVscyBmb3IgZWFjaCByZWdpb24gY29tZXMgZnJvbSBVU0dTLCB3aGljaCBpcyBwdWJsaXNoZWQgaGVyZTpcbiAgICAvLyBodHRwOi8vZWdzYy51c2dzLmdvdi9pc2IvcHVicy9NYXBQcm9qZWN0aW9ucy9wcm9qZWN0aW9ucy5odG1sI2FsYmVyc1xuICAgIHZhciBhbGJlcnNVc2EgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYWNoZSwgY2FjaGVTdHJlYW0sIGxvd2VyNDggPSBhbGJlcnMoKSwgbG93ZXI0OFBvaW50LCBhbGFza2EgPSBjb25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbMTU0LCAwXSkuY2VudGVyKFstMiwgNTguNV0pLnBhcmFsbGVscyhbNTUsIDY1XSksIGFsYXNrYVBvaW50LCAvLyBFUFNHOjMzMzhcbiAgICAgICAgaGF3YWlpID0gY29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWzE1NywgMF0pLmNlbnRlcihbLTMsIDE5LjldKS5wYXJhbGxlbHMoWzgsIDE4XSksIGhhd2FpaVBvaW50LCAvLyBFU1JJOjEwMjAwN1xuICAgICAgICBwb2ludCwgcG9pbnRTdHJlYW0gPSB7IHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyBwb2ludCA9IFt4LCB5XTsgfSB9O1xuICAgICAgICBmdW5jdGlvbiBhbGJlcnNVc2EoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciB4ID0gY29vcmRpbmF0ZXNbMF0sIHkgPSBjb29yZGluYXRlc1sxXTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludCA9IG51bGwsXG4gICAgICAgICAgICAgICAgKGxvd2VyNDhQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIHx8IChhbGFza2FQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIHx8IChoYXdhaWlQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGFsYmVyc1VzYS5pbnZlcnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLCB0ID0gbG93ZXI0OC50cmFuc2xhdGUoKSwgeCA9IChjb29yZGluYXRlc1swXSAtIHRbMF0pIC8gaywgeSA9IChjb29yZGluYXRlc1sxXSAtIHRbMV0pIC8gaztcbiAgICAgICAgICAgIHJldHVybiAoeSA+PSAwLjEyMCAmJiB5IDwgMC4yMzQgJiYgeCA+PSAtMC40MjUgJiYgeCA8IC0wLjIxNCA/IGFsYXNrYVxuICAgICAgICAgICAgICAgIDogeSA+PSAwLjE2NiAmJiB5IDwgMC4yMzQgJiYgeCA+PSAtMC4yMTQgJiYgeCA8IC0wLjExNSA/IGhhd2FpaVxuICAgICAgICAgICAgICAgICAgICA6IGxvd2VyNDgpLmludmVydChjb29yZGluYXRlcyk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBtdWx0aXBsZXgoW2xvd2VyNDguc3RyZWFtKGNhY2hlU3RyZWFtID0gc3RyZWFtKSwgYWxhc2thLnN0cmVhbShzdHJlYW0pLCBoYXdhaWkuc3RyZWFtKHN0cmVhbSldKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLnByZWNpc2lvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvd2VyNDgucHJlY2lzaW9uKCk7XG4gICAgICAgICAgICBsb3dlcjQ4LnByZWNpc2lvbihfKSwgYWxhc2thLnByZWNpc2lvbihfKSwgaGF3YWlpLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2Euc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBsb3dlcjQ4LnNjYWxlKCk7XG4gICAgICAgICAgICBsb3dlcjQ4LnNjYWxlKF8pLCBhbGFza2Euc2NhbGUoXyAqIDAuMzUpLCBoYXdhaWkuc2NhbGUoXyk7XG4gICAgICAgICAgICByZXR1cm4gYWxiZXJzVXNhLnRyYW5zbGF0ZShsb3dlcjQ4LnRyYW5zbGF0ZSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvd2VyNDgudHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB2YXIgayA9IGxvd2VyNDguc2NhbGUoKSwgeCA9ICtfWzBdLCB5ID0gK19bMV07XG4gICAgICAgICAgICBsb3dlcjQ4UG9pbnQgPSBsb3dlcjQ4XG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShfKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuNDU1ICogaywgeSAtIDAuMjM4ICoga10sIFt4ICsgMC40NTUgKiBrLCB5ICsgMC4yMzggKiBrXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBhbGFza2FQb2ludCA9IGFsYXNrYVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjMwNyAqIGssIHkgKyAwLjIwMSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuNDI1ICogayArIGVwc2lsb24sIHkgKyAwLjEyMCAqIGsgKyBlcHNpbG9uXSwgW3ggLSAwLjIxNCAqIGsgLSBlcHNpbG9uLCB5ICsgMC4yMzQgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgaGF3YWlpUG9pbnQgPSBoYXdhaWlcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4yMDUgKiBrLCB5ICsgMC4yMTIgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjIxNCAqIGsgKyBlcHNpbG9uLCB5ICsgMC4xNjYgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4xMTUgKiBrIC0gZXBzaWxvbiwgeSArIDAuMjM0ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2EuZml0RXh0ZW50ID0gZnVuY3Rpb24gKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0RXh0ZW50KGFsYmVyc1VzYSwgZXh0ZW50LCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2EuZml0U2l6ZSA9IGZ1bmN0aW9uIChzaXplLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRTaXplKGFsYmVyc1VzYSwgc2l6ZSwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBhbGJlcnNVc2E7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsYmVyc1VzYS5zY2FsZSgxMDcwKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGF6aW11dGhhbFJhdyhzY2FsZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBjeCA9IGNvcyh4KSwgY3kgPSBjb3MoeSksIGsgPSBzY2FsZShjeCAqIGN5KTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgayAqIGN5ICogc2luKHgpLFxuICAgICAgICAgICAgICAgIGsgKiBzaW4oeSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF6aW11dGhhbEludmVydChhbmdsZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciB6ID0gc3FydCh4ICogeCArIHkgKiB5KSwgYyA9IGFuZ2xlKHopLCBzYyA9IHNpbihjKSwgY2MgPSBjb3MoYyk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGF0YW4yKHggKiBzYywgeiAqIGNjKSxcbiAgICAgICAgICAgICAgICBhc2luKHogJiYgeSAqIHNjIC8geilcbiAgICAgICAgICAgIF07XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBhemltdXRoYWxFcXVhbEFyZWFSYXcgPSBhemltdXRoYWxSYXcoZnVuY3Rpb24gKGN4Y3kpIHtcbiAgICAgICAgcmV0dXJuIHNxcnQoMiAvICgxICsgY3hjeSkpO1xuICAgIH0pO1xuICAgIGF6aW11dGhhbEVxdWFsQXJlYVJhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoZnVuY3Rpb24gKHopIHtcbiAgICAgICAgcmV0dXJuIDIgKiBhc2luKHogLyAyKTtcbiAgICB9KTtcbiAgICB2YXIgYXppbXV0aGFsRXF1YWxBcmVhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvamVjdGlvbihhemltdXRoYWxFcXVhbEFyZWFSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTI0Ljc1KVxuICAgICAgICAgICAgLmNsaXBBbmdsZSgxODAgLSAxZS0zKTtcbiAgICB9O1xuICAgIHZhciBhemltdXRoYWxFcXVpZGlzdGFudFJhdyA9IGF6aW11dGhhbFJhdyhmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gKGMgPSBhY29zKGMpKSAmJiBjIC8gc2luKGMpO1xuICAgIH0pO1xuICAgIGF6aW11dGhhbEVxdWlkaXN0YW50UmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChmdW5jdGlvbiAoeikge1xuICAgICAgICByZXR1cm4gejtcbiAgICB9KTtcbiAgICB2YXIgYXppbXV0aGFsRXF1aWRpc3RhbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uKGF6aW11dGhhbEVxdWlkaXN0YW50UmF3KVxuICAgICAgICAgICAgLnNjYWxlKDc5LjQxODgpXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDE4MCAtIDFlLTMpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbWVyY2F0b3JSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgcmV0dXJuIFtsYW1iZGEsIGxvZyh0YW4oKGhhbGZQaSArIHBoaSkgLyAyKSldO1xuICAgIH1cbiAgICBtZXJjYXRvclJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gW3gsIDIgKiBhdGFuKGV4cCh5KSkgLSBoYWxmUGldO1xuICAgIH07XG4gICAgdmFyIG1lcmNhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbWVyY2F0b3JQcm9qZWN0aW9uKG1lcmNhdG9yUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDk2MSAvIHRhdSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBtZXJjYXRvclByb2plY3Rpb24ocHJvamVjdCkge1xuICAgICAgICB2YXIgbSA9IHByb2plY3Rpb24ocHJvamVjdCksIGNlbnRlciA9IG0uY2VudGVyLCBzY2FsZSA9IG0uc2NhbGUsIHRyYW5zbGF0ZSA9IG0udHJhbnNsYXRlLCBjbGlwRXh0ZW50ID0gbS5jbGlwRXh0ZW50LCB4MCA9IG51bGwsIHkwLCB4MSwgeTE7IC8vIGNsaXAgZXh0ZW50XG4gICAgICAgIG0uc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2NhbGUoXyksIHJlY2xpcCgpKSA6IHNjYWxlKCk7XG4gICAgICAgIH07XG4gICAgICAgIG0udHJhbnNsYXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zbGF0ZShfKSwgcmVjbGlwKCkpIDogdHJhbnNsYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIG0uY2VudGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNlbnRlcihfKSwgcmVjbGlwKCkpIDogY2VudGVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIG0uY2xpcEV4dGVudCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoXyA9PSBudWxsID8geDAgPSB5MCA9IHgxID0geTEgPSBudWxsIDogKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pKSwgcmVjbGlwKCkpIDogeDAgPT0gbnVsbCA/IG51bGwgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gcmVjbGlwKCkge1xuICAgICAgICAgICAgdmFyIGsgPSBwaSAqIHNjYWxlKCksIHQgPSBtKHJvdGF0aW9uKG0ucm90YXRlKCkpLmludmVydChbMCwgMF0pKTtcbiAgICAgICAgICAgIHJldHVybiBjbGlwRXh0ZW50KHgwID09IG51bGxcbiAgICAgICAgICAgICAgICA/IFtbdFswXSAtIGssIHRbMV0gLSBrXSwgW3RbMF0gKyBrLCB0WzFdICsga11dIDogcHJvamVjdCA9PT0gbWVyY2F0b3JSYXdcbiAgICAgICAgICAgICAgICA/IFtbTWF0aC5tYXgodFswXSAtIGssIHgwKSwgeTBdLCBbTWF0aC5taW4odFswXSArIGssIHgxKSwgeTFdXVxuICAgICAgICAgICAgICAgIDogW1t4MCwgTWF0aC5tYXgodFsxXSAtIGssIHkwKV0sIFt4MSwgTWF0aC5taW4odFsxXSArIGssIHkxKV1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjbGlwKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRhbnkoeSkge1xuICAgICAgICByZXR1cm4gdGFuKChoYWxmUGkgKyB5KSAvIDIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb25pY0NvbmZvcm1hbFJhdyh5MCwgeTEpIHtcbiAgICAgICAgdmFyIGN5MCA9IGNvcyh5MCksIG4gPSB5MCA9PT0geTEgPyBzaW4oeTApIDogbG9nKGN5MCAvIGNvcyh5MSkpIC8gbG9nKHRhbnkoeTEpIC8gdGFueSh5MCkpLCBmID0gY3kwICogcG93KHRhbnkoeTApLCBuKSAvIG47XG4gICAgICAgIGlmICghbilcbiAgICAgICAgICAgIHJldHVybiBtZXJjYXRvclJhdztcbiAgICAgICAgZnVuY3Rpb24gcHJvamVjdCh4LCB5KSB7XG4gICAgICAgICAgICBpZiAoZiA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoeSA8IC1oYWxmUGkgKyBlcHNpbG9uKVxuICAgICAgICAgICAgICAgICAgICB5ID0gLWhhbGZQaSArIGVwc2lsb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoeSA+IGhhbGZQaSAtIGVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgIHkgPSBoYWxmUGkgLSBlcHNpbG9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHIgPSBmIC8gcG93KHRhbnkoeSksIG4pO1xuICAgICAgICAgICAgcmV0dXJuIFtyICogc2luKG4gKiB4KSwgZiAtIHIgKiBjb3MobiAqIHgpXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9qZWN0LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgZnkgPSBmIC0geSwgciA9IHNpZ24obikgKiBzcXJ0KHggKiB4ICsgZnkgKiBmeSk7XG4gICAgICAgICAgICByZXR1cm4gW2F0YW4yKHgsIGFicyhmeSkpIC8gbiAqIHNpZ24oZnkpLCAyICogYXRhbihwb3coZiAvIHIsIDEgLyBuKSkgLSBoYWxmUGldO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJvamVjdDtcbiAgICB9XG4gICAgdmFyIGNvbmljQ29uZm9ybWFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29uaWNQcm9qZWN0aW9uKGNvbmljQ29uZm9ybWFsUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDEwOS41KVxuICAgICAgICAgICAgLnBhcmFsbGVscyhbMzAsIDMwXSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBlcXVpcmVjdGFuZ3VsYXJSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgcmV0dXJuIFtsYW1iZGEsIHBoaV07XG4gICAgfVxuICAgIGVxdWlyZWN0YW5ndWxhclJhdy5pbnZlcnQgPSBlcXVpcmVjdGFuZ3VsYXJSYXc7XG4gICAgdmFyIGVxdWlyZWN0YW5ndWxhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb2plY3Rpb24oZXF1aXJlY3Rhbmd1bGFyUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE1Mi42Myk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjb25pY0VxdWlkaXN0YW50UmF3KHkwLCB5MSkge1xuICAgICAgICB2YXIgY3kwID0gY29zKHkwKSwgbiA9IHkwID09PSB5MSA/IHNpbih5MCkgOiAoY3kwIC0gY29zKHkxKSkgLyAoeTEgLSB5MCksIGcgPSBjeTAgLyBuICsgeTA7XG4gICAgICAgIGlmIChhYnMobikgPCBlcHNpbG9uKVxuICAgICAgICAgICAgcmV0dXJuIGVxdWlyZWN0YW5ndWxhclJhdztcbiAgICAgICAgZnVuY3Rpb24gcHJvamVjdCh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgZ3kgPSBnIC0geSwgbnggPSBuICogeDtcbiAgICAgICAgICAgIHJldHVybiBbZ3kgKiBzaW4obngpLCBnIC0gZ3kgKiBjb3MobngpXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9qZWN0LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgZ3kgPSBnIC0geTtcbiAgICAgICAgICAgIHJldHVybiBbYXRhbjIoeCwgYWJzKGd5KSkgLyBuICogc2lnbihneSksIGcgLSBzaWduKG4pICogc3FydCh4ICogeCArIGd5ICogZ3kpXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByb2plY3Q7XG4gICAgfVxuICAgIHZhciBjb25pY0VxdWlkaXN0YW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29uaWNQcm9qZWN0aW9uKGNvbmljRXF1aWRpc3RhbnRSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTMxLjE1NClcbiAgICAgICAgICAgIC5jZW50ZXIoWzAsIDEzLjkzODldKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdub21vbmljUmF3KHgsIHkpIHtcbiAgICAgICAgdmFyIGN5ID0gY29zKHkpLCBrID0gY29zKHgpICogY3k7XG4gICAgICAgIHJldHVybiBbY3kgKiBzaW4oeCkgLyBrLCBzaW4oeSkgLyBrXTtcbiAgICB9XG4gICAgZ25vbW9uaWNSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGF0YW4pO1xuICAgIHZhciBnbm9tb25pYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb2plY3Rpb24oZ25vbW9uaWNSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTQ0LjA0OSlcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoNjApO1xuICAgIH07XG4gICAgZnVuY3Rpb24gc2NhbGVUcmFuc2xhdGUoa3gsIGt5LCB0eCwgdHkpIHtcbiAgICAgICAgcmV0dXJuIGt4ID09PSAxICYmIGt5ID09PSAxICYmIHR4ID09PSAwICYmIHR5ID09PSAwID8gaWRlbnRpdHkgOiB0cmFuc2Zvcm1lcih7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5wb2ludCh4ICoga3ggKyB0eCwgeSAqIGt5ICsgdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGlkZW50aXR5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrID0gMSwgdHggPSAwLCB0eSA9IDAsIHN4ID0gMSwgc3kgPSAxLCB0cmFuc2Zvcm0gPSBpZGVudGl0eSwgLy8gc2NhbGUsIHRyYW5zbGF0ZSBhbmQgcmVmbGVjdFxuICAgICAgICB4MCA9IG51bGwsIHkwLCB4MSwgeTEsIGNsaXAgPSBpZGVudGl0eSwgLy8gY2xpcCBleHRlbnRcbiAgICAgICAgY2FjaGUsIGNhY2hlU3RyZWFtLCBwcm9qZWN0aW9uO1xuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHByb2plY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2plY3Rpb24gPSB7XG4gICAgICAgICAgICBzdHJlYW06IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSB0cmFuc2Zvcm0oY2xpcChjYWNoZVN0cmVhbSA9IHN0cmVhbSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsaXBFeHRlbnQ6IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xpcCA9IF8gPT0gbnVsbCA/ICh4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIGlkZW50aXR5KSA6IGNsaXBFeHRlbnQoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSksIHJlc2V0KCkpIDogeDAgPT0gbnVsbCA/IG51bGwgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY2FsZTogZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2Zvcm0gPSBzY2FsZVRyYW5zbGF0ZSgoayA9ICtfKSAqIHN4LCBrICogc3ksIHR4LCB0eSksIHJlc2V0KCkpIDogaztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtID0gc2NhbGVUcmFuc2xhdGUoayAqIHN4LCBrICogc3ksIHR4ID0gK19bMF0sIHR5ID0gK19bMV0pLCByZXNldCgpKSA6IFt0eCwgdHldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZmxlY3RYOiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zZm9ybSA9IHNjYWxlVHJhbnNsYXRlKGsgKiAoc3ggPSBfID8gLTEgOiAxKSwgayAqIHN5LCB0eCwgdHkpLCByZXNldCgpKSA6IHN4IDwgMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWZsZWN0WTogZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2Zvcm0gPSBzY2FsZVRyYW5zbGF0ZShrICogc3gsIGsgKiAoc3kgPSBfID8gLTEgOiAxKSwgdHgsIHR5KSwgcmVzZXQoKSkgOiBzeSA8IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml0RXh0ZW50OiBmdW5jdGlvbiAoZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXRTaXplOiBmdW5jdGlvbiAoc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG9ydGhvZ3JhcGhpY1Jhdyh4LCB5KSB7XG4gICAgICAgIHJldHVybiBbY29zKHkpICogc2luKHgpLCBzaW4oeSldO1xuICAgIH1cbiAgICBvcnRob2dyYXBoaWNSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGFzaW4pO1xuICAgIHZhciBvcnRob2dyYXBoaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uKG9ydGhvZ3JhcGhpY1JhdylcbiAgICAgICAgICAgIC5zY2FsZSgyNDkuNSlcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoOTAgKyBlcHNpbG9uKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHN0ZXJlb2dyYXBoaWNSYXcoeCwgeSkge1xuICAgICAgICB2YXIgY3kgPSBjb3MoeSksIGsgPSAxICsgY29zKHgpICogY3k7XG4gICAgICAgIHJldHVybiBbY3kgKiBzaW4oeCkgLyBrLCBzaW4oeSkgLyBrXTtcbiAgICB9XG4gICAgc3RlcmVvZ3JhcGhpY1Jhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoZnVuY3Rpb24gKHopIHtcbiAgICAgICAgcmV0dXJuIDIgKiBhdGFuKHopO1xuICAgIH0pO1xuICAgIHZhciBzdGVyZW9ncmFwaGljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvamVjdGlvbihzdGVyZW9ncmFwaGljUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDI1MClcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoMTQyKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHRyYW5zdmVyc2VNZXJjYXRvclJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICByZXR1cm4gW2xvZyh0YW4oKGhhbGZQaSArIHBoaSkgLyAyKSksIC1sYW1iZGFdO1xuICAgIH1cbiAgICB0cmFuc3ZlcnNlTWVyY2F0b3JSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIFsteSwgMiAqIGF0YW4oZXhwKHgpKSAtIGhhbGZQaV07XG4gICAgfTtcbiAgICB2YXIgdHJhbnN2ZXJzZU1lcmNhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IG1lcmNhdG9yUHJvamVjdGlvbih0cmFuc3ZlcnNlTWVyY2F0b3JSYXcpLCBjZW50ZXIgPSBtLmNlbnRlciwgcm90YXRlID0gbS5yb3RhdGU7XG4gICAgICAgIG0uY2VudGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gY2VudGVyKFstX1sxXSwgX1swXV0pIDogKF8gPSBjZW50ZXIoKSwgW19bMV0sIC1fWzBdXSk7XG4gICAgICAgIH07XG4gICAgICAgIG0ucm90YXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gcm90YXRlKFtfWzBdLCBfWzFdLCBfLmxlbmd0aCA+IDIgPyBfWzJdICsgOTAgOiA5MF0pIDogKF8gPSByb3RhdGUoKSwgW19bMF0sIF9bMV0sIF9bMl0gLSA5MF0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcm90YXRlKFswLCAwLCA5MF0pXG4gICAgICAgICAgICAuc2NhbGUoMTU5LjE1NSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmdlb0FyZWEgPSBhcmVhO1xuICAgIGV4cG9ydHMuZ2VvQm91bmRzID0gYm91bmRzO1xuICAgIGV4cG9ydHMuZ2VvQ2VudHJvaWQgPSBjZW50cm9pZDtcbiAgICBleHBvcnRzLmdlb0NpcmNsZSA9IGNpcmNsZTtcbiAgICBleHBvcnRzLmdlb0NsaXBFeHRlbnQgPSBleHRlbnQ7XG4gICAgZXhwb3J0cy5nZW9Db250YWlucyA9IGNvbnRhaW5zO1xuICAgIGV4cG9ydHMuZ2VvRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICBleHBvcnRzLmdlb0dyYXRpY3VsZSA9IGdyYXRpY3VsZTtcbiAgICBleHBvcnRzLmdlb0dyYXRpY3VsZTEwID0gZ3JhdGljdWxlMTA7XG4gICAgZXhwb3J0cy5nZW9JbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlO1xuICAgIGV4cG9ydHMuZ2VvTGVuZ3RoID0gbGVuZ3RoO1xuICAgIGV4cG9ydHMuZ2VvUGF0aCA9IGluZGV4O1xuICAgIGV4cG9ydHMuZ2VvQWxiZXJzID0gYWxiZXJzO1xuICAgIGV4cG9ydHMuZ2VvQWxiZXJzVXNhID0gYWxiZXJzVXNhO1xuICAgIGV4cG9ydHMuZ2VvQXppbXV0aGFsRXF1YWxBcmVhID0gYXppbXV0aGFsRXF1YWxBcmVhO1xuICAgIGV4cG9ydHMuZ2VvQXppbXV0aGFsRXF1YWxBcmVhUmF3ID0gYXppbXV0aGFsRXF1YWxBcmVhUmF3O1xuICAgIGV4cG9ydHMuZ2VvQXppbXV0aGFsRXF1aWRpc3RhbnQgPSBhemltdXRoYWxFcXVpZGlzdGFudDtcbiAgICBleHBvcnRzLmdlb0F6aW11dGhhbEVxdWlkaXN0YW50UmF3ID0gYXppbXV0aGFsRXF1aWRpc3RhbnRSYXc7XG4gICAgZXhwb3J0cy5nZW9Db25pY0NvbmZvcm1hbCA9IGNvbmljQ29uZm9ybWFsO1xuICAgIGV4cG9ydHMuZ2VvQ29uaWNDb25mb3JtYWxSYXcgPSBjb25pY0NvbmZvcm1hbFJhdztcbiAgICBleHBvcnRzLmdlb0NvbmljRXF1YWxBcmVhID0gY29uaWNFcXVhbEFyZWE7XG4gICAgZXhwb3J0cy5nZW9Db25pY0VxdWFsQXJlYVJhdyA9IGNvbmljRXF1YWxBcmVhUmF3O1xuICAgIGV4cG9ydHMuZ2VvQ29uaWNFcXVpZGlzdGFudCA9IGNvbmljRXF1aWRpc3RhbnQ7XG4gICAgZXhwb3J0cy5nZW9Db25pY0VxdWlkaXN0YW50UmF3ID0gY29uaWNFcXVpZGlzdGFudFJhdztcbiAgICBleHBvcnRzLmdlb0VxdWlyZWN0YW5ndWxhciA9IGVxdWlyZWN0YW5ndWxhcjtcbiAgICBleHBvcnRzLmdlb0VxdWlyZWN0YW5ndWxhclJhdyA9IGVxdWlyZWN0YW5ndWxhclJhdztcbiAgICBleHBvcnRzLmdlb0dub21vbmljID0gZ25vbW9uaWM7XG4gICAgZXhwb3J0cy5nZW9Hbm9tb25pY1JhdyA9IGdub21vbmljUmF3O1xuICAgIGV4cG9ydHMuZ2VvSWRlbnRpdHkgPSBpZGVudGl0eSQxO1xuICAgIGV4cG9ydHMuZ2VvUHJvamVjdGlvbiA9IHByb2plY3Rpb247XG4gICAgZXhwb3J0cy5nZW9Qcm9qZWN0aW9uTXV0YXRvciA9IHByb2plY3Rpb25NdXRhdG9yO1xuICAgIGV4cG9ydHMuZ2VvTWVyY2F0b3IgPSBtZXJjYXRvcjtcbiAgICBleHBvcnRzLmdlb01lcmNhdG9yUmF3ID0gbWVyY2F0b3JSYXc7XG4gICAgZXhwb3J0cy5nZW9PcnRob2dyYXBoaWMgPSBvcnRob2dyYXBoaWM7XG4gICAgZXhwb3J0cy5nZW9PcnRob2dyYXBoaWNSYXcgPSBvcnRob2dyYXBoaWNSYXc7XG4gICAgZXhwb3J0cy5nZW9TdGVyZW9ncmFwaGljID0gc3RlcmVvZ3JhcGhpYztcbiAgICBleHBvcnRzLmdlb1N0ZXJlb2dyYXBoaWNSYXcgPSBzdGVyZW9ncmFwaGljUmF3O1xuICAgIGV4cG9ydHMuZ2VvVHJhbnN2ZXJzZU1lcmNhdG9yID0gdHJhbnN2ZXJzZU1lcmNhdG9yO1xuICAgIGV4cG9ydHMuZ2VvVHJhbnN2ZXJzZU1lcmNhdG9yUmF3ID0gdHJhbnN2ZXJzZU1lcmNhdG9yUmF3O1xuICAgIGV4cG9ydHMuZ2VvUm90YXRpb24gPSByb3RhdGlvbjtcbiAgICBleHBvcnRzLmdlb1N0cmVhbSA9IGdlb1N0cmVhbTtcbiAgICBleHBvcnRzLmdlb1RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufSkpKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtaGV4anNvbkAxLjEuMEBkMy1oZXhqc29uL2J1aWxkL2QzLWhleGpzb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kMy1oZXhqc29uQDEuMS4wQGQzLWhleGpzb24vYnVpbGQvZDMtaGV4anNvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICAgdHJ1ZSA/IGZhY3RvcnkoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtYXJyYXlAMS4yLjRAZDMtYXJyYXkvZGlzdC9kMy1hcnJheS5qc1wiKSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLCBkM0FycmF5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIE1haW4gcmVuZGVyIG1ldGhvZFxuICAgIGZ1bmN0aW9uIHJlbmRlckhleEpTT04oaGV4anNvbiwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAvLyBHZXQgdGhlIGxheW91dFxuICAgICAgICB2YXIgbGF5b3V0ID0gaGV4anNvbi5sYXlvdXQ7XG4gICAgICAgIC8vIEdldCB0aGUgaGV4IG9iamVjdHMgYXMgYW4gYXJyYXlcbiAgICAgICAgdmFyIGhleGVzID0gW107XG4gICAgICAgIHZhciBoZXhSYWRpdXMgPSAwO1xuICAgICAgICBPYmplY3Qua2V5cyhoZXhqc29uLmhleGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGhleGpzb24uaGV4ZXNba2V5XS5rZXkgPSBrZXk7XG4gICAgICAgICAgICBoZXhlcy5wdXNoKGhleGpzb24uaGV4ZXNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zXG4gICAgICAgIHZhciBxbWF4ID0gZDNBcnJheS5tYXgoaGV4ZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiArZC5xOyB9KSwgcW1pbiA9IGQzQXJyYXkubWluKGhleGVzLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gK2QucTsgfSksIHJtYXggPSBkM0FycmF5Lm1heChoZXhlcywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuICtkLnI7IH0pLCBybWluID0gZDNBcnJheS5taW4oaGV4ZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiArZC5yOyB9KTtcbiAgICAgICAgdmFyIHFudW0gPSBxbWF4IC0gcW1pbiArIDEsIHJudW0gPSBybWF4IC0gcm1pbiArIDE7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBtYXhpbXVtIHJhZGl1cyB0aGUgaGV4YWdvbnMgY2FuIGhhdmUgdG8gZml0IHRoZSBzdmdcbiAgICAgICAgaWYgKGxheW91dCA9PT0gXCJvZGQtclwiIHx8IGxheW91dCA9PT0gXCJldmVuLXJcIikge1xuICAgICAgICAgICAgaGV4UmFkaXVzID0gZDNBcnJheS5taW4oWyh3aWR0aCkgLyAoKHFudW0gKyAwLjUpICogTWF0aC5zcXJ0KDMpKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgLyAoKHJudW0gKyAxIC8gMykgKiAxLjUpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZXhSYWRpdXMgPSBkM0FycmF5Lm1pbihbKGhlaWdodCkgLyAoKHJudW0gKyAwLjUpICogTWF0aC5zcXJ0KDMpKSxcbiAgICAgICAgICAgICAgICB3aWR0aCAvICgocW51bSArIDEgLyAzKSAqIDEuNSldKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGhleGFnb24gd2lkdGhcbiAgICAgICAgdmFyIGhleFdpZHRoID0gaGV4UmFkaXVzICogTWF0aC5zcXJ0KDMpO1xuICAgICAgICAvLyBHZXQgdGhlIHZlcnRpY2VzIGFuZCBwb2ludHMgZm9yIHRoaXMgbGF5b3V0XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGdldFZlcnRpY2VzKGxheW91dCwgaGV4V2lkdGgsIGhleFJhZGl1cyk7XG4gICAgICAgIHZhciBwb2ludHMgPSBnZXRQb2ludHModmVydGljZXMpO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHZhbHVlcyBuZWVkZWQgdG8gcmVuZGVyIGVhY2ggaGV4IGFuZCBhZGQgdG8gaGV4ZXNcbiAgICAgICAgaGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaGV4KSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGFic29sdXRlIGNvLW9yZGluYXRlcyBvZiBlYWNoIGhleFxuICAgICAgICAgICAgaGV4LnFjID0gaGV4LnEgLSBxbWluO1xuICAgICAgICAgICAgaGV4LnJjID0gcm1heCAtIGhleC5yO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB4IGFuZCB5IHBvc2l0aW9uIG9mIGVhY2ggaGV4IGZvciB0aGlzIHN2Z1xuICAgICAgICAgICAgaGV4LnggPSBnZXRYKGhleCwgbGF5b3V0LCBoZXhXaWR0aCwgaGV4UmFkaXVzKTtcbiAgICAgICAgICAgIGhleC55ID0gZ2V0WShoZXgsIGxheW91dCwgaGV4V2lkdGgsIGhleFJhZGl1cyk7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIHZlcnRleCBwb3NpdGlvbnMgYW5kIHBvaW50cyByZWxhdGl2ZSB0byB4IGFuZCB5XG4gICAgICAgICAgICBoZXgudmVydGljZXMgPSB2ZXJ0aWNlcztcbiAgICAgICAgICAgIGhleC5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGV4ZXM7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgeCBwb3NpdGlvbiBmb3IgYSBoZXhcbiAgICBmdW5jdGlvbiBnZXRYKGhleCwgbGF5b3V0LCBoZXhXaWR0aCwgaGV4UmFkaXVzKSB7XG4gICAgICAgIHZhciB4ID0gMCwgeE9mZnNldCA9IDA7XG4gICAgICAgIHN3aXRjaCAobGF5b3V0KSB7XG4gICAgICAgICAgICBjYXNlIFwib2RkLXJcIjpcbiAgICAgICAgICAgICAgICB4T2Zmc2V0ID0gKGhleC5yYyAlIDIgPT09IDEpID8gaGV4V2lkdGggOiAoaGV4V2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICB4ID0gKGhleC5xYyAqIGhleFdpZHRoKSArIHhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZXZlbi1yXCI6XG4gICAgICAgICAgICAgICAgeE9mZnNldCA9IChoZXgucmMgJSAyID09PSAwKSA/IGhleFdpZHRoIDogKGhleFdpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgeCA9IChoZXgucWMgKiBoZXhXaWR0aCkgKyB4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9kZC1xXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXZlbi1xXCI6XG4gICAgICAgICAgICAgICAgeCA9IChoZXgucWMgKiBoZXhSYWRpdXMgKiAxLjUpICsgaGV4UmFkaXVzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIHkgcG9zaXRpb24gZm9yIGEgaGV4XG4gICAgZnVuY3Rpb24gZ2V0WShoZXgsIGxheW91dCwgaGV4V2lkdGgsIGhleFJhZGl1cykge1xuICAgICAgICB2YXIgeSA9IDAsIHlPZmZzZXQgPSAwO1xuICAgICAgICBzd2l0Y2ggKGxheW91dCkge1xuICAgICAgICAgICAgY2FzZSBcIm9kZC1yXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXZlbi1yXCI6XG4gICAgICAgICAgICAgICAgeSA9IChoZXgucmMgKiBoZXhSYWRpdXMgKiAxLjUpICsgaGV4UmFkaXVzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9kZC1xXCI6XG4gICAgICAgICAgICAgICAgeU9mZnNldCA9IChoZXgucWMgJSAyID09PSAxKSA/IGhleFdpZHRoIDogKGhleFdpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgeSA9IChoZXgucmMgKiBoZXhXaWR0aCkgKyB5T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImV2ZW4tcVwiOlxuICAgICAgICAgICAgICAgIHlPZmZzZXQgPSAoaGV4LnFjICUgMiA9PT0gMCkgPyBoZXhXaWR0aCA6IChoZXhXaWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgIHkgPSAoaGV4LnJjICogaGV4V2lkdGgpICsgeU9mZnNldDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBwb3NpdGlvbnMgb2YgdGhlIHZlcnRpY2VzIGZvciB0aGUgaGV4OlxuICAgIC8vIC0gUm93IGxheW91dHMgYXJlIG9yZGVyZWQgZnJvbSB0aGUgdG9wbW9zdCB2ZXJ0ZXggY2xvY2t3aXNlXG4gICAgLy8gLSBDb2x1bW4gbGF5b3V0cyBhcmUgb3JkZXJlZCBmcm9tIHRoZSBsZWZ0bW9zdCB2ZXJ0ZXggY2xvY2t3aXNlXG4gICAgZnVuY3Rpb24gZ2V0VmVydGljZXMobGF5b3V0LCBoZXhXaWR0aCwgaGV4UmFkaXVzKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgICBzd2l0Y2ggKGxheW91dCkge1xuICAgICAgICAgICAgY2FzZSBcIm9kZC1yXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXZlbi1yXCI6XG4gICAgICAgICAgICAgICAgdmVydGljZXMucHVzaCh7IHg6IDAsIHk6ICgwIC0gaGV4UmFkaXVzKSB9KTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHsgeDogKDAgKyBoZXhXaWR0aCAqIDAuNSksIHk6ICgwIC0gMC41ICogaGV4UmFkaXVzKSB9KTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHsgeDogKDAgKyBoZXhXaWR0aCAqIDAuNSksIHk6ICgwICsgMC41ICogaGV4UmFkaXVzKSB9KTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHsgeDogMCwgeTogKDAgKyBoZXhSYWRpdXMpIH0pO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goeyB4OiAoMCAtIGhleFdpZHRoICogMC41KSwgeTogKDAgKyAwLjUgKiBoZXhSYWRpdXMpIH0pO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goeyB4OiAoMCAtIGhleFdpZHRoICogMC41KSwgeTogKDAgLSAwLjUgKiBoZXhSYWRpdXMpIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9kZC1xXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXZlbi1xXCI6XG4gICAgICAgICAgICAgICAgdmVydGljZXMucHVzaCh7IHg6ICgwIC0gaGV4UmFkaXVzKSwgeTogMCB9KTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHsgeDogKDAgLSAwLjUgKiBoZXhSYWRpdXMpLCB5OiAoMCAtIGhleFdpZHRoICogMC41KSB9KTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHsgeDogKDAgKyAwLjUgKiBoZXhSYWRpdXMpLCB5OiAoMCAtIGhleFdpZHRoICogMC41KSB9KTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHsgeDogKDAgKyBoZXhSYWRpdXMpLCB5OiAwIH0pO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goeyB4OiAoMCArIDAuNSAqIGhleFJhZGl1cyksIHk6ICgwICsgaGV4V2lkdGggKiAwLjUpIH0pO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goeyB4OiAoMCAtIDAuNSAqIGhleFJhZGl1cyksIHk6ICgwICsgaGV4V2lkdGggKiAwLjUpIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ZXJ0aWNlcztcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBwb2ludHMgYXR0cmlidXRlIGZvciBhIHBvbHlnb24gd2l0aCB0aGVzZSB2ZXJ0aWNlc1xuICAgIGZ1bmN0aW9uIGdldFBvaW50cyh2ZXJ0aWNlcykge1xuICAgICAgICB2YXIgcG9pbnRzID0gXCJcIjtcbiAgICAgICAgdmVydGljZXMuZm9yRWFjaChmdW5jdGlvbiAodikgeyBwb2ludHMgKz0gdi54ICsgXCIsXCIgKyB2LnkgKyBcIiBcIjsgfSk7XG4gICAgICAgIHJldHVybiBwb2ludHMuc3Vic3RyaW5nKDAsIHBvaW50cy5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlcyBhIGhleGpzb24gZ3JpZCB3aXRoIHRoZSBsYXlvdXQgYW5kIGRpbWVuc2lvbnMgb2YgdGhlIGdpdmVuIGhleGpzb25cbiAgICBmdW5jdGlvbiBnZXRHcmlkRm9ySGV4SlNPTihoZXhqc29uKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBIZXhKU09OIG9iamVjdCBmb3IgdGhlIGdyaWRcbiAgICAgICAgdmFyIGdyaWQgPSB7fTtcbiAgICAgICAgZ3JpZC5sYXlvdXQgPSBoZXhqc29uLmxheW91dDtcbiAgICAgICAgZ3JpZC5oZXhlcyA9IHt9O1xuICAgICAgICAvLyBHZXQgdGhlIGhleCBvYmplY3RzIGZyb20gdGhlIGhleGpzb24gYXMgYW4gYXJyYXlcbiAgICAgICAgdmFyIGhleGVzID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKGhleGpzb24uaGV4ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaGV4ZXMucHVzaChoZXhqc29uLmhleGVzW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyBpbiB0aGUgZ3JpZFxuICAgICAgICB2YXIgcW1heCA9IGQzQXJyYXkubWF4KGhleGVzLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gK2QucTsgfSksIHFtaW4gPSBkM0FycmF5Lm1pbihoZXhlcywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuICtkLnE7IH0pLCBybWF4ID0gZDNBcnJheS5tYXgoaGV4ZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiArZC5yOyB9KSwgcm1pbiA9IGQzQXJyYXkubWluKGhleGVzLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gK2QucjsgfSk7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgaGV4anNvbiBncmlkXG4gICAgICAgIHZhciBpLCBqLCBma2V5O1xuICAgICAgICBmb3IgKGkgPSBxbWluOyBpIDw9IHFtYXg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gcm1pbjsgaiA8PSBybWF4OyBqKyspIHtcbiAgICAgICAgICAgICAgICBma2V5ID0gXCJRXCIgKyBpICsgXCJSXCIgKyBqO1xuICAgICAgICAgICAgICAgIGdyaWQuaGV4ZXNbZmtleV0gPSB7IHE6IGksIHI6IGogfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JpZDtcbiAgICB9XG4gICAgLy8gQ3JlYXRlcyBhIGxpc3Qgb2YgZG90cyBhbG9uZyB0aGUgYm91bmRhcmllcyBiZXR3ZWVuXG4gICAgLy8gaGV4ZXMgd2hpY2ggaGF2ZSBkaWZmZXJlbnQgdmFsdWVzIG9mIFwiZmllbGRcIlxuICAgIGZ1bmN0aW9uIGdldEJvdW5kYXJ5RG90c0ZvckhleEpTT04oaGV4anNvbiwgd2lkdGgsIGhlaWdodCwgZmllbGQpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBoZXggb2JqZWN0cyBmcm9tIHRoZSBoZXhqc29uIGFzIGFuIGFycmF5XG4gICAgICAgIHZhciBoZXhlcyA9IFtdO1xuICAgICAgICB2YXIgbGF5b3V0ID0gaGV4anNvbi5sYXlvdXQ7XG4gICAgICAgIE9iamVjdC5rZXlzKGhleGpzb24uaGV4ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaGV4ZXMucHVzaChoZXhqc29uLmhleGVzW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1uc1xuICAgICAgICB2YXIgcW1heCA9IGQzQXJyYXkubWF4KGhleGVzLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gK2QucTsgfSksIHFtaW4gPSBkM0FycmF5Lm1pbihoZXhlcywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuICtkLnE7IH0pLCBybWF4ID0gZDNBcnJheS5tYXgoaGV4ZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiArZC5yOyB9KSwgcm1pbiA9IGQzQXJyYXkubWluKGhleGVzLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gK2QucjsgfSk7XG4gICAgICAgIHZhciBxbnVtID0gcW1heCAtIHFtaW4gKyAxLCBybnVtID0gcm1heCAtIHJtaW4gKyAxO1xuICAgICAgICB2YXIgaGV4UmFkaXVzO1xuICAgICAgICAvLyBDYWxjdWxhdGUgbWF4aW11bSByYWRpdXMgdGhlIGhleGFnb25zIGNhbiBoYXZlIHRvIGZpdCB0aGUgc3ZnXG4gICAgICAgIGlmIChsYXlvdXQgPT09IFwib2RkLXJcIiB8fCBsYXlvdXQgPT09IFwiZXZlbi1yXCIpIHtcbiAgICAgICAgICAgIGhleFJhZGl1cyA9IGQzQXJyYXkubWluKFsod2lkdGgpIC8gKChxbnVtICsgMC41KSAqIE1hdGguc3FydCgzKSksXG4gICAgICAgICAgICAgICAgaGVpZ2h0IC8gKChybnVtICsgMSAvIDMpICogMS41KV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGV4UmFkaXVzID0gZDNBcnJheS5taW4oWyhoZWlnaHQpIC8gKChybnVtICsgMC41KSAqIE1hdGguc3FydCgzKSksXG4gICAgICAgICAgICAgICAgd2lkdGggLyAoKHFudW0gKyAxIC8gMykgKiAxLjUpXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBoZXhhZ29uIHdpZHRoXG4gICAgICAgIHZhciBoZXhXaWR0aCA9IGhleFJhZGl1cyAqIE1hdGguc3FydCgzKTtcbiAgICAgICAgLy8gQ3JlYXRlIGFuIGFycmF5IGludG8gd2hpY2ggd2Ugd2lsbCBwdXQgcG9pbnRzIGFsb25nIHRoZVxuICAgICAgICAvLyBib3VuZGFyaWVzIGJldHdlZW4gZGlmZmVyaW5nIGhleGVzLlxuICAgICAgICAvLyBFYWNoIGVkZ2UgaGFzIGZpdmUgcG9pbnRzLCBlcXVhbGx5IHNwYWNlZC5cbiAgICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICAgIHZhciBoZXhSYWRpdXNTcXVhcmVkID0gaGV4UmFkaXVzICogaGV4UmFkaXVzICogNDtcbiAgICAgICAgdmFyIG1heEhleCA9IGhleGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKG1heEhleCA+IDEpIHtcbiAgICAgICAgICAgIGhleGVzLmZvckVhY2goZnVuY3Rpb24gKGhleCkge1xuICAgICAgICAgICAgICAgIGhleC5xYyA9IGhleC5xIC0gcW1pbjtcbiAgICAgICAgICAgICAgICBoZXgucmMgPSBybWF4IC0gaGV4LnI7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB4IGFuZCB5IHBvc2l0aW9uIG9mIGVhY2ggaGV4IGZvciB0aGlzIHN2Z1xuICAgICAgICAgICAgICAgIGhleC54ID0gZ2V0WChoZXgsIGxheW91dCwgaGV4V2lkdGgsIGhleFJhZGl1cyk7XG4gICAgICAgICAgICAgICAgaGV4LnkgPSBnZXRZKGhleCwgbGF5b3V0LCBoZXhXaWR0aCwgaGV4UmFkaXVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhIZXggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBtYXhIZXg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGV4ID0gaGV4ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdGhlckhleCA9IGhleGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGV4W2ZpZWxkXSAhPT0gb3RoZXJIZXhbZmllbGRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoaGV4LnEgLSBvdGhlckhleC5xKSA8PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoaGV4LnIgLSBvdGhlckhleC5yKSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoaGV4LnggLSBvdGhlckhleC54KSAqIChoZXgueCAtIG90aGVySGV4LngpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoaGV4LnkgLSBvdGhlckhleC55KSAqIChoZXgueSAtIG90aGVySGV4LnkpKSA8IGhleFJhZGl1c1NxdWFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhleSdyZSBuZWlnaGJvdXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaWRwb2ludCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWRwb2ludC54ID0gb3RoZXJIZXgueCArIChoZXgueCAtIG90aGVySGV4LngpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlkcG9pbnQueSA9IG90aGVySGV4LnkgKyAoaGV4LnkgLSBvdGhlckhleC55KSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJwID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZW5vbSA9IE1hdGguc3FydCgzKSAqIDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnAuZHggPSAoaGV4LnkgLSBvdGhlckhleC55KSAvIGRlbm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJwLmR5ID0gLShoZXgueCAtIG90aGVySGV4LngpIC8gZGVub207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goeyB4OiBtaWRwb2ludC54IC0gMiAqIHBlcnAuZHgsIHk6IG1pZHBvaW50LnkgLSAyICogcGVycC5keSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaCh7IHg6IG1pZHBvaW50LnggLSBwZXJwLmR4LCB5OiBtaWRwb2ludC55IC0gcGVycC5keSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaCh7IHg6IG1pZHBvaW50LngsIHk6IG1pZHBvaW50LnkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goeyB4OiBtaWRwb2ludC54ICsgcGVycC5keCwgeTogbWlkcG9pbnQueSArIHBlcnAuZHkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goeyB4OiBtaWRwb2ludC54ICsgMiAqIHBlcnAuZHgsIHk6IG1pZHBvaW50LnkgKyAyICogcGVycC5keSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICAvLyBDcmVhdGVzIGEgbGlzdCBvZiBsaW5lIHNlZ21lbnRzIGFsb25nIHRoZSBib3VuZGFyaWVzXG4gICAgLy8gYmV0d2VlbiBoZXhlcyB3aGljaCBoYXZlIGRpZmZlcmVudCB2YWx1ZXMgb2YgXCJmaWVsZFwiXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRhcnlTZWdtZW50c0ZvckhleEpTT04oaGV4anNvbiwgd2lkdGgsIGhlaWdodCwgZmllbGQpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBoZXggb2JqZWN0cyBmcm9tIHRoZSBoZXhqc29uIGFzIGFuIGFycmF5XG4gICAgICAgIHZhciBoZXhlcyA9IFtdO1xuICAgICAgICB2YXIgbGF5b3V0ID0gaGV4anNvbi5sYXlvdXQ7XG4gICAgICAgIE9iamVjdC5rZXlzKGhleGpzb24uaGV4ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaGV4ZXMucHVzaChoZXhqc29uLmhleGVzW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1uc1xuICAgICAgICB2YXIgcW1heCA9IGQzQXJyYXkubWF4KGhleGVzLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gK2QucTsgfSksIHFtaW4gPSBkM0FycmF5Lm1pbihoZXhlcywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuICtkLnE7IH0pLCBybWF4ID0gZDNBcnJheS5tYXgoaGV4ZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiArZC5yOyB9KSwgcm1pbiA9IGQzQXJyYXkubWluKGhleGVzLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gK2QucjsgfSk7XG4gICAgICAgIHZhciBxbnVtID0gcW1heCAtIHFtaW4gKyAxLCBybnVtID0gcm1heCAtIHJtaW4gKyAxO1xuICAgICAgICB2YXIgaGV4UmFkaXVzO1xuICAgICAgICAvLyBDYWxjdWxhdGUgbWF4aW11bSByYWRpdXMgdGhlIGhleGFnb25zIGNhbiBoYXZlIHRvIGZpdCB0aGUgc3ZnXG4gICAgICAgIGlmIChsYXlvdXQgPT09IFwib2RkLXJcIiB8fCBsYXlvdXQgPT09IFwiZXZlbi1yXCIpIHtcbiAgICAgICAgICAgIGhleFJhZGl1cyA9IGQzQXJyYXkubWluKFsod2lkdGgpIC8gKChxbnVtICsgMC41KSAqIE1hdGguc3FydCgzKSksXG4gICAgICAgICAgICAgICAgaGVpZ2h0IC8gKChybnVtICsgMSAvIDMpICogMS41KV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGV4UmFkaXVzID0gZDNBcnJheS5taW4oWyhoZWlnaHQpIC8gKChybnVtICsgMC41KSAqIE1hdGguc3FydCgzKSksXG4gICAgICAgICAgICAgICAgd2lkdGggLyAoKHFudW0gKyAxIC8gMykgKiAxLjUpXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBoZXhhZ29uIHdpZHRoXG4gICAgICAgIHZhciBoZXhXaWR0aCA9IGhleFJhZGl1cyAqIE1hdGguc3FydCgzKTtcbiAgICAgICAgLy8gQ3JlYXRlIGFuIGFycmF5IGludG8gd2hpY2ggd2Ugd2lsbCBwdXQgcG9pbnRzIGFsb25nIHRoZVxuICAgICAgICAvLyBib3VuZGFyaWVzIGJldHdlZW4gZGlmZmVyaW5nIGhleGVzLlxuICAgICAgICAvLyBFYWNoIHNlZ21lbnQgd2lsbCBiZSBvZiB0aGUgZm9ybVxuICAgICAgICAvLyB7eDogPHN0YXJ0IHBvaW50IFg+LCB5OiA8c3RhcnQgcG9pbnQgWT4sIGN4OiA8ZGlmZmVyZW5jZSBYPiwgY3k6IDxkaWZmZXJlbmNlIFk+IH1cbiAgICAgICAgLy8gaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoIHRoZSBzaW1wbGUgbGluZSBkcmF3aW5nIGZ1bmN0aW9uYWxpdHkgb2YgZDNcbiAgICAgICAgLy9cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gW107XG4gICAgICAgIHZhciBoZXhSYWRpdXNTcXVhcmVkID0gaGV4UmFkaXVzICogaGV4UmFkaXVzICogNDtcbiAgICAgICAgdmFyIG1heEhleCA9IGhleGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKG1heEhleCA+IDEpIHtcbiAgICAgICAgICAgIGhleGVzLmZvckVhY2goZnVuY3Rpb24gKGhleCkge1xuICAgICAgICAgICAgICAgIGhleC5xYyA9IGhleC5xIC0gcW1pbjtcbiAgICAgICAgICAgICAgICBoZXgucmMgPSBybWF4IC0gaGV4LnI7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB4IGFuZCB5IHBvc2l0aW9uIG9mIGVhY2ggaGV4IGZvciB0aGlzIHN2Z1xuICAgICAgICAgICAgICAgIGhleC54ID0gZ2V0WChoZXgsIGxheW91dCwgaGV4V2lkdGgsIGhleFJhZGl1cyk7XG4gICAgICAgICAgICAgICAgaGV4LnkgPSBnZXRZKGhleCwgbGF5b3V0LCBoZXhXaWR0aCwgaGV4UmFkaXVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhIZXggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBtYXhIZXg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGV4ID0gaGV4ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdGhlckhleCA9IGhleGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGV4W2ZpZWxkXSAhPT0gb3RoZXJIZXhbZmllbGRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoaGV4LnEgLSBvdGhlckhleC5xKSA8PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoaGV4LnIgLSBvdGhlckhleC5yKSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoaGV4LnggLSBvdGhlckhleC54KSAqIChoZXgueCAtIG90aGVySGV4LngpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoaGV4LnkgLSBvdGhlckhleC55KSAqIChoZXgueSAtIG90aGVySGV4LnkpKSA8IGhleFJhZGl1c1NxdWFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhleSdyZSBuZWlnaGJvdXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaWRwb2ludCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWRwb2ludC54ID0gb3RoZXJIZXgueCArIChoZXgueCAtIG90aGVySGV4LngpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlkcG9pbnQueSA9IG90aGVySGV4LnkgKyAoaGV4LnkgLSBvdGhlckhleC55KSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJwID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSArMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhleFtmaWVsZF0gPCBvdGhlckhleFtmaWVsZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IC8vIG90aGVyd2lzZSwgZGlyZWN0aW9uIHdpbGwgYmUgKzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbm9tID0gTWF0aC5zcXJ0KDMpICogMiAqIGRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVycC5keCA9IChoZXgueSAtIG90aGVySGV4LnkpIC8gZGVub207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnAuZHkgPSAtKGhleC54IC0gb3RoZXJIZXgueCkgLyBkZW5vbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MTogbWlkcG9pbnQueCAtIHBlcnAuZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MTogbWlkcG9pbnQueSAtIHBlcnAuZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MjogbWlkcG9pbnQueCArIHBlcnAuZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MjogbWlkcG9pbnQueSArIHBlcnAuZHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdtZW50cztcbiAgICB9XG4gICAgZXhwb3J0cy5yZW5kZXJIZXhKU09OID0gcmVuZGVySGV4SlNPTjtcbiAgICBleHBvcnRzLmdldEdyaWRGb3JIZXhKU09OID0gZ2V0R3JpZEZvckhleEpTT047XG4gICAgZXhwb3J0cy5nZXRCb3VuZGFyeURvdHNGb3JIZXhKU09OID0gZ2V0Qm91bmRhcnlEb3RzRm9ySGV4SlNPTjtcbiAgICBleHBvcnRzLmdldEJvdW5kYXJ5U2VnbWVudHNGb3JIZXhKU09OID0gZ2V0Qm91bmRhcnlTZWdtZW50c0ZvckhleEpTT047XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn0pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtaGllcmFyY2h5QDEuMS45QGQzLWhpZXJhcmNoeS9kaXN0L2QzLWhpZXJhcmNoeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZDMtaGllcmFyY2h5QDEuMS45QGQzLWhpZXJhcmNoeS9kaXN0L2QzLWhpZXJhcmNoeS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBodHRwczovL2QzanMub3JnL2QzLWhpZXJhcmNoeS8gdjEuMS45IENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICAgdHJ1ZSA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICAgICAgICB1bmRlZmluZWQ7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRTZXBhcmF0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEucGFyZW50ID09PSBiLnBhcmVudCA/IDEgOiAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZWFuWChjaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4ucmVkdWNlKG1lYW5YUmVkdWNlLCAwKSAvIGNoaWxkcmVuLmxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVhblhSZWR1Y2UoeCwgYykge1xuICAgICAgICByZXR1cm4geCArIGMueDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWF4WShjaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gMSArIGNoaWxkcmVuLnJlZHVjZShtYXhZUmVkdWNlLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWF4WVJlZHVjZSh5LCBjKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh5LCBjLnkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZWFmTGVmdChub2RlKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbjtcbiAgICAgICAgd2hpbGUgKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbilcbiAgICAgICAgICAgIG5vZGUgPSBjaGlsZHJlblswXTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxlYWZSaWdodChub2RlKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbjtcbiAgICAgICAgd2hpbGUgKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbilcbiAgICAgICAgICAgIG5vZGUgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsdXN0ZXIoKSB7XG4gICAgICAgIHZhciBzZXBhcmF0aW9uID0gZGVmYXVsdFNlcGFyYXRpb24sIGR4ID0gMSwgZHkgPSAxLCBub2RlU2l6ZSA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBjbHVzdGVyKHJvb3QpIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c05vZGUsIHggPSAwO1xuICAgICAgICAgICAgLy8gRmlyc3Qgd2FsaywgY29tcHV0aW5nIHRoZSBpbml0aWFsIHggJiB5IHZhbHVlcy5cbiAgICAgICAgICAgIHJvb3QuZWFjaEFmdGVyKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS54ID0gbWVhblgoY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnkgPSBtYXhZKGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUueCA9IHByZXZpb3VzTm9kZSA/IHggKz0gc2VwYXJhdGlvbihub2RlLCBwcmV2aW91c05vZGUpIDogMDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS55ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gbGVhZkxlZnQocm9vdCksIHJpZ2h0ID0gbGVhZlJpZ2h0KHJvb3QpLCB4MCA9IGxlZnQueCAtIHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMiwgeDEgPSByaWdodC54ICsgc2VwYXJhdGlvbihyaWdodCwgbGVmdCkgLyAyO1xuICAgICAgICAgICAgLy8gU2Vjb25kIHdhbGssIG5vcm1hbGl6aW5nIHggJiB5IHRvIHRoZSBkZXNpcmVkIHNpemUuXG4gICAgICAgICAgICByZXR1cm4gcm9vdC5lYWNoQWZ0ZXIobm9kZVNpemUgPyBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUueCA9IChub2RlLnggLSByb290LngpICogZHg7XG4gICAgICAgICAgICAgICAgbm9kZS55ID0gKHJvb3QueSAtIG5vZGUueSkgKiBkeTtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUueCA9IChub2RlLnggLSB4MCkgLyAoeDEgLSB4MCkgKiBkeDtcbiAgICAgICAgICAgICAgICBub2RlLnkgPSAoMSAtIChyb290LnkgPyBub2RlLnkgLyByb290LnkgOiAxKSkgKiBkeTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNsdXN0ZXIuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzZXBhcmF0aW9uID0geCwgY2x1c3RlcikgOiBzZXBhcmF0aW9uO1xuICAgICAgICB9O1xuICAgICAgICBjbHVzdGVyLnNpemUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZVNpemUgPSBmYWxzZSwgZHggPSAreFswXSwgZHkgPSAreFsxXSwgY2x1c3RlcikgOiAobm9kZVNpemUgPyBudWxsIDogW2R4LCBkeV0pO1xuICAgICAgICB9O1xuICAgICAgICBjbHVzdGVyLm5vZGVTaXplID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVTaXplID0gdHJ1ZSwgZHggPSAreFswXSwgZHkgPSAreFsxXSwgY2x1c3RlcikgOiAobm9kZVNpemUgPyBbZHgsIGR5XSA6IG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2x1c3RlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY291bnQobm9kZSkge1xuICAgICAgICB2YXIgc3VtID0gMCwgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLCBpID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBpZiAoIWkpXG4gICAgICAgICAgICBzdW0gPSAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3aGlsZSAoLS1pID49IDApXG4gICAgICAgICAgICAgICAgc3VtICs9IGNoaWxkcmVuW2ldLnZhbHVlO1xuICAgICAgICBub2RlLnZhbHVlID0gc3VtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub2RlX2NvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoQWZ0ZXIoY291bnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub2RlX2VhY2goY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLCBjdXJyZW50LCBuZXh0ID0gW25vZGVdLCBjaGlsZHJlbiwgaSwgbjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY3VycmVudCA9IG5leHQucmV2ZXJzZSgpLCBuZXh0ID0gW107XG4gICAgICAgICAgICB3aGlsZSAobm9kZSA9IGN1cnJlbnQucG9wKCkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlKSwgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChuZXh0Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub2RlX2VhY2hCZWZvcmUoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLCBub2RlcyA9IFtub2RlXSwgY2hpbGRyZW4sIGk7XG4gICAgICAgIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5vZGUpLCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgZm9yIChpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub2RlX2VhY2hBZnRlcihjYWxsYmFjaykge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVzID0gW25vZGVdLCBuZXh0ID0gW10sIGNoaWxkcmVuLCBpLCBuO1xuICAgICAgICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgICAgICAgICBuZXh0LnB1c2gobm9kZSksIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbilcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobm9kZSA9IG5leHQucG9wKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub2RlX3N1bSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoQWZ0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSArdmFsdWUobm9kZS5kYXRhKSB8fCAwLCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4sIGkgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoLS1pID49IDApXG4gICAgICAgICAgICAgICAgc3VtICs9IGNoaWxkcmVuW2ldLnZhbHVlO1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHN1bTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vZGVfc29ydChjb21wYXJlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2hCZWZvcmUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9kZV9wYXRoKGVuZCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLCBhbmNlc3RvciA9IGxlYXN0Q29tbW9uQW5jZXN0b3Ioc3RhcnQsIGVuZCksIG5vZGVzID0gW3N0YXJ0XTtcbiAgICAgICAgd2hpbGUgKHN0YXJ0ICE9PSBhbmNlc3Rvcikge1xuICAgICAgICAgICAgc3RhcnQgPSBzdGFydC5wYXJlbnQ7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgayA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGVuZCAhPT0gYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIG5vZGVzLnNwbGljZShrLCAwLCBlbmQpO1xuICAgICAgICAgICAgZW5kID0gZW5kLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxlYXN0Q29tbW9uQW5jZXN0b3IoYSwgYikge1xuICAgICAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB2YXIgYU5vZGVzID0gYS5hbmNlc3RvcnMoKSwgYk5vZGVzID0gYi5hbmNlc3RvcnMoKSwgYyA9IG51bGw7XG4gICAgICAgIGEgPSBhTm9kZXMucG9wKCk7XG4gICAgICAgIGIgPSBiTm9kZXMucG9wKCk7XG4gICAgICAgIHdoaWxlIChhID09PSBiKSB7XG4gICAgICAgICAgICBjID0gYTtcbiAgICAgICAgICAgIGEgPSBhTm9kZXMucG9wKCk7XG4gICAgICAgICAgICBiID0gYk5vZGVzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub2RlX2FuY2VzdG9ycygpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLCBub2RlcyA9IFtub2RlXTtcbiAgICAgICAgd2hpbGUgKG5vZGUgPSBub2RlLnBhcmVudCkge1xuICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vZGVfZGVzY2VuZGFudHMoKSB7XG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vZGVfbGVhdmVzKCkge1xuICAgICAgICB2YXIgbGVhdmVzID0gW107XG4gICAgICAgIHRoaXMuZWFjaEJlZm9yZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgbGVhdmVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGVhdmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub2RlX2xpbmtzKCkge1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMsIGxpbmtzID0gW107XG4gICAgICAgIHJvb3QuZWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUgIT09IHJvb3QpIHsgLy8gRG9u4oCZdCBpbmNsdWRlIHRoZSByb2904oCZcyBwYXJlbnQsIGlmIGFueS5cbiAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKHsgc291cmNlOiBub2RlLnBhcmVudCwgdGFyZ2V0OiBub2RlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxpbmtzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoaWVyYXJjaHkoZGF0YSwgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHJvb3QgPSBuZXcgTm9kZShkYXRhKSwgdmFsdWVkID0gK2RhdGEudmFsdWUgJiYgKHJvb3QudmFsdWUgPSBkYXRhLnZhbHVlKSwgbm9kZSwgbm9kZXMgPSBbcm9vdF0sIGNoaWxkLCBjaGlsZHMsIGksIG47XG4gICAgICAgIGlmIChjaGlsZHJlbiA9PSBudWxsKVxuICAgICAgICAgICAgY2hpbGRyZW4gPSBkZWZhdWx0Q2hpbGRyZW47XG4gICAgICAgIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZWQpXG4gICAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9ICtub2RlLmRhdGEudmFsdWU7XG4gICAgICAgICAgICBpZiAoKGNoaWxkcyA9IGNoaWxkcmVuKG5vZGUuZGF0YSkpICYmIChuID0gY2hpbGRzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXSA9IG5ldyBOb2RlKGNoaWxkc1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZXB0aCA9IG5vZGUuZGVwdGggKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdC5lYWNoQmVmb3JlKGNvbXB1dGVIZWlnaHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub2RlX2NvcHkoKSB7XG4gICAgICAgIHJldHVybiBoaWVyYXJjaHkodGhpcykuZWFjaEJlZm9yZShjb3B5RGF0YSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRDaGlsZHJlbihkKSB7XG4gICAgICAgIHJldHVybiBkLmNoaWxkcmVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5RGF0YShub2RlKSB7XG4gICAgICAgIG5vZGUuZGF0YSA9IG5vZGUuZGF0YS5kYXRhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlSGVpZ2h0KG5vZGUpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICAgIGRvXG4gICAgICAgICAgICBub2RlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgd2hpbGUgKChub2RlID0gbm9kZS5wYXJlbnQpICYmIChub2RlLmhlaWdodCA8ICsraGVpZ2h0KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE5vZGUoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmRlcHRoID1cbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBOb2RlLnByb3RvdHlwZSA9IGhpZXJhcmNoeS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBOb2RlLFxuICAgICAgICBjb3VudDogbm9kZV9jb3VudCxcbiAgICAgICAgZWFjaDogbm9kZV9lYWNoLFxuICAgICAgICBlYWNoQWZ0ZXI6IG5vZGVfZWFjaEFmdGVyLFxuICAgICAgICBlYWNoQmVmb3JlOiBub2RlX2VhY2hCZWZvcmUsXG4gICAgICAgIHN1bTogbm9kZV9zdW0sXG4gICAgICAgIHNvcnQ6IG5vZGVfc29ydCxcbiAgICAgICAgcGF0aDogbm9kZV9wYXRoLFxuICAgICAgICBhbmNlc3RvcnM6IG5vZGVfYW5jZXN0b3JzLFxuICAgICAgICBkZXNjZW5kYW50czogbm9kZV9kZXNjZW5kYW50cyxcbiAgICAgICAgbGVhdmVzOiBub2RlX2xlYXZlcyxcbiAgICAgICAgbGlua3M6IG5vZGVfbGlua3MsXG4gICAgICAgIGNvcHk6IG5vZGVfY29weVxuICAgIH07XG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICAgIGZ1bmN0aW9uIHNodWZmbGUoYXJyYXkpIHtcbiAgICAgICAgdmFyIG0gPSBhcnJheS5sZW5ndGgsIHQsIGk7XG4gICAgICAgIHdoaWxlIChtKSB7XG4gICAgICAgICAgICBpID0gTWF0aC5yYW5kb20oKSAqIG0tLSB8IDA7XG4gICAgICAgICAgICB0ID0gYXJyYXlbbV07XG4gICAgICAgICAgICBhcnJheVttXSA9IGFycmF5W2ldO1xuICAgICAgICAgICAgYXJyYXlbaV0gPSB0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jbG9zZShjaXJjbGVzKSB7XG4gICAgICAgIHZhciBpID0gMCwgbiA9IChjaXJjbGVzID0gc2h1ZmZsZShzbGljZS5jYWxsKGNpcmNsZXMpKSkubGVuZ3RoLCBCID0gW10sIHAsIGU7XG4gICAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICAgICAgcCA9IGNpcmNsZXNbaV07XG4gICAgICAgICAgICBpZiAoZSAmJiBlbmNsb3Nlc1dlYWsoZSwgcCkpXG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGUgPSBlbmNsb3NlQmFzaXMoQiA9IGV4dGVuZEJhc2lzKEIsIHApKSwgaSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4dGVuZEJhc2lzKEIsIHApIHtcbiAgICAgICAgdmFyIGksIGo7XG4gICAgICAgIGlmIChlbmNsb3Nlc1dlYWtBbGwocCwgQikpXG4gICAgICAgICAgICByZXR1cm4gW3BdO1xuICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIEIgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBlbGVtZW50LlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgQi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGVuY2xvc2VzTm90KHAsIEJbaV0pXG4gICAgICAgICAgICAgICAgJiYgZW5jbG9zZXNXZWFrQWxsKGVuY2xvc2VCYXNpczIoQltpXSwgcCksIEIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtCW2ldLCBwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIEIgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBlbGVtZW50cy5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IEIubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IEIubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jbG9zZXNOb3QoZW5jbG9zZUJhc2lzMihCW2ldLCBCW2pdKSwgcClcbiAgICAgICAgICAgICAgICAgICAgJiYgZW5jbG9zZXNOb3QoZW5jbG9zZUJhc2lzMihCW2ldLCBwKSwgQltqXSlcbiAgICAgICAgICAgICAgICAgICAgJiYgZW5jbG9zZXNOb3QoZW5jbG9zZUJhc2lzMihCW2pdLCBwKSwgQltpXSlcbiAgICAgICAgICAgICAgICAgICAgJiYgZW5jbG9zZXNXZWFrQWxsKGVuY2xvc2VCYXNpczMoQltpXSwgQltqXSwgcCksIEIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbQltpXSwgQltqXSwgcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlIHRoZW4gc29tZXRoaW5nIGlzIHZlcnkgd3JvbmcuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jbG9zZXNOb3QoYSwgYikge1xuICAgICAgICB2YXIgZHIgPSBhLnIgLSBiLnIsIGR4ID0gYi54IC0gYS54LCBkeSA9IGIueSAtIGEueTtcbiAgICAgICAgcmV0dXJuIGRyIDwgMCB8fCBkciAqIGRyIDwgZHggKiBkeCArIGR5ICogZHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY2xvc2VzV2VhayhhLCBiKSB7XG4gICAgICAgIHZhciBkciA9IGEuciAtIGIuciArIDFlLTYsIGR4ID0gYi54IC0gYS54LCBkeSA9IGIueSAtIGEueTtcbiAgICAgICAgcmV0dXJuIGRyID4gMCAmJiBkciAqIGRyID4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY2xvc2VzV2Vha0FsbChhLCBCKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFlbmNsb3Nlc1dlYWsoYSwgQltpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY2xvc2VCYXNpcyhCKSB7XG4gICAgICAgIHN3aXRjaCAoQi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGVuY2xvc2VCYXNpczEoQlswXSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBlbmNsb3NlQmFzaXMyKEJbMF0sIEJbMV0pO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gZW5jbG9zZUJhc2lzMyhCWzBdLCBCWzFdLCBCWzJdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNsb3NlQmFzaXMxKGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGEueCxcbiAgICAgICAgICAgIHk6IGEueSxcbiAgICAgICAgICAgIHI6IGEuclxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNsb3NlQmFzaXMyKGEsIGIpIHtcbiAgICAgICAgdmFyIHgxID0gYS54LCB5MSA9IGEueSwgcjEgPSBhLnIsIHgyID0gYi54LCB5MiA9IGIueSwgcjIgPSBiLnIsIHgyMSA9IHgyIC0geDEsIHkyMSA9IHkyIC0geTEsIHIyMSA9IHIyIC0gcjEsIGwgPSBNYXRoLnNxcnQoeDIxICogeDIxICsgeTIxICogeTIxKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6ICh4MSArIHgyICsgeDIxIC8gbCAqIHIyMSkgLyAyLFxuICAgICAgICAgICAgeTogKHkxICsgeTIgKyB5MjEgLyBsICogcjIxKSAvIDIsXG4gICAgICAgICAgICByOiAobCArIHIxICsgcjIpIC8gMlxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNsb3NlQmFzaXMzKGEsIGIsIGMpIHtcbiAgICAgICAgdmFyIHgxID0gYS54LCB5MSA9IGEueSwgcjEgPSBhLnIsIHgyID0gYi54LCB5MiA9IGIueSwgcjIgPSBiLnIsIHgzID0gYy54LCB5MyA9IGMueSwgcjMgPSBjLnIsIGEyID0geDEgLSB4MiwgYTMgPSB4MSAtIHgzLCBiMiA9IHkxIC0geTIsIGIzID0geTEgLSB5MywgYzIgPSByMiAtIHIxLCBjMyA9IHIzIC0gcjEsIGQxID0geDEgKiB4MSArIHkxICogeTEgLSByMSAqIHIxLCBkMiA9IGQxIC0geDIgKiB4MiAtIHkyICogeTIgKyByMiAqIHIyLCBkMyA9IGQxIC0geDMgKiB4MyAtIHkzICogeTMgKyByMyAqIHIzLCBhYiA9IGEzICogYjIgLSBhMiAqIGIzLCB4YSA9IChiMiAqIGQzIC0gYjMgKiBkMikgLyAoYWIgKiAyKSAtIHgxLCB4YiA9IChiMyAqIGMyIC0gYjIgKiBjMykgLyBhYiwgeWEgPSAoYTMgKiBkMiAtIGEyICogZDMpIC8gKGFiICogMikgLSB5MSwgeWIgPSAoYTIgKiBjMyAtIGEzICogYzIpIC8gYWIsIEEgPSB4YiAqIHhiICsgeWIgKiB5YiAtIDEsIEIgPSAyICogKHIxICsgeGEgKiB4YiArIHlhICogeWIpLCBDID0geGEgKiB4YSArIHlhICogeWEgLSByMSAqIHIxLCByID0gLShBID8gKEIgKyBNYXRoLnNxcnQoQiAqIEIgLSA0ICogQSAqIEMpKSAvICgyICogQSkgOiBDIC8gQik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4MSArIHhhICsgeGIgKiByLFxuICAgICAgICAgICAgeTogeTEgKyB5YSArIHliICogcixcbiAgICAgICAgICAgIHI6IHJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGxhY2UoYiwgYSwgYykge1xuICAgICAgICB2YXIgZHggPSBiLnggLSBhLngsIHgsIGEyLCBkeSA9IGIueSAtIGEueSwgeSwgYjIsIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIGlmIChkMikge1xuICAgICAgICAgICAgYTIgPSBhLnIgKyBjLnIsIGEyICo9IGEyO1xuICAgICAgICAgICAgYjIgPSBiLnIgKyBjLnIsIGIyICo9IGIyO1xuICAgICAgICAgICAgaWYgKGEyID4gYjIpIHtcbiAgICAgICAgICAgICAgICB4ID0gKGQyICsgYjIgLSBhMikgLyAoMiAqIGQyKTtcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGIyIC8gZDIgLSB4ICogeCkpO1xuICAgICAgICAgICAgICAgIGMueCA9IGIueCAtIHggKiBkeCAtIHkgKiBkeTtcbiAgICAgICAgICAgICAgICBjLnkgPSBiLnkgLSB4ICogZHkgKyB5ICogZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gKGQyICsgYTIgLSBiMikgLyAoMiAqIGQyKTtcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGEyIC8gZDIgLSB4ICogeCkpO1xuICAgICAgICAgICAgICAgIGMueCA9IGEueCArIHggKiBkeCAtIHkgKiBkeTtcbiAgICAgICAgICAgICAgICBjLnkgPSBhLnkgKyB4ICogZHkgKyB5ICogZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjLnggPSBhLnggKyBjLnI7XG4gICAgICAgICAgICBjLnkgPSBhLnk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0cyhhLCBiKSB7XG4gICAgICAgIHZhciBkciA9IGEuciArIGIuciAtIDFlLTYsIGR4ID0gYi54IC0gYS54LCBkeSA9IGIueSAtIGEueTtcbiAgICAgICAgcmV0dXJuIGRyID4gMCAmJiBkciAqIGRyID4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjb3JlKG5vZGUpIHtcbiAgICAgICAgdmFyIGEgPSBub2RlLl8sIGIgPSBub2RlLm5leHQuXywgYWIgPSBhLnIgKyBiLnIsIGR4ID0gKGEueCAqIGIuciArIGIueCAqIGEucikgLyBhYiwgZHkgPSAoYS55ICogYi5yICsgYi55ICogYS5yKSAvIGFiO1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE5vZGUkMShjaXJjbGUpIHtcbiAgICAgICAgdGhpcy5fID0gY2lyY2xlO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFja0VuY2xvc2UoY2lyY2xlcykge1xuICAgICAgICBpZiAoIShuID0gY2lyY2xlcy5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHZhciBhLCBiLCBjLCBuLCBhYSwgY2EsIGksIGosIGssIHNqLCBzaztcbiAgICAgICAgLy8gUGxhY2UgdGhlIGZpcnN0IGNpcmNsZS5cbiAgICAgICAgYSA9IGNpcmNsZXNbMF0sIGEueCA9IDAsIGEueSA9IDA7XG4gICAgICAgIGlmICghKG4gPiAxKSlcbiAgICAgICAgICAgIHJldHVybiBhLnI7XG4gICAgICAgIC8vIFBsYWNlIHRoZSBzZWNvbmQgY2lyY2xlLlxuICAgICAgICBiID0gY2lyY2xlc1sxXSwgYS54ID0gLWIuciwgYi54ID0gYS5yLCBiLnkgPSAwO1xuICAgICAgICBpZiAoIShuID4gMikpXG4gICAgICAgICAgICByZXR1cm4gYS5yICsgYi5yO1xuICAgICAgICAvLyBQbGFjZSB0aGUgdGhpcmQgY2lyY2xlLlxuICAgICAgICBwbGFjZShiLCBhLCBjID0gY2lyY2xlc1syXSk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGZyb250LWNoYWluIHVzaW5nIHRoZSBmaXJzdCB0aHJlZSBjaXJjbGVzIGEsIGIgYW5kIGMuXG4gICAgICAgIGEgPSBuZXcgTm9kZSQxKGEpLCBiID0gbmV3IE5vZGUkMShiKSwgYyA9IG5ldyBOb2RlJDEoYyk7XG4gICAgICAgIGEubmV4dCA9IGMucHJldmlvdXMgPSBiO1xuICAgICAgICBiLm5leHQgPSBhLnByZXZpb3VzID0gYztcbiAgICAgICAgYy5uZXh0ID0gYi5wcmV2aW91cyA9IGE7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gcGxhY2UgZWFjaCByZW1haW5pbmcgY2lyY2xl4oCmXG4gICAgICAgIHBhY2s6IGZvciAoaSA9IDM7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHBsYWNlKGEuXywgYi5fLCBjID0gY2lyY2xlc1tpXSksIGMgPSBuZXcgTm9kZSQxKGMpO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgY2xvc2VzdCBpbnRlcnNlY3RpbmcgY2lyY2xlIG9uIHRoZSBmcm9udC1jaGFpbiwgaWYgYW55LlxuICAgICAgICAgICAgLy8g4oCcQ2xvc2VuZXNz4oCdIGlzIGRldGVybWluZWQgYnkgbGluZWFyIGRpc3RhbmNlIGFsb25nIHRoZSBmcm9udC1jaGFpbi5cbiAgICAgICAgICAgIC8vIOKAnEFoZWFk4oCdIG9yIOKAnGJlaGluZOKAnSBpcyBsaWtld2lzZSBkZXRlcm1pbmVkIGJ5IGxpbmVhciBkaXN0YW5jZS5cbiAgICAgICAgICAgIGogPSBiLm5leHQsIGsgPSBhLnByZXZpb3VzLCBzaiA9IGIuXy5yLCBzayA9IGEuXy5yO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChzaiA8PSBzaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhqLl8sIGMuXykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBqLCBhLm5leHQgPSBiLCBiLnByZXZpb3VzID0gYSwgLS1pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgcGFjaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzaiArPSBqLl8uciwgaiA9IGoubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGsuXywgYy5fKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGssIGEubmV4dCA9IGIsIGIucHJldmlvdXMgPSBhLCAtLWk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBwYWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNrICs9IGsuXy5yLCBrID0gay5wcmV2aW91cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChqICE9PSBrLm5leHQpO1xuICAgICAgICAgICAgLy8gU3VjY2VzcyEgSW5zZXJ0IHRoZSBuZXcgY2lyY2xlIGMgYmV0d2VlbiBhIGFuZCBiLlxuICAgICAgICAgICAgYy5wcmV2aW91cyA9IGEsIGMubmV4dCA9IGIsIGEubmV4dCA9IGIucHJldmlvdXMgPSBiID0gYztcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIG5ldyBjbG9zZXN0IGNpcmNsZSBwYWlyIHRvIHRoZSBjZW50cm9pZC5cbiAgICAgICAgICAgIGFhID0gc2NvcmUoYSk7XG4gICAgICAgICAgICB3aGlsZSAoKGMgPSBjLm5leHQpICE9PSBiKSB7XG4gICAgICAgICAgICAgICAgaWYgKChjYSA9IHNjb3JlKGMpKSA8IGFhKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBjLCBhYSA9IGNhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgPSBhLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZW5jbG9zaW5nIGNpcmNsZSBvZiB0aGUgZnJvbnQgY2hhaW4uXG4gICAgICAgIGEgPSBbYi5fXSwgYyA9IGI7XG4gICAgICAgIHdoaWxlICgoYyA9IGMubmV4dCkgIT09IGIpXG4gICAgICAgICAgICBhLnB1c2goYy5fKTtcbiAgICAgICAgYyA9IGVuY2xvc2UoYSk7XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgY2lyY2xlcyB0byBwdXQgdGhlIGVuY2xvc2luZyBjaXJjbGUgYXJvdW5kIHRoZSBvcmlnaW4uXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgICAgICAgICBhID0gY2lyY2xlc1tpXSwgYS54IC09IGMueCwgYS55IC09IGMueTtcbiAgICAgICAgcmV0dXJuIGMucjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2libGluZ3MoY2lyY2xlcykge1xuICAgICAgICBwYWNrRW5jbG9zZShjaXJjbGVzKTtcbiAgICAgICAgcmV0dXJuIGNpcmNsZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9wdGlvbmFsKGYpIHtcbiAgICAgICAgcmV0dXJuIGYgPT0gbnVsbCA/IG51bGwgOiByZXF1aXJlZChmKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWlyZWQoZikge1xuICAgICAgICBpZiAodHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcjtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnN0YW50WmVybygpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0UmFkaXVzKGQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkLnZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5kZXgoKSB7XG4gICAgICAgIHZhciByYWRpdXMgPSBudWxsLCBkeCA9IDEsIGR5ID0gMSwgcGFkZGluZyA9IGNvbnN0YW50WmVybztcbiAgICAgICAgZnVuY3Rpb24gcGFjayhyb290KSB7XG4gICAgICAgICAgICByb290LnggPSBkeCAvIDIsIHJvb3QueSA9IGR5IC8gMjtcbiAgICAgICAgICAgIGlmIChyYWRpdXMpIHtcbiAgICAgICAgICAgICAgICByb290LmVhY2hCZWZvcmUocmFkaXVzTGVhZihyYWRpdXMpKVxuICAgICAgICAgICAgICAgICAgICAuZWFjaEFmdGVyKHBhY2tDaGlsZHJlbihwYWRkaW5nLCAwLjUpKVxuICAgICAgICAgICAgICAgICAgICAuZWFjaEJlZm9yZSh0cmFuc2xhdGVDaGlsZCgxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb290LmVhY2hCZWZvcmUocmFkaXVzTGVhZihkZWZhdWx0UmFkaXVzKSlcbiAgICAgICAgICAgICAgICAgICAgLmVhY2hBZnRlcihwYWNrQ2hpbGRyZW4oY29uc3RhbnRaZXJvLCAxKSlcbiAgICAgICAgICAgICAgICAgICAgLmVhY2hBZnRlcihwYWNrQ2hpbGRyZW4ocGFkZGluZywgcm9vdC5yIC8gTWF0aC5taW4oZHgsIGR5KSkpXG4gICAgICAgICAgICAgICAgICAgIC5lYWNoQmVmb3JlKHRyYW5zbGF0ZUNoaWxkKE1hdGgubWluKGR4LCBkeSkgLyAoMiAqIHJvb3QucikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9XG4gICAgICAgIHBhY2sucmFkaXVzID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IG9wdGlvbmFsKHgpLCBwYWNrKSA6IHJhZGl1cztcbiAgICAgICAgfTtcbiAgICAgICAgcGFjay5zaXplID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHBhY2spIDogW2R4LCBkeV07XG4gICAgICAgIH07XG4gICAgICAgIHBhY2sucGFkZGluZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHBhY2spIDogcGFkZGluZztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhZGl1c0xlYWYocmFkaXVzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yID0gTWF0aC5tYXgoMCwgK3JhZGl1cyhub2RlKSB8fCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFja0NoaWxkcmVuKHBhZGRpbmcsIGspIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuLCBpLCBuID0gY2hpbGRyZW4ubGVuZ3RoLCByID0gcGFkZGluZyhub2RlKSAqIGsgfHwgMCwgZTtcbiAgICAgICAgICAgICAgICBpZiAocilcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLnIgKz0gcjtcbiAgICAgICAgICAgICAgICBlID0gcGFja0VuY2xvc2UoY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGlmIChyKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uciAtPSByO1xuICAgICAgICAgICAgICAgIG5vZGUuciA9IGUgKyByO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVDaGlsZChrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgbm9kZS5yICo9IGs7XG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgbm9kZS54ID0gcGFyZW50LnggKyBrICogbm9kZS54O1xuICAgICAgICAgICAgICAgIG5vZGUueSA9IHBhcmVudC55ICsgayAqIG5vZGUueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcm91bmROb2RlKG5vZGUpIHtcbiAgICAgICAgbm9kZS54MCA9IE1hdGgucm91bmQobm9kZS54MCk7XG4gICAgICAgIG5vZGUueTAgPSBNYXRoLnJvdW5kKG5vZGUueTApO1xuICAgICAgICBub2RlLngxID0gTWF0aC5yb3VuZChub2RlLngxKTtcbiAgICAgICAgbm9kZS55MSA9IE1hdGgucm91bmQobm9kZS55MSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyZWVtYXBEaWNlKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gcGFyZW50LmNoaWxkcmVuLCBub2RlLCBpID0gLTEsIG4gPSBub2Rlcy5sZW5ndGgsIGsgPSBwYXJlbnQudmFsdWUgJiYgKHgxIC0geDApIC8gcGFyZW50LnZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLnkwID0geTAsIG5vZGUueTEgPSB5MTtcbiAgICAgICAgICAgIG5vZGUueDAgPSB4MCwgbm9kZS54MSA9IHgwICs9IG5vZGUudmFsdWUgKiBrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnRpdGlvbigpIHtcbiAgICAgICAgdmFyIGR4ID0gMSwgZHkgPSAxLCBwYWRkaW5nID0gMCwgcm91bmQgPSBmYWxzZTtcbiAgICAgICAgZnVuY3Rpb24gcGFydGl0aW9uKHJvb3QpIHtcbiAgICAgICAgICAgIHZhciBuID0gcm9vdC5oZWlnaHQgKyAxO1xuICAgICAgICAgICAgcm9vdC54MCA9XG4gICAgICAgICAgICAgICAgcm9vdC55MCA9IHBhZGRpbmc7XG4gICAgICAgICAgICByb290LngxID0gZHg7XG4gICAgICAgICAgICByb290LnkxID0gZHkgLyBuO1xuICAgICAgICAgICAgcm9vdC5lYWNoQmVmb3JlKHBvc2l0aW9uTm9kZShkeSwgbikpO1xuICAgICAgICAgICAgaWYgKHJvdW5kKVxuICAgICAgICAgICAgICAgIHJvb3QuZWFjaEJlZm9yZShyb3VuZE5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcG9zaXRpb25Ob2RlKGR5LCBuKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICB0cmVlbWFwRGljZShub2RlLCBub2RlLngwLCBkeSAqIChub2RlLmRlcHRoICsgMSkgLyBuLCBub2RlLngxLCBkeSAqIChub2RlLmRlcHRoICsgMikgLyBuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHgwID0gbm9kZS54MCwgeTAgPSBub2RlLnkwLCB4MSA9IG5vZGUueDEgLSBwYWRkaW5nLCB5MSA9IG5vZGUueTEgLSBwYWRkaW5nO1xuICAgICAgICAgICAgICAgIGlmICh4MSA8IHgwKVxuICAgICAgICAgICAgICAgICAgICB4MCA9IHgxID0gKHgwICsgeDEpIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAoeTEgPCB5MClcbiAgICAgICAgICAgICAgICAgICAgeTAgPSB5MSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICAgICAgICAgICAgbm9kZS54MCA9IHgwO1xuICAgICAgICAgICAgICAgIG5vZGUueTAgPSB5MDtcbiAgICAgICAgICAgICAgICBub2RlLngxID0geDE7XG4gICAgICAgICAgICAgICAgbm9kZS55MSA9IHkxO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0aXRpb24ucm91bmQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocm91bmQgPSAhIXgsIHBhcnRpdGlvbikgOiByb3VuZDtcbiAgICAgICAgfTtcbiAgICAgICAgcGFydGl0aW9uLnNpemUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZHggPSAreFswXSwgZHkgPSAreFsxXSwgcGFydGl0aW9uKSA6IFtkeCwgZHldO1xuICAgICAgICB9O1xuICAgICAgICBwYXJ0aXRpb24ucGFkZGluZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nID0gK3gsIHBhcnRpdGlvbikgOiBwYWRkaW5nO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFydGl0aW9uO1xuICAgIH1cbiAgICB2YXIga2V5UHJlZml4ID0gXCIkXCIsIC8vIFByb3RlY3QgYWdhaW5zdCBrZXlzIGxpa2Ug4oCcX19wcm90b19f4oCdLlxuICAgIHByZXJvb3QgPSB7IGRlcHRoOiAtMSB9LCBhbWJpZ3VvdXMgPSB7fTtcbiAgICBmdW5jdGlvbiBkZWZhdWx0SWQoZCkge1xuICAgICAgICByZXR1cm4gZC5pZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcmVudElkKGQpIHtcbiAgICAgICAgcmV0dXJuIGQucGFyZW50SWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmF0aWZ5KCkge1xuICAgICAgICB2YXIgaWQgPSBkZWZhdWx0SWQsIHBhcmVudElkID0gZGVmYXVsdFBhcmVudElkO1xuICAgICAgICBmdW5jdGlvbiBzdHJhdGlmeShkYXRhKSB7XG4gICAgICAgICAgICB2YXIgZCwgaSwgbiA9IGRhdGEubGVuZ3RoLCByb290LCBwYXJlbnQsIG5vZGUsIG5vZGVzID0gbmV3IEFycmF5KG4pLCBub2RlSWQsIG5vZGVLZXksIG5vZGVCeUtleSA9IHt9O1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIGQgPSBkYXRhW2ldLCBub2RlID0gbm9kZXNbaV0gPSBuZXcgTm9kZShkKTtcbiAgICAgICAgICAgICAgICBpZiAoKG5vZGVJZCA9IGlkKGQsIGksIGRhdGEpKSAhPSBudWxsICYmIChub2RlSWQgKz0gXCJcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUtleSA9IGtleVByZWZpeCArIChub2RlLmlkID0gbm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUJ5S2V5W25vZGVLZXldID0gbm9kZUtleSBpbiBub2RlQnlLZXkgPyBhbWJpZ3VvdXMgOiBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGVJZCA9IHBhcmVudElkKGRhdGFbaV0sIGksIGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlSWQgPT0gbnVsbCB8fCAhKG5vZGVJZCArPSBcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocm9vdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIHJvb3RzXCIpO1xuICAgICAgICAgICAgICAgICAgICByb290ID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGVCeUtleVtrZXlQcmVmaXggKyBub2RlSWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmc6IFwiICsgbm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gYW1iaWd1b3VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYW1iaWd1b3VzOiBcIiArIG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuID0gW25vZGVdO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJvb3QpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gcm9vdFwiKTtcbiAgICAgICAgICAgIHJvb3QucGFyZW50ID0gcHJlcm9vdDtcbiAgICAgICAgICAgIHJvb3QuZWFjaEJlZm9yZShmdW5jdGlvbiAobm9kZSkgeyBub2RlLmRlcHRoID0gbm9kZS5wYXJlbnQuZGVwdGggKyAxOyAtLW47IH0pLmVhY2hCZWZvcmUoY29tcHV0ZUhlaWdodCk7XG4gICAgICAgICAgICByb290LnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICBpZiAobiA+IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3ljbGVcIik7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICBzdHJhdGlmeS5pZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpZCA9IHJlcXVpcmVkKHgpLCBzdHJhdGlmeSkgOiBpZDtcbiAgICAgICAgfTtcbiAgICAgICAgc3RyYXRpZnkucGFyZW50SWQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFyZW50SWQgPSByZXF1aXJlZCh4KSwgc3RyYXRpZnkpIDogcGFyZW50SWQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdHJhdGlmeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFNlcGFyYXRpb24kMShhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnBhcmVudCA9PT0gYi5wYXJlbnQgPyAxIDogMjtcbiAgICB9XG4gICAgLy8gZnVuY3Rpb24gcmFkaWFsU2VwYXJhdGlvbihhLCBiKSB7XG4gICAgLy8gICByZXR1cm4gKGEucGFyZW50ID09PSBiLnBhcmVudCA/IDEgOiAyKSAvIGEuZGVwdGg7XG4gICAgLy8gfVxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byB0cmF2ZXJzZSB0aGUgbGVmdCBjb250b3VyIG9mIGEgc3VidHJlZSAob3JcbiAgICAvLyBzdWJmb3Jlc3QpLiBJdCByZXR1cm5zIHRoZSBzdWNjZXNzb3Igb2YgdiBvbiB0aGlzIGNvbnRvdXIuIFRoaXMgc3VjY2Vzc29yIGlzXG4gICAgLy8gZWl0aGVyIGdpdmVuIGJ5IHRoZSBsZWZ0bW9zdCBjaGlsZCBvZiB2IG9yIGJ5IHRoZSB0aHJlYWQgb2Ygdi4gVGhlIGZ1bmN0aW9uXG4gICAgLy8gcmV0dXJucyBudWxsIGlmIGFuZCBvbmx5IGlmIHYgaXMgb24gdGhlIGhpZ2hlc3QgbGV2ZWwgb2YgaXRzIHN1YnRyZWUuXG4gICAgZnVuY3Rpb24gbmV4dExlZnQodikge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4gPyBjaGlsZHJlblswXSA6IHYudDtcbiAgICB9XG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3b3JrcyBhbmFsb2dvdXNseSB0byBuZXh0TGVmdC5cbiAgICBmdW5jdGlvbiBuZXh0UmlnaHQodikge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4gPyBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSA6IHYudDtcbiAgICB9XG4gICAgLy8gU2hpZnRzIHRoZSBjdXJyZW50IHN1YnRyZWUgcm9vdGVkIGF0IHcrLiBUaGlzIGlzIGRvbmUgYnkgaW5jcmVhc2luZ1xuICAgIC8vIHByZWxpbSh3KykgYW5kIG1vZCh3KykgYnkgc2hpZnQuXG4gICAgZnVuY3Rpb24gbW92ZVN1YnRyZWUod20sIHdwLCBzaGlmdCkge1xuICAgICAgICB2YXIgY2hhbmdlID0gc2hpZnQgLyAod3AuaSAtIHdtLmkpO1xuICAgICAgICB3cC5jIC09IGNoYW5nZTtcbiAgICAgICAgd3AucyArPSBzaGlmdDtcbiAgICAgICAgd20uYyArPSBjaGFuZ2U7XG4gICAgICAgIHdwLnogKz0gc2hpZnQ7XG4gICAgICAgIHdwLm0gKz0gc2hpZnQ7XG4gICAgfVxuICAgIC8vIEFsbCBvdGhlciBzaGlmdHMsIGFwcGxpZWQgdG8gdGhlIHNtYWxsZXIgc3VidHJlZXMgYmV0d2VlbiB3LSBhbmQgdyssIGFyZVxuICAgIC8vIHBlcmZvcm1lZCBieSB0aGlzIGZ1bmN0aW9uLiBUbyBwcmVwYXJlIHRoZSBzaGlmdHMsIHdlIGhhdmUgdG8gYWRqdXN0XG4gICAgLy8gY2hhbmdlKHcrKSwgc2hpZnQodyspLCBhbmQgY2hhbmdlKHctKS5cbiAgICBmdW5jdGlvbiBleGVjdXRlU2hpZnRzKHYpIHtcbiAgICAgICAgdmFyIHNoaWZ0ID0gMCwgY2hhbmdlID0gMCwgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLCBpID0gY2hpbGRyZW4ubGVuZ3RoLCB3O1xuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIHcgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIHcueiArPSBzaGlmdDtcbiAgICAgICAgICAgIHcubSArPSBzaGlmdDtcbiAgICAgICAgICAgIHNoaWZ0ICs9IHcucyArIChjaGFuZ2UgKz0gdy5jKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB2aS3igJlzIGFuY2VzdG9yIGlzIGEgc2libGluZyBvZiB2LCByZXR1cm5zIHZpLeKAmXMgYW5jZXN0b3IuIE90aGVyd2lzZSxcbiAgICAvLyByZXR1cm5zIHRoZSBzcGVjaWZpZWQgKGRlZmF1bHQpIGFuY2VzdG9yLlxuICAgIGZ1bmN0aW9uIG5leHRBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSB7XG4gICAgICAgIHJldHVybiB2aW0uYS5wYXJlbnQgPT09IHYucGFyZW50ID8gdmltLmEgOiBhbmNlc3RvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJlZU5vZGUobm9kZSwgaSkge1xuICAgICAgICB0aGlzLl8gPSBub2RlO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xuICAgICAgICB0aGlzLkEgPSBudWxsOyAvLyBkZWZhdWx0IGFuY2VzdG9yXG4gICAgICAgIHRoaXMuYSA9IHRoaXM7IC8vIGFuY2VzdG9yXG4gICAgICAgIHRoaXMueiA9IDA7IC8vIHByZWxpbVxuICAgICAgICB0aGlzLm0gPSAwOyAvLyBtb2RcbiAgICAgICAgdGhpcy5jID0gMDsgLy8gY2hhbmdlXG4gICAgICAgIHRoaXMucyA9IDA7IC8vIHNoaWZ0XG4gICAgICAgIHRoaXMudCA9IG51bGw7IC8vIHRocmVhZFxuICAgICAgICB0aGlzLmkgPSBpOyAvLyBudW1iZXJcbiAgICB9XG4gICAgVHJlZU5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlLnByb3RvdHlwZSk7XG4gICAgZnVuY3Rpb24gdHJlZVJvb3Qocm9vdCkge1xuICAgICAgICB2YXIgdHJlZSA9IG5ldyBUcmVlTm9kZShyb290LCAwKSwgbm9kZSwgbm9kZXMgPSBbdHJlZV0sIGNoaWxkLCBjaGlsZHJlbiwgaSwgbjtcbiAgICAgICAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuID0gbm9kZS5fLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbiA9IG5ldyBBcnJheShuID0gY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV0gPSBuZXcgVHJlZU5vZGUoY2hpbGRyZW5baV0sIGkpKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKHRyZWUucGFyZW50ID0gbmV3IFRyZWVOb2RlKG51bGwsIDApKS5jaGlsZHJlbiA9IFt0cmVlXTtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuICAgIC8vIE5vZGUtbGluayB0cmVlIGRpYWdyYW0gdXNpbmcgdGhlIFJlaW5nb2xkLVRpbGZvcmQgXCJ0aWR5XCIgYWxnb3JpdGhtXG4gICAgZnVuY3Rpb24gdHJlZSgpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRpb24gPSBkZWZhdWx0U2VwYXJhdGlvbiQxLCBkeCA9IDEsIGR5ID0gMSwgbm9kZVNpemUgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiB0cmVlKHJvb3QpIHtcbiAgICAgICAgICAgIHZhciB0ID0gdHJlZVJvb3Qocm9vdCk7XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBsYXlvdXQgdXNpbmcgQnVjaGhlaW0gZXQgYWwu4oCZcyBhbGdvcml0aG0uXG4gICAgICAgICAgICB0LmVhY2hBZnRlcihmaXJzdFdhbGspLCB0LnBhcmVudC5tID0gLXQuejtcbiAgICAgICAgICAgIHQuZWFjaEJlZm9yZShzZWNvbmRXYWxrKTtcbiAgICAgICAgICAgIC8vIElmIGEgZml4ZWQgbm9kZSBzaXplIGlzIHNwZWNpZmllZCwgc2NhbGUgeCBhbmQgeS5cbiAgICAgICAgICAgIGlmIChub2RlU2l6ZSlcbiAgICAgICAgICAgICAgICByb290LmVhY2hCZWZvcmUoc2l6ZU5vZGUpO1xuICAgICAgICAgICAgLy8gSWYgYSBmaXhlZCB0cmVlIHNpemUgaXMgc3BlY2lmaWVkLCBzY2FsZSB4IGFuZCB5IGJhc2VkIG9uIHRoZSBleHRlbnQuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBsZWZ0LW1vc3QsIHJpZ2h0LW1vc3QsIGFuZCBkZXB0aC1tb3N0IG5vZGVzIGZvciBleHRlbnRzLlxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSByb290LCByaWdodCA9IHJvb3QsIGJvdHRvbSA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgcm9vdC5lYWNoQmVmb3JlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnggPCBsZWZ0LngpXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUueCA+IHJpZ2h0LngpXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmRlcHRoID4gYm90dG9tLmRlcHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IGxlZnQgPT09IHJpZ2h0ID8gMSA6IHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMiwgdHggPSBzIC0gbGVmdC54LCBreCA9IGR4IC8gKHJpZ2h0LnggKyBzICsgdHgpLCBreSA9IGR5IC8gKGJvdHRvbS5kZXB0aCB8fCAxKTtcbiAgICAgICAgICAgICAgICByb290LmVhY2hCZWZvcmUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS54ID0gKG5vZGUueCArIHR4KSAqIGt4O1xuICAgICAgICAgICAgICAgICAgICBub2RlLnkgPSBub2RlLmRlcHRoICoga3k7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlcyBhIHByZWxpbWluYXJ5IHgtY29vcmRpbmF0ZSBmb3Igdi4gQmVmb3JlIHRoYXQsIEZJUlNUIFdBTEsgaXNcbiAgICAgICAgLy8gYXBwbGllZCByZWN1cnNpdmVseSB0byB0aGUgY2hpbGRyZW4gb2YgdiwgYXMgd2VsbCBhcyB0aGUgZnVuY3Rpb25cbiAgICAgICAgLy8gQVBQT1JUSU9OLiBBZnRlciBzcGFjaW5nIG91dCB0aGUgY2hpbGRyZW4gYnkgY2FsbGluZyBFWEVDVVRFIFNISUZUUywgdGhlXG4gICAgICAgIC8vIG5vZGUgdiBpcyBwbGFjZWQgdG8gdGhlIG1pZHBvaW50IG9mIGl0cyBvdXRlcm1vc3QgY2hpbGRyZW4uXG4gICAgICAgIGZ1bmN0aW9uIGZpcnN0V2Fsayh2KSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLCBzaWJsaW5ncyA9IHYucGFyZW50LmNoaWxkcmVuLCB3ID0gdi5pID8gc2libGluZ3Nbdi5pIC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgZXhlY3V0ZVNoaWZ0cyh2KTtcbiAgICAgICAgICAgICAgICB2YXIgbWlkcG9pbnQgPSAoY2hpbGRyZW5bMF0ueiArIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnopIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAodykge1xuICAgICAgICAgICAgICAgICAgICB2LnogPSB3LnogKyBzZXBhcmF0aW9uKHYuXywgdy5fKTtcbiAgICAgICAgICAgICAgICAgICAgdi5tID0gdi56IC0gbWlkcG9pbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2LnogPSBtaWRwb2ludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3KSB7XG4gICAgICAgICAgICAgICAgdi56ID0gdy56ICsgc2VwYXJhdGlvbih2Ll8sIHcuXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2LnBhcmVudC5BID0gYXBwb3J0aW9uKHYsIHcsIHYucGFyZW50LkEgfHwgc2libGluZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGVzIGFsbCByZWFsIHgtY29vcmRpbmF0ZXMgYnkgc3VtbWluZyB1cCB0aGUgbW9kaWZpZXJzIHJlY3Vyc2l2ZWx5LlxuICAgICAgICBmdW5jdGlvbiBzZWNvbmRXYWxrKHYpIHtcbiAgICAgICAgICAgIHYuXy54ID0gdi56ICsgdi5wYXJlbnQubTtcbiAgICAgICAgICAgIHYubSArPSB2LnBhcmVudC5tO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBjb3JlIG9mIHRoZSBhbGdvcml0aG0uIEhlcmUsIGEgbmV3IHN1YnRyZWUgaXMgY29tYmluZWQgd2l0aCB0aGVcbiAgICAgICAgLy8gcHJldmlvdXMgc3VidHJlZXMuIFRocmVhZHMgYXJlIHVzZWQgdG8gdHJhdmVyc2UgdGhlIGluc2lkZSBhbmQgb3V0c2lkZVxuICAgICAgICAvLyBjb250b3VycyBvZiB0aGUgbGVmdCBhbmQgcmlnaHQgc3VidHJlZSB1cCB0byB0aGUgaGlnaGVzdCBjb21tb24gbGV2ZWwuIFRoZVxuICAgICAgICAvLyB2ZXJ0aWNlcyB1c2VkIGZvciB0aGUgdHJhdmVyc2FscyBhcmUgdmkrLCB2aS0sIHZvLSwgYW5kIHZvKywgd2hlcmUgdGhlXG4gICAgICAgIC8vIHN1cGVyc2NyaXB0IG8gbWVhbnMgb3V0c2lkZSBhbmQgaSBtZWFucyBpbnNpZGUsIHRoZSBzdWJzY3JpcHQgLSBtZWFucyBsZWZ0XG4gICAgICAgIC8vIHN1YnRyZWUgYW5kICsgbWVhbnMgcmlnaHQgc3VidHJlZS4gRm9yIHN1bW1pbmcgdXAgdGhlIG1vZGlmaWVycyBhbG9uZyB0aGVcbiAgICAgICAgLy8gY29udG91ciwgd2UgdXNlIHJlc3BlY3RpdmUgdmFyaWFibGVzIHNpKywgc2ktLCBzby0sIGFuZCBzbysuIFdoZW5ldmVyIHR3b1xuICAgICAgICAvLyBub2RlcyBvZiB0aGUgaW5zaWRlIGNvbnRvdXJzIGNvbmZsaWN0LCB3ZSBjb21wdXRlIHRoZSBsZWZ0IG9uZSBvZiB0aGVcbiAgICAgICAgLy8gZ3JlYXRlc3QgdW5jb21tb24gYW5jZXN0b3JzIHVzaW5nIHRoZSBmdW5jdGlvbiBBTkNFU1RPUiBhbmQgY2FsbCBNT1ZFXG4gICAgICAgIC8vIFNVQlRSRUUgdG8gc2hpZnQgdGhlIHN1YnRyZWUgYW5kIHByZXBhcmUgdGhlIHNoaWZ0cyBvZiBzbWFsbGVyIHN1YnRyZWVzLlxuICAgICAgICAvLyBGaW5hbGx5LCB3ZSBhZGQgYSBuZXcgdGhyZWFkIChpZiBuZWNlc3NhcnkpLlxuICAgICAgICBmdW5jdGlvbiBhcHBvcnRpb24odiwgdywgYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpcCA9IHYsIHZvcCA9IHYsIHZpbSA9IHcsIHZvbSA9IHZpcC5wYXJlbnQuY2hpbGRyZW5bMF0sIHNpcCA9IHZpcC5tLCBzb3AgPSB2b3AubSwgc2ltID0gdmltLm0sIHNvbSA9IHZvbS5tLCBzaGlmdDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodmltID0gbmV4dFJpZ2h0KHZpbSksIHZpcCA9IG5leHRMZWZ0KHZpcCksIHZpbSAmJiB2aXApIHtcbiAgICAgICAgICAgICAgICAgICAgdm9tID0gbmV4dExlZnQodm9tKTtcbiAgICAgICAgICAgICAgICAgICAgdm9wID0gbmV4dFJpZ2h0KHZvcCk7XG4gICAgICAgICAgICAgICAgICAgIHZvcC5hID0gdjtcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSB2aW0ueiArIHNpbSAtIHZpcC56IC0gc2lwICsgc2VwYXJhdGlvbih2aW0uXywgdmlwLl8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hpZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlU3VidHJlZShuZXh0QW5jZXN0b3IodmltLCB2LCBhbmNlc3RvciksIHYsIHNoaWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpcCArPSBzaGlmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcCArPSBzaGlmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzaW0gKz0gdmltLm07XG4gICAgICAgICAgICAgICAgICAgIHNpcCArPSB2aXAubTtcbiAgICAgICAgICAgICAgICAgICAgc29tICs9IHZvbS5tO1xuICAgICAgICAgICAgICAgICAgICBzb3AgKz0gdm9wLm07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2aW0gJiYgIW5leHRSaWdodCh2b3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHZvcC50ID0gdmltO1xuICAgICAgICAgICAgICAgICAgICB2b3AubSArPSBzaW0gLSBzb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2aXAgJiYgIW5leHRMZWZ0KHZvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdm9tLnQgPSB2aXA7XG4gICAgICAgICAgICAgICAgICAgIHZvbS5tICs9IHNpcCAtIHNvbTtcbiAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3IgPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhbmNlc3RvcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzaXplTm9kZShub2RlKSB7XG4gICAgICAgICAgICBub2RlLnggKj0gZHg7XG4gICAgICAgICAgICBub2RlLnkgPSBub2RlLmRlcHRoICogZHk7XG4gICAgICAgIH1cbiAgICAgICAgdHJlZS5zZXBhcmF0aW9uID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNlcGFyYXRpb24gPSB4LCB0cmVlKSA6IHNlcGFyYXRpb247XG4gICAgICAgIH07XG4gICAgICAgIHRyZWUuc2l6ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IGZhbHNlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCB0cmVlKSA6IChub2RlU2l6ZSA/IG51bGwgOiBbZHgsIGR5XSk7XG4gICAgICAgIH07XG4gICAgICAgIHRyZWUubm9kZVNpemUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZVNpemUgPSB0cnVlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCB0cmVlKSA6IChub2RlU2l6ZSA/IFtkeCwgZHldIDogbnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmVlbWFwU2xpY2UocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgICB2YXIgbm9kZXMgPSBwYXJlbnQuY2hpbGRyZW4sIG5vZGUsIGkgPSAtMSwgbiA9IG5vZGVzLmxlbmd0aCwgayA9IHBhcmVudC52YWx1ZSAmJiAoeTEgLSB5MCkgLyBwYXJlbnQudmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUueDAgPSB4MCwgbm9kZS54MSA9IHgxO1xuICAgICAgICAgICAgbm9kZS55MCA9IHkwLCBub2RlLnkxID0geTAgKz0gbm9kZS52YWx1ZSAqIGs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHBoaSA9ICgxICsgTWF0aC5zcXJ0KDUpKSAvIDI7XG4gICAgZnVuY3Rpb24gc3F1YXJpZnlSYXRpbyhyYXRpbywgcGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgICB2YXIgcm93cyA9IFtdLCBub2RlcyA9IHBhcmVudC5jaGlsZHJlbiwgcm93LCBub2RlVmFsdWUsIGkwID0gMCwgaTEgPSAwLCBuID0gbm9kZXMubGVuZ3RoLCBkeCwgZHksIHZhbHVlID0gcGFyZW50LnZhbHVlLCBzdW1WYWx1ZSwgbWluVmFsdWUsIG1heFZhbHVlLCBuZXdSYXRpbywgbWluUmF0aW8sIGFscGhhLCBiZXRhO1xuICAgICAgICB3aGlsZSAoaTAgPCBuKSB7XG4gICAgICAgICAgICBkeCA9IHgxIC0geDAsIGR5ID0geTEgLSB5MDtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIG5leHQgbm9uLWVtcHR5IG5vZGUuXG4gICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgIHN1bVZhbHVlID0gbm9kZXNbaTErK10udmFsdWU7XG4gICAgICAgICAgICB3aGlsZSAoIXN1bVZhbHVlICYmIGkxIDwgbik7XG4gICAgICAgICAgICBtaW5WYWx1ZSA9IG1heFZhbHVlID0gc3VtVmFsdWU7XG4gICAgICAgICAgICBhbHBoYSA9IE1hdGgubWF4KGR5IC8gZHgsIGR4IC8gZHkpIC8gKHZhbHVlICogcmF0aW8pO1xuICAgICAgICAgICAgYmV0YSA9IHN1bVZhbHVlICogc3VtVmFsdWUgKiBhbHBoYTtcbiAgICAgICAgICAgIG1pblJhdGlvID0gTWF0aC5tYXgobWF4VmFsdWUgLyBiZXRhLCBiZXRhIC8gbWluVmFsdWUpO1xuICAgICAgICAgICAgLy8gS2VlcCBhZGRpbmcgbm9kZXMgd2hpbGUgdGhlIGFzcGVjdCByYXRpbyBtYWludGFpbnMgb3IgaW1wcm92ZXMuXG4gICAgICAgICAgICBmb3IgKDsgaTEgPCBuOyArK2kxKSB7XG4gICAgICAgICAgICAgICAgc3VtVmFsdWUgKz0gbm9kZVZhbHVlID0gbm9kZXNbaTFdLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlVmFsdWUgPCBtaW5WYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgbWluVmFsdWUgPSBub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVWYWx1ZSA+IG1heFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IG5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICBiZXRhID0gc3VtVmFsdWUgKiBzdW1WYWx1ZSAqIGFscGhhO1xuICAgICAgICAgICAgICAgIG5ld1JhdGlvID0gTWF0aC5tYXgobWF4VmFsdWUgLyBiZXRhLCBiZXRhIC8gbWluVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdSYXRpbyA+IG1pblJhdGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bVZhbHVlIC09IG5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1pblJhdGlvID0gbmV3UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQb3NpdGlvbiBhbmQgcmVjb3JkIHRoZSByb3cgb3JpZW50YXRpb24uXG4gICAgICAgICAgICByb3dzLnB1c2gocm93ID0geyB2YWx1ZTogc3VtVmFsdWUsIGRpY2U6IGR4IDwgZHksIGNoaWxkcmVuOiBub2Rlcy5zbGljZShpMCwgaTEpIH0pO1xuICAgICAgICAgICAgaWYgKHJvdy5kaWNlKVxuICAgICAgICAgICAgICAgIHRyZWVtYXBEaWNlKHJvdywgeDAsIHkwLCB4MSwgdmFsdWUgPyB5MCArPSBkeSAqIHN1bVZhbHVlIC8gdmFsdWUgOiB5MSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdHJlZW1hcFNsaWNlKHJvdywgeDAsIHkwLCB2YWx1ZSA/IHgwICs9IGR4ICogc3VtVmFsdWUgLyB2YWx1ZSA6IHgxLCB5MSk7XG4gICAgICAgICAgICB2YWx1ZSAtPSBzdW1WYWx1ZSwgaTAgPSBpMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93cztcbiAgICB9XG4gICAgdmFyIHNxdWFyaWZ5ID0gKGZ1bmN0aW9uIGN1c3RvbShyYXRpbykge1xuICAgICAgICBmdW5jdGlvbiBzcXVhcmlmeShwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgICAgICBzcXVhcmlmeVJhdGlvKHJhdGlvLCBwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKTtcbiAgICAgICAgfVxuICAgICAgICBzcXVhcmlmeS5yYXRpbyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tKCh4ID0gK3gpID4gMSA/IHggOiAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNxdWFyaWZ5O1xuICAgIH0pKHBoaSk7XG4gICAgZnVuY3Rpb24gaW5kZXgkMSgpIHtcbiAgICAgICAgdmFyIHRpbGUgPSBzcXVhcmlmeSwgcm91bmQgPSBmYWxzZSwgZHggPSAxLCBkeSA9IDEsIHBhZGRpbmdTdGFjayA9IFswXSwgcGFkZGluZ0lubmVyID0gY29uc3RhbnRaZXJvLCBwYWRkaW5nVG9wID0gY29uc3RhbnRaZXJvLCBwYWRkaW5nUmlnaHQgPSBjb25zdGFudFplcm8sIHBhZGRpbmdCb3R0b20gPSBjb25zdGFudFplcm8sIHBhZGRpbmdMZWZ0ID0gY29uc3RhbnRaZXJvO1xuICAgICAgICBmdW5jdGlvbiB0cmVlbWFwKHJvb3QpIHtcbiAgICAgICAgICAgIHJvb3QueDAgPVxuICAgICAgICAgICAgICAgIHJvb3QueTAgPSAwO1xuICAgICAgICAgICAgcm9vdC54MSA9IGR4O1xuICAgICAgICAgICAgcm9vdC55MSA9IGR5O1xuICAgICAgICAgICAgcm9vdC5lYWNoQmVmb3JlKHBvc2l0aW9uTm9kZSk7XG4gICAgICAgICAgICBwYWRkaW5nU3RhY2sgPSBbMF07XG4gICAgICAgICAgICBpZiAocm91bmQpXG4gICAgICAgICAgICAgICAgcm9vdC5lYWNoQmVmb3JlKHJvdW5kTm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwb3NpdGlvbk5vZGUobm9kZSkge1xuICAgICAgICAgICAgdmFyIHAgPSBwYWRkaW5nU3RhY2tbbm9kZS5kZXB0aF0sIHgwID0gbm9kZS54MCArIHAsIHkwID0gbm9kZS55MCArIHAsIHgxID0gbm9kZS54MSAtIHAsIHkxID0gbm9kZS55MSAtIHA7XG4gICAgICAgICAgICBpZiAoeDEgPCB4MClcbiAgICAgICAgICAgICAgICB4MCA9IHgxID0gKHgwICsgeDEpIC8gMjtcbiAgICAgICAgICAgIGlmICh5MSA8IHkwKVxuICAgICAgICAgICAgICAgIHkwID0geTEgPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgICAgICAgbm9kZS54MCA9IHgwO1xuICAgICAgICAgICAgbm9kZS55MCA9IHkwO1xuICAgICAgICAgICAgbm9kZS54MSA9IHgxO1xuICAgICAgICAgICAgbm9kZS55MSA9IHkxO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBwID0gcGFkZGluZ1N0YWNrW25vZGUuZGVwdGggKyAxXSA9IHBhZGRpbmdJbm5lcihub2RlKSAvIDI7XG4gICAgICAgICAgICAgICAgeDAgKz0gcGFkZGluZ0xlZnQobm9kZSkgLSBwO1xuICAgICAgICAgICAgICAgIHkwICs9IHBhZGRpbmdUb3Aobm9kZSkgLSBwO1xuICAgICAgICAgICAgICAgIHgxIC09IHBhZGRpbmdSaWdodChub2RlKSAtIHA7XG4gICAgICAgICAgICAgICAgeTEgLT0gcGFkZGluZ0JvdHRvbShub2RlKSAtIHA7XG4gICAgICAgICAgICAgICAgaWYgKHgxIDwgeDApXG4gICAgICAgICAgICAgICAgICAgIHgwID0geDEgPSAoeDAgKyB4MSkgLyAyO1xuICAgICAgICAgICAgICAgIGlmICh5MSA8IHkwKVxuICAgICAgICAgICAgICAgICAgICB5MCA9IHkxID0gKHkwICsgeTEpIC8gMjtcbiAgICAgICAgICAgICAgICB0aWxlKG5vZGUsIHgwLCB5MCwgeDEsIHkxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlbWFwLnJvdW5kID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJvdW5kID0gISF4LCB0cmVlbWFwKSA6IHJvdW5kO1xuICAgICAgICB9O1xuICAgICAgICB0cmVlbWFwLnNpemUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZHggPSAreFswXSwgZHkgPSAreFsxXSwgdHJlZW1hcCkgOiBbZHgsIGR5XTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJlZW1hcC50aWxlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpbGUgPSByZXF1aXJlZCh4KSwgdHJlZW1hcCkgOiB0aWxlO1xuICAgICAgICB9O1xuICAgICAgICB0cmVlbWFwLnBhZGRpbmcgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0cmVlbWFwLnBhZGRpbmdJbm5lcih4KS5wYWRkaW5nT3V0ZXIoeCkgOiB0cmVlbWFwLnBhZGRpbmdJbm5lcigpO1xuICAgICAgICB9O1xuICAgICAgICB0cmVlbWFwLnBhZGRpbmdJbm5lciA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nSW5uZXI7XG4gICAgICAgIH07XG4gICAgICAgIHRyZWVtYXAucGFkZGluZ091dGVyID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdHJlZW1hcC5wYWRkaW5nVG9wKHgpLnBhZGRpbmdSaWdodCh4KS5wYWRkaW5nQm90dG9tKHgpLnBhZGRpbmdMZWZ0KHgpIDogdHJlZW1hcC5wYWRkaW5nVG9wKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRyZWVtYXAucGFkZGluZ1RvcCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nVG9wID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHRyZWVtYXApIDogcGFkZGluZ1RvcDtcbiAgICAgICAgfTtcbiAgICAgICAgdHJlZW1hcC5wYWRkaW5nUmlnaHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ1JpZ2h0ID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHRyZWVtYXApIDogcGFkZGluZ1JpZ2h0O1xuICAgICAgICB9O1xuICAgICAgICB0cmVlbWFwLnBhZGRpbmdCb3R0b20gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0JvdHRvbSA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdCb3R0b207XG4gICAgICAgIH07XG4gICAgICAgIHRyZWVtYXAucGFkZGluZ0xlZnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0xlZnQgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nTGVmdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJpbmFyeShwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgIHZhciBub2RlcyA9IHBhcmVudC5jaGlsZHJlbiwgaSwgbiA9IG5vZGVzLmxlbmd0aCwgc3VtLCBzdW1zID0gbmV3IEFycmF5KG4gKyAxKTtcbiAgICAgICAgZm9yIChzdW1zWzBdID0gc3VtID0gaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHN1bXNbaSArIDFdID0gc3VtICs9IG5vZGVzW2ldLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRpdGlvbigwLCBuLCBwYXJlbnQudmFsdWUsIHgwLCB5MCwgeDEsIHkxKTtcbiAgICAgICAgZnVuY3Rpb24gcGFydGl0aW9uKGksIGosIHZhbHVlLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgICAgICAgaWYgKGkgPj0gaiAtIDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIG5vZGUueDAgPSB4MCwgbm9kZS55MCA9IHkwO1xuICAgICAgICAgICAgICAgIG5vZGUueDEgPSB4MSwgbm9kZS55MSA9IHkxO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZU9mZnNldCA9IHN1bXNbaV0sIHZhbHVlVGFyZ2V0ID0gKHZhbHVlIC8gMikgKyB2YWx1ZU9mZnNldCwgayA9IGkgKyAxLCBoaSA9IGogLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGsgPCBoaSkge1xuICAgICAgICAgICAgICAgIHZhciBtaWQgPSBrICsgaGkgPj4+IDE7XG4gICAgICAgICAgICAgICAgaWYgKHN1bXNbbWlkXSA8IHZhbHVlVGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICBrID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGhpID0gbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh2YWx1ZVRhcmdldCAtIHN1bXNbayAtIDFdKSA8IChzdW1zW2tdIC0gdmFsdWVUYXJnZXQpICYmIGkgKyAxIDwgaylcbiAgICAgICAgICAgICAgICAtLWs7XG4gICAgICAgICAgICB2YXIgdmFsdWVMZWZ0ID0gc3Vtc1trXSAtIHZhbHVlT2Zmc2V0LCB2YWx1ZVJpZ2h0ID0gdmFsdWUgLSB2YWx1ZUxlZnQ7XG4gICAgICAgICAgICBpZiAoKHgxIC0geDApID4gKHkxIC0geTApKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhrID0gKHgwICogdmFsdWVSaWdodCArIHgxICogdmFsdWVMZWZ0KSAvIHZhbHVlO1xuICAgICAgICAgICAgICAgIHBhcnRpdGlvbihpLCBrLCB2YWx1ZUxlZnQsIHgwLCB5MCwgeGssIHkxKTtcbiAgICAgICAgICAgICAgICBwYXJ0aXRpb24oaywgaiwgdmFsdWVSaWdodCwgeGssIHkwLCB4MSwgeTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHlrID0gKHkwICogdmFsdWVSaWdodCArIHkxICogdmFsdWVMZWZ0KSAvIHZhbHVlO1xuICAgICAgICAgICAgICAgIHBhcnRpdGlvbihpLCBrLCB2YWx1ZUxlZnQsIHgwLCB5MCwgeDEsIHlrKTtcbiAgICAgICAgICAgICAgICBwYXJ0aXRpb24oaywgaiwgdmFsdWVSaWdodCwgeDAsIHlrLCB4MSwgeTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNsaWNlRGljZShwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgIChwYXJlbnQuZGVwdGggJiAxID8gdHJlZW1hcFNsaWNlIDogdHJlZW1hcERpY2UpKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpO1xuICAgIH1cbiAgICB2YXIgcmVzcXVhcmlmeSA9IChmdW5jdGlvbiBjdXN0b20ocmF0aW8pIHtcbiAgICAgICAgZnVuY3Rpb24gcmVzcXVhcmlmeShwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgICAgICBpZiAoKHJvd3MgPSBwYXJlbnQuX3NxdWFyaWZ5KSAmJiAocm93cy5yYXRpbyA9PT0gcmF0aW8pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvd3MsIHJvdywgbm9kZXMsIGksIGogPSAtMSwgbiwgbSA9IHJvd3MubGVuZ3RoLCB2YWx1ZSA9IHBhcmVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytqIDwgbSkge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSByb3dzW2pdLCBub2RlcyA9IHJvdy5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gcm93LnZhbHVlID0gMCwgbiA9IG5vZGVzLmxlbmd0aDsgaSA8IG47ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy52YWx1ZSArPSBub2Rlc1tpXS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdy5kaWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZW1hcERpY2Uocm93LCB4MCwgeTAsIHgxLCB5MCArPSAoeTEgLSB5MCkgKiByb3cudmFsdWUgLyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVtYXBTbGljZShyb3csIHgwLCB5MCwgeDAgKz0gKHgxIC0geDApICogcm93LnZhbHVlIC8gdmFsdWUsIHkxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgLT0gcm93LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC5fc3F1YXJpZnkgPSByb3dzID0gc3F1YXJpZnlSYXRpbyhyYXRpbywgcGFyZW50LCB4MCwgeTAsIHgxLCB5MSk7XG4gICAgICAgICAgICAgICAgcm93cy5yYXRpbyA9IHJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3F1YXJpZnkucmF0aW8gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbSgoeCA9ICt4KSA+IDEgPyB4IDogMSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXNxdWFyaWZ5O1xuICAgIH0pKHBoaSk7XG4gICAgZXhwb3J0cy5jbHVzdGVyID0gY2x1c3RlcjtcbiAgICBleHBvcnRzLmhpZXJhcmNoeSA9IGhpZXJhcmNoeTtcbiAgICBleHBvcnRzLnBhY2sgPSBpbmRleDtcbiAgICBleHBvcnRzLnBhY2tFbmNsb3NlID0gZW5jbG9zZTtcbiAgICBleHBvcnRzLnBhY2tTaWJsaW5ncyA9IHNpYmxpbmdzO1xuICAgIGV4cG9ydHMucGFydGl0aW9uID0gcGFydGl0aW9uO1xuICAgIGV4cG9ydHMuc3RyYXRpZnkgPSBzdHJhdGlmeTtcbiAgICBleHBvcnRzLnRyZWUgPSB0cmVlO1xuICAgIGV4cG9ydHMudHJlZW1hcCA9IGluZGV4JDE7XG4gICAgZXhwb3J0cy50cmVlbWFwQmluYXJ5ID0gYmluYXJ5O1xuICAgIGV4cG9ydHMudHJlZW1hcERpY2UgPSB0cmVlbWFwRGljZTtcbiAgICBleHBvcnRzLnRyZWVtYXBSZXNxdWFyaWZ5ID0gcmVzcXVhcmlmeTtcbiAgICBleHBvcnRzLnRyZWVtYXBTbGljZSA9IHRyZWVtYXBTbGljZTtcbiAgICBleHBvcnRzLnRyZWVtYXBTbGljZURpY2UgPSBzbGljZURpY2U7XG4gICAgZXhwb3J0cy50cmVlbWFwU3F1YXJpZnkgPSBzcXVhcmlmeTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1wYXRoQDEuMC45QGQzLXBhdGgvZGlzdC9kMy1wYXRoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kMy1wYXRoQDEuMC45QGQzLXBhdGgvZGlzdC9kMy1wYXRoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtcGF0aC8gdjEuMC45IENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICAgdHJ1ZSA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICAgICAgICB1bmRlZmluZWQ7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBwaSA9IE1hdGguUEksIHRhdSA9IDIgKiBwaSwgZXBzaWxvbiA9IDFlLTYsIHRhdUVwc2lsb24gPSB0YXUgLSBlcHNpbG9uO1xuICAgIGZ1bmN0aW9uIFBhdGgoKSB7XG4gICAgICAgIHRoaXMuX3gwID0gdGhpcy5feTAgPSAvLyBzdGFydCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgICAgICAgICAgIHRoaXMuX3gxID0gdGhpcy5feTEgPSBudWxsOyAvLyBlbmQgb2YgY3VycmVudCBzdWJwYXRoXG4gICAgICAgIHRoaXMuXyA9IFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aDtcbiAgICB9XG4gICAgUGF0aC5wcm90b3R5cGUgPSBwYXRoLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IFBhdGgsXG4gICAgICAgIG1vdmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuXyArPSBcIk1cIiArICh0aGlzLl94MCA9IHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTAgPSB0aGlzLl95MSA9ICt5KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2VQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5feDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94MSA9IHRoaXMuX3gwLCB0aGlzLl95MSA9IHRoaXMuX3kwO1xuICAgICAgICAgICAgICAgIHRoaXMuXyArPSBcIlpcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGluZVRvOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5fICs9IFwiTFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gICAgICAgIH0sXG4gICAgICAgIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuXyArPSBcIlFcIiArICgreDEpICsgXCIsXCIgKyAoK3kxKSArIFwiLFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gICAgICAgIH0sXG4gICAgICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5fICs9IFwiQ1wiICsgKCt4MSkgKyBcIixcIiArICgreTEpICsgXCIsXCIgKyAoK3gyKSArIFwiLFwiICsgKCt5MikgKyBcIixcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICAgICAgICB9LFxuICAgICAgICBhcmNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCByKSB7XG4gICAgICAgICAgICB4MSA9ICt4MSwgeTEgPSAreTEsIHgyID0gK3gyLCB5MiA9ICt5MiwgciA9ICtyO1xuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5feDEsIHkwID0gdGhpcy5feTEsIHgyMSA9IHgyIC0geDEsIHkyMSA9IHkyIC0geTEsIHgwMSA9IHgwIC0geDEsIHkwMSA9IHkwIC0geTEsIGwwMV8yID0geDAxICogeDAxICsgeTAxICogeTAxO1xuICAgICAgICAgICAgLy8gSXMgdGhlIHJhZGl1cyBuZWdhdGl2ZT8gRXJyb3IuXG4gICAgICAgICAgICBpZiAociA8IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmVnYXRpdmUgcmFkaXVzOiBcIiArIHIpO1xuICAgICAgICAgICAgLy8gSXMgdGhpcyBwYXRoIGVtcHR5PyBNb3ZlIHRvICh4MSx5MSkuXG4gICAgICAgICAgICBpZiAodGhpcy5feDEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9yLCBpcyAoeDEseTEpIGNvaW5jaWRlbnQgd2l0aCAoeDAseTApPyBEbyBub3RoaW5nLlxuICAgICAgICAgICAgZWxzZSBpZiAoIShsMDFfMiA+IGVwc2lsb24pKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIC8vIE9yLCBhcmUgKHgwLHkwKSwgKHgxLHkxKSBhbmQgKHgyLHkyKSBjb2xsaW5lYXI/XG4gICAgICAgICAgICAvLyBFcXVpdmFsZW50bHksIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4Mix5Mik/XG4gICAgICAgICAgICAvLyBPciwgaXMgdGhlIHJhZGl1cyB6ZXJvPyBMaW5lIHRvICh4MSx5MSkuXG4gICAgICAgICAgICBlbHNlIGlmICghKE1hdGguYWJzKHkwMSAqIHgyMSAtIHkyMSAqIHgwMSkgPiBlcHNpbG9uKSB8fCAhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuXyArPSBcIkxcIiArICh0aGlzLl94MSA9IHgxKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBkcmF3IGFuIGFyYyFcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB4MjAgPSB4MiAtIHgwLCB5MjAgPSB5MiAtIHkwLCBsMjFfMiA9IHgyMSAqIHgyMSArIHkyMSAqIHkyMSwgbDIwXzIgPSB4MjAgKiB4MjAgKyB5MjAgKiB5MjAsIGwyMSA9IE1hdGguc3FydChsMjFfMiksIGwwMSA9IE1hdGguc3FydChsMDFfMiksIGwgPSByICogTWF0aC50YW4oKHBpIC0gTWF0aC5hY29zKChsMjFfMiArIGwwMV8yIC0gbDIwXzIpIC8gKDIgKiBsMjEgKiBsMDEpKSkgLyAyKSwgdDAxID0gbCAvIGwwMSwgdDIxID0gbCAvIGwyMTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc3RhcnQgdGFuZ2VudCBpcyBub3QgY29pbmNpZGVudCB3aXRoICh4MCx5MCksIGxpbmUgdG8uXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHQwMSAtIDEpID4gZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8gKz0gXCJMXCIgKyAoeDEgKyB0MDEgKiB4MDEpICsgXCIsXCIgKyAoeTEgKyB0MDEgKiB5MDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwwLFwiICsgKCsoeTAxICogeDIwID4geDAxICogeTIwKSkgKyBcIixcIiArICh0aGlzLl94MSA9IHgxICsgdDIxICogeDIxKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTEgKyB0MjEgKiB5MjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhcmM6IGZ1bmN0aW9uICh4LCB5LCByLCBhMCwgYTEsIGNjdykge1xuICAgICAgICAgICAgeCA9ICt4LCB5ID0gK3ksIHIgPSArciwgY2N3ID0gISFjY3c7XG4gICAgICAgICAgICB2YXIgZHggPSByICogTWF0aC5jb3MoYTApLCBkeSA9IHIgKiBNYXRoLnNpbihhMCksIHgwID0geCArIGR4LCB5MCA9IHkgKyBkeSwgY3cgPSAxIF4gY2N3LCBkYSA9IGNjdyA/IGEwIC0gYTEgOiBhMSAtIGEwO1xuICAgICAgICAgICAgLy8gSXMgdGhlIHJhZGl1cyBuZWdhdGl2ZT8gRXJyb3IuXG4gICAgICAgICAgICBpZiAociA8IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmVnYXRpdmUgcmFkaXVzOiBcIiArIHIpO1xuICAgICAgICAgICAgLy8gSXMgdGhpcyBwYXRoIGVtcHR5PyBNb3ZlIHRvICh4MCx5MCkuXG4gICAgICAgICAgICBpZiAodGhpcy5feDEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8gKz0gXCJNXCIgKyB4MCArIFwiLFwiICsgeTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPciwgaXMgKHgwLHkwKSBub3QgY29pbmNpZGVudCB3aXRoIHRoZSBwcmV2aW91cyBwb2ludD8gTGluZSB0byAoeDAseTApLlxuICAgICAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB4MCkgPiBlcHNpbG9uIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0geTApID4gZXBzaWxvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuXyArPSBcIkxcIiArIHgwICsgXCIsXCIgKyB5MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElzIHRoaXMgYXJjIGVtcHR5PyBXZeKAmXJlIGRvbmUuXG4gICAgICAgICAgICBpZiAoIXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gRG9lcyB0aGUgYW5nbGUgZ28gdGhlIHdyb25nIHdheT8gRmxpcCB0aGUgZGlyZWN0aW9uLlxuICAgICAgICAgICAgaWYgKGRhIDwgMClcbiAgICAgICAgICAgICAgICBkYSA9IGRhICUgdGF1ICsgdGF1O1xuICAgICAgICAgICAgLy8gSXMgdGhpcyBhIGNvbXBsZXRlIGNpcmNsZT8gRHJhdyB0d28gYXJjcyB0byBjb21wbGV0ZSB0aGUgY2lyY2xlLlxuICAgICAgICAgICAgaWYgKGRhID4gdGF1RXBzaWxvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuXyArPSBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiwwLDEsXCIgKyBjdyArIFwiLFwiICsgKHggLSBkeCkgKyBcIixcIiArICh5IC0gZHkpICsgXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwxLFwiICsgY3cgKyBcIixcIiArICh0aGlzLl94MSA9IHgwKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSXMgdGhpcyBhcmMgbm9uLWVtcHR5PyBEcmF3IGFuIGFyYyFcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhID4gZXBzaWxvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuXyArPSBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiwwLFwiICsgKCsoZGEgPj0gcGkpKSArIFwiLFwiICsgY3cgKyBcIixcIiArICh0aGlzLl94MSA9IHggKyByICogTWF0aC5jb3MoYTEpKSArIFwiLFwiICsgKHRoaXMuX3kxID0geSArIHIgKiBNYXRoLnNpbihhMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgICAgICAgICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpICsgXCJoXCIgKyAoK3cpICsgXCJ2XCIgKyAoK2gpICsgXCJoXCIgKyAoLXcpICsgXCJaXCI7XG4gICAgICAgIH0sXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLnBhdGggPSBwYXRoO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2QzLXNhbmtleUAwLjkuMUBkMy1zYW5rZXkvZGlzdC9kMy1zYW5rZXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2QzLXNhbmtleUAwLjkuMUBkMy1zYW5rZXkvZGlzdC9kMy1zYW5rZXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2Fua2V5IHYwLjkuMSBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgIHRydWUgPyBmYWN0b3J5KGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWFycmF5QDEuMi40QGQzLWFycmF5L2Rpc3QvZDMtYXJyYXkuanNcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLWNvbGxlY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtY29sbGVjdGlvbkAxLjAuN0BkMy1jb2xsZWN0aW9uL2Rpc3QvZDMtY29sbGVjdGlvbi5qc1wiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtc2hhcGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtc2hhcGVAMS4zLjdAZDMtc2hhcGUvZGlzdC9kMy1zaGFwZS5qc1wiKSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLCBkM0FycmF5LCBkM0NvbGxlY3Rpb24sIGQzU2hhcGUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgZnVuY3Rpb24gdGFyZ2V0RGVwdGgoZCkge1xuICAgICAgICByZXR1cm4gZC50YXJnZXQuZGVwdGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxlZnQobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5kZXB0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmlnaHQobm9kZSwgbikge1xuICAgICAgICByZXR1cm4gbiAtIDEgLSBub2RlLmhlaWdodDtcbiAgICB9XG4gICAgZnVuY3Rpb24ganVzdGlmeShub2RlLCBuKSB7XG4gICAgICAgIHJldHVybiBub2RlLnNvdXJjZUxpbmtzLmxlbmd0aCA/IG5vZGUuZGVwdGggOiBuIC0gMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudGVyKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUudGFyZ2V0TGlua3MubGVuZ3RoID8gbm9kZS5kZXB0aFxuICAgICAgICAgICAgOiBub2RlLnNvdXJjZUxpbmtzLmxlbmd0aCA/IGQzQXJyYXkubWluKG5vZGUuc291cmNlTGlua3MsIHRhcmdldERlcHRoKSAtIDFcbiAgICAgICAgICAgICAgICA6IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc2NlbmRpbmdTb3VyY2VCcmVhZHRoKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFzY2VuZGluZ0JyZWFkdGgoYS5zb3VyY2UsIGIuc291cmNlKSB8fCBhLmluZGV4IC0gYi5pbmRleDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNjZW5kaW5nVGFyZ2V0QnJlYWR0aChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhc2NlbmRpbmdCcmVhZHRoKGEudGFyZ2V0LCBiLnRhcmdldCkgfHwgYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzY2VuZGluZ0JyZWFkdGgoYSwgYikge1xuICAgICAgICByZXR1cm4gYS55MCAtIGIueTA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbHVlKGQpIHtcbiAgICAgICAgcmV0dXJuIGQudmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRJZChkKSB7XG4gICAgICAgIHJldHVybiBkLmluZGV4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0Tm9kZXMoZ3JhcGgpIHtcbiAgICAgICAgcmV0dXJuIGdyYXBoLm5vZGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0TGlua3MoZ3JhcGgpIHtcbiAgICAgICAgcmV0dXJuIGdyYXBoLmxpbmtzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kKG5vZGVCeUlkLCBpZCkge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVCeUlkLmdldChpZCk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmc6IFwiICsgaWQpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2Fua2V5KCkge1xuICAgICAgICB2YXIgeDAgPSAwLCB5MCA9IDAsIHgxID0gMSwgeTEgPSAxLCAvLyBleHRlbnRcbiAgICAgICAgZHggPSAyNCwgLy8gbm9kZVdpZHRoXG4gICAgICAgIHB5ID0gOCwgLy8gbm9kZVBhZGRpbmdcbiAgICAgICAgaWQgPSBkZWZhdWx0SWQsIGFsaWduID0ganVzdGlmeSwgc29ydCwgbm9kZXMgPSBkZWZhdWx0Tm9kZXMsIGxpbmtzID0gZGVmYXVsdExpbmtzLCBpdGVyYXRpb25zID0gNjtcbiAgICAgICAgZnVuY3Rpb24gc2Fua2V5KCkge1xuICAgICAgICAgICAgdmFyIGdyYXBoID0geyBub2Rlczogbm9kZXMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSwgbGlua3M6IGxpbmtzLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgfTtcbiAgICAgICAgICAgIGNvbXB1dGVOb2RlTGlua3MoZ3JhcGgpO1xuICAgICAgICAgICAgY29tcHV0ZU5vZGVWYWx1ZXMoZ3JhcGgpO1xuICAgICAgICAgICAgY29tcHV0ZU5vZGVEZXB0aHMoZ3JhcGgpO1xuICAgICAgICAgICAgY29tcHV0ZU5vZGVCcmVhZHRocyhncmFwaCk7XG4gICAgICAgICAgICBjb21wdXRlTGlua0JyZWFkdGhzKGdyYXBoKTtcbiAgICAgICAgICAgIHJldHVybiBncmFwaDtcbiAgICAgICAgfVxuICAgICAgICBzYW5rZXkudXBkYXRlID0gZnVuY3Rpb24gKGdyYXBoKSB7XG4gICAgICAgICAgICBjb21wdXRlTGlua0JyZWFkdGhzKGdyYXBoKTtcbiAgICAgICAgICAgIHJldHVybiBncmFwaDtcbiAgICAgICAgfTtcbiAgICAgICAgc2Fua2V5Lm5vZGVJZCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIHNhbmtleSkgOiBpZDtcbiAgICAgICAgfTtcbiAgICAgICAgc2Fua2V5Lm5vZGVBbGlnbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbGlnbiA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIHNhbmtleSkgOiBhbGlnbjtcbiAgICAgICAgfTtcbiAgICAgICAgc2Fua2V5Lm5vZGVTb3J0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnQgPSBfLCBzYW5rZXkpIDogc29ydDtcbiAgICAgICAgfTtcbiAgICAgICAgc2Fua2V5Lm5vZGVXaWR0aCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkeCA9ICtfLCBzYW5rZXkpIDogZHg7XG4gICAgICAgIH07XG4gICAgICAgIHNhbmtleS5ub2RlUGFkZGluZyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChweSA9ICtfLCBzYW5rZXkpIDogcHk7XG4gICAgICAgIH07XG4gICAgICAgIHNhbmtleS5ub2RlcyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlcyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIHNhbmtleSkgOiBub2RlcztcbiAgICAgICAgfTtcbiAgICAgICAgc2Fua2V5LmxpbmtzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGxpbmtzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgc2Fua2V5KSA6IGxpbmtzO1xuICAgICAgICB9O1xuICAgICAgICBzYW5rZXkuc2l6ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHkwID0gMCwgeDEgPSArX1swXSwgeTEgPSArX1sxXSwgc2Fua2V5KSA6IFt4MSAtIHgwLCB5MSAtIHkwXTtcbiAgICAgICAgfTtcbiAgICAgICAgc2Fua2V5LmV4dGVudCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9ICtfWzBdWzBdLCB4MSA9ICtfWzFdWzBdLCB5MCA9ICtfWzBdWzFdLCB5MSA9ICtfWzFdWzFdLCBzYW5rZXkpIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgICAgIH07XG4gICAgICAgIHNhbmtleS5pdGVyYXRpb25zID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGl0ZXJhdGlvbnMgPSArXywgc2Fua2V5KSA6IGl0ZXJhdGlvbnM7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBzb3VyY2VMaW5rcyBhbmQgdGFyZ2V0TGlua3MgZm9yIGVhY2ggbm9kZS5cbiAgICAgICAgLy8gQWxzbywgaWYgdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBub3Qgb2JqZWN0cywgYXNzdW1lIHRoZXkgYXJlIGluZGljZXMuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVOb2RlTGlua3MoZ3JhcGgpIHtcbiAgICAgICAgICAgIGdyYXBoLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgICAgICAgICAgICBub2RlLmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBub2RlLnNvdXJjZUxpbmtzID0gW107XG4gICAgICAgICAgICAgICAgbm9kZS50YXJnZXRMaW5rcyA9IFtdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbm9kZUJ5SWQgPSBkM0NvbGxlY3Rpb24ubWFwKGdyYXBoLm5vZGVzLCBpZCk7XG4gICAgICAgICAgICBncmFwaC5saW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rLCBpKSB7XG4gICAgICAgICAgICAgICAgbGluay5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGxpbmsuc291cmNlLCB0YXJnZXQgPSBsaW5rLnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbGluay5zb3VyY2UgPSBmaW5kKG5vZGVCeUlkLCBzb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBsaW5rLnRhcmdldCA9IGZpbmQobm9kZUJ5SWQsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgc291cmNlLnNvdXJjZUxpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnRhcmdldExpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSB2YWx1ZSAoc2l6ZSkgb2YgZWFjaCBub2RlIGJ5IHN1bW1pbmcgdGhlIGFzc29jaWF0ZWQgbGlua3MuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVOb2RlVmFsdWVzKGdyYXBoKSB7XG4gICAgICAgICAgICBncmFwaC5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IE1hdGgubWF4KGQzQXJyYXkuc3VtKG5vZGUuc291cmNlTGlua3MsIHZhbHVlKSwgZDNBcnJheS5zdW0obm9kZS50YXJnZXRMaW5rcywgdmFsdWUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdGl2ZWx5IGFzc2lnbiB0aGUgZGVwdGggKHgtcG9zaXRpb24pIGZvciBlYWNoIG5vZGUuXG4gICAgICAgIC8vIE5vZGVzIGFyZSBhc3NpZ25lZCB0aGUgbWF4aW11bSBkZXB0aCBvZiBpbmNvbWluZyBuZWlnaGJvcnMgcGx1cyBvbmU7XG4gICAgICAgIC8vIG5vZGVzIHdpdGggbm8gaW5jb21pbmcgbGlua3MgYXJlIGFzc2lnbmVkIGRlcHRoIHplcm8sIHdoaWxlXG4gICAgICAgIC8vIG5vZGVzIHdpdGggbm8gb3V0Z29pbmcgbGlua3MgYXJlIGFzc2lnbmVkIHRoZSBtYXhpbXVtIGRlcHRoLlxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlTm9kZURlcHRocyhncmFwaCkge1xuICAgICAgICAgICAgdmFyIG5vZGVzLCBuZXh0LCB4LCBuID0gZ3JhcGgubm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChub2RlcyA9IGdyYXBoLm5vZGVzLCBuZXh0ID0gW10sIHggPSAwOyBub2Rlcy5sZW5ndGg7ICsreCwgbm9kZXMgPSBuZXh0LCBuZXh0ID0gW10pIHtcbiAgICAgICAgICAgICAgICBpZiAoeCA+IG4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNpcmN1bGFyIGxpbmtcIik7XG4gICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmRlcHRoID0geDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zb3VyY2VMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5pbmRleE9mKGxpbmsudGFyZ2V0KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnB1c2gobGluay50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobm9kZXMgPSBncmFwaC5ub2RlcywgbmV4dCA9IFtdLCB4ID0gMDsgbm9kZXMubGVuZ3RoOyArK3gsIG5vZGVzID0gbmV4dCwgbmV4dCA9IFtdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHggPiBuKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaXJjdWxhciBsaW5rXCIpO1xuICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5oZWlnaHQgPSB4O1xuICAgICAgICAgICAgICAgICAgICBub2RlLnRhcmdldExpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmluZGV4T2YobGluay5zb3VyY2UpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQucHVzaChsaW5rLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGt4ID0gKHgxIC0geDAgLSBkeCkgLyAoeCAtIDEpO1xuICAgICAgICAgICAgZ3JhcGgubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUueDEgPSAobm9kZS54MCA9IHgwICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oeCAtIDEsIE1hdGguZmxvb3IoYWxpZ24uY2FsbChudWxsLCBub2RlLCB4KSkpKSAqIGt4KSArIGR4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZU5vZGVCcmVhZHRocyhncmFwaCkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBkM0NvbGxlY3Rpb24ubmVzdCgpXG4gICAgICAgICAgICAgICAgLmtleShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC54MDsgfSlcbiAgICAgICAgICAgICAgICAuc29ydEtleXMoZDNBcnJheS5hc2NlbmRpbmcpXG4gICAgICAgICAgICAgICAgLmVudHJpZXMoZ3JhcGgubm9kZXMpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZXM7IH0pO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGluaXRpYWxpemVOb2RlQnJlYWR0aCgpO1xuICAgICAgICAgICAgcmVzb2x2ZUNvbGxpc2lvbnMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGFscGhhID0gMC45LCBuID0gaXRlcmF0aW9uczsgbiA+IDA7IC0tbiwgYWxwaGEgKj0gMC45KSB7XG4gICAgICAgICAgICAgICAgcmVsYXhSaWdodFRvTGVmdChhbHBoYSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNvbGxpc2lvbnMoKTtcbiAgICAgICAgICAgICAgICByZWxheExlZnRUb1JpZ2h0KGFscGhhKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlQ29sbGlzaW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaW5pdGlhbGl6ZU5vZGVCcmVhZHRoKCkge1xuICAgICAgICAgICAgICAgIHZhciBreSA9IGQzQXJyYXkubWluKGNvbHVtbnMsIGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHkxIC0geTAgLSAobm9kZXMubGVuZ3RoIC0gMSkgKiBweSkgLyBkM0FycmF5LnN1bShub2RlcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNvcnQoc29ydCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUueTEgPSAobm9kZS55MCA9IGkpICsgbm9kZS52YWx1ZSAqIGt5O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBncmFwaC5saW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmsud2lkdGggPSBsaW5rLnZhbHVlICoga3k7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiByZWxheExlZnRUb1JpZ2h0KGFscGhhKSB7XG4gICAgICAgICAgICAgICAgY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gbm9kZS55MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSB0c2xpYl8xLl9fdmFsdWVzKG5vZGUuc291cmNlTGlua3Muc29ydChhc2NlbmRpbmdUYXJnZXRCcmVhZHRoKSksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9lID0gX2QudmFsdWUsIHRhcmdldCA9IF9lLnRhcmdldCwgd2lkdGggPSBfZS53aWR0aCwgdmFsdWVfMSA9IF9lLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVfMSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9mID0gKGVfMiA9IHZvaWQgMCwgdHNsaWJfMS5fX3ZhbHVlcyh0YXJnZXQudGFyZ2V0TGlua3MpKSwgX2cgPSBfZi5uZXh0KCk7ICFfZy5kb25lOyBfZyA9IF9mLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2ggPSBfZy52YWx1ZSwgc291cmNlID0gX2guc291cmNlLCB3aWR0aF8xID0gX2gud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgPT09IG5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHkgKz0gd2lkdGhfMSArIHB5IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9nICYmICFfZy5kb25lICYmIChfYiA9IF9mLnJldHVybikpIF9iLmNhbGwoX2YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeSA9ICh5IC0gZHkgLSB0YXJnZXQueTApICogYWxwaGEgKiAodmFsdWVfMSAvIE1hdGgubWluKG5vZGUudmFsdWUsIHRhcmdldC52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnkwICs9IGR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnkxICs9IGR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gd2lkdGggKyBweSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbGF4UmlnaHRUb0xlZnQoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnNsaWNlKCkucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlXzMsIF9hLCBlXzQsIF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBub2RlLnkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYyA9IHRzbGliXzEuX192YWx1ZXMobm9kZS50YXJnZXRMaW5rcy5zb3J0KGFzY2VuZGluZ1NvdXJjZUJyZWFkdGgpKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2UgPSBfZC52YWx1ZSwgc291cmNlID0gX2Uuc291cmNlLCB3aWR0aCA9IF9lLndpZHRoLCB2YWx1ZV8yID0gX2UudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZV8yID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSAoZV80ID0gdm9pZCAwLCB0c2xpYl8xLl9fdmFsdWVzKHNvdXJjZS5zb3VyY2VMaW5rcykpLCBfZyA9IF9mLm5leHQoKTsgIV9nLmRvbmU7IF9nID0gX2YubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfaCA9IF9nLnZhbHVlLCB0YXJnZXQgPSBfaC50YXJnZXQsIHdpZHRoXzIgPSBfaC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeSArPSB3aWR0aF8yICsgcHkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2cgJiYgIV9nLmRvbmUgJiYgKF9iID0gX2YucmV0dXJuKSkgX2IuY2FsbChfZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5ID0gKHkgLSBkeSAtIHNvdXJjZS55MCkgKiBhbHBoYSAqICh2YWx1ZV8yIC8gTWF0aC5taW4obm9kZS52YWx1ZSwgc291cmNlLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UueTAgKz0gZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UueTEgKz0gZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArPSB3aWR0aCArIHB5IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZUNvbGxpc2lvbnMoKSB7XG4gICAgICAgICAgICAgICAgY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSwgZHksIHkgPSB5MCwgbiA9IG5vZGVzLmxlbmd0aCwgaTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHVzaCBhbnkgb3ZlcmxhcHBpbmcgbm9kZXMgZG93bi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNvcnQoYXNjZW5kaW5nQnJlYWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5ID0geSAtIG5vZGUueTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHkgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUueTAgKz0gZHksIG5vZGUueTEgKz0gZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gbm9kZS55MSArIHB5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBib3R0b21tb3N0IG5vZGUgZ29lcyBvdXRzaWRlIHRoZSBib3VuZHMsIHB1c2ggaXQgYmFjayB1cC5cbiAgICAgICAgICAgICAgICAgICAgZHkgPSB5IC0gcHkgLSB5MTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR5ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IChub2RlLnkwIC09IGR5KSwgbm9kZS55MSAtPSBkeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2ggYW55IG92ZXJsYXBwaW5nIG5vZGVzIGJhY2sgdXAuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSBub2RlLnkxICsgcHkgLSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeSA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUueTAgLT0gZHksIG5vZGUueTEgLT0gZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IG5vZGUueTA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlTGlua0JyZWFkdGhzKGdyYXBoKSB7XG4gICAgICAgICAgICBncmFwaC5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zb3VyY2VMaW5rcy5zb3J0KGFzY2VuZGluZ1RhcmdldEJyZWFkdGgpO1xuICAgICAgICAgICAgICAgIG5vZGUudGFyZ2V0TGlua3Muc29ydChhc2NlbmRpbmdTb3VyY2VCcmVhZHRoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JhcGgubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciB5MCA9IG5vZGUueTAsIHkxID0geTA7XG4gICAgICAgICAgICAgICAgbm9kZS5zb3VyY2VMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmsueTAgPSB5MCArIGxpbmsud2lkdGggLyAyLCB5MCArPSBsaW5rLndpZHRoO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG5vZGUudGFyZ2V0TGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgICAgICAgICAgICBsaW5rLnkxID0geTEgKyBsaW5rLndpZHRoIC8gMiwgeTEgKz0gbGluay53aWR0aDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYW5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvcml6b250YWxTb3VyY2UoZCkge1xuICAgICAgICByZXR1cm4gW2Quc291cmNlLngxLCBkLnkwXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaG9yaXpvbnRhbFRhcmdldChkKSB7XG4gICAgICAgIHJldHVybiBbZC50YXJnZXQueDAsIGQueTFdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzYW5rZXlMaW5rSG9yaXpvbnRhbCgpIHtcbiAgICAgICAgcmV0dXJuIGQzU2hhcGUubGlua0hvcml6b250YWwoKVxuICAgICAgICAgICAgLnNvdXJjZShob3Jpem9udGFsU291cmNlKVxuICAgICAgICAgICAgLnRhcmdldChob3Jpem9udGFsVGFyZ2V0KTtcbiAgICB9XG4gICAgZXhwb3J0cy5zYW5rZXkgPSBTYW5rZXk7XG4gICAgZXhwb3J0cy5zYW5rZXlDZW50ZXIgPSBjZW50ZXI7XG4gICAgZXhwb3J0cy5zYW5rZXlMZWZ0ID0gbGVmdDtcbiAgICBleHBvcnRzLnNhbmtleVJpZ2h0ID0gcmlnaHQ7XG4gICAgZXhwb3J0cy5zYW5rZXlKdXN0aWZ5ID0ganVzdGlmeTtcbiAgICBleHBvcnRzLnNhbmtleUxpbmtIb3Jpem9udGFsID0gc2Fua2V5TGlua0hvcml6b250YWw7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn0pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtc2hhcGVAMS4zLjdAZDMtc2hhcGUvZGlzdC9kMy1zaGFwZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZDMtc2hhcGVAMS4zLjdAZDMtc2hhcGUvZGlzdC9kMy1zaGFwZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBodHRwczovL2QzanMub3JnL2QzLXNoYXBlLyB2MS4zLjcgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgICB0cnVlID8gZmFjdG9yeShleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1wYXRoICovIFwiLi9ub2RlX21vZHVsZXMvX2QzLXBhdGhAMS4wLjlAZDMtcGF0aC9kaXN0L2QzLXBhdGguanNcIikpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgZDNQYXRoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN0YW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluO1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgc3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgZXBzaWxvbiA9IDFlLTEyO1xuICAgIHZhciBwaSA9IE1hdGguUEk7XG4gICAgdmFyIGhhbGZQaSA9IHBpIC8gMjtcbiAgICB2YXIgdGF1ID0gMiAqIHBpO1xuICAgIGZ1bmN0aW9uIGFjb3MoeCkge1xuICAgICAgICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkgOiBNYXRoLmFjb3MoeCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzaW4oeCkge1xuICAgICAgICByZXR1cm4geCA+PSAxID8gaGFsZlBpIDogeCA8PSAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyY0lubmVyUmFkaXVzKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaW5uZXJSYWRpdXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyY091dGVyUmFkaXVzKGQpIHtcbiAgICAgICAgcmV0dXJuIGQub3V0ZXJSYWRpdXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyY1N0YXJ0QW5nbGUoZCkge1xuICAgICAgICByZXR1cm4gZC5zdGFydEFuZ2xlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmNFbmRBbmdsZShkKSB7XG4gICAgICAgIHJldHVybiBkLmVuZEFuZ2xlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmNQYWRBbmdsZShkKSB7XG4gICAgICAgIHJldHVybiBkICYmIGQucGFkQW5nbGU7IC8vIE5vdGU6IG9wdGlvbmFsIVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3QoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgIHZhciB4MTAgPSB4MSAtIHgwLCB5MTAgPSB5MSAtIHkwLCB4MzIgPSB4MyAtIHgyLCB5MzIgPSB5MyAtIHkyLCB0ID0geTMyICogeDEwIC0geDMyICogeTEwO1xuICAgICAgICBpZiAodCAqIHQgPCBlcHNpbG9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0ID0gKHgzMiAqICh5MCAtIHkyKSAtIHkzMiAqICh4MCAtIHgyKSkgLyB0O1xuICAgICAgICByZXR1cm4gW3gwICsgdCAqIHgxMCwgeTAgKyB0ICogeTEwXTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSBwZXJwZW5kaWN1bGFyIG9mZnNldCBsaW5lIG9mIGxlbmd0aCByYy5cbiAgICAvLyBodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0NpcmNsZS1MaW5lSW50ZXJzZWN0aW9uLmh0bWxcbiAgICBmdW5jdGlvbiBjb3JuZXJUYW5nZW50cyh4MCwgeTAsIHgxLCB5MSwgcjEsIHJjLCBjdykge1xuICAgICAgICB2YXIgeDAxID0geDAgLSB4MSwgeTAxID0geTAgLSB5MSwgbG8gPSAoY3cgPyByYyA6IC1yYykgLyBzcXJ0KHgwMSAqIHgwMSArIHkwMSAqIHkwMSksIG94ID0gbG8gKiB5MDEsIG95ID0gLWxvICogeDAxLCB4MTEgPSB4MCArIG94LCB5MTEgPSB5MCArIG95LCB4MTAgPSB4MSArIG94LCB5MTAgPSB5MSArIG95LCB4MDAgPSAoeDExICsgeDEwKSAvIDIsIHkwMCA9ICh5MTEgKyB5MTApIC8gMiwgZHggPSB4MTAgLSB4MTEsIGR5ID0geTEwIC0geTExLCBkMiA9IGR4ICogZHggKyBkeSAqIGR5LCByID0gcjEgLSByYywgRCA9IHgxMSAqIHkxMCAtIHgxMCAqIHkxMSwgZCA9IChkeSA8IDAgPyAtMSA6IDEpICogc3FydChtYXgoMCwgciAqIHIgKiBkMiAtIEQgKiBEKSksIGN4MCA9IChEICogZHkgLSBkeCAqIGQpIC8gZDIsIGN5MCA9ICgtRCAqIGR4IC0gZHkgKiBkKSAvIGQyLCBjeDEgPSAoRCAqIGR5ICsgZHggKiBkKSAvIGQyLCBjeTEgPSAoLUQgKiBkeCArIGR5ICogZCkgLyBkMiwgZHgwID0gY3gwIC0geDAwLCBkeTAgPSBjeTAgLSB5MDAsIGR4MSA9IGN4MSAtIHgwMCwgZHkxID0gY3kxIC0geTAwO1xuICAgICAgICAvLyBQaWNrIHRoZSBjbG9zZXIgb2YgdGhlIHR3byBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuICAgICAgICAvLyBUT0RPIElzIHRoZXJlIGEgZmFzdGVyIHdheSB0byBkZXRlcm1pbmUgd2hpY2ggaW50ZXJzZWN0aW9uIHRvIHVzZT9cbiAgICAgICAgaWYgKGR4MCAqIGR4MCArIGR5MCAqIGR5MCA+IGR4MSAqIGR4MSArIGR5MSAqIGR5MSlcbiAgICAgICAgICAgIGN4MCA9IGN4MSwgY3kwID0gY3kxO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3g6IGN4MCxcbiAgICAgICAgICAgIGN5OiBjeTAsXG4gICAgICAgICAgICB4MDE6IC1veCxcbiAgICAgICAgICAgIHkwMTogLW95LFxuICAgICAgICAgICAgeDExOiBjeDAgKiAocjEgLyByIC0gMSksXG4gICAgICAgICAgICB5MTE6IGN5MCAqIChyMSAvIHIgLSAxKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmMoKSB7XG4gICAgICAgIHZhciBpbm5lclJhZGl1cyA9IGFyY0lubmVyUmFkaXVzLCBvdXRlclJhZGl1cyA9IGFyY091dGVyUmFkaXVzLCBjb3JuZXJSYWRpdXMgPSBjb25zdGFudCgwKSwgcGFkUmFkaXVzID0gbnVsbCwgc3RhcnRBbmdsZSA9IGFyY1N0YXJ0QW5nbGUsIGVuZEFuZ2xlID0gYXJjRW5kQW5nbGUsIHBhZEFuZ2xlID0gYXJjUGFkQW5nbGUsIGNvbnRleHQgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBhcmMoKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyLCByLCByMCA9ICtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCByMSA9ICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBhMCA9IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGZQaSwgYTEgPSBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpLCBkYSA9IGFicyhhMSAtIGEwKSwgY3cgPSBhMSA+IGEwO1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0KVxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBidWZmZXIgPSBkM1BhdGgucGF0aCgpO1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIG91dGVyIHJhZGl1cyBpcyBhbHdheXMgbGFyZ2VyIHRoYW4gdGhlIGlubmVyIHJhZGl1cy5cbiAgICAgICAgICAgIGlmIChyMSA8IHIwKVxuICAgICAgICAgICAgICAgIHIgPSByMSwgcjEgPSByMCwgcjAgPSByO1xuICAgICAgICAgICAgLy8gSXMgaXQgYSBwb2ludD9cbiAgICAgICAgICAgIGlmICghKHIxID4gZXBzaWxvbikpXG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgICAgICAvLyBPciBpcyBpdCBhIGNpcmNsZSBvciBhbm51bHVzP1xuICAgICAgICAgICAgZWxzZSBpZiAoZGEgPiB0YXUgLSBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocjEgKiBjb3MoYTApLCByMSAqIHNpbihhMCkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhMCwgYTEsICFjdyk7XG4gICAgICAgICAgICAgICAgaWYgKHIwID4gZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhyMCAqIGNvcyhhMSksIHIwICogc2luKGExKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMSwgYTAsIGN3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPciBpcyBpdCBhIGNpcmN1bGFyIG9yIGFubnVsYXIgc2VjdG9yP1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGEwMSA9IGEwLCBhMTEgPSBhMSwgYTAwID0gYTAsIGExMCA9IGExLCBkYTAgPSBkYSwgZGExID0gZGEsIGFwID0gcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvIDIsIHJwID0gKGFwID4gZXBzaWxvbikgJiYgKHBhZFJhZGl1cyA/ICtwYWRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHNxcnQocjAgKiByMCArIHIxICogcjEpKSwgcmMgPSBtaW4oYWJzKHIxIC0gcjApIC8gMiwgK2Nvcm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSwgcmMwID0gcmMsIHJjMSA9IHJjLCB0MCwgdDE7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgcGFkZGluZz8gTm90ZSB0aGF0IHNpbmNlIHIxIOKJpSByMCwgZGExIOKJpSBkYTAuXG4gICAgICAgICAgICAgICAgaWYgKHJwID4gZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcDAgPSBhc2luKHJwIC8gcjAgKiBzaW4oYXApKSwgcDEgPSBhc2luKHJwIC8gcjEgKiBzaW4oYXApKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkYTAgLT0gcDAgKiAyKSA+IGVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBwMCAqPSAoY3cgPyAxIDogLTEpLCBhMDAgKz0gcDAsIGExMCAtPSBwMDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGEwID0gMCwgYTAwID0gYTEwID0gKGEwICsgYTEpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkYTEgLT0gcDEgKiAyKSA+IGVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBwMSAqPSAoY3cgPyAxIDogLTEpLCBhMDEgKz0gcDEsIGExMSAtPSBwMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGExID0gMCwgYTAxID0gYTExID0gKGEwICsgYTEpIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHgwMSA9IHIxICogY29zKGEwMSksIHkwMSA9IHIxICogc2luKGEwMSksIHgxMCA9IHIwICogY29zKGExMCksIHkxMCA9IHIwICogc2luKGExMCk7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgICAgICAgICAgIGlmIChyYyA+IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxMSA9IHIxICogY29zKGExMSksIHkxMSA9IHIxICogc2luKGExMSksIHgwMCA9IHIwICogY29zKGEwMCksIHkwMCA9IHIwICogc2luKGEwMCksIG9jO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0cmljdCB0aGUgY29ybmVyIHJhZGl1cyBhY2NvcmRpbmcgdG8gdGhlIHNlY3RvciBhbmdsZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhIDwgcGkgJiYgKG9jID0gaW50ZXJzZWN0KHgwMSwgeTAxLCB4MDAsIHkwMCwgeDExLCB5MTEsIHgxMCwgeTEwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheCA9IHgwMSAtIG9jWzBdLCBheSA9IHkwMSAtIG9jWzFdLCBieCA9IHgxMSAtIG9jWzBdLCBieSA9IHkxMSAtIG9jWzFdLCBrYyA9IDEgLyBzaW4oYWNvcygoYXggKiBieCArIGF5ICogYnkpIC8gKHNxcnQoYXggKiBheCArIGF5ICogYXkpICogc3FydChieCAqIGJ4ICsgYnkgKiBieSkpKSAvIDIpLCBsYyA9IHNxcnQob2NbMF0gKiBvY1swXSArIG9jWzFdICogb2NbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmMwID0gbWluKHJjLCAocjAgLSBsYykgLyAoa2MgLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYzEgPSBtaW4ocmMsIChyMSAtIGxjKSAvIChrYyArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJcyB0aGUgc2VjdG9yIGNvbGxhcHNlZCB0byBhIGxpbmU/XG4gICAgICAgICAgICAgICAgaWYgKCEoZGExID4gZXBzaWxvbikpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKTtcbiAgICAgICAgICAgICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIG91dGVyIHJpbmcgaGF2ZSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmMxID4gZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgwMCwgeTAwLCB4MDEsIHkwMSwgcjEsIHJjMSwgY3cpO1xuICAgICAgICAgICAgICAgICAgICB0MSA9IGNvcm5lclRhbmdlbnRzKHgxMSwgeTExLCB4MTAsIHkxMCwgcjEsIHJjMSwgY3cpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh0MC5jeCArIHQwLngwMSwgdDAuY3kgKyB0MC55MDEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJjMSA8IHJjKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzEsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGRyYXcgdGhlIHR3byBjb3JuZXJzIGFuZCB0aGUgcmluZy5cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MC55MTEsIHQwLngxMSksICFjdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMSwgYXRhbjIodDAuY3kgKyB0MC55MTEsIHQwLmN4ICsgdDAueDExKSwgYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgIWN3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMxLCBhdGFuMih0MS55MTEsIHQxLngxMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPciBpcyB0aGUgb3V0ZXIgcmluZyBqdXN0IGEgY2lyY3VsYXIgYXJjP1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpLCBjb250ZXh0LmFyYygwLCAwLCByMSwgYTAxLCBhMTEsICFjdyk7XG4gICAgICAgICAgICAgICAgLy8gSXMgdGhlcmUgbm8gaW5uZXIgcmluZywgYW5kIGl04oCZcyBhIGNpcmN1bGFyIHNlY3Rvcj9cbiAgICAgICAgICAgICAgICAvLyBPciBwZXJoYXBzIGl04oCZcyBhbiBhbm51bGFyIHNlY3RvciBjb2xsYXBzZWQgZHVlIHRvIHBhZGRpbmc/XG4gICAgICAgICAgICAgICAgaWYgKCEocjAgPiBlcHNpbG9uKSB8fCAhKGRhMCA+IGVwc2lsb24pKVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4MTAsIHkxMCk7XG4gICAgICAgICAgICAgICAgLy8gRG9lcyB0aGUgc2VjdG9y4oCZcyBpbm5lciByaW5nIChvciBwb2ludCkgaGF2ZSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmMwID4gZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgxMCwgeTEwLCB4MTEsIHkxMSwgcjAsIC1yYzAsIGN3KTtcbiAgICAgICAgICAgICAgICAgICAgdDEgPSBjb3JuZXJUYW5nZW50cyh4MDEsIHkwMSwgeDAwLCB5MDAsIHIwLCAtcmMwLCBjdyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHQwLmN4ICsgdDAueDAxLCB0MC5jeSArIHQwLnkwMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhdmUgdGhlIGNvcm5lcnMgbWVyZ2VkP1xuICAgICAgICAgICAgICAgICAgICBpZiAocmMwIDwgcmMpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMwLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQwLnkxMSwgdDAueDExKSwgIWN3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhdGFuMih0MC5jeSArIHQwLnkxMSwgdDAuY3ggKyB0MC54MTEpLCBhdGFuMih0MS5jeSArIHQxLnkxMSwgdDEuY3ggKyB0MS54MTEpLCBjdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyh0MS5jeCwgdDEuY3ksIHJjMCwgYXRhbjIodDEueTExLCB0MS54MTEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3IgaXMgdGhlIGlubmVyIHJpbmcganVzdCBhIGNpcmN1bGFyIGFyYz9cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMTAsIGEwMCwgY3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGlmIChidWZmZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYXJjLmNlbnRyb2lkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHIgPSAoK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyLCBhID0gKCtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyIC0gcGkgLyAyO1xuICAgICAgICAgICAgcmV0dXJuIFtjb3MoYSkgKiByLCBzaW4oYSkgKiByXTtcbiAgICAgICAgfTtcbiAgICAgICAgYXJjLmlubmVyUmFkaXVzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGlubmVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBpbm5lclJhZGl1cztcbiAgICAgICAgfTtcbiAgICAgICAgYXJjLm91dGVyUmFkaXVzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG91dGVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBvdXRlclJhZGl1cztcbiAgICAgICAgfTtcbiAgICAgICAgYXJjLmNvcm5lclJhZGl1cyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb3JuZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGNvcm5lclJhZGl1cztcbiAgICAgICAgfTtcbiAgICAgICAgYXJjLnBhZFJhZGl1cyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRSYWRpdXMgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBwYWRSYWRpdXM7XG4gICAgICAgIH07XG4gICAgICAgIGFyYy5zdGFydEFuZ2xlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0YXJ0QW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHN0YXJ0QW5nbGU7XG4gICAgICAgIH07XG4gICAgICAgIGFyYy5lbmRBbmdsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlbmRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogZW5kQW5nbGU7XG4gICAgICAgIH07XG4gICAgICAgIGFyYy5wYWRBbmdsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogcGFkQW5nbGU7XG4gICAgICAgIH07XG4gICAgICAgIGFyYy5jb250ZXh0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8pLCBhcmMpIDogY29udGV4dDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGFyYztcbiAgICB9XG4gICAgZnVuY3Rpb24gTGluZWFyKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIExpbmVhci5wcm90b3R5cGUgPSB7XG4gICAgICAgIGFyZWFTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGFyZWFFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB4ID0gK3gsIHkgPSAreTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyAvLyBwcm9jZWVkXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjdXJ2ZUxpbmVhcihjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZWFyKGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB4KHApIHtcbiAgICAgICAgcmV0dXJuIHBbMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHkocCkge1xuICAgICAgICByZXR1cm4gcFsxXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZSgpIHtcbiAgICAgICAgdmFyIHgkMSA9IHgsIHkkMSA9IHksIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSwgY29udGV4dCA9IG51bGwsIGN1cnZlID0gY3VydmVMaW5lYXIsIG91dHB1dCA9IG51bGw7XG4gICAgICAgIGZ1bmN0aW9uIGxpbmUoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGksIG4gPSBkYXRhLmxlbmd0aCwgZCwgZGVmaW5lZDAgPSBmYWxzZSwgYnVmZmVyO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBjdXJ2ZShidWZmZXIgPSBkM1BhdGgucGF0aCgpKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoaSA8IG4gJiYgZGVmaW5lZChkID0gZGF0YVtpXSwgaSwgZGF0YSkpID09PSBkZWZpbmVkMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkMClcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnBvaW50KCt4JDEoZCwgaSwgZGF0YSksICt5JDEoZCwgaSwgZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUueCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4JDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluZSkgOiB4JDE7XG4gICAgICAgIH07XG4gICAgICAgIGxpbmUueSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5JDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluZSkgOiB5JDE7XG4gICAgICAgIH07XG4gICAgICAgIGxpbmUuZGVmaW5lZCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBsaW5lKSA6IGRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIGxpbmUuY3VydmUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY3VydmUgPSBfLCBjb250ZXh0ICE9IG51bGwgJiYgKG91dHB1dCA9IGN1cnZlKGNvbnRleHQpKSwgbGluZSkgOiBjdXJ2ZTtcbiAgICAgICAgfTtcbiAgICAgICAgbGluZS5jb250ZXh0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IGNvbnRleHQgPSBvdXRwdXQgPSBudWxsIDogb3V0cHV0ID0gY3VydmUoY29udGV4dCA9IF8pLCBsaW5lKSA6IGNvbnRleHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmVhKCkge1xuICAgICAgICB2YXIgeDAgPSB4LCB4MSA9IG51bGwsIHkwID0gY29uc3RhbnQoMCksIHkxID0geSwgZGVmaW5lZCA9IGNvbnN0YW50KHRydWUpLCBjb250ZXh0ID0gbnVsbCwgY3VydmUgPSBjdXJ2ZUxpbmVhciwgb3V0cHV0ID0gbnVsbDtcbiAgICAgICAgZnVuY3Rpb24gYXJlYShkYXRhKSB7XG4gICAgICAgICAgICB2YXIgaSwgaiwgaywgbiA9IGRhdGEubGVuZ3RoLCBkLCBkZWZpbmVkMCA9IGZhbHNlLCBidWZmZXIsIHgweiA9IG5ldyBBcnJheShuKSwgeTB6ID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBjdXJ2ZShidWZmZXIgPSBkM1BhdGgucGF0aCgpKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoaSA8IG4gJiYgZGVmaW5lZChkID0gZGF0YVtpXSwgaSwgZGF0YSkpID09PSBkZWZpbmVkMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFyZWFTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IGkgLSAxOyBrID49IGo7IC0taykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wb2ludCh4MHpba10sIHkweltrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmFyZWFFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVmaW5lZDApIHtcbiAgICAgICAgICAgICAgICAgICAgeDB6W2ldID0gK3gwKGQsIGksIGRhdGEpLCB5MHpbaV0gPSAreTAoZCwgaSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wb2ludCh4MSA/ICt4MShkLCBpLCBkYXRhKSA6IHgweltpXSwgeTEgPyAreTEoZCwgaSwgZGF0YSkgOiB5MHpbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWZmZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcmVhbGluZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lKCkuZGVmaW5lZChkZWZpbmVkKS5jdXJ2ZShjdXJ2ZSkuY29udGV4dChjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBhcmVhLnggPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgeDEgPSBudWxsLCBhcmVhKSA6IHgwO1xuICAgICAgICB9O1xuICAgICAgICBhcmVhLngwID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeDA7XG4gICAgICAgIH07XG4gICAgICAgIGFyZWEueDEgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDEgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeDE7XG4gICAgICAgIH07XG4gICAgICAgIGFyZWEueSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB5MSA9IG51bGwsIGFyZWEpIDogeTA7XG4gICAgICAgIH07XG4gICAgICAgIGFyZWEueTAgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB5MDtcbiAgICAgICAgfTtcbiAgICAgICAgYXJlYS55MSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MSA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB5MTtcbiAgICAgICAgfTtcbiAgICAgICAgYXJlYS5saW5lWDAgPVxuICAgICAgICAgICAgYXJlYS5saW5lWTAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBhcmVhLmxpbmVZMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVhbGluZSgpLngoeDApLnkoeTEpO1xuICAgICAgICB9O1xuICAgICAgICBhcmVhLmxpbmVYMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVhbGluZSgpLngoeDEpLnkoeTApO1xuICAgICAgICB9O1xuICAgICAgICBhcmVhLmRlZmluZWQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVmaW5lZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgYXJlYSkgOiBkZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICBhcmVhLmN1cnZlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGN1cnZlID0gXywgY29udGV4dCAhPSBudWxsICYmIChvdXRwdXQgPSBjdXJ2ZShjb250ZXh0KSksIGFyZWEpIDogY3VydmU7XG4gICAgICAgIH07XG4gICAgICAgIGFyZWEuY29udGV4dCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgYXJlYSkgOiBjb250ZXh0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXJlYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY2VuZGluZyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBiIDwgYSA/IC0xIDogYiA+IGEgPyAxIDogYiA+PSBhID8gMCA6IE5hTjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaWRlbnRpdHkoZCkge1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGllKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpZGVudGl0eSwgc29ydFZhbHVlcyA9IGRlc2NlbmRpbmcsIHNvcnQgPSBudWxsLCBzdGFydEFuZ2xlID0gY29uc3RhbnQoMCksIGVuZEFuZ2xlID0gY29uc3RhbnQodGF1KSwgcGFkQW5nbGUgPSBjb25zdGFudCgwKTtcbiAgICAgICAgZnVuY3Rpb24gcGllKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBpLCBuID0gZGF0YS5sZW5ndGgsIGosIGssIHN1bSA9IDAsIGluZGV4ID0gbmV3IEFycmF5KG4pLCBhcmNzID0gbmV3IEFycmF5KG4pLCBhMCA9ICtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGRhID0gTWF0aC5taW4odGF1LCBNYXRoLm1heCgtdGF1LCBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gYTApKSwgYTEsIHAgPSBNYXRoLm1pbihNYXRoLmFicyhkYSkgLyBuLCBwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSwgcGEgPSBwICogKGRhIDwgMCA/IC0xIDogMSksIHY7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh2ID0gYXJjc1tpbmRleFtpXSA9IGldID0gK3ZhbHVlKGRhdGFbaV0sIGksIGRhdGEpKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3B0aW9uYWxseSBzb3J0IHRoZSBhcmNzIGJ5IHByZXZpb3VzbHktY29tcHV0ZWQgdmFsdWVzIG9yIGJ5IGRhdGEuXG4gICAgICAgICAgICBpZiAoc29ydFZhbHVlcyAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGluZGV4LnNvcnQoZnVuY3Rpb24gKGksIGopIHsgcmV0dXJuIHNvcnRWYWx1ZXMoYXJjc1tpXSwgYXJjc1tqXSk7IH0pO1xuICAgICAgICAgICAgZWxzZSBpZiAoc29ydCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGluZGV4LnNvcnQoZnVuY3Rpb24gKGksIGopIHsgcmV0dXJuIHNvcnQoZGF0YVtpXSwgZGF0YVtqXSk7IH0pO1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgYXJjcyEgVGhleSBhcmUgc3RvcmVkIGluIHRoZSBvcmlnaW5hbCBkYXRhJ3Mgb3JkZXIuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBrID0gc3VtID8gKGRhIC0gbiAqIHBhKSAvIHN1bSA6IDA7IGkgPCBuOyArK2ksIGEwID0gYTEpIHtcbiAgICAgICAgICAgICAgICBqID0gaW5kZXhbaV0sIHYgPSBhcmNzW2pdLCBhMSA9IGEwICsgKHYgPiAwID8gdiAqIGsgOiAwKSArIHBhLCBhcmNzW2pdID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhW2pdLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IGEwLFxuICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZTogYTEsXG4gICAgICAgICAgICAgICAgICAgIHBhZEFuZ2xlOiBwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmNzO1xuICAgICAgICB9XG4gICAgICAgIHBpZS52YWx1ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2YWx1ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHBpZS5zb3J0VmFsdWVzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnRWYWx1ZXMgPSBfLCBzb3J0ID0gbnVsbCwgcGllKSA6IHNvcnRWYWx1ZXM7XG4gICAgICAgIH07XG4gICAgICAgIHBpZS5zb3J0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnQgPSBfLCBzb3J0VmFsdWVzID0gbnVsbCwgcGllKSA6IHNvcnQ7XG4gICAgICAgIH07XG4gICAgICAgIHBpZS5zdGFydEFuZ2xlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0YXJ0QW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IHN0YXJ0QW5nbGU7XG4gICAgICAgIH07XG4gICAgICAgIHBpZS5lbmRBbmdsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlbmRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogZW5kQW5nbGU7XG4gICAgICAgIH07XG4gICAgICAgIHBpZS5wYWRBbmdsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogcGFkQW5nbGU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwaWU7XG4gICAgfVxuICAgIHZhciBjdXJ2ZVJhZGlhbExpbmVhciA9IGN1cnZlUmFkaWFsKGN1cnZlTGluZWFyKTtcbiAgICBmdW5jdGlvbiBSYWRpYWwoY3VydmUpIHtcbiAgICAgICAgdGhpcy5fY3VydmUgPSBjdXJ2ZTtcbiAgICB9XG4gICAgUmFkaWFsLnByb3RvdHlwZSA9IHtcbiAgICAgICAgYXJlYVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZS5hcmVhU3RhcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY3VydmUuYXJlYUVuZCgpO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnZlLmxpbmVTdGFydCgpO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZS5saW5lRW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoYSwgcikge1xuICAgICAgICAgICAgdGhpcy5fY3VydmUucG9pbnQociAqIE1hdGguc2luKGEpLCByICogLU1hdGguY29zKGEpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gY3VydmVSYWRpYWwoY3VydmUpIHtcbiAgICAgICAgZnVuY3Rpb24gcmFkaWFsKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFkaWFsKGN1cnZlKGNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICByYWRpYWwuX2N1cnZlID0gY3VydmU7XG4gICAgICAgIHJldHVybiByYWRpYWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVSYWRpYWwobCkge1xuICAgICAgICB2YXIgYyA9IGwuY3VydmU7XG4gICAgICAgIGwuYW5nbGUgPSBsLngsIGRlbGV0ZSBsLng7XG4gICAgICAgIGwucmFkaXVzID0gbC55LCBkZWxldGUgbC55O1xuICAgICAgICBsLmN1cnZlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gYyhjdXJ2ZVJhZGlhbChfKSkgOiBjKCkuX2N1cnZlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZVJhZGlhbCQxKCkge1xuICAgICAgICByZXR1cm4gbGluZVJhZGlhbChsaW5lKCkuY3VydmUoY3VydmVSYWRpYWxMaW5lYXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJlYVJhZGlhbCgpIHtcbiAgICAgICAgdmFyIGEgPSBhcmVhKCkuY3VydmUoY3VydmVSYWRpYWxMaW5lYXIpLCBjID0gYS5jdXJ2ZSwgeDAgPSBhLmxpbmVYMCwgeDEgPSBhLmxpbmVYMSwgeTAgPSBhLmxpbmVZMCwgeTEgPSBhLmxpbmVZMTtcbiAgICAgICAgYS5hbmdsZSA9IGEueCwgZGVsZXRlIGEueDtcbiAgICAgICAgYS5zdGFydEFuZ2xlID0gYS54MCwgZGVsZXRlIGEueDA7XG4gICAgICAgIGEuZW5kQW5nbGUgPSBhLngxLCBkZWxldGUgYS54MTtcbiAgICAgICAgYS5yYWRpdXMgPSBhLnksIGRlbGV0ZSBhLnk7XG4gICAgICAgIGEuaW5uZXJSYWRpdXMgPSBhLnkwLCBkZWxldGUgYS55MDtcbiAgICAgICAgYS5vdXRlclJhZGl1cyA9IGEueTEsIGRlbGV0ZSBhLnkxO1xuICAgICAgICBhLmxpbmVTdGFydEFuZ2xlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGluZVJhZGlhbCh4MCgpKTsgfSwgZGVsZXRlIGEubGluZVgwO1xuICAgICAgICBhLmxpbmVFbmRBbmdsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmVSYWRpYWwoeDEoKSk7IH0sIGRlbGV0ZSBhLmxpbmVYMTtcbiAgICAgICAgYS5saW5lSW5uZXJSYWRpdXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsaW5lUmFkaWFsKHkwKCkpOyB9LCBkZWxldGUgYS5saW5lWTA7XG4gICAgICAgIGEubGluZU91dGVyUmFkaXVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGluZVJhZGlhbCh5MSgpKTsgfSwgZGVsZXRlIGEubGluZVkxO1xuICAgICAgICBhLmN1cnZlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gYyhjdXJ2ZVJhZGlhbChfKSkgOiBjKCkuX2N1cnZlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRSYWRpYWwoeCwgeSkge1xuICAgICAgICByZXR1cm4gWyh5ID0gK3kpICogTWF0aC5jb3MoeCAtPSBNYXRoLlBJIC8gMiksIHkgKiBNYXRoLnNpbih4KV07XG4gICAgfVxuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgICBmdW5jdGlvbiBsaW5rU291cmNlKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuc291cmNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5rVGFyZ2V0KGQpIHtcbiAgICAgICAgcmV0dXJuIGQudGFyZ2V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5rKGN1cnZlKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBsaW5rU291cmNlLCB0YXJnZXQgPSBsaW5rVGFyZ2V0LCB4JDEgPSB4LCB5JDEgPSB5LCBjb250ZXh0ID0gbnVsbDtcbiAgICAgICAgZnVuY3Rpb24gbGluaygpIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIsIGFyZ3YgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksIHMgPSBzb3VyY2UuYXBwbHkodGhpcywgYXJndiksIHQgPSB0YXJnZXQuYXBwbHkodGhpcywgYXJndik7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQpXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGJ1ZmZlciA9IGQzUGF0aC5wYXRoKCk7XG4gICAgICAgICAgICBjdXJ2ZShjb250ZXh0LCAreCQxLmFwcGx5KHRoaXMsIChhcmd2WzBdID0gcywgYXJndikpLCAreSQxLmFwcGx5KHRoaXMsIGFyZ3YpLCAreCQxLmFwcGx5KHRoaXMsIChhcmd2WzBdID0gdCwgYXJndikpLCAreSQxLmFwcGx5KHRoaXMsIGFyZ3YpKTtcbiAgICAgICAgICAgIGlmIChidWZmZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGluay5zb3VyY2UgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc291cmNlID0gXywgbGluaykgOiBzb3VyY2U7XG4gICAgICAgIH07XG4gICAgICAgIGxpbmsudGFyZ2V0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRhcmdldCA9IF8sIGxpbmspIDogdGFyZ2V0O1xuICAgICAgICB9O1xuICAgICAgICBsaW5rLnggPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCQxID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmspIDogeCQxO1xuICAgICAgICB9O1xuICAgICAgICBsaW5rLnkgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSQxID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmspIDogeSQxO1xuICAgICAgICB9O1xuICAgICAgICBsaW5rLmNvbnRleHQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXyksIGxpbmspIDogY29udGV4dDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN1cnZlSG9yaXpvbnRhbChjb250ZXh0LCB4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeDAgPSAoeDAgKyB4MSkgLyAyLCB5MCwgeDAsIHkxLCB4MSwgeTEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjdXJ2ZVZlcnRpY2FsKGNvbnRleHQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCwgeTAgPSAoeTAgKyB5MSkgLyAyLCB4MSwgeTAsIHgxLCB5MSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN1cnZlUmFkaWFsJDEoY29udGV4dCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgICAgdmFyIHAwID0gcG9pbnRSYWRpYWwoeDAsIHkwKSwgcDEgPSBwb2ludFJhZGlhbCh4MCwgeTAgPSAoeTAgKyB5MSkgLyAyKSwgcDIgPSBwb2ludFJhZGlhbCh4MSwgeTApLCBwMyA9IHBvaW50UmFkaWFsKHgxLCB5MSk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHAwWzBdLCBwMFsxXSk7XG4gICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhwMVswXSwgcDFbMV0sIHAyWzBdLCBwMlsxXSwgcDNbMF0sIHAzWzFdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGlua0hvcml6b250YWwoKSB7XG4gICAgICAgIHJldHVybiBsaW5rKGN1cnZlSG9yaXpvbnRhbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmtWZXJ0aWNhbCgpIHtcbiAgICAgICAgcmV0dXJuIGxpbmsoY3VydmVWZXJ0aWNhbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmtSYWRpYWwoKSB7XG4gICAgICAgIHZhciBsID0gbGluayhjdXJ2ZVJhZGlhbCQxKTtcbiAgICAgICAgbC5hbmdsZSA9IGwueCwgZGVsZXRlIGwueDtcbiAgICAgICAgbC5yYWRpdXMgPSBsLnksIGRlbGV0ZSBsLnk7XG4gICAgICAgIHJldHVybiBsO1xuICAgIH1cbiAgICB2YXIgY2lyY2xlID0ge1xuICAgICAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIHBpKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHIsIDApO1xuICAgICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgciwgMCwgdGF1KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNyb3NzID0ge1xuICAgICAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKC0zICogciwgLXIpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oLXIsIC1yKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKC1yLCAtMyAqIHIpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ociwgLTMgKiByKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHIsIC1yKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDMgKiByLCAtcik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygzICogciwgcik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyLCByKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHIsIDMgKiByKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKC1yLCAzICogcik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygtciwgcik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygtMyAqIHIsIHIpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHRhbjMwID0gTWF0aC5zcXJ0KDEgLyAzKSwgdGFuMzBfMiA9IHRhbjMwICogMjtcbiAgICB2YXIgZGlhbW9uZCA9IHtcbiAgICAgICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgICAgICAgIHZhciB5ID0gTWF0aC5zcXJ0KHNpemUgLyB0YW4zMF8yKSwgeCA9IHkgKiB0YW4zMDtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKDAsIC15KTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHgsIDApO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMCwgeSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygteCwgMCk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIga2EgPSAwLjg5MDgxMzA5MTUyOTI4NTIyODEwLCBrciA9IE1hdGguc2luKHBpIC8gMTApIC8gTWF0aC5zaW4oNyAqIHBpIC8gMTApLCBreCA9IE1hdGguc2luKHRhdSAvIDEwKSAqIGtyLCBreSA9IC1NYXRoLmNvcyh0YXUgLyAxMCkgKiBrcjtcbiAgICB2YXIgc3RhciA9IHtcbiAgICAgICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgKiBrYSksIHggPSBreCAqIHIsIHkgPSBreSAqIHI7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCAtcik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0YXUgKiBpIC8gNSwgYyA9IE1hdGguY29zKGEpLCBzID0gTWF0aC5zaW4oYSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocyAqIHIsIC1jICogcik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYyAqIHggLSBzICogeSwgcyAqIHggKyBjICogeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3F1YXJlID0ge1xuICAgICAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgICAgICAgdmFyIHcgPSBNYXRoLnNxcnQoc2l6ZSksIHggPSAtdyAvIDI7XG4gICAgICAgICAgICBjb250ZXh0LnJlY3QoeCwgeCwgdywgdyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzcXJ0MyA9IE1hdGguc3FydCgzKTtcbiAgICB2YXIgdHJpYW5nbGUgPSB7XG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICAgICAgICB2YXIgeSA9IC1NYXRoLnNxcnQoc2l6ZSAvIChzcXJ0MyAqIDMpKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKDAsIHkgKiAyKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKC1zcXJ0MyAqIHksIC15KTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHNxcnQzICogeSwgLXkpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGMgPSAtMC41LCBzID0gTWF0aC5zcXJ0KDMpIC8gMiwgayA9IDEgLyBNYXRoLnNxcnQoMTIpLCBhID0gKGsgLyAyICsgMSkgKiAzO1xuICAgIHZhciB3eWUgPSB7XG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICAgICAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gYSksIHgwID0gciAvIDIsIHkwID0gciAqIGssIHgxID0geDAsIHkxID0gciAqIGsgKyByLCB4MiA9IC14MSwgeTIgPSB5MTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4MSwgeTEpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGMgKiB4MCAtIHMgKiB5MCwgcyAqIHgwICsgYyAqIHkwKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGMgKiB4MSAtIHMgKiB5MSwgcyAqIHgxICsgYyAqIHkxKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiAtIHMgKiB5MiwgcyAqIHgyICsgYyAqIHkyKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGMgKiB4MCArIHMgKiB5MCwgYyAqIHkwIC0gcyAqIHgwKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGMgKiB4MSArIHMgKiB5MSwgYyAqIHkxIC0gcyAqIHgxKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiArIHMgKiB5MiwgYyAqIHkyIC0gcyAqIHgyKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzeW1ib2xzID0gW1xuICAgICAgICBjaXJjbGUsXG4gICAgICAgIGNyb3NzLFxuICAgICAgICBkaWFtb25kLFxuICAgICAgICBzcXVhcmUsXG4gICAgICAgIHN0YXIsXG4gICAgICAgIHRyaWFuZ2xlLFxuICAgICAgICB3eWVcbiAgICBdO1xuICAgIGZ1bmN0aW9uIHN5bWJvbCgpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBjb25zdGFudChjaXJjbGUpLCBzaXplID0gY29uc3RhbnQoNjQpLCBjb250ZXh0ID0gbnVsbDtcbiAgICAgICAgZnVuY3Rpb24gc3ltYm9sKCkge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlcjtcbiAgICAgICAgICAgIGlmICghY29udGV4dClcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gYnVmZmVyID0gZDNQYXRoLnBhdGgoKTtcbiAgICAgICAgICAgIHR5cGUuYXBwbHkodGhpcywgYXJndW1lbnRzKS5kcmF3KGNvbnRleHQsICtzaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzeW1ib2wudHlwZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0eXBlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgc3ltYm9sKSA6IHR5cGU7XG4gICAgICAgIH07XG4gICAgICAgIHN5bWJvbC5zaXplID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNpemUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgc3ltYm9sKSA6IHNpemU7XG4gICAgICAgIH07XG4gICAgICAgIHN5bWJvbC5jb250ZXh0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXywgc3ltYm9sKSA6IGNvbnRleHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7IH1cbiAgICBmdW5jdGlvbiBwb2ludCh0aGF0LCB4LCB5KSB7XG4gICAgICAgIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbygoMiAqIHRoYXQuX3gwICsgdGhhdC5feDEpIC8gMywgKDIgKiB0aGF0Ll95MCArIHRoYXQuX3kxKSAvIDMsICh0aGF0Ll94MCArIDIgKiB0aGF0Ll94MSkgLyAzLCAodGhhdC5feTAgKyAyICogdGhhdC5feTEpIC8gMywgKHRoYXQuX3gwICsgNCAqIHRoYXQuX3gxICsgeCkgLyA2LCAodGhhdC5feTAgKyA0ICogdGhhdC5feTEgKyB5KSAvIDYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBCYXNpcyhjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICBCYXNpcy5wcm90b3R5cGUgPSB7XG4gICAgICAgIGFyZWFTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGFyZWFFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgICAgICAgICAgICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IE5hTjtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcG9pbnQodGhpcywgdGhpcy5feDEsIHRoaXMuX3kxKTsgLy8gcHJvY2VlZFxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDEsIHRoaXMuX3kxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB4ID0gK3gsIHkgPSAreTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oKDUgKiB0aGlzLl94MCArIHRoaXMuX3gxKSAvIDYsICg1ICogdGhpcy5feTAgKyB0aGlzLl95MSkgLyA2KTsgLy8gcHJvY2VlZFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHBvaW50KHRoaXMsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICAgICAgICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gYmFzaXMoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2lzKGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBCYXNpc0Nsb3NlZChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICBCYXNpc0Nsb3NlZC5wcm90b3R5cGUgPSB7XG4gICAgICAgIGFyZWFTdGFydDogbm9vcCxcbiAgICAgICAgYXJlYUVuZDogbm9vcCxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID1cbiAgICAgICAgICAgICAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gTmFOO1xuICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oKHRoaXMuX3gyICsgMiAqIHRoaXMuX3gzKSAvIDMsICh0aGlzLl95MiArIDIgKiB0aGlzLl95MykgLyAzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oKHRoaXMuX3gzICsgMiAqIHRoaXMuX3gyKSAvIDMsICh0aGlzLl95MyArIDIgKiB0aGlzLl95MikgLyAzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gyLCB0aGlzLl95Mik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3gyID0geCwgdGhpcy5feTIgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgeCkgLyA2LCAodGhpcy5feTAgKyA0ICogdGhpcy5feTEgKyB5KSAvIDYpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwb2ludCh0aGlzLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgICAgICAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGJhc2lzQ2xvc2VkKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNpc0Nsb3NlZChjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQmFzaXNPcGVuKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIEJhc2lzT3Blbi5wcm90b3R5cGUgPSB7XG4gICAgICAgIGFyZWFTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGFyZWFFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgICAgICAgICAgICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IE5hTjtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgwID0gKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgeCkgLyA2LCB5MCA9ICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHkpIC8gNjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgwLCB5MCkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHBvaW50KHRoaXMsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICAgICAgICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gYmFzaXNPcGVuKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNpc09wZW4oY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJ1bmRsZShjb250ZXh0LCBiZXRhKSB7XG4gICAgICAgIHRoaXMuX2Jhc2lzID0gbmV3IEJhc2lzKGNvbnRleHQpO1xuICAgICAgICB0aGlzLl9iZXRhID0gYmV0YTtcbiAgICB9XG4gICAgQnVuZGxlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl94ID0gW107XG4gICAgICAgICAgICB0aGlzLl95ID0gW107XG4gICAgICAgICAgICB0aGlzLl9iYXNpcy5saW5lU3RhcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLl94LCB5ID0gdGhpcy5feSwgaiA9IHgubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciB4MCA9IHhbMF0sIHkwID0geVswXSwgZHggPSB4W2pdIC0geDAsIGR5ID0geVtqXSAtIHkwLCBpID0gLTEsIHQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSBpIC8gajtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmFzaXMucG9pbnQodGhpcy5fYmV0YSAqIHhbaV0gKyAoMSAtIHRoaXMuX2JldGEpICogKHgwICsgdCAqIGR4KSwgdGhpcy5fYmV0YSAqIHlbaV0gKyAoMSAtIHRoaXMuX2JldGEpICogKHkwICsgdCAqIGR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5feCA9IHRoaXMuX3kgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fYmFzaXMubGluZUVuZCgpO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3gucHVzaCgreCk7XG4gICAgICAgICAgICB0aGlzLl95LnB1c2goK3kpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgYnVuZGxlID0gKGZ1bmN0aW9uIGN1c3RvbShiZXRhKSB7XG4gICAgICAgIGZ1bmN0aW9uIGJ1bmRsZShjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gYmV0YSA9PT0gMSA/IG5ldyBCYXNpcyhjb250ZXh0KSA6IG5ldyBCdW5kbGUoY29udGV4dCwgYmV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVuZGxlLmJldGEgPSBmdW5jdGlvbiAoYmV0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbSgrYmV0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBidW5kbGU7XG4gICAgfSkoMC44NSk7XG4gICAgZnVuY3Rpb24gcG9pbnQkMSh0aGF0LCB4LCB5KSB7XG4gICAgICAgIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh0aGF0Ll94MSArIHRoYXQuX2sgKiAodGhhdC5feDIgLSB0aGF0Ll94MCksIHRoYXQuX3kxICsgdGhhdC5fayAqICh0aGF0Ll95MiAtIHRoYXQuX3kwKSwgdGhhdC5feDIgKyB0aGF0Ll9rICogKHRoYXQuX3gxIC0geCksIHRoYXQuX3kyICsgdGhhdC5fayAqICh0aGF0Ll95MSAtIHkpLCB0aGF0Ll94MiwgdGhhdC5feTIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDYXJkaW5hbChjb250ZXh0LCB0ZW5zaW9uKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG4gICAgfVxuICAgIENhcmRpbmFsLnByb3RvdHlwZSA9IHtcbiAgICAgICAgYXJlYVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgICAgICAgICAgICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBwb2ludCQxKHRoaXMsIHRoaXMuX3gxLCB0aGlzLl95MSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feDEgPSB4LCB0aGlzLl95MSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyAvLyBwcm9jZWVkXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQkMSh0aGlzLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgICAgICAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjYXJkaW5hbCA9IChmdW5jdGlvbiBjdXN0b20odGVuc2lvbikge1xuICAgICAgICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENhcmRpbmFsKGNvbnRleHQsIHRlbnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhcmRpbmFsLnRlbnNpb24gPSBmdW5jdGlvbiAodGVuc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYXJkaW5hbDtcbiAgICB9KSgwKTtcbiAgICBmdW5jdGlvbiBDYXJkaW5hbENsb3NlZChjb250ZXh0LCB0ZW5zaW9uKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG4gICAgfVxuICAgIENhcmRpbmFsQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgICAgICAgYXJlYVN0YXJ0OiBub29wLFxuICAgICAgICBhcmVhRW5kOiBub29wLFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPSB0aGlzLl94NSA9XG4gICAgICAgICAgICAgICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IHRoaXMuX3k1ID0gTmFOO1xuICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NSwgdGhpcy5feTUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3gzID0geCwgdGhpcy5feTMgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDQgPSB4LCB0aGlzLl95NCA9IHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feDUgPSB4LCB0aGlzLl95NSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHBvaW50JDEodGhpcywgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgICAgICAgICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY2FyZGluYWxDbG9zZWQgPSAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcbiAgICAgICAgZnVuY3Rpb24gY2FyZGluYWwoY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCB0ZW5zaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24gKHRlbnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2FyZGluYWw7XG4gICAgfSkoMCk7XG4gICAgZnVuY3Rpb24gQ2FyZGluYWxPcGVuKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbiAgICB9XG4gICAgQ2FyZGluYWxPcGVuLnByb3RvdHlwZSA9IHtcbiAgICAgICAgYXJlYVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgICAgICAgICAgICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95MikgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MiwgdGhpcy5feTIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHBvaW50JDEodGhpcywgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgICAgICAgICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY2FyZGluYWxPcGVuID0gKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNhcmRpbmFsKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FyZGluYWxPcGVuKGNvbnRleHQsIHRlbnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhcmRpbmFsLnRlbnNpb24gPSBmdW5jdGlvbiAodGVuc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYXJkaW5hbDtcbiAgICB9KSgwKTtcbiAgICBmdW5jdGlvbiBwb2ludCQyKHRoYXQsIHgsIHkpIHtcbiAgICAgICAgdmFyIHgxID0gdGhhdC5feDEsIHkxID0gdGhhdC5feTEsIHgyID0gdGhhdC5feDIsIHkyID0gdGhhdC5feTI7XG4gICAgICAgIGlmICh0aGF0Ll9sMDFfYSA+IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHZhciBhID0gMiAqIHRoYXQuX2wwMV8yYSArIDMgKiB0aGF0Ll9sMDFfYSAqIHRoYXQuX2wxMl9hICsgdGhhdC5fbDEyXzJhLCBuID0gMyAqIHRoYXQuX2wwMV9hICogKHRoYXQuX2wwMV9hICsgdGhhdC5fbDEyX2EpO1xuICAgICAgICAgICAgeDEgPSAoeDEgKiBhIC0gdGhhdC5feDAgKiB0aGF0Ll9sMTJfMmEgKyB0aGF0Ll94MiAqIHRoYXQuX2wwMV8yYSkgLyBuO1xuICAgICAgICAgICAgeTEgPSAoeTEgKiBhIC0gdGhhdC5feTAgKiB0aGF0Ll9sMTJfMmEgKyB0aGF0Ll95MiAqIHRoYXQuX2wwMV8yYSkgLyBuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGF0Ll9sMjNfYSA+IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHZhciBiID0gMiAqIHRoYXQuX2wyM18yYSArIDMgKiB0aGF0Ll9sMjNfYSAqIHRoYXQuX2wxMl9hICsgdGhhdC5fbDEyXzJhLCBtID0gMyAqIHRoYXQuX2wyM19hICogKHRoYXQuX2wyM19hICsgdGhhdC5fbDEyX2EpO1xuICAgICAgICAgICAgeDIgPSAoeDIgKiBiICsgdGhhdC5feDEgKiB0aGF0Ll9sMjNfMmEgLSB4ICogdGhhdC5fbDEyXzJhKSAvIG07XG4gICAgICAgICAgICB5MiA9ICh5MiAqIGIgKyB0aGF0Ll95MSAqIHRoYXQuX2wyM18yYSAtIHkgKiB0aGF0Ll9sMTJfMmEpIC8gbTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHRoYXQuX3gyLCB0aGF0Ll95Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENhdG11bGxSb20oY29udGV4dCwgYWxwaGEpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX2FscGhhID0gYWxwaGE7XG4gICAgfVxuICAgIENhdG11bGxSb20ucHJvdG90eXBlID0ge1xuICAgICAgICBhcmVhU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBhcmVhRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gTmFOO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgICAgICAgICAgICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgICAgICAgICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICAgICAgICAgICAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MiwgdGhpcy5feTIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSlcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHggPSAreCwgeSA9ICt5O1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCwgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KHgyMyAqIHgyMyArIHkyMyAqIHkyMywgdGhpcy5fYWxwaGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgLy8gcHJvY2VlZFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHBvaW50JDIodGhpcywgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSwgdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYTtcbiAgICAgICAgICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhO1xuICAgICAgICAgICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgICAgICAgICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY2F0bXVsbFJvbSA9IChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcbiAgICAgICAgZnVuY3Rpb24gY2F0bXVsbFJvbShjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbShjb250ZXh0LCBhbHBoYSkgOiBuZXcgQ2FyZGluYWwoY29udGV4dCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0bXVsbFJvbS5hbHBoYSA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbSgrYWxwaGEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2F0bXVsbFJvbTtcbiAgICB9KSgwLjUpO1xuICAgIGZ1bmN0aW9uIENhdG11bGxSb21DbG9zZWQoY29udGV4dCwgYWxwaGEpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX2FscGhhID0gYWxwaGE7XG4gICAgfVxuICAgIENhdG11bGxSb21DbG9zZWQucHJvdG90eXBlID0ge1xuICAgICAgICBhcmVhU3RhcnQ6IG5vb3AsXG4gICAgICAgIGFyZWFFbmQ6IG5vb3AsXG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9IHRoaXMuX3g1ID1cbiAgICAgICAgICAgICAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gdGhpcy5feTUgPSBOYU47XG4gICAgICAgICAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPVxuICAgICAgICAgICAgICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnQodGhpcy5feDUsIHRoaXMuX3k1KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHggPSAreCwgeSA9ICt5O1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCwgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KHgyMyAqIHgyMyArIHkyMyAqIHkyMywgdGhpcy5fYWxwaGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94NSA9IHgsIHRoaXMuX3k1ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQkMih0aGlzLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xuICAgICAgICAgICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgICAgICAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgICAgICAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjYXRtdWxsUm9tQ2xvc2VkID0gKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuICAgICAgICBmdW5jdGlvbiBjYXRtdWxsUm9tKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tQ2xvc2VkKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRtdWxsUm9tLmFscGhhID0gZnVuY3Rpb24gKGFscGhhKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tKCthbHBoYSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYXRtdWxsUm9tO1xuICAgIH0pKDAuNSk7XG4gICAgZnVuY3Rpb24gQ2F0bXVsbFJvbU9wZW4oY29udGV4dCwgYWxwaGEpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX2FscGhhID0gYWxwaGE7XG4gICAgfVxuICAgIENhdG11bGxSb21PcGVuLnByb3RvdHlwZSA9IHtcbiAgICAgICAgYXJlYVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgICAgICAgICAgICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICAgICAgICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgICAgICAgICAgICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMykpXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB4ID0gK3gsIHkgPSAreTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciB4MjMgPSB0aGlzLl94MiAtIHgsIHkyMyA9IHRoaXMuX3kyIC0geTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95MikgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MiwgdGhpcy5feTIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHBvaW50JDIodGhpcywgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSwgdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYTtcbiAgICAgICAgICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhO1xuICAgICAgICAgICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgICAgICAgICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY2F0bXVsbFJvbU9wZW4gPSAoZnVuY3Rpb24gY3VzdG9tKGFscGhhKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGFscGhhID8gbmV3IENhdG11bGxSb21PcGVuKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbE9wZW4oY29udGV4dCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0bXVsbFJvbS5hbHBoYSA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbSgrYWxwaGEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2F0bXVsbFJvbTtcbiAgICB9KSgwLjUpO1xuICAgIGZ1bmN0aW9uIExpbmVhckNsb3NlZChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICBMaW5lYXJDbG9zZWQucHJvdG90eXBlID0ge1xuICAgICAgICBhcmVhU3RhcnQ6IG5vb3AsXG4gICAgICAgIGFyZWFFbmQ6IG5vb3AsXG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9pbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB4ID0gK3gsIHkgPSAreTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wb2ludClcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDEsIHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsaW5lYXJDbG9zZWQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IExpbmVhckNsb3NlZChjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2lnbih4KSB7XG4gICAgICAgIHJldHVybiB4IDwgMCA/IC0xIDogMTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzbG9wZXMgb2YgdGhlIHRhbmdlbnRzIChIZXJtaXRlLXR5cGUgaW50ZXJwb2xhdGlvbikgYmFzZWQgb25cbiAgICAvLyB0aGUgZm9sbG93aW5nIHBhcGVyOiBTdGVmZmVuLCBNLiAxOTkwLiBBIFNpbXBsZSBNZXRob2QgZm9yIE1vbm90b25pY1xuICAgIC8vIEludGVycG9sYXRpb24gaW4gT25lIERpbWVuc2lvbi4gQXN0cm9ub215IGFuZCBBc3Ryb3BoeXNpY3MsIFZvbC4gMjM5LCBOTy5cbiAgICAvLyBOT1YoSUkpLCBQLiA0NDMsIDE5OTAuXG4gICAgZnVuY3Rpb24gc2xvcGUzKHRoYXQsIHgyLCB5Mikge1xuICAgICAgICB2YXIgaDAgPSB0aGF0Ll94MSAtIHRoYXQuX3gwLCBoMSA9IHgyIC0gdGhhdC5feDEsIHMwID0gKHRoYXQuX3kxIC0gdGhhdC5feTApIC8gKGgwIHx8IGgxIDwgMCAmJiAtMCksIHMxID0gKHkyIC0gdGhhdC5feTEpIC8gKGgxIHx8IGgwIDwgMCAmJiAtMCksIHAgPSAoczAgKiBoMSArIHMxICogaDApIC8gKGgwICsgaDEpO1xuICAgICAgICByZXR1cm4gKHNpZ24oczApICsgc2lnbihzMSkpICogTWF0aC5taW4oTWF0aC5hYnMoczApLCBNYXRoLmFicyhzMSksIDAuNSAqIE1hdGguYWJzKHApKSB8fCAwO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgYSBvbmUtc2lkZWQgc2xvcGUuXG4gICAgZnVuY3Rpb24gc2xvcGUyKHRoYXQsIHQpIHtcbiAgICAgICAgdmFyIGggPSB0aGF0Ll94MSAtIHRoYXQuX3gwO1xuICAgICAgICByZXR1cm4gaCA/ICgzICogKHRoYXQuX3kxIC0gdGhhdC5feTApIC8gaCAtIHQpIC8gMiA6IHQ7XG4gICAgfVxuICAgIC8vIEFjY29yZGluZyB0byBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19IZXJtaXRlX3NwbGluZSNSZXByZXNlbnRhdGlvbnNcbiAgICAvLyBcInlvdSBjYW4gZXhwcmVzcyBjdWJpYyBIZXJtaXRlIGludGVycG9sYXRpb24gaW4gdGVybXMgb2YgY3ViaWMgQsOpemllciBjdXJ2ZXNcbiAgICAvLyB3aXRoIHJlc3BlY3QgdG8gdGhlIGZvdXIgdmFsdWVzIHAwLCBwMCArIG0wIC8gMywgcDEgLSBtMSAvIDMsIHAxXCIuXG4gICAgZnVuY3Rpb24gcG9pbnQkMyh0aGF0LCB0MCwgdDEpIHtcbiAgICAgICAgdmFyIHgwID0gdGhhdC5feDAsIHkwID0gdGhhdC5feTAsIHgxID0gdGhhdC5feDEsIHkxID0gdGhhdC5feTEsIGR4ID0gKHgxIC0geDApIC8gMztcbiAgICAgICAgdGhhdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgwICsgZHgsIHkwICsgZHggKiB0MCwgeDEgLSBkeCwgeTEgLSBkeCAqIHQxLCB4MSwgeTEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNb25vdG9uZVgoY29udGV4dCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgTW9ub3RvbmVYLnByb3RvdHlwZSA9IHtcbiAgICAgICAgYXJlYVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl94MCA9IHRoaXMuX3gxID1cbiAgICAgICAgICAgICAgICB0aGlzLl95MCA9IHRoaXMuX3kxID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdDAgPSBOYU47XG4gICAgICAgICAgICB0aGlzLl9wb2ludCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gxLCB0aGlzLl95MSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQkMyh0aGlzLCB0aGlzLl90MCwgc2xvcGUyKHRoaXMsIHRoaXMuX3QwKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHQxID0gTmFOO1xuICAgICAgICAgICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgICAgICAgICBpZiAoeCA9PT0gdGhpcy5feDEgJiYgeSA9PT0gdGhpcy5feTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgY29pbmNpZGVudCBwb2ludHMuXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50JDModGhpcywgc2xvcGUyKHRoaXMsIHQxID0gc2xvcGUzKHRoaXMsIHgsIHkpKSwgdDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwb2ludCQzKHRoaXMsIHRoaXMuX3QwLCB0MSA9IHNsb3BlMyh0aGlzLCB4LCB5KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgICAgICAgICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICAgICAgICAgICAgdGhpcy5fdDAgPSB0MTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gTW9ub3RvbmVZKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IG5ldyBSZWZsZWN0Q29udGV4dChjb250ZXh0KTtcbiAgICB9XG4gICAgKE1vbm90b25lWS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vbm90b25lWC5wcm90b3R5cGUpKS5wb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIE1vbm90b25lWC5wcm90b3R5cGUucG9pbnQuY2FsbCh0aGlzLCB5LCB4KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIFJlZmxlY3RDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIFJlZmxlY3RDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgbW92ZVRvOiBmdW5jdGlvbiAoeCwgeSkgeyB0aGlzLl9jb250ZXh0Lm1vdmVUbyh5LCB4KTsgfSxcbiAgICAgICAgY2xvc2VQYXRoOiBmdW5jdGlvbiAoKSB7IHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7IH0sXG4gICAgICAgIGxpbmVUbzogZnVuY3Rpb24gKHgsIHkpIHsgdGhpcy5fY29udGV4dC5saW5lVG8oeSwgeCk7IH0sXG4gICAgICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeCwgeSkgeyB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8oeTEsIHgxLCB5MiwgeDIsIHksIHgpOyB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBtb25vdG9uZVgoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbm90b25lWChjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9ub3RvbmVZKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb25vdG9uZVkoY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE5hdHVyYWwoY29udGV4dCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgTmF0dXJhbC5wcm90b3R5cGUgPSB7XG4gICAgICAgIGFyZWFTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGFyZWFFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5feCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5feSA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuX3gsIHkgPSB0aGlzLl95LCBuID0geC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4WzBdLCB5WzBdKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHhbMF0sIHlbMF0pO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHhbMV0sIHlbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHB4ID0gY29udHJvbFBvaW50cyh4KSwgcHkgPSBjb250cm9sUG9pbnRzKHkpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpMCA9IDAsIGkxID0gMTsgaTEgPCBuOyArK2kwLCArK2kxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8ocHhbMF1baTBdLCBweVswXVtpMF0sIHB4WzFdW2kwXSwgcHlbMV1baTBdLCB4W2kxXSwgeVtpMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgbiA9PT0gMSkpXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgICAgICAgICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLl94LnB1c2goK3gpO1xuICAgICAgICAgICAgdGhpcy5feS5wdXNoKCt5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gU2VlIGh0dHBzOi8vd3d3LnBhcnRpY2xlaW5jZWxsLmNvbS8yMDEyL2Jlemllci1zcGxpbmVzLyBmb3IgZGVyaXZhdGlvbi5cbiAgICBmdW5jdGlvbiBjb250cm9sUG9pbnRzKHgpIHtcbiAgICAgICAgdmFyIGksIG4gPSB4Lmxlbmd0aCAtIDEsIG0sIGEgPSBuZXcgQXJyYXkobiksIGIgPSBuZXcgQXJyYXkobiksIHIgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIGFbMF0gPSAwLCBiWzBdID0gMiwgclswXSA9IHhbMF0gKyAyICogeFsxXTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyArK2kpXG4gICAgICAgICAgICBhW2ldID0gMSwgYltpXSA9IDQsIHJbaV0gPSA0ICogeFtpXSArIDIgKiB4W2kgKyAxXTtcbiAgICAgICAgYVtuIC0gMV0gPSAyLCBiW24gLSAxXSA9IDcsIHJbbiAtIDFdID0gOCAqIHhbbiAtIDFdICsgeFtuXTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG47ICsraSlcbiAgICAgICAgICAgIG0gPSBhW2ldIC8gYltpIC0gMV0sIGJbaV0gLT0gbSwgcltpXSAtPSBtICogcltpIC0gMV07XG4gICAgICAgIGFbbiAtIDFdID0gcltuIC0gMV0gLyBiW24gLSAxXTtcbiAgICAgICAgZm9yIChpID0gbiAtIDI7IGkgPj0gMDsgLS1pKVxuICAgICAgICAgICAgYVtpXSA9IChyW2ldIC0gYVtpICsgMV0pIC8gYltpXTtcbiAgICAgICAgYltuIC0gMV0gPSAoeFtuXSArIGFbbiAtIDFdKSAvIDI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuIC0gMTsgKytpKVxuICAgICAgICAgICAgYltpXSA9IDIgKiB4W2kgKyAxXSAtIGFbaSArIDFdO1xuICAgICAgICByZXR1cm4gW2EsIGJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuYXR1cmFsKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYXR1cmFsKGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTdGVwKGNvbnRleHQsIHQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3QgPSB0O1xuICAgIH1cbiAgICBTdGVwLnByb3RvdHlwZSA9IHtcbiAgICAgICAgYXJlYVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl94ID0gdGhpcy5feSA9IE5hTjtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKDAgPCB0aGlzLl90ICYmIHRoaXMuX3QgPCAxICYmIHRoaXMuX3BvaW50ID09PSAyKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZSA+PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMuX3QgPSAxIC0gdGhpcy5fdCwgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHggPSAreCwgeSA9ICt5O1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIHByb2NlZWRcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSB0aGlzLl94ICogKDEgLSB0aGlzLl90KSArIHggKiB0aGlzLl90O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeDEsIHRoaXMuX3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeDEsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ggPSB4LCB0aGlzLl95ID0geTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gc3RlcChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcChjb250ZXh0LCAwLjUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGVwQmVmb3JlKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGVwQWZ0ZXIoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZXAoY29udGV4dCwgMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vbmUoc2VyaWVzLCBvcmRlcikge1xuICAgICAgICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBqLCBzMCwgczEgPSBzZXJpZXNbb3JkZXJbMF1dLCBuLCBtID0gczEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBzMCA9IHMxLCBzMSA9IHNlcmllc1tvcmRlcltpXV07XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgICAgICAgczFbal1bMV0gKz0gczFbal1bMF0gPSBpc05hTihzMFtqXVsxXSkgPyBzMFtqXVswXSA6IHMwW2pdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vbmUkMShzZXJpZXMpIHtcbiAgICAgICAgdmFyIG4gPSBzZXJpZXMubGVuZ3RoLCBvID0gbmV3IEFycmF5KG4pO1xuICAgICAgICB3aGlsZSAoLS1uID49IDApXG4gICAgICAgICAgICBvW25dID0gbjtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YWNrVmFsdWUoZCwga2V5KSB7XG4gICAgICAgIHJldHVybiBkW2tleV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YWNrKCkge1xuICAgICAgICB2YXIga2V5cyA9IGNvbnN0YW50KFtdKSwgb3JkZXIgPSBub25lJDEsIG9mZnNldCA9IG5vbmUsIHZhbHVlID0gc3RhY2tWYWx1ZTtcbiAgICAgICAgZnVuY3Rpb24gc3RhY2soZGF0YSkge1xuICAgICAgICAgICAgdmFyIGt6ID0ga2V5cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBpLCBtID0gZGF0YS5sZW5ndGgsIG4gPSBrei5sZW5ndGgsIHN6ID0gbmV3IEFycmF5KG4pLCBvejtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBraSA9IGt6W2ldLCBzaSA9IHN6W2ldID0gbmV3IEFycmF5KG0pLCBqID0gMCwgc2lqOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpW2pdID0gc2lqID0gWzAsICt2YWx1ZShkYXRhW2pdLCBraSwgaiwgZGF0YSldO1xuICAgICAgICAgICAgICAgICAgICBzaWouZGF0YSA9IGRhdGFbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpLmtleSA9IGtpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMCwgb3ogPSBvcmRlcihzeik7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzeltveltpXV0uaW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0KHN6LCBveik7XG4gICAgICAgICAgICByZXR1cm4gc3o7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sua2V5cyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChrZXlzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChzbGljZS5jYWxsKF8pKSwgc3RhY2spIDoga2V5cztcbiAgICAgICAgfTtcbiAgICAgICAgc3RhY2sudmFsdWUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmFsdWUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgc3RhY2spIDogdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHN0YWNrLm9yZGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9yZGVyID0gXyA9PSBudWxsID8gbm9uZSQxIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChzbGljZS5jYWxsKF8pKSwgc3RhY2spIDogb3JkZXI7XG4gICAgICAgIH07XG4gICAgICAgIHN0YWNrLm9mZnNldCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvZmZzZXQgPSBfID09IG51bGwgPyBub25lIDogXywgc3RhY2spIDogb2Zmc2V0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4cGFuZChzZXJpZXMsIG9yZGVyKSB7XG4gICAgICAgIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAwKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgaSwgbiwgaiA9IDAsIG0gPSBzZXJpZXNbMF0ubGVuZ3RoLCB5OyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgICBmb3IgKHkgPSBpID0gMDsgaSA8IG47ICsraSlcbiAgICAgICAgICAgICAgICB5ICs9IHNlcmllc1tpXVtqXVsxXSB8fCAwO1xuICAgICAgICAgICAgaWYgKHkpXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSlcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzW2ldW2pdWzFdIC89IHk7XG4gICAgICAgIH1cbiAgICAgICAgbm9uZShzZXJpZXMsIG9yZGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGl2ZXJnaW5nKHNlcmllcywgb3JkZXIpIHtcbiAgICAgICAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBpLCBqID0gMCwgZCwgZHksIHlwLCB5biwgbiwgbSA9IHNlcmllc1tvcmRlclswXV0ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgICBmb3IgKHlwID0geW4gPSAwLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICgoZHkgPSAoZCA9IHNlcmllc1tvcmRlcltpXV1bal0pWzFdIC0gZFswXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRbMF0gPSB5cCwgZFsxXSA9IHlwICs9IGR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkeSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZFsxXSA9IHluLCBkWzBdID0geW4gKz0gZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkWzBdID0gMCwgZFsxXSA9IGR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzaWxob3VldHRlKHNlcmllcywgb3JkZXIpIHtcbiAgICAgICAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgczAgPSBzZXJpZXNbb3JkZXJbMF1dLCBuLCBtID0gczAubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgeSA9IDA7IGkgPCBuOyArK2kpXG4gICAgICAgICAgICAgICAgeSArPSBzZXJpZXNbaV1bal1bMV0gfHwgMDtcbiAgICAgICAgICAgIHMwW2pdWzFdICs9IHMwW2pdWzBdID0gLXkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIG5vbmUoc2VyaWVzLCBvcmRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdpZ2dsZShzZXJpZXMsIG9yZGVyKSB7XG4gICAgICAgIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAwKSB8fCAhKChtID0gKHMwID0gc2VyaWVzW29yZGVyWzBdXSkubGVuZ3RoKSA+IDApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciB5ID0gMCwgaiA9IDEsIHMwLCBtLCBuOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgczEgPSAwLCBzMiA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2kgPSBzZXJpZXNbb3JkZXJbaV1dLCBzaWowID0gc2lbal1bMV0gfHwgMCwgc2lqMSA9IHNpW2ogLSAxXVsxXSB8fCAwLCBzMyA9IChzaWowIC0gc2lqMSkgLyAyO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaTsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzayA9IHNlcmllc1tvcmRlcltrXV0sIHNrajAgPSBza1tqXVsxXSB8fCAwLCBza2oxID0gc2tbaiAtIDFdWzFdIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIHMzICs9IHNrajAgLSBza2oxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzMSArPSBzaWowLCBzMiArPSBzMyAqIHNpajA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzMFtqIC0gMV1bMV0gKz0gczBbaiAtIDFdWzBdID0geTtcbiAgICAgICAgICAgIGlmIChzMSlcbiAgICAgICAgICAgICAgICB5IC09IHMyIC8gczE7XG4gICAgICAgIH1cbiAgICAgICAgczBbaiAtIDFdWzFdICs9IHMwW2ogLSAxXVswXSA9IHk7XG4gICAgICAgIG5vbmUoc2VyaWVzLCBvcmRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGVhcmFuY2Uoc2VyaWVzKSB7XG4gICAgICAgIHZhciBwZWFrcyA9IHNlcmllcy5tYXAocGVhayk7XG4gICAgICAgIHJldHVybiBub25lJDEoc2VyaWVzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBwZWFrc1thXSAtIHBlYWtzW2JdOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVhayhzZXJpZXMpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgaiA9IDAsIG4gPSBzZXJpZXMubGVuZ3RoLCB2aSwgdmogPSAtSW5maW5pdHk7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgaWYgKCh2aSA9ICtzZXJpZXNbaV1bMV0pID4gdmopXG4gICAgICAgICAgICAgICAgdmogPSB2aSwgaiA9IGk7XG4gICAgICAgIHJldHVybiBqO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc2NlbmRpbmcoc2VyaWVzKSB7XG4gICAgICAgIHZhciBzdW1zID0gc2VyaWVzLm1hcChzdW0pO1xuICAgICAgICByZXR1cm4gbm9uZSQxKHNlcmllcykuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gc3Vtc1thXSAtIHN1bXNbYl07IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdW0oc2VyaWVzKSB7XG4gICAgICAgIHZhciBzID0gMCwgaSA9IC0xLCBuID0gc2VyaWVzLmxlbmd0aCwgdjtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICBpZiAodiA9ICtzZXJpZXNbaV1bMV0pXG4gICAgICAgICAgICAgICAgcyArPSB2O1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY2VuZGluZyQxKHNlcmllcykge1xuICAgICAgICByZXR1cm4gYXNjZW5kaW5nKHNlcmllcykucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnNpZGVPdXQoc2VyaWVzKSB7XG4gICAgICAgIHZhciBuID0gc2VyaWVzLmxlbmd0aCwgaSwgaiwgc3VtcyA9IHNlcmllcy5tYXAoc3VtKSwgb3JkZXIgPSBhcHBlYXJhbmNlKHNlcmllcyksIHRvcCA9IDAsIGJvdHRvbSA9IDAsIHRvcHMgPSBbXSwgYm90dG9tcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBqID0gb3JkZXJbaV07XG4gICAgICAgICAgICBpZiAodG9wIDwgYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgdG9wICs9IHN1bXNbal07XG4gICAgICAgICAgICAgICAgdG9wcy5wdXNoKGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYm90dG9tICs9IHN1bXNbal07XG4gICAgICAgICAgICAgICAgYm90dG9tcy5wdXNoKGopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib3R0b21zLnJldmVyc2UoKS5jb25jYXQodG9wcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldmVyc2Uoc2VyaWVzKSB7XG4gICAgICAgIHJldHVybiBub25lJDEoc2VyaWVzKS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGV4cG9ydHMuYXJjID0gYXJjO1xuICAgIGV4cG9ydHMuYXJlYSA9IGFyZWE7XG4gICAgZXhwb3J0cy5hcmVhUmFkaWFsID0gYXJlYVJhZGlhbDtcbiAgICBleHBvcnRzLmN1cnZlQmFzaXMgPSBiYXNpcztcbiAgICBleHBvcnRzLmN1cnZlQmFzaXNDbG9zZWQgPSBiYXNpc0Nsb3NlZDtcbiAgICBleHBvcnRzLmN1cnZlQmFzaXNPcGVuID0gYmFzaXNPcGVuO1xuICAgIGV4cG9ydHMuY3VydmVCdW5kbGUgPSBidW5kbGU7XG4gICAgZXhwb3J0cy5jdXJ2ZUNhcmRpbmFsID0gY2FyZGluYWw7XG4gICAgZXhwb3J0cy5jdXJ2ZUNhcmRpbmFsQ2xvc2VkID0gY2FyZGluYWxDbG9zZWQ7XG4gICAgZXhwb3J0cy5jdXJ2ZUNhcmRpbmFsT3BlbiA9IGNhcmRpbmFsT3BlbjtcbiAgICBleHBvcnRzLmN1cnZlQ2F0bXVsbFJvbSA9IGNhdG11bGxSb207XG4gICAgZXhwb3J0cy5jdXJ2ZUNhdG11bGxSb21DbG9zZWQgPSBjYXRtdWxsUm9tQ2xvc2VkO1xuICAgIGV4cG9ydHMuY3VydmVDYXRtdWxsUm9tT3BlbiA9IGNhdG11bGxSb21PcGVuO1xuICAgIGV4cG9ydHMuY3VydmVMaW5lYXIgPSBjdXJ2ZUxpbmVhcjtcbiAgICBleHBvcnRzLmN1cnZlTGluZWFyQ2xvc2VkID0gbGluZWFyQ2xvc2VkO1xuICAgIGV4cG9ydHMuY3VydmVNb25vdG9uZVggPSBtb25vdG9uZVg7XG4gICAgZXhwb3J0cy5jdXJ2ZU1vbm90b25lWSA9IG1vbm90b25lWTtcbiAgICBleHBvcnRzLmN1cnZlTmF0dXJhbCA9IG5hdHVyYWw7XG4gICAgZXhwb3J0cy5jdXJ2ZVN0ZXAgPSBzdGVwO1xuICAgIGV4cG9ydHMuY3VydmVTdGVwQWZ0ZXIgPSBzdGVwQWZ0ZXI7XG4gICAgZXhwb3J0cy5jdXJ2ZVN0ZXBCZWZvcmUgPSBzdGVwQmVmb3JlO1xuICAgIGV4cG9ydHMubGluZSA9IGxpbmU7XG4gICAgZXhwb3J0cy5saW5lUmFkaWFsID0gbGluZVJhZGlhbCQxO1xuICAgIGV4cG9ydHMubGlua0hvcml6b250YWwgPSBsaW5rSG9yaXpvbnRhbDtcbiAgICBleHBvcnRzLmxpbmtSYWRpYWwgPSBsaW5rUmFkaWFsO1xuICAgIGV4cG9ydHMubGlua1ZlcnRpY2FsID0gbGlua1ZlcnRpY2FsO1xuICAgIGV4cG9ydHMucGllID0gcGllO1xuICAgIGV4cG9ydHMucG9pbnRSYWRpYWwgPSBwb2ludFJhZGlhbDtcbiAgICBleHBvcnRzLnJhZGlhbEFyZWEgPSBhcmVhUmFkaWFsO1xuICAgIGV4cG9ydHMucmFkaWFsTGluZSA9IGxpbmVSYWRpYWwkMTtcbiAgICBleHBvcnRzLnN0YWNrID0gc3RhY2s7XG4gICAgZXhwb3J0cy5zdGFja09mZnNldERpdmVyZ2luZyA9IGRpdmVyZ2luZztcbiAgICBleHBvcnRzLnN0YWNrT2Zmc2V0RXhwYW5kID0gZXhwYW5kO1xuICAgIGV4cG9ydHMuc3RhY2tPZmZzZXROb25lID0gbm9uZTtcbiAgICBleHBvcnRzLnN0YWNrT2Zmc2V0U2lsaG91ZXR0ZSA9IHNpbGhvdWV0dGU7XG4gICAgZXhwb3J0cy5zdGFja09mZnNldFdpZ2dsZSA9IHdpZ2dsZTtcbiAgICBleHBvcnRzLnN0YWNrT3JkZXJBcHBlYXJhbmNlID0gYXBwZWFyYW5jZTtcbiAgICBleHBvcnRzLnN0YWNrT3JkZXJBc2NlbmRpbmcgPSBhc2NlbmRpbmc7XG4gICAgZXhwb3J0cy5zdGFja09yZGVyRGVzY2VuZGluZyA9IGRlc2NlbmRpbmckMTtcbiAgICBleHBvcnRzLnN0YWNrT3JkZXJJbnNpZGVPdXQgPSBpbnNpZGVPdXQ7XG4gICAgZXhwb3J0cy5zdGFja09yZGVyTm9uZSA9IG5vbmUkMTtcbiAgICBleHBvcnRzLnN0YWNrT3JkZXJSZXZlcnNlID0gcmV2ZXJzZTtcbiAgICBleHBvcnRzLnN5bWJvbCA9IHN5bWJvbDtcbiAgICBleHBvcnRzLnN5bWJvbENpcmNsZSA9IGNpcmNsZTtcbiAgICBleHBvcnRzLnN5bWJvbENyb3NzID0gY3Jvc3M7XG4gICAgZXhwb3J0cy5zeW1ib2xEaWFtb25kID0gZGlhbW9uZDtcbiAgICBleHBvcnRzLnN5bWJvbFNxdWFyZSA9IHNxdWFyZTtcbiAgICBleHBvcnRzLnN5bWJvbFN0YXIgPSBzdGFyO1xuICAgIGV4cG9ydHMuc3ltYm9sVHJpYW5nbGUgPSB0cmlhbmdsZTtcbiAgICBleHBvcnRzLnN5bWJvbFd5ZSA9IHd5ZTtcbiAgICBleHBvcnRzLnN5bWJvbHMgPSBzeW1ib2xzO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2QzLXZvcm9ub2lAMS4xLjRAZDMtdm9yb25vaS9kaXN0L2QzLXZvcm9ub2kuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2QzLXZvcm9ub2lAMS4xLjRAZDMtdm9yb25vaS9kaXN0L2QzLXZvcm9ub2kuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy12b3Jvbm9pLyB2MS4xLjQgQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgICB0cnVlID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB4KGQpIHtcbiAgICAgICAgcmV0dXJuIGRbMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHkoZCkge1xuICAgICAgICByZXR1cm4gZFsxXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVkQmxhY2tUcmVlKCkge1xuICAgICAgICB0aGlzLl8gPSBudWxsOyAvLyByb290IG5vZGVcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVkQmxhY2tOb2RlKG5vZGUpIHtcbiAgICAgICAgbm9kZS5VID0gLy8gcGFyZW50IG5vZGVcbiAgICAgICAgICAgIG5vZGUuQyA9IC8vIGNvbG9yIC0gdHJ1ZSBmb3IgcmVkLCBmYWxzZSBmb3IgYmxhY2tcbiAgICAgICAgICAgICAgICBub2RlLkwgPSAvLyBsZWZ0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5SID0gLy8gcmlnaHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5QID0gLy8gcHJldmlvdXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuTiA9IG51bGw7IC8vIG5leHQgbm9kZVxuICAgIH1cbiAgICBSZWRCbGFja1RyZWUucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogUmVkQmxhY2tUcmVlLFxuICAgICAgICBpbnNlcnQ6IGZ1bmN0aW9uIChhZnRlciwgbm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCwgZ3JhbmRwYSwgdW5jbGU7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBub2RlLlAgPSBhZnRlcjtcbiAgICAgICAgICAgICAgICBub2RlLk4gPSBhZnRlci5OO1xuICAgICAgICAgICAgICAgIGlmIChhZnRlci5OKVxuICAgICAgICAgICAgICAgICAgICBhZnRlci5OLlAgPSBub2RlO1xuICAgICAgICAgICAgICAgIGFmdGVyLk4gPSBub2RlO1xuICAgICAgICAgICAgICAgIGlmIChhZnRlci5SKSB7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gYWZ0ZXIuUjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFmdGVyLkwpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlciA9IGFmdGVyLkw7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyLkwgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIuUiA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IGFmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBSZWRCbGFja0ZpcnN0KHRoaXMuXyk7XG4gICAgICAgICAgICAgICAgbm9kZS5QID0gbnVsbDtcbiAgICAgICAgICAgICAgICBub2RlLk4gPSBhZnRlcjtcbiAgICAgICAgICAgICAgICBhZnRlci5QID0gYWZ0ZXIuTCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gYWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLlAgPSBub2RlLk4gPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuXyA9IG5vZGU7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuTCA9IG5vZGUuUiA9IG51bGw7XG4gICAgICAgICAgICBub2RlLlUgPSBwYXJlbnQ7XG4gICAgICAgICAgICBub2RlLkMgPSB0cnVlO1xuICAgICAgICAgICAgYWZ0ZXIgPSBub2RlO1xuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuQykge1xuICAgICAgICAgICAgICAgIGdyYW5kcGEgPSBwYXJlbnQuVTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09PSBncmFuZHBhLkwpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5jbGUgPSBncmFuZHBhLlI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmNsZSAmJiB1bmNsZS5DKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuQyA9IHVuY2xlLkMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlciA9IGdyYW5kcGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIgPT09IHBhcmVudC5SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5DID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBncmFuZHBhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdW5jbGUgPSBncmFuZHBhLkw7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmNsZSAmJiB1bmNsZS5DKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuQyA9IHVuY2xlLkMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlciA9IGdyYW5kcGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIgPT09IHBhcmVudC5MKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGFmdGVyLlU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuQyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBncmFuZHBhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBhZnRlci5VO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fLkMgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuTilcbiAgICAgICAgICAgICAgICBub2RlLk4uUCA9IG5vZGUuUDtcbiAgICAgICAgICAgIGlmIChub2RlLlApXG4gICAgICAgICAgICAgICAgbm9kZS5QLk4gPSBub2RlLk47XG4gICAgICAgICAgICBub2RlLk4gPSBub2RlLlAgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUuVSwgc2libGluZywgbGVmdCA9IG5vZGUuTCwgcmlnaHQgPSBub2RlLlIsIG5leHQsIHJlZDtcbiAgICAgICAgICAgIGlmICghbGVmdClcbiAgICAgICAgICAgICAgICBuZXh0ID0gcmlnaHQ7XG4gICAgICAgICAgICBlbHNlIGlmICghcmlnaHQpXG4gICAgICAgICAgICAgICAgbmV4dCA9IGxlZnQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbmV4dCA9IFJlZEJsYWNrRmlyc3QocmlnaHQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuTCA9PT0gbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LkwgPSBuZXh0O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LlIgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWZ0ICYmIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmVkID0gbmV4dC5DO1xuICAgICAgICAgICAgICAgIG5leHQuQyA9IG5vZGUuQztcbiAgICAgICAgICAgICAgICBuZXh0LkwgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIGxlZnQuVSA9IG5leHQ7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IG5leHQuVTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5VID0gbm9kZS5VO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbmV4dC5SO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuTCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuUiA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByaWdodC5VID0gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuVSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5leHQuUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWQgPSBub2RlLkM7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgICAgICBub2RlLlUgPSBwYXJlbnQ7XG4gICAgICAgICAgICBpZiAocmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUuQykge1xuICAgICAgICAgICAgICAgIG5vZGUuQyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5fKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gcGFyZW50LkwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2libGluZy5DKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLkMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5DID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgoc2libGluZy5MICYmIHNpYmxpbmcuTC5DKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHNpYmxpbmcuUiAmJiBzaWJsaW5nLlIuQykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2libGluZy5SIHx8ICFzaWJsaW5nLlIuQykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuTC5DID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZy5DID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuUjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuQyA9IHBhcmVudC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LkMgPSBzaWJsaW5nLlIuQyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5fO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpYmxpbmcuQykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZy5DID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuQyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50Lkw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChzaWJsaW5nLkwgJiYgc2libGluZy5MLkMpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAoc2libGluZy5SICYmIHNpYmxpbmcuUi5DKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaWJsaW5nLkwgfHwgIXNpYmxpbmcuTC5DKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZy5SLkMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLkMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50Lkw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLkMgPSBwYXJlbnQuQztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5DID0gc2libGluZy5MLkMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLl87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaWJsaW5nLkMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LlU7XG4gICAgICAgICAgICB9IHdoaWxlICghbm9kZS5DKTtcbiAgICAgICAgICAgIGlmIChub2RlKVxuICAgICAgICAgICAgICAgIG5vZGUuQyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBSZWRCbGFja1JvdGF0ZUxlZnQodHJlZSwgbm9kZSkge1xuICAgICAgICB2YXIgcCA9IG5vZGUsIHEgPSBub2RlLlIsIHBhcmVudCA9IHAuVTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC5MID09PSBwKVxuICAgICAgICAgICAgICAgIHBhcmVudC5MID0gcTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJlbnQuUiA9IHE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cmVlLl8gPSBxO1xuICAgICAgICB9XG4gICAgICAgIHEuVSA9IHBhcmVudDtcbiAgICAgICAgcC5VID0gcTtcbiAgICAgICAgcC5SID0gcS5MO1xuICAgICAgICBpZiAocC5SKVxuICAgICAgICAgICAgcC5SLlUgPSBwO1xuICAgICAgICBxLkwgPSBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRyZWUsIG5vZGUpIHtcbiAgICAgICAgdmFyIHAgPSBub2RlLCBxID0gbm9kZS5MLCBwYXJlbnQgPSBwLlU7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuTCA9PT0gcClcbiAgICAgICAgICAgICAgICBwYXJlbnQuTCA9IHE7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGFyZW50LlIgPSBxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJlZS5fID0gcTtcbiAgICAgICAgfVxuICAgICAgICBxLlUgPSBwYXJlbnQ7XG4gICAgICAgIHAuVSA9IHE7XG4gICAgICAgIHAuTCA9IHEuUjtcbiAgICAgICAgaWYgKHAuTClcbiAgICAgICAgICAgIHAuTC5VID0gcDtcbiAgICAgICAgcS5SID0gcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVkQmxhY2tGaXJzdChub2RlKSB7XG4gICAgICAgIHdoaWxlIChub2RlLkwpXG4gICAgICAgICAgICBub2RlID0gbm9kZS5MO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRWRnZShsZWZ0LCByaWdodCwgdjAsIHYxKSB7XG4gICAgICAgIHZhciBlZGdlID0gW251bGwsIG51bGxdLCBpbmRleCA9IGVkZ2VzLnB1c2goZWRnZSkgLSAxO1xuICAgICAgICBlZGdlLmxlZnQgPSBsZWZ0O1xuICAgICAgICBlZGdlLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIGlmICh2MClcbiAgICAgICAgICAgIHNldEVkZ2VFbmQoZWRnZSwgbGVmdCwgcmlnaHQsIHYwKTtcbiAgICAgICAgaWYgKHYxKVxuICAgICAgICAgICAgc2V0RWRnZUVuZChlZGdlLCByaWdodCwgbGVmdCwgdjEpO1xuICAgICAgICBjZWxsc1tsZWZ0LmluZGV4XS5oYWxmZWRnZXMucHVzaChpbmRleCk7XG4gICAgICAgIGNlbGxzW3JpZ2h0LmluZGV4XS5oYWxmZWRnZXMucHVzaChpbmRleCk7XG4gICAgICAgIHJldHVybiBlZGdlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVCb3JkZXJFZGdlKGxlZnQsIHYwLCB2MSkge1xuICAgICAgICB2YXIgZWRnZSA9IFt2MCwgdjFdO1xuICAgICAgICBlZGdlLmxlZnQgPSBsZWZ0O1xuICAgICAgICByZXR1cm4gZWRnZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0RWRnZUVuZChlZGdlLCBsZWZ0LCByaWdodCwgdmVydGV4KSB7XG4gICAgICAgIGlmICghZWRnZVswXSAmJiAhZWRnZVsxXSkge1xuICAgICAgICAgICAgZWRnZVswXSA9IHZlcnRleDtcbiAgICAgICAgICAgIGVkZ2UubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICBlZGdlLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWRnZS5sZWZ0ID09PSByaWdodCkge1xuICAgICAgICAgICAgZWRnZVsxXSA9IHZlcnRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVkZ2VbMF0gPSB2ZXJ0ZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTGlhbmfigJNCYXJza3kgbGluZSBjbGlwcGluZy5cbiAgICBmdW5jdGlvbiBjbGlwRWRnZShlZGdlLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgICB2YXIgYSA9IGVkZ2VbMF0sIGIgPSBlZGdlWzFdLCBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYnggPSBiWzBdLCBieSA9IGJbMV0sIHQwID0gMCwgdDEgPSAxLCBkeCA9IGJ4IC0gYXgsIGR5ID0gYnkgLSBheSwgcjtcbiAgICAgICAgciA9IHgwIC0gYXg7XG4gICAgICAgIGlmICghZHggJiYgciA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHIgLz0gZHg7XG4gICAgICAgIGlmIChkeCA8IDApIHtcbiAgICAgICAgICAgIGlmIChyIDwgdDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHIgPCB0MSlcbiAgICAgICAgICAgICAgICB0MSA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgICAgICAgICBpZiAociA+IHQxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyID4gdDApXG4gICAgICAgICAgICAgICAgdDAgPSByO1xuICAgICAgICB9XG4gICAgICAgIHIgPSB4MSAtIGF4O1xuICAgICAgICBpZiAoIWR4ICYmIHIgPCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByIC89IGR4O1xuICAgICAgICBpZiAoZHggPCAwKSB7XG4gICAgICAgICAgICBpZiAociA+IHQxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyID4gdDApXG4gICAgICAgICAgICAgICAgdDAgPSByO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgICAgICAgaWYgKHIgPCB0MClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAociA8IHQxKVxuICAgICAgICAgICAgICAgIHQxID0gcjtcbiAgICAgICAgfVxuICAgICAgICByID0geTAgLSBheTtcbiAgICAgICAgaWYgKCFkeSAmJiByID4gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgciAvPSBkeTtcbiAgICAgICAgaWYgKGR5IDwgMCkge1xuICAgICAgICAgICAgaWYgKHIgPCB0MClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAociA8IHQxKVxuICAgICAgICAgICAgICAgIHQxID0gcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkeSA+IDApIHtcbiAgICAgICAgICAgIGlmIChyID4gdDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHIgPiB0MClcbiAgICAgICAgICAgICAgICB0MCA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgciA9IHkxIC0gYXk7XG4gICAgICAgIGlmICghZHkgJiYgciA8IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHIgLz0gZHk7XG4gICAgICAgIGlmIChkeSA8IDApIHtcbiAgICAgICAgICAgIGlmIChyID4gdDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHIgPiB0MClcbiAgICAgICAgICAgICAgICB0MCA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgICAgICAgICBpZiAociA8IHQwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyIDwgdDEpXG4gICAgICAgICAgICAgICAgdDEgPSByO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHQwID4gMCkgJiYgISh0MSA8IDEpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIFRPRE8gQmV0dGVyIGNoZWNrP1xuICAgICAgICBpZiAodDAgPiAwKVxuICAgICAgICAgICAgZWRnZVswXSA9IFtheCArIHQwICogZHgsIGF5ICsgdDAgKiBkeV07XG4gICAgICAgIGlmICh0MSA8IDEpXG4gICAgICAgICAgICBlZGdlWzFdID0gW2F4ICsgdDEgKiBkeCwgYXkgKyB0MSAqIGR5XTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbm5lY3RFZGdlKGVkZ2UsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgIHZhciB2MSA9IGVkZ2VbMV07XG4gICAgICAgIGlmICh2MSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgdjAgPSBlZGdlWzBdLCBsZWZ0ID0gZWRnZS5sZWZ0LCByaWdodCA9IGVkZ2UucmlnaHQsIGx4ID0gbGVmdFswXSwgbHkgPSBsZWZ0WzFdLCByeCA9IHJpZ2h0WzBdLCByeSA9IHJpZ2h0WzFdLCBmeCA9IChseCArIHJ4KSAvIDIsIGZ5ID0gKGx5ICsgcnkpIC8gMiwgZm0sIGZiO1xuICAgICAgICBpZiAocnkgPT09IGx5KSB7XG4gICAgICAgICAgICBpZiAoZnggPCB4MCB8fCBmeCA+PSB4MSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAobHggPiByeCkge1xuICAgICAgICAgICAgICAgIGlmICghdjApXG4gICAgICAgICAgICAgICAgICAgIHYwID0gW2Z4LCB5MF07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjBbMV0gPj0geTEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2MSA9IFtmeCwgeTFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2MClcbiAgICAgICAgICAgICAgICAgICAgdjAgPSBbZngsIHkxXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2MFsxXSA8IHkwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdjEgPSBbZngsIHkwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZtID0gKGx4IC0gcngpIC8gKHJ5IC0gbHkpO1xuICAgICAgICAgICAgZmIgPSBmeSAtIGZtICogZng7XG4gICAgICAgICAgICBpZiAoZm0gPCAtMSB8fCBmbSA+IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobHggPiByeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXYwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdjAgPSBbKHkwIC0gZmIpIC8gZm0sIHkwXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodjBbMV0gPj0geTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHYxID0gWyh5MSAtIGZiKSAvIGZtLCB5MV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXYwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdjAgPSBbKHkxIC0gZmIpIC8gZm0sIHkxXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodjBbMV0gPCB5MClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdjEgPSBbKHkwIC0gZmIpIC8gZm0sIHkwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobHkgPCByeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXYwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdjAgPSBbeDAsIGZtICogeDAgKyBmYl07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYwWzBdID49IHgxKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB2MSA9IFt4MSwgZm0gKiB4MSArIGZiXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdjApXG4gICAgICAgICAgICAgICAgICAgICAgICB2MCA9IFt4MSwgZm0gKiB4MSArIGZiXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodjBbMF0gPCB4MClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdjEgPSBbeDAsIGZtICogeDAgKyBmYl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVkZ2VbMF0gPSB2MDtcbiAgICAgICAgZWRnZVsxXSA9IHYxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xpcEVkZ2VzKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgIHZhciBpID0gZWRnZXMubGVuZ3RoLCBlZGdlO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBpZiAoIWNvbm5lY3RFZGdlKGVkZ2UgPSBlZGdlc1tpXSwgeDAsIHkwLCB4MSwgeTEpXG4gICAgICAgICAgICAgICAgfHwgIWNsaXBFZGdlKGVkZ2UsIHgwLCB5MCwgeDEsIHkxKVxuICAgICAgICAgICAgICAgIHx8ICEoTWF0aC5hYnMoZWRnZVswXVswXSAtIGVkZ2VbMV1bMF0pID4gZXBzaWxvblxuICAgICAgICAgICAgICAgICAgICB8fCBNYXRoLmFicyhlZGdlWzBdWzFdIC0gZWRnZVsxXVsxXSkgPiBlcHNpbG9uKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlZGdlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDZWxsKHNpdGUpIHtcbiAgICAgICAgcmV0dXJuIGNlbGxzW3NpdGUuaW5kZXhdID0ge1xuICAgICAgICAgICAgc2l0ZTogc2l0ZSxcbiAgICAgICAgICAgIGhhbGZlZGdlczogW11cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VsbEhhbGZlZGdlQW5nbGUoY2VsbCwgZWRnZSkge1xuICAgICAgICB2YXIgc2l0ZSA9IGNlbGwuc2l0ZSwgdmEgPSBlZGdlLmxlZnQsIHZiID0gZWRnZS5yaWdodDtcbiAgICAgICAgaWYgKHNpdGUgPT09IHZiKVxuICAgICAgICAgICAgdmIgPSB2YSwgdmEgPSBzaXRlO1xuICAgICAgICBpZiAodmIpXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih2YlsxXSAtIHZhWzFdLCB2YlswXSAtIHZhWzBdKTtcbiAgICAgICAgaWYgKHNpdGUgPT09IHZhKVxuICAgICAgICAgICAgdmEgPSBlZGdlWzFdLCB2YiA9IGVkZ2VbMF07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhID0gZWRnZVswXSwgdmIgPSBlZGdlWzFdO1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih2YVswXSAtIHZiWzBdLCB2YlsxXSAtIHZhWzFdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VsbEhhbGZlZGdlU3RhcnQoY2VsbCwgZWRnZSkge1xuICAgICAgICByZXR1cm4gZWRnZVsrKGVkZ2UubGVmdCAhPT0gY2VsbC5zaXRlKV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbGxIYWxmZWRnZUVuZChjZWxsLCBlZGdlKSB7XG4gICAgICAgIHJldHVybiBlZGdlWysoZWRnZS5sZWZ0ID09PSBjZWxsLnNpdGUpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc29ydENlbGxIYWxmZWRnZXMoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY2VsbHMubGVuZ3RoLCBjZWxsLCBoYWxmZWRnZXMsIGosIG07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGlmICgoY2VsbCA9IGNlbGxzW2ldKSAmJiAobSA9IChoYWxmZWRnZXMgPSBjZWxsLmhhbGZlZGdlcykubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG5ldyBBcnJheShtKSwgYXJyYXkgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsrailcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhbal0gPSBqLCBhcnJheVtqXSA9IGNlbGxIYWxmZWRnZUFuZ2xlKGNlbGwsIGVkZ2VzW2hhbGZlZGdlc1tqXV0pO1xuICAgICAgICAgICAgICAgIGluZGV4LnNvcnQoZnVuY3Rpb24gKGksIGopIHsgcmV0dXJuIGFycmF5W2pdIC0gYXJyYXlbaV07IH0pO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2pdID0gaGFsZmVkZ2VzW2luZGV4W2pdXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKVxuICAgICAgICAgICAgICAgICAgICBoYWxmZWRnZXNbal0gPSBhcnJheVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjbGlwQ2VsbHMoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgICAgdmFyIG5DZWxscyA9IGNlbGxzLmxlbmd0aCwgaUNlbGwsIGNlbGwsIHNpdGUsIGlIYWxmZWRnZSwgaGFsZmVkZ2VzLCBuSGFsZmVkZ2VzLCBzdGFydCwgc3RhcnRYLCBzdGFydFksIGVuZCwgZW5kWCwgZW5kWSwgY292ZXIgPSB0cnVlO1xuICAgICAgICBmb3IgKGlDZWxsID0gMDsgaUNlbGwgPCBuQ2VsbHM7ICsraUNlbGwpIHtcbiAgICAgICAgICAgIGlmIChjZWxsID0gY2VsbHNbaUNlbGxdKSB7XG4gICAgICAgICAgICAgICAgc2l0ZSA9IGNlbGwuc2l0ZTtcbiAgICAgICAgICAgICAgICBoYWxmZWRnZXMgPSBjZWxsLmhhbGZlZGdlcztcbiAgICAgICAgICAgICAgICBpSGFsZmVkZ2UgPSBoYWxmZWRnZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgZGFuZ2xpbmcgY2xpcHBlZCBlZGdlcy5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaUhhbGZlZGdlLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlZGdlc1toYWxmZWRnZXNbaUhhbGZlZGdlXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbGZlZGdlcy5zcGxpY2UoaUhhbGZlZGdlLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgYW55IGJvcmRlciBlZGdlcyBhcyBuZWNlc3NhcnkuXG4gICAgICAgICAgICAgICAgaUhhbGZlZGdlID0gMCwgbkhhbGZlZGdlcyA9IGhhbGZlZGdlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlIYWxmZWRnZSA8IG5IYWxmZWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gY2VsbEhhbGZlZGdlRW5kKGNlbGwsIGVkZ2VzW2hhbGZlZGdlc1tpSGFsZmVkZ2VdXSksIGVuZFggPSBlbmRbMF0sIGVuZFkgPSBlbmRbMV07XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gY2VsbEhhbGZlZGdlU3RhcnQoY2VsbCwgZWRnZXNbaGFsZmVkZ2VzWysraUhhbGZlZGdlICUgbkhhbGZlZGdlc11dKSwgc3RhcnRYID0gc3RhcnRbMF0sIHN0YXJ0WSA9IHN0YXJ0WzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZW5kWCAtIHN0YXJ0WCkgPiBlcHNpbG9uIHx8IE1hdGguYWJzKGVuZFkgLSBzdGFydFkpID4gZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFsZmVkZ2VzLnNwbGljZShpSGFsZmVkZ2UsIDAsIGVkZ2VzLnB1c2goY3JlYXRlQm9yZGVyRWRnZShzaXRlLCBlbmQsIE1hdGguYWJzKGVuZFggLSB4MCkgPCBlcHNpbG9uICYmIHkxIC0gZW5kWSA+IGVwc2lsb24gPyBbeDAsIE1hdGguYWJzKHN0YXJ0WCAtIHgwKSA8IGVwc2lsb24gPyBzdGFydFkgOiB5MV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGguYWJzKGVuZFkgLSB5MSkgPCBlcHNpbG9uICYmIHgxIC0gZW5kWCA+IGVwc2lsb24gPyBbTWF0aC5hYnMoc3RhcnRZIC0geTEpIDwgZXBzaWxvbiA/IHN0YXJ0WCA6IHgxLCB5MV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLmFicyhlbmRYIC0geDEpIDwgZXBzaWxvbiAmJiBlbmRZIC0geTAgPiBlcHNpbG9uID8gW3gxLCBNYXRoLmFicyhzdGFydFggLSB4MSkgPCBlcHNpbG9uID8gc3RhcnRZIDogeTBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGguYWJzKGVuZFkgLSB5MCkgPCBlcHNpbG9uICYmIGVuZFggLSB4MCA+IGVwc2lsb24gPyBbTWF0aC5hYnMoc3RhcnRZIC0geTApIDwgZXBzaWxvbiA/IHN0YXJ0WCA6IHgwLCB5MF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwpKSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKytuSGFsZmVkZ2VzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuSGFsZmVkZ2VzKVxuICAgICAgICAgICAgICAgICAgICBjb3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIHdlcmVu4oCZdCBhbnkgZWRnZXMsIGhhdmUgdGhlIGNsb3Nlc3Qgc2l0ZSBjb3ZlciB0aGUgZXh0ZW50LlxuICAgICAgICAvLyBJdCBkb2VzbuKAmXQgbWF0dGVyIHdoaWNoIGNvcm5lciBvZiB0aGUgZXh0ZW50IHdlIG1lYXN1cmUhXG4gICAgICAgIGlmIChjb3Zlcikge1xuICAgICAgICAgICAgdmFyIGR4LCBkeSwgZDIsIGRjID0gSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKGlDZWxsID0gMCwgY292ZXIgPSBudWxsOyBpQ2VsbCA8IG5DZWxsczsgKytpQ2VsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsID0gY2VsbHNbaUNlbGxdKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpdGUgPSBjZWxsLnNpdGU7XG4gICAgICAgICAgICAgICAgICAgIGR4ID0gc2l0ZVswXSAtIHgwO1xuICAgICAgICAgICAgICAgICAgICBkeSA9IHNpdGVbMV0gLSB5MDtcbiAgICAgICAgICAgICAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQyIDwgZGMpXG4gICAgICAgICAgICAgICAgICAgICAgICBkYyA9IGQyLCBjb3ZlciA9IGNlbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYwMCA9IFt4MCwgeTBdLCB2MDEgPSBbeDAsIHkxXSwgdjExID0gW3gxLCB5MV0sIHYxMCA9IFt4MSwgeTBdO1xuICAgICAgICAgICAgICAgIGNvdmVyLmhhbGZlZGdlcy5wdXNoKGVkZ2VzLnB1c2goY3JlYXRlQm9yZGVyRWRnZShzaXRlID0gY292ZXIuc2l0ZSwgdjAwLCB2MDEpKSAtIDEsIGVkZ2VzLnB1c2goY3JlYXRlQm9yZGVyRWRnZShzaXRlLCB2MDEsIHYxMSkpIC0gMSwgZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUsIHYxMSwgdjEwKSkgLSAxLCBlZGdlcy5wdXNoKGNyZWF0ZUJvcmRlckVkZ2Uoc2l0ZSwgdjEwLCB2MDApKSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExhc3RseSBkZWxldGUgYW55IGNlbGxzIHdpdGggbm8gZWRnZXM7IHRoZXNlIHdlcmUgZW50aXJlbHkgY2xpcHBlZC5cbiAgICAgICAgZm9yIChpQ2VsbCA9IDA7IGlDZWxsIDwgbkNlbGxzOyArK2lDZWxsKSB7XG4gICAgICAgICAgICBpZiAoY2VsbCA9IGNlbGxzW2lDZWxsXSkge1xuICAgICAgICAgICAgICAgIGlmICghY2VsbC5oYWxmZWRnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjZWxsc1tpQ2VsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBjaXJjbGVQb29sID0gW107XG4gICAgdmFyIGZpcnN0Q2lyY2xlO1xuICAgIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgICAgUmVkQmxhY2tOb2RlKHRoaXMpO1xuICAgICAgICB0aGlzLnggPVxuICAgICAgICAgICAgdGhpcy55ID1cbiAgICAgICAgICAgICAgICB0aGlzLmFyYyA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l0ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN5ID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0YWNoQ2lyY2xlKGFyYykge1xuICAgICAgICB2YXIgbEFyYyA9IGFyYy5QLCByQXJjID0gYXJjLk47XG4gICAgICAgIGlmICghbEFyYyB8fCAhckFyYylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGxTaXRlID0gbEFyYy5zaXRlLCBjU2l0ZSA9IGFyYy5zaXRlLCByU2l0ZSA9IHJBcmMuc2l0ZTtcbiAgICAgICAgaWYgKGxTaXRlID09PSByU2l0ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGJ4ID0gY1NpdGVbMF0sIGJ5ID0gY1NpdGVbMV0sIGF4ID0gbFNpdGVbMF0gLSBieCwgYXkgPSBsU2l0ZVsxXSAtIGJ5LCBjeCA9IHJTaXRlWzBdIC0gYngsIGN5ID0gclNpdGVbMV0gLSBieTtcbiAgICAgICAgdmFyIGQgPSAyICogKGF4ICogY3kgLSBheSAqIGN4KTtcbiAgICAgICAgaWYgKGQgPj0gLWVwc2lsb24yKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgaGEgPSBheCAqIGF4ICsgYXkgKiBheSwgaGMgPSBjeCAqIGN4ICsgY3kgKiBjeSwgeCA9IChjeSAqIGhhIC0gYXkgKiBoYykgLyBkLCB5ID0gKGF4ICogaGMgLSBjeCAqIGhhKSAvIGQ7XG4gICAgICAgIHZhciBjaXJjbGUgPSBjaXJjbGVQb29sLnBvcCgpIHx8IG5ldyBDaXJjbGU7XG4gICAgICAgIGNpcmNsZS5hcmMgPSBhcmM7XG4gICAgICAgIGNpcmNsZS5zaXRlID0gY1NpdGU7XG4gICAgICAgIGNpcmNsZS54ID0geCArIGJ4O1xuICAgICAgICBjaXJjbGUueSA9IChjaXJjbGUuY3kgPSB5ICsgYnkpICsgTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpOyAvLyB5IGJvdHRvbVxuICAgICAgICBhcmMuY2lyY2xlID0gY2lyY2xlO1xuICAgICAgICB2YXIgYmVmb3JlID0gbnVsbCwgbm9kZSA9IGNpcmNsZXMuXztcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChjaXJjbGUueSA8IG5vZGUueSB8fCAoY2lyY2xlLnkgPT09IG5vZGUueSAmJiBjaXJjbGUueCA8PSBub2RlLngpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuTClcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuTDtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlID0gbm9kZS5QO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5SKVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5SO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2lyY2xlcy5pbnNlcnQoYmVmb3JlLCBjaXJjbGUpO1xuICAgICAgICBpZiAoIWJlZm9yZSlcbiAgICAgICAgICAgIGZpcnN0Q2lyY2xlID0gY2lyY2xlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXRhY2hDaXJjbGUoYXJjKSB7XG4gICAgICAgIHZhciBjaXJjbGUgPSBhcmMuY2lyY2xlO1xuICAgICAgICBpZiAoY2lyY2xlKSB7XG4gICAgICAgICAgICBpZiAoIWNpcmNsZS5QKVxuICAgICAgICAgICAgICAgIGZpcnN0Q2lyY2xlID0gY2lyY2xlLk47XG4gICAgICAgICAgICBjaXJjbGVzLnJlbW92ZShjaXJjbGUpO1xuICAgICAgICAgICAgY2lyY2xlUG9vbC5wdXNoKGNpcmNsZSk7XG4gICAgICAgICAgICBSZWRCbGFja05vZGUoY2lyY2xlKTtcbiAgICAgICAgICAgIGFyYy5jaXJjbGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBiZWFjaFBvb2wgPSBbXTtcbiAgICBmdW5jdGlvbiBCZWFjaCgpIHtcbiAgICAgICAgUmVkQmxhY2tOb2RlKHRoaXMpO1xuICAgICAgICB0aGlzLmVkZ2UgPVxuICAgICAgICAgICAgdGhpcy5zaXRlID1cbiAgICAgICAgICAgICAgICB0aGlzLmNpcmNsZSA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUJlYWNoKHNpdGUpIHtcbiAgICAgICAgdmFyIGJlYWNoID0gYmVhY2hQb29sLnBvcCgpIHx8IG5ldyBCZWFjaDtcbiAgICAgICAgYmVhY2guc2l0ZSA9IHNpdGU7XG4gICAgICAgIHJldHVybiBiZWFjaDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGV0YWNoQmVhY2goYmVhY2gpIHtcbiAgICAgICAgZGV0YWNoQ2lyY2xlKGJlYWNoKTtcbiAgICAgICAgYmVhY2hlcy5yZW1vdmUoYmVhY2gpO1xuICAgICAgICBiZWFjaFBvb2wucHVzaChiZWFjaCk7XG4gICAgICAgIFJlZEJsYWNrTm9kZShiZWFjaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZUJlYWNoKGJlYWNoKSB7XG4gICAgICAgIHZhciBjaXJjbGUgPSBiZWFjaC5jaXJjbGUsIHggPSBjaXJjbGUueCwgeSA9IGNpcmNsZS5jeSwgdmVydGV4ID0gW3gsIHldLCBwcmV2aW91cyA9IGJlYWNoLlAsIG5leHQgPSBiZWFjaC5OLCBkaXNhcHBlYXJpbmcgPSBbYmVhY2hdO1xuICAgICAgICBkZXRhY2hCZWFjaChiZWFjaCk7XG4gICAgICAgIHZhciBsQXJjID0gcHJldmlvdXM7XG4gICAgICAgIHdoaWxlIChsQXJjLmNpcmNsZVxuICAgICAgICAgICAgJiYgTWF0aC5hYnMoeCAtIGxBcmMuY2lyY2xlLngpIDwgZXBzaWxvblxuICAgICAgICAgICAgJiYgTWF0aC5hYnMoeSAtIGxBcmMuY2lyY2xlLmN5KSA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHByZXZpb3VzID0gbEFyYy5QO1xuICAgICAgICAgICAgZGlzYXBwZWFyaW5nLnVuc2hpZnQobEFyYyk7XG4gICAgICAgICAgICBkZXRhY2hCZWFjaChsQXJjKTtcbiAgICAgICAgICAgIGxBcmMgPSBwcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICBkaXNhcHBlYXJpbmcudW5zaGlmdChsQXJjKTtcbiAgICAgICAgZGV0YWNoQ2lyY2xlKGxBcmMpO1xuICAgICAgICB2YXIgckFyYyA9IG5leHQ7XG4gICAgICAgIHdoaWxlIChyQXJjLmNpcmNsZVxuICAgICAgICAgICAgJiYgTWF0aC5hYnMoeCAtIHJBcmMuY2lyY2xlLngpIDwgZXBzaWxvblxuICAgICAgICAgICAgJiYgTWF0aC5hYnMoeSAtIHJBcmMuY2lyY2xlLmN5KSA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgIG5leHQgPSByQXJjLk47XG4gICAgICAgICAgICBkaXNhcHBlYXJpbmcucHVzaChyQXJjKTtcbiAgICAgICAgICAgIGRldGFjaEJlYWNoKHJBcmMpO1xuICAgICAgICAgICAgckFyYyA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZGlzYXBwZWFyaW5nLnB1c2gockFyYyk7XG4gICAgICAgIGRldGFjaENpcmNsZShyQXJjKTtcbiAgICAgICAgdmFyIG5BcmNzID0gZGlzYXBwZWFyaW5nLmxlbmd0aCwgaUFyYztcbiAgICAgICAgZm9yIChpQXJjID0gMTsgaUFyYyA8IG5BcmNzOyArK2lBcmMpIHtcbiAgICAgICAgICAgIHJBcmMgPSBkaXNhcHBlYXJpbmdbaUFyY107XG4gICAgICAgICAgICBsQXJjID0gZGlzYXBwZWFyaW5nW2lBcmMgLSAxXTtcbiAgICAgICAgICAgIHNldEVkZ2VFbmQockFyYy5lZGdlLCBsQXJjLnNpdGUsIHJBcmMuc2l0ZSwgdmVydGV4KTtcbiAgICAgICAgfVxuICAgICAgICBsQXJjID0gZGlzYXBwZWFyaW5nWzBdO1xuICAgICAgICByQXJjID0gZGlzYXBwZWFyaW5nW25BcmNzIC0gMV07XG4gICAgICAgIHJBcmMuZWRnZSA9IGNyZWF0ZUVkZ2UobEFyYy5zaXRlLCByQXJjLnNpdGUsIG51bGwsIHZlcnRleCk7XG4gICAgICAgIGF0dGFjaENpcmNsZShsQXJjKTtcbiAgICAgICAgYXR0YWNoQ2lyY2xlKHJBcmMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRCZWFjaChzaXRlKSB7XG4gICAgICAgIHZhciB4ID0gc2l0ZVswXSwgZGlyZWN0cml4ID0gc2l0ZVsxXSwgbEFyYywgckFyYywgZHhsLCBkeHIsIG5vZGUgPSBiZWFjaGVzLl87XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBkeGwgPSBsZWZ0QnJlYWtQb2ludChub2RlLCBkaXJlY3RyaXgpIC0geDtcbiAgICAgICAgICAgIGlmIChkeGwgPiBlcHNpbG9uKVxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLkw7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkeHIgPSB4IC0gcmlnaHRCcmVha1BvaW50KG5vZGUsIGRpcmVjdHJpeCk7XG4gICAgICAgICAgICAgICAgaWYgKGR4ciA+IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLlIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxBcmMgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkeGwgPiAtZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbEFyYyA9IG5vZGUuUDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJBcmMgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR4ciA+IC1lcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsQXJjID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJBcmMgPSBub2RlLk47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsQXJjID0gckFyYyA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZUNlbGwoc2l0ZSk7XG4gICAgICAgIHZhciBuZXdBcmMgPSBjcmVhdGVCZWFjaChzaXRlKTtcbiAgICAgICAgYmVhY2hlcy5pbnNlcnQobEFyYywgbmV3QXJjKTtcbiAgICAgICAgaWYgKCFsQXJjICYmICFyQXJjKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAobEFyYyA9PT0gckFyYykge1xuICAgICAgICAgICAgZGV0YWNoQ2lyY2xlKGxBcmMpO1xuICAgICAgICAgICAgckFyYyA9IGNyZWF0ZUJlYWNoKGxBcmMuc2l0ZSk7XG4gICAgICAgICAgICBiZWFjaGVzLmluc2VydChuZXdBcmMsIHJBcmMpO1xuICAgICAgICAgICAgbmV3QXJjLmVkZ2UgPSByQXJjLmVkZ2UgPSBjcmVhdGVFZGdlKGxBcmMuc2l0ZSwgbmV3QXJjLnNpdGUpO1xuICAgICAgICAgICAgYXR0YWNoQ2lyY2xlKGxBcmMpO1xuICAgICAgICAgICAgYXR0YWNoQ2lyY2xlKHJBcmMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghckFyYykgeyAvLyAmJiBsQXJjXG4gICAgICAgICAgICBuZXdBcmMuZWRnZSA9IGNyZWF0ZUVkZ2UobEFyYy5zaXRlLCBuZXdBcmMuc2l0ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSBsQXJjICE9PSByQXJjXG4gICAgICAgIGRldGFjaENpcmNsZShsQXJjKTtcbiAgICAgICAgZGV0YWNoQ2lyY2xlKHJBcmMpO1xuICAgICAgICB2YXIgbFNpdGUgPSBsQXJjLnNpdGUsIGF4ID0gbFNpdGVbMF0sIGF5ID0gbFNpdGVbMV0sIGJ4ID0gc2l0ZVswXSAtIGF4LCBieSA9IHNpdGVbMV0gLSBheSwgclNpdGUgPSByQXJjLnNpdGUsIGN4ID0gclNpdGVbMF0gLSBheCwgY3kgPSByU2l0ZVsxXSAtIGF5LCBkID0gMiAqIChieCAqIGN5IC0gYnkgKiBjeCksIGhiID0gYnggKiBieCArIGJ5ICogYnksIGhjID0gY3ggKiBjeCArIGN5ICogY3ksIHZlcnRleCA9IFsoY3kgKiBoYiAtIGJ5ICogaGMpIC8gZCArIGF4LCAoYnggKiBoYyAtIGN4ICogaGIpIC8gZCArIGF5XTtcbiAgICAgICAgc2V0RWRnZUVuZChyQXJjLmVkZ2UsIGxTaXRlLCByU2l0ZSwgdmVydGV4KTtcbiAgICAgICAgbmV3QXJjLmVkZ2UgPSBjcmVhdGVFZGdlKGxTaXRlLCBzaXRlLCBudWxsLCB2ZXJ0ZXgpO1xuICAgICAgICByQXJjLmVkZ2UgPSBjcmVhdGVFZGdlKHNpdGUsIHJTaXRlLCBudWxsLCB2ZXJ0ZXgpO1xuICAgICAgICBhdHRhY2hDaXJjbGUobEFyYyk7XG4gICAgICAgIGF0dGFjaENpcmNsZShyQXJjKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGVmdEJyZWFrUG9pbnQoYXJjLCBkaXJlY3RyaXgpIHtcbiAgICAgICAgdmFyIHNpdGUgPSBhcmMuc2l0ZSwgcmZvY3ggPSBzaXRlWzBdLCByZm9jeSA9IHNpdGVbMV0sIHBieTIgPSByZm9jeSAtIGRpcmVjdHJpeDtcbiAgICAgICAgaWYgKCFwYnkyKVxuICAgICAgICAgICAgcmV0dXJuIHJmb2N4O1xuICAgICAgICB2YXIgbEFyYyA9IGFyYy5QO1xuICAgICAgICBpZiAoIWxBcmMpXG4gICAgICAgICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgICAgICBzaXRlID0gbEFyYy5zaXRlO1xuICAgICAgICB2YXIgbGZvY3ggPSBzaXRlWzBdLCBsZm9jeSA9IHNpdGVbMV0sIHBsYnkyID0gbGZvY3kgLSBkaXJlY3RyaXg7XG4gICAgICAgIGlmICghcGxieTIpXG4gICAgICAgICAgICByZXR1cm4gbGZvY3g7XG4gICAgICAgIHZhciBobCA9IGxmb2N4IC0gcmZvY3gsIGFieTIgPSAxIC8gcGJ5MiAtIDEgLyBwbGJ5MiwgYiA9IGhsIC8gcGxieTI7XG4gICAgICAgIGlmIChhYnkyKVxuICAgICAgICAgICAgcmV0dXJuICgtYiArIE1hdGguc3FydChiICogYiAtIDIgKiBhYnkyICogKGhsICogaGwgLyAoLTIgKiBwbGJ5MikgLSBsZm9jeSArIHBsYnkyIC8gMiArIHJmb2N5IC0gcGJ5MiAvIDIpKSkgLyBhYnkyICsgcmZvY3g7XG4gICAgICAgIHJldHVybiAocmZvY3ggKyBsZm9jeCkgLyAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiByaWdodEJyZWFrUG9pbnQoYXJjLCBkaXJlY3RyaXgpIHtcbiAgICAgICAgdmFyIHJBcmMgPSBhcmMuTjtcbiAgICAgICAgaWYgKHJBcmMpXG4gICAgICAgICAgICByZXR1cm4gbGVmdEJyZWFrUG9pbnQockFyYywgZGlyZWN0cml4KTtcbiAgICAgICAgdmFyIHNpdGUgPSBhcmMuc2l0ZTtcbiAgICAgICAgcmV0dXJuIHNpdGVbMV0gPT09IGRpcmVjdHJpeCA/IHNpdGVbMF0gOiBJbmZpbml0eTtcbiAgICB9XG4gICAgdmFyIGVwc2lsb24gPSAxZS02O1xuICAgIHZhciBlcHNpbG9uMiA9IDFlLTEyO1xuICAgIHZhciBiZWFjaGVzO1xuICAgIHZhciBjZWxscztcbiAgICB2YXIgY2lyY2xlcztcbiAgICB2YXIgZWRnZXM7XG4gICAgZnVuY3Rpb24gdHJpYW5nbGVBcmVhKGEsIGIsIGMpIHtcbiAgICAgICAgcmV0dXJuIChhWzBdIC0gY1swXSkgKiAoYlsxXSAtIGFbMV0pIC0gKGFbMF0gLSBiWzBdKSAqIChjWzFdIC0gYVsxXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxleGljb2dyYXBoaWMoYSwgYikge1xuICAgICAgICByZXR1cm4gYlsxXSAtIGFbMV1cbiAgICAgICAgICAgIHx8IGJbMF0gLSBhWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBEaWFncmFtKHNpdGVzLCBleHRlbnQpIHtcbiAgICAgICAgdmFyIHNpdGUgPSBzaXRlcy5zb3J0KGxleGljb2dyYXBoaWMpLnBvcCgpLCB4LCB5LCBjaXJjbGU7XG4gICAgICAgIGVkZ2VzID0gW107XG4gICAgICAgIGNlbGxzID0gbmV3IEFycmF5KHNpdGVzLmxlbmd0aCk7XG4gICAgICAgIGJlYWNoZXMgPSBuZXcgUmVkQmxhY2tUcmVlO1xuICAgICAgICBjaXJjbGVzID0gbmV3IFJlZEJsYWNrVHJlZTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNpcmNsZSA9IGZpcnN0Q2lyY2xlO1xuICAgICAgICAgICAgaWYgKHNpdGUgJiYgKCFjaXJjbGUgfHwgc2l0ZVsxXSA8IGNpcmNsZS55IHx8IChzaXRlWzFdID09PSBjaXJjbGUueSAmJiBzaXRlWzBdIDwgY2lyY2xlLngpKSkge1xuICAgICAgICAgICAgICAgIGlmIChzaXRlWzBdICE9PSB4IHx8IHNpdGVbMV0gIT09IHkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkQmVhY2goc2l0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBzaXRlWzBdLCB5ID0gc2l0ZVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2l0ZSA9IHNpdGVzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2lyY2xlKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQmVhY2goY2lyY2xlLmFyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzb3J0Q2VsbEhhbGZlZGdlcygpO1xuICAgICAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgICAgICB2YXIgeDAgPSArZXh0ZW50WzBdWzBdLCB5MCA9ICtleHRlbnRbMF1bMV0sIHgxID0gK2V4dGVudFsxXVswXSwgeTEgPSArZXh0ZW50WzFdWzFdO1xuICAgICAgICAgICAgY2xpcEVkZ2VzKHgwLCB5MCwgeDEsIHkxKTtcbiAgICAgICAgICAgIGNsaXBDZWxscyh4MCwgeTAsIHgxLCB5MSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGdlcyA9IGVkZ2VzO1xuICAgICAgICB0aGlzLmNlbGxzID0gY2VsbHM7XG4gICAgICAgIGJlYWNoZXMgPVxuICAgICAgICAgICAgY2lyY2xlcyA9XG4gICAgICAgICAgICAgICAgZWRnZXMgPVxuICAgICAgICAgICAgICAgICAgICBjZWxscyA9IG51bGw7XG4gICAgfVxuICAgIERpYWdyYW0ucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogRGlhZ3JhbSxcbiAgICAgICAgcG9seWdvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxscy5tYXAoZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9seWdvbiA9IGNlbGwuaGFsZmVkZ2VzLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gY2VsbEhhbGZlZGdlU3RhcnQoY2VsbCwgZWRnZXNbaV0pOyB9KTtcbiAgICAgICAgICAgICAgICBwb2x5Z29uLmRhdGEgPSBjZWxsLnNpdGUuZGF0YTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9seWdvbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB0cmlhbmdsZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0cmlhbmdsZXMgPSBbXSwgZWRnZXMgPSB0aGlzLmVkZ2VzO1xuICAgICAgICAgICAgdGhpcy5jZWxscy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEobSA9IChoYWxmZWRnZXMgPSBjZWxsLmhhbGZlZGdlcykubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBzaXRlID0gY2VsbC5zaXRlLCBoYWxmZWRnZXMsIGogPSAtMSwgbSwgczAsIGUxID0gZWRnZXNbaGFsZmVkZ2VzW20gLSAxXV0sIHMxID0gZTEubGVmdCA9PT0gc2l0ZSA/IGUxLnJpZ2h0IDogZTEubGVmdDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytqIDwgbSkge1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgICAgICBlMSA9IGVkZ2VzW2hhbGZlZGdlc1tqXV07XG4gICAgICAgICAgICAgICAgICAgIHMxID0gZTEubGVmdCA9PT0gc2l0ZSA/IGUxLnJpZ2h0IDogZTEubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMwICYmIHMxICYmIGkgPCBzMC5pbmRleCAmJiBpIDwgczEuaW5kZXggJiYgdHJpYW5nbGVBcmVhKHNpdGUsIHMwLCBzMSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZXMucHVzaChbc2l0ZS5kYXRhLCBzMC5kYXRhLCBzMS5kYXRhXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cmlhbmdsZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmtzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWRnZS5yaWdodDtcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZWRnZS5sZWZ0LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogZWRnZS5yaWdodC5kYXRhXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kOiBmdW5jdGlvbiAoeCwgeSwgcmFkaXVzKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIGkwLCBpMSA9IHRoYXQuX2ZvdW5kIHx8IDAsIG4gPSB0aGF0LmNlbGxzLmxlbmd0aCwgY2VsbDtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgcHJldmlvdXNseS1mb3VuZCBjZWxsLCBvciBzdGFydCB3aXRoIGFuIGFyYml0cmFyeSBvbmUuXG4gICAgICAgICAgICB3aGlsZSAoIShjZWxsID0gdGhhdC5jZWxsc1tpMV0pKVxuICAgICAgICAgICAgICAgIGlmICgrK2kxID49IG4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIGR4ID0geCAtIGNlbGwuc2l0ZVswXSwgZHkgPSB5IC0gY2VsbC5zaXRlWzFdLCBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICAgICAgLy8gVHJhdmVyc2UgdGhlIGhhbGYtZWRnZXMgdG8gZmluZCBhIGNsb3NlciBjZWxsLCBpZiBhbnkuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY2VsbCA9IHRoYXQuY2VsbHNbaTAgPSBpMV0sIGkxID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjZWxsLmhhbGZlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGdlID0gdGhhdC5lZGdlc1tlXSwgdiA9IGVkZ2UubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2ID09PSBjZWxsLnNpdGUgfHwgIXYpICYmICEodiA9IGVkZ2UucmlnaHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdnggPSB4IC0gdlswXSwgdnkgPSB5IC0gdlsxXSwgdjIgPSB2eCAqIHZ4ICsgdnkgKiB2eTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYyIDwgZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICBkMiA9IHYyLCBpMSA9IHYuaW5kZXg7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IHdoaWxlIChpMSAhPT0gbnVsbCk7XG4gICAgICAgICAgICB0aGF0Ll9mb3VuZCA9IGkwO1xuICAgICAgICAgICAgcmV0dXJuIHJhZGl1cyA9PSBudWxsIHx8IGQyIDw9IHJhZGl1cyAqIHJhZGl1cyA/IGNlbGwuc2l0ZSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHZvcm9ub2koKSB7XG4gICAgICAgIHZhciB4JCQxID0geCwgeSQkMSA9IHksIGV4dGVudCA9IG51bGw7XG4gICAgICAgIGZ1bmN0aW9uIHZvcm9ub2koZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaWFncmFtKGRhdGEubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBbTWF0aC5yb3VuZCh4JCQxKGQsIGksIGRhdGEpIC8gZXBzaWxvbikgKiBlcHNpbG9uLCBNYXRoLnJvdW5kKHkkJDEoZCwgaSwgZGF0YSkgLyBlcHNpbG9uKSAqIGVwc2lsb25dO1xuICAgICAgICAgICAgICAgIHMuaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIHMuZGF0YSA9IGQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICB9KSwgZXh0ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2b3Jvbm9pLnBvbHlnb25zID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB2b3Jvbm9pKGRhdGEpLnBvbHlnb25zKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZvcm9ub2kubGlua3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHZvcm9ub2koZGF0YSkubGlua3MoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdm9yb25vaS50cmlhbmdsZXMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHZvcm9ub2koZGF0YSkudHJpYW5nbGVzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZvcm9ub2kueCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4JCQxID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHZvcm9ub2kpIDogeCQkMTtcbiAgICAgICAgfTtcbiAgICAgICAgdm9yb25vaS55ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkkJDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgdm9yb25vaSkgOiB5JCQxO1xuICAgICAgICB9O1xuICAgICAgICB2b3Jvbm9pLmV4dGVudCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHRlbnQgPSBfID09IG51bGwgPyBudWxsIDogW1srX1swXVswXSwgK19bMF1bMV1dLCBbK19bMV1bMF0sICtfWzFdWzFdXV0sIHZvcm9ub2kpIDogZXh0ZW50ICYmIFtbZXh0ZW50WzBdWzBdLCBleHRlbnRbMF1bMV1dLCBbZXh0ZW50WzFdWzBdLCBleHRlbnRbMV1bMV1dXTtcbiAgICAgICAgfTtcbiAgICAgICAgdm9yb25vaS5zaXplID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4dGVudCA9IF8gPT0gbnVsbCA/IG51bGwgOiBbWzAsIDBdLCBbK19bMF0sICtfWzFdXV0sIHZvcm9ub2kpIDogZXh0ZW50ICYmIFtleHRlbnRbMV1bMF0gLSBleHRlbnRbMF1bMF0sIGV4dGVudFsxXVsxXSAtIGV4dGVudFswXVsxXV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB2b3Jvbm9pO1xuICAgIH1cbiAgICBleHBvcnRzLnZvcm9ub2kgPSB2b3Jvbm9pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59KSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgQ2hyaXMgUGV0dGl0dFxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ3JhcGhsaWI6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGliL2dyYXBobGliICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9ncmFwaGxpYi5qc1wiKSxcblxuICBsYXlvdXQ6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGliL2xheW91dCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbGF5b3V0LmpzXCIpLFxuICBkZWJ1ZzogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saWIvZGVidWcgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2RlYnVnLmpzXCIpLFxuICB1dGlsOiB7XG4gICAgdGltZTogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saWIvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvdXRpbC5qc1wiKS50aW1lLFxuICAgIG5vdGltZTogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saWIvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvdXRpbC5qc1wiKS5ub3RpbWVcbiAgfSxcbiAgdmVyc2lvbjogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saWIvdmVyc2lvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvdmVyc2lvbi5qc1wiKVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2FjeWNsaWMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvYWN5Y2xpYy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xudmFyIGdyZWVkeUZBUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ3JlZWR5LWZhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvZ3JlZWR5LWZhcy5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJ1bjogcnVuLFxuICB1bmRvOiB1bmRvXG59O1xuXG5mdW5jdGlvbiBydW4oZykge1xuICB2YXIgZmFzID0gKGcuZ3JhcGgoKS5hY3ljbGljZXIgPT09IFwiZ3JlZWR5XCJcbiAgICA/IGdyZWVkeUZBUyhnLCB3ZWlnaHRGbihnKSlcbiAgICA6IGRmc0ZBUyhnKSk7XG4gIF8uZm9yRWFjaChmYXMsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbGFiZWwgPSBnLmVkZ2UoZSk7XG4gICAgZy5yZW1vdmVFZGdlKGUpO1xuICAgIGxhYmVsLmZvcndhcmROYW1lID0gZS5uYW1lO1xuICAgIGxhYmVsLnJldmVyc2VkID0gdHJ1ZTtcbiAgICBnLnNldEVkZ2UoZS53LCBlLnYsIGxhYmVsLCBfLnVuaXF1ZUlkKFwicmV2XCIpKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gd2VpZ2h0Rm4oZykge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gZy5lZGdlKGUpLndlaWdodDtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGRmc0ZBUyhnKSB7XG4gIHZhciBmYXMgPSBbXTtcbiAgdmFyIHN0YWNrID0ge307XG4gIHZhciB2aXNpdGVkID0ge307XG5cbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICBpZiAoXy5oYXModmlzaXRlZCwgdikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmlzaXRlZFt2XSA9IHRydWU7XG4gICAgc3RhY2tbdl0gPSB0cnVlO1xuICAgIF8uZm9yRWFjaChnLm91dEVkZ2VzKHYpLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoXy5oYXMoc3RhY2ssIGUudykpIHtcbiAgICAgICAgZmFzLnB1c2goZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZnMoZS53KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZWxldGUgc3RhY2tbdl07XG4gIH1cblxuICBfLmZvckVhY2goZy5ub2RlcygpLCBkZnMpO1xuICByZXR1cm4gZmFzO1xufVxuXG5mdW5jdGlvbiB1bmRvKGcpIHtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBsYWJlbCA9IGcuZWRnZShlKTtcbiAgICBpZiAobGFiZWwucmV2ZXJzZWQpIHtcbiAgICAgIGcucmVtb3ZlRWRnZShlKTtcblxuICAgICAgdmFyIGZvcndhcmROYW1lID0gbGFiZWwuZm9yd2FyZE5hbWU7XG4gICAgICBkZWxldGUgbGFiZWwucmV2ZXJzZWQ7XG4gICAgICBkZWxldGUgbGFiZWwuZm9yd2FyZE5hbWU7XG4gICAgICBnLnNldEVkZ2UoZS53LCBlLnYsIGxhYmVsLCBmb3J3YXJkTmFtZSk7XG4gICAgfVxuICB9KTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2FkZC1ib3JkZXItc2VnbWVudHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvYWRkLWJvcmRlci1zZWdtZW50cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3V0aWwuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkQm9yZGVyU2VnbWVudHM7XG5cbmZ1bmN0aW9uIGFkZEJvcmRlclNlZ21lbnRzKGcpIHtcbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBnLmNoaWxkcmVuKHYpO1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIF8uZm9yRWFjaChjaGlsZHJlbiwgZGZzKTtcbiAgICB9XG5cbiAgICBpZiAoXy5oYXMobm9kZSwgXCJtaW5SYW5rXCIpKSB7XG4gICAgICBub2RlLmJvcmRlckxlZnQgPSBbXTtcbiAgICAgIG5vZGUuYm9yZGVyUmlnaHQgPSBbXTtcbiAgICAgIGZvciAodmFyIHJhbmsgPSBub2RlLm1pblJhbmssIG1heFJhbmsgPSBub2RlLm1heFJhbmsgKyAxO1xuICAgICAgICByYW5rIDwgbWF4UmFuaztcbiAgICAgICAgKytyYW5rKSB7XG4gICAgICAgIGFkZEJvcmRlck5vZGUoZywgXCJib3JkZXJMZWZ0XCIsIFwiX2JsXCIsIHYsIG5vZGUsIHJhbmspO1xuICAgICAgICBhZGRCb3JkZXJOb2RlKGcsIFwiYm9yZGVyUmlnaHRcIiwgXCJfYnJcIiwgdiwgbm9kZSwgcmFuayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgXy5mb3JFYWNoKGcuY2hpbGRyZW4oKSwgZGZzKTtcbn1cblxuZnVuY3Rpb24gYWRkQm9yZGVyTm9kZShnLCBwcm9wLCBwcmVmaXgsIHNnLCBzZ05vZGUsIHJhbmspIHtcbiAgdmFyIGxhYmVsID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwLCByYW5rOiByYW5rLCBib3JkZXJUeXBlOiBwcm9wIH07XG4gIHZhciBwcmV2ID0gc2dOb2RlW3Byb3BdW3JhbmsgLSAxXTtcbiAgdmFyIGN1cnIgPSB1dGlsLmFkZER1bW15Tm9kZShnLCBcImJvcmRlclwiLCBsYWJlbCwgcHJlZml4KTtcbiAgc2dOb2RlW3Byb3BdW3JhbmtdID0gY3VycjtcbiAgZy5zZXRQYXJlbnQoY3Vyciwgc2cpO1xuICBpZiAocHJldikge1xuICAgIGcuc2V0RWRnZShwcmV2LCBjdXJyLCB7IHdlaWdodDogMSB9KTtcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvY29vcmRpbmF0ZS1zeXN0ZW0uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2Nvb3JkaW5hdGUtc3lzdGVtLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRqdXN0OiBhZGp1c3QsXG4gIHVuZG86IHVuZG9cbn07XG5cbmZ1bmN0aW9uIGFkanVzdChnKSB7XG4gIHZhciByYW5rRGlyID0gZy5ncmFwaCgpLnJhbmtkaXIudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHJhbmtEaXIgPT09IFwibHJcIiB8fCByYW5rRGlyID09PSBcInJsXCIpIHtcbiAgICBzd2FwV2lkdGhIZWlnaHQoZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5kbyhnKSB7XG4gIHZhciByYW5rRGlyID0gZy5ncmFwaCgpLnJhbmtkaXIudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHJhbmtEaXIgPT09IFwiYnRcIiB8fCByYW5rRGlyID09PSBcInJsXCIpIHtcbiAgICByZXZlcnNlWShnKTtcbiAgfVxuXG4gIGlmIChyYW5rRGlyID09PSBcImxyXCIgfHwgcmFua0RpciA9PT0gXCJybFwiKSB7XG4gICAgc3dhcFhZKGcpO1xuICAgIHN3YXBXaWR0aEhlaWdodChnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzd2FwV2lkdGhIZWlnaHQoZykge1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7IHN3YXBXaWR0aEhlaWdodE9uZShnLm5vZGUodikpOyB9KTtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkgeyBzd2FwV2lkdGhIZWlnaHRPbmUoZy5lZGdlKGUpKTsgfSk7XG59XG5cbmZ1bmN0aW9uIHN3YXBXaWR0aEhlaWdodE9uZShhdHRycykge1xuICB2YXIgdyA9IGF0dHJzLndpZHRoO1xuICBhdHRycy53aWR0aCA9IGF0dHJzLmhlaWdodDtcbiAgYXR0cnMuaGVpZ2h0ID0gdztcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVkoZykge1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7IHJldmVyc2VZT25lKGcubm9kZSh2KSk7IH0pO1xuXG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBfLmZvckVhY2goZWRnZS5wb2ludHMsIHJldmVyc2VZT25lKTtcbiAgICBpZiAoXy5oYXMoZWRnZSwgXCJ5XCIpKSB7XG4gICAgICByZXZlcnNlWU9uZShlZGdlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlWU9uZShhdHRycykge1xuICBhdHRycy55ID0gLWF0dHJzLnk7XG59XG5cbmZ1bmN0aW9uIHN3YXBYWShnKSB7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgc3dhcFhZT25lKGcubm9kZSh2KSk7IH0pO1xuXG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBfLmZvckVhY2goZWRnZS5wb2ludHMsIHN3YXBYWU9uZSk7XG4gICAgaWYgKF8uaGFzKGVkZ2UsIFwieFwiKSkge1xuICAgICAgc3dhcFhZT25lKGVkZ2UpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN3YXBYWU9uZShhdHRycykge1xuICB2YXIgeCA9IGF0dHJzLng7XG4gIGF0dHJzLnggPSBhdHRycy55O1xuICBhdHRycy55ID0geDtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2RhdGEvbGlzdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2RhdGEvbGlzdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKlxuICogU2ltcGxlIGRvdWJseSBsaW5rZWQgbGlzdCBpbXBsZW1lbnRhdGlvbiBkZXJpdmVkIGZyb20gQ29ybWVuLCBldCBhbC4sXG4gKiBcIkludHJvZHVjdGlvbiB0byBBbGdvcml0aG1zXCIuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0O1xuXG5mdW5jdGlvbiBMaXN0KCkge1xuICB2YXIgc2VudGluZWwgPSB7fTtcbiAgc2VudGluZWwuX25leHQgPSBzZW50aW5lbC5fcHJldiA9IHNlbnRpbmVsO1xuICB0aGlzLl9zZW50aW5lbCA9IHNlbnRpbmVsO1xufVxuXG5MaXN0LnByb3RvdHlwZS5kZXF1ZXVlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZW50aW5lbCA9IHRoaXMuX3NlbnRpbmVsO1xuICB2YXIgZW50cnkgPSBzZW50aW5lbC5fcHJldjtcbiAgaWYgKGVudHJ5ICE9PSBzZW50aW5lbCkge1xuICAgIHVubGluayhlbnRyeSk7XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5MaXN0LnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgdmFyIHNlbnRpbmVsID0gdGhpcy5fc2VudGluZWw7XG4gIGlmIChlbnRyeS5fcHJldiAmJiBlbnRyeS5fbmV4dCkge1xuICAgIHVubGluayhlbnRyeSk7XG4gIH1cbiAgZW50cnkuX25leHQgPSBzZW50aW5lbC5fbmV4dDtcbiAgc2VudGluZWwuX25leHQuX3ByZXYgPSBlbnRyeTtcbiAgc2VudGluZWwuX25leHQgPSBlbnRyeTtcbiAgZW50cnkuX3ByZXYgPSBzZW50aW5lbDtcbn07XG5cbkxpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdHJzID0gW107XG4gIHZhciBzZW50aW5lbCA9IHRoaXMuX3NlbnRpbmVsO1xuICB2YXIgY3VyciA9IHNlbnRpbmVsLl9wcmV2O1xuICB3aGlsZSAoY3VyciAhPT0gc2VudGluZWwpIHtcbiAgICBzdHJzLnB1c2goSlNPTi5zdHJpbmdpZnkoY3VyciwgZmlsdGVyT3V0TGlua3MpKTtcbiAgICBjdXJyID0gY3Vyci5fcHJldjtcbiAgfVxuICByZXR1cm4gXCJbXCIgKyBzdHJzLmpvaW4oXCIsIFwiKSArIFwiXVwiO1xufTtcblxuZnVuY3Rpb24gdW5saW5rKGVudHJ5KSB7XG4gIGVudHJ5Ll9wcmV2Ll9uZXh0ID0gZW50cnkuX25leHQ7XG4gIGVudHJ5Ll9uZXh0Ll9wcmV2ID0gZW50cnkuX3ByZXY7XG4gIGRlbGV0ZSBlbnRyeS5fbmV4dDtcbiAgZGVsZXRlIGVudHJ5Ll9wcmV2O1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJPdXRMaW5rcyhrLCB2KSB7XG4gIGlmIChrICE9PSBcIl9uZXh0XCIgJiYgayAhPT0gXCJfcHJldlwiKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2RlYnVnLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9kZWJ1Zy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2xvZGFzaC5qc1wiKTtcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi91dGlsLmpzXCIpO1xudmFyIEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ncmFwaGxpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvZ3JhcGhsaWIuanNcIikuR3JhcGg7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWJ1Z09yZGVyaW5nOiBkZWJ1Z09yZGVyaW5nXG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZGVidWdPcmRlcmluZyhnKSB7XG4gIHZhciBsYXllck1hdHJpeCA9IHV0aWwuYnVpbGRMYXllck1hdHJpeChnKTtcblxuICB2YXIgaCA9IG5ldyBHcmFwaCh7IGNvbXBvdW5kOiB0cnVlLCBtdWx0aWdyYXBoOiB0cnVlIH0pLnNldEdyYXBoKHt9KTtcblxuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgaC5zZXROb2RlKHYsIHsgbGFiZWw6IHYgfSk7XG4gICAgaC5zZXRQYXJlbnQodiwgXCJsYXllclwiICsgZy5ub2RlKHYpLnJhbmspO1xuICB9KTtcblxuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgaC5zZXRFZGdlKGUudiwgZS53LCB7fSwgZS5uYW1lKTtcbiAgfSk7XG5cbiAgXy5mb3JFYWNoKGxheWVyTWF0cml4LCBmdW5jdGlvbihsYXllciwgaSkge1xuICAgIHZhciBsYXllclYgPSBcImxheWVyXCIgKyBpO1xuICAgIGguc2V0Tm9kZShsYXllclYsIHsgcmFuazogXCJzYW1lXCIgfSk7XG4gICAgXy5yZWR1Y2UobGF5ZXIsIGZ1bmN0aW9uKHUsIHYpIHtcbiAgICAgIGguc2V0RWRnZSh1LCB2LCB7IHN0eWxlOiBcImludmlzXCIgfSk7XG4gICAgICByZXR1cm4gdjtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGg7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9ncmFwaGxpYi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvZ3JhcGhsaWIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBnbG9iYWwgd2luZG93ICovXG5cbnZhciBncmFwaGxpYjtcblxuaWYgKHRydWUpIHtcbiAgdHJ5IHtcbiAgICBncmFwaGxpYiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGdyYXBobGliICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2luZGV4LmpzXCIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICB9XG59XG5cbmlmICghZ3JhcGhsaWIpIHtcbiAgZ3JhcGhsaWIgPSB3aW5kb3cuZ3JhcGhsaWI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ3JhcGhsaWI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9ncmVlZHktZmFzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2dyZWVkeS1mYXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2xvZGFzaC5qc1wiKTtcbnZhciBHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ3JhcGhsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2dyYXBobGliLmpzXCIpLkdyYXBoO1xudmFyIExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RhdGEvbGlzdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvZGF0YS9saXN0LmpzXCIpO1xuXG4vKlxuICogQSBncmVlZHkgaGV1cmlzdGljIGZvciBmaW5kaW5nIGEgZmVlZGJhY2sgYXJjIHNldCBmb3IgYSBncmFwaC4gQSBmZWVkYmFja1xuICogYXJjIHNldCBpcyBhIHNldCBvZiBlZGdlcyB0aGF0IGNhbiBiZSByZW1vdmVkIHRvIG1ha2UgYSBncmFwaCBhY3ljbGljLlxuICogVGhlIGFsZ29yaXRobSBjb21lcyBmcm9tOiBQLiBFYWRlcywgWC4gTGluLCBhbmQgVy4gRi4gU215dGgsIFwiQSBmYXN0IGFuZFxuICogZWZmZWN0aXZlIGhldXJpc3RpYyBmb3IgdGhlIGZlZWRiYWNrIGFyYyBzZXQgcHJvYmxlbS5cIiBUaGlzIGltcGxlbWVudGF0aW9uXG4gKiBhZGp1c3RzIHRoYXQgZnJvbSB0aGUgcGFwZXIgdG8gYWxsb3cgZm9yIHdlaWdodGVkIGVkZ2VzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGdyZWVkeUZBUztcblxudmFyIERFRkFVTFRfV0VJR0hUX0ZOID0gXy5jb25zdGFudCgxKTtcblxuZnVuY3Rpb24gZ3JlZWR5RkFTKGcsIHdlaWdodEZuKSB7XG4gIGlmIChnLm5vZGVDb3VudCgpIDw9IDEpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIHN0YXRlID0gYnVpbGRTdGF0ZShnLCB3ZWlnaHRGbiB8fCBERUZBVUxUX1dFSUdIVF9GTik7XG4gIHZhciByZXN1bHRzID0gZG9HcmVlZHlGQVMoc3RhdGUuZ3JhcGgsIHN0YXRlLmJ1Y2tldHMsIHN0YXRlLnplcm9JZHgpO1xuXG4gIC8vIEV4cGFuZCBtdWx0aS1lZGdlc1xuICByZXR1cm4gXy5mbGF0dGVuKF8ubWFwKHJlc3VsdHMsIGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZy5vdXRFZGdlcyhlLnYsIGUudyk7XG4gIH0pLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZG9HcmVlZHlGQVMoZywgYnVja2V0cywgemVyb0lkeCkge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgc291cmNlcyA9IGJ1Y2tldHNbYnVja2V0cy5sZW5ndGggLSAxXTtcbiAgdmFyIHNpbmtzID0gYnVja2V0c1swXTtcblxuICB2YXIgZW50cnk7XG4gIHdoaWxlIChnLm5vZGVDb3VudCgpKSB7XG4gICAgd2hpbGUgKChlbnRyeSA9IHNpbmtzLmRlcXVldWUoKSkpICAgeyByZW1vdmVOb2RlKGcsIGJ1Y2tldHMsIHplcm9JZHgsIGVudHJ5KTsgfVxuICAgIHdoaWxlICgoZW50cnkgPSBzb3VyY2VzLmRlcXVldWUoKSkpIHsgcmVtb3ZlTm9kZShnLCBidWNrZXRzLCB6ZXJvSWR4LCBlbnRyeSk7IH1cbiAgICBpZiAoZy5ub2RlQ291bnQoKSkge1xuICAgICAgZm9yICh2YXIgaSA9IGJ1Y2tldHMubGVuZ3RoIC0gMjsgaSA+IDA7IC0taSkge1xuICAgICAgICBlbnRyeSA9IGJ1Y2tldHNbaV0uZGVxdWV1ZSgpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQocmVtb3ZlTm9kZShnLCBidWNrZXRzLCB6ZXJvSWR4LCBlbnRyeSwgdHJ1ZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUoZywgYnVja2V0cywgemVyb0lkeCwgZW50cnksIGNvbGxlY3RQcmVkZWNlc3NvcnMpIHtcbiAgdmFyIHJlc3VsdHMgPSBjb2xsZWN0UHJlZGVjZXNzb3JzID8gW10gOiB1bmRlZmluZWQ7XG5cbiAgXy5mb3JFYWNoKGcuaW5FZGdlcyhlbnRyeS52KSwgZnVuY3Rpb24oZWRnZSkge1xuICAgIHZhciB3ZWlnaHQgPSBnLmVkZ2UoZWRnZSk7XG4gICAgdmFyIHVFbnRyeSA9IGcubm9kZShlZGdlLnYpO1xuXG4gICAgaWYgKGNvbGxlY3RQcmVkZWNlc3NvcnMpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7IHY6IGVkZ2UudiwgdzogZWRnZS53IH0pO1xuICAgIH1cblxuICAgIHVFbnRyeS5vdXQgLT0gd2VpZ2h0O1xuICAgIGFzc2lnbkJ1Y2tldChidWNrZXRzLCB6ZXJvSWR4LCB1RW50cnkpO1xuICB9KTtcblxuICBfLmZvckVhY2goZy5vdXRFZGdlcyhlbnRyeS52KSwgZnVuY3Rpb24oZWRnZSkge1xuICAgIHZhciB3ZWlnaHQgPSBnLmVkZ2UoZWRnZSk7XG4gICAgdmFyIHcgPSBlZGdlLnc7XG4gICAgdmFyIHdFbnRyeSA9IGcubm9kZSh3KTtcbiAgICB3RW50cnlbXCJpblwiXSAtPSB3ZWlnaHQ7XG4gICAgYXNzaWduQnVja2V0KGJ1Y2tldHMsIHplcm9JZHgsIHdFbnRyeSk7XG4gIH0pO1xuXG4gIGcucmVtb3ZlTm9kZShlbnRyeS52KTtcblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gYnVpbGRTdGF0ZShnLCB3ZWlnaHRGbikge1xuICB2YXIgZmFzR3JhcGggPSBuZXcgR3JhcGgoKTtcbiAgdmFyIG1heEluID0gMDtcbiAgdmFyIG1heE91dCA9IDA7XG5cbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIGZhc0dyYXBoLnNldE5vZGUodiwgeyB2OiB2LCBcImluXCI6IDAsIG91dDogMCB9KTtcbiAgfSk7XG5cbiAgLy8gQWdncmVnYXRlIHdlaWdodHMgb24gbm9kZXMsIGJ1dCBhbHNvIHN1bSB0aGUgd2VpZ2h0cyBhY3Jvc3MgbXVsdGktZWRnZXNcbiAgLy8gaW50byBhIHNpbmdsZSBlZGdlIGZvciB0aGUgZmFzR3JhcGguXG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgcHJldldlaWdodCA9IGZhc0dyYXBoLmVkZ2UoZS52LCBlLncpIHx8IDA7XG4gICAgdmFyIHdlaWdodCA9IHdlaWdodEZuKGUpO1xuICAgIHZhciBlZGdlV2VpZ2h0ID0gcHJldldlaWdodCArIHdlaWdodDtcbiAgICBmYXNHcmFwaC5zZXRFZGdlKGUudiwgZS53LCBlZGdlV2VpZ2h0KTtcbiAgICBtYXhPdXQgPSBNYXRoLm1heChtYXhPdXQsIGZhc0dyYXBoLm5vZGUoZS52KS5vdXQgKz0gd2VpZ2h0KTtcbiAgICBtYXhJbiAgPSBNYXRoLm1heChtYXhJbiwgIGZhc0dyYXBoLm5vZGUoZS53KVtcImluXCJdICArPSB3ZWlnaHQpO1xuICB9KTtcblxuICB2YXIgYnVja2V0cyA9IF8ucmFuZ2UobWF4T3V0ICsgbWF4SW4gKyAzKS5tYXAoZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgTGlzdCgpOyB9KTtcbiAgdmFyIHplcm9JZHggPSBtYXhJbiArIDE7XG5cbiAgXy5mb3JFYWNoKGZhc0dyYXBoLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBhc3NpZ25CdWNrZXQoYnVja2V0cywgemVyb0lkeCwgZmFzR3JhcGgubm9kZSh2KSk7XG4gIH0pO1xuXG4gIHJldHVybiB7IGdyYXBoOiBmYXNHcmFwaCwgYnVja2V0czogYnVja2V0cywgemVyb0lkeDogemVyb0lkeCB9O1xufVxuXG5mdW5jdGlvbiBhc3NpZ25CdWNrZXQoYnVja2V0cywgemVyb0lkeCwgZW50cnkpIHtcbiAgaWYgKCFlbnRyeS5vdXQpIHtcbiAgICBidWNrZXRzWzBdLmVucXVldWUoZW50cnkpO1xuICB9IGVsc2UgaWYgKCFlbnRyeVtcImluXCJdKSB7XG4gICAgYnVja2V0c1tidWNrZXRzLmxlbmd0aCAtIDFdLmVucXVldWUoZW50cnkpO1xuICB9IGVsc2Uge1xuICAgIGJ1Y2tldHNbZW50cnkub3V0IC0gZW50cnlbXCJpblwiXSArIHplcm9JZHhdLmVucXVldWUoZW50cnkpO1xuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sYXlvdXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sYXlvdXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xudmFyIGFjeWNsaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FjeWNsaWMgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2FjeWNsaWMuanNcIik7XG52YXIgbm9ybWFsaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ub3JtYWxpemUgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL25vcm1hbGl6ZS5qc1wiKTtcbnZhciByYW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yYW5rICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9yYW5rL2luZGV4LmpzXCIpO1xudmFyIG5vcm1hbGl6ZVJhbmtzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi91dGlsLmpzXCIpLm5vcm1hbGl6ZVJhbmtzO1xudmFyIHBhcmVudER1bW15Q2hhaW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wYXJlbnQtZHVtbXktY2hhaW5zICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9wYXJlbnQtZHVtbXktY2hhaW5zLmpzXCIpO1xudmFyIHJlbW92ZUVtcHR5UmFua3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3V0aWwuanNcIikucmVtb3ZlRW1wdHlSYW5rcztcbnZhciBuZXN0aW5nR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL25lc3RpbmctZ3JhcGggKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL25lc3RpbmctZ3JhcGguanNcIik7XG52YXIgYWRkQm9yZGVyU2VnbWVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FkZC1ib3JkZXItc2VnbWVudHMgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2FkZC1ib3JkZXItc2VnbWVudHMuanNcIik7XG52YXIgY29vcmRpbmF0ZVN5c3RlbSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29vcmRpbmF0ZS1zeXN0ZW0gKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2Nvb3JkaW5hdGUtc3lzdGVtLmpzXCIpO1xudmFyIG9yZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9vcmRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvaW5kZXguanNcIik7XG52YXIgcG9zaXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Bvc2l0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9wb3NpdGlvbi9pbmRleC5qc1wiKTtcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi91dGlsLmpzXCIpO1xudmFyIEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ncmFwaGxpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvZ3JhcGhsaWIuanNcIikuR3JhcGg7XG5cbm1vZHVsZS5leHBvcnRzID0gbGF5b3V0O1xuXG5mdW5jdGlvbiBsYXlvdXQoZywgb3B0cykge1xuICB2YXIgdGltZSA9IG9wdHMgJiYgb3B0cy5kZWJ1Z1RpbWluZyA/IHV0aWwudGltZSA6IHV0aWwubm90aW1lO1xuICB0aW1lKFwibGF5b3V0XCIsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBsYXlvdXRHcmFwaCA9IFxuICAgICAgdGltZShcIiAgYnVpbGRMYXlvdXRHcmFwaFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGJ1aWxkTGF5b3V0R3JhcGgoZyk7IH0pO1xuICAgIHRpbWUoXCIgIHJ1bkxheW91dFwiLCAgICAgICAgZnVuY3Rpb24oKSB7IHJ1bkxheW91dChsYXlvdXRHcmFwaCwgdGltZSk7IH0pO1xuICAgIHRpbWUoXCIgIHVwZGF0ZUlucHV0R3JhcGhcIiwgZnVuY3Rpb24oKSB7IHVwZGF0ZUlucHV0R3JhcGgoZywgbGF5b3V0R3JhcGgpOyB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJ1bkxheW91dChnLCB0aW1lKSB7XG4gIHRpbWUoXCIgICAgbWFrZVNwYWNlRm9yRWRnZUxhYmVsc1wiLCBmdW5jdGlvbigpIHsgbWFrZVNwYWNlRm9yRWRnZUxhYmVscyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgcmVtb3ZlU2VsZkVkZ2VzXCIsICAgICAgICBmdW5jdGlvbigpIHsgcmVtb3ZlU2VsZkVkZ2VzKGcpOyB9KTtcbiAgdGltZShcIiAgICBhY3ljbGljXCIsICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyBhY3ljbGljLnJ1bihnKTsgfSk7XG4gIHRpbWUoXCIgICAgbmVzdGluZ0dyYXBoLnJ1blwiLCAgICAgICBmdW5jdGlvbigpIHsgbmVzdGluZ0dyYXBoLnJ1bihnKTsgfSk7XG4gIHRpbWUoXCIgICAgcmFua1wiLCAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHsgcmFuayh1dGlsLmFzTm9uQ29tcG91bmRHcmFwaChnKSk7IH0pO1xuICB0aW1lKFwiICAgIGluamVjdEVkZ2VMYWJlbFByb3hpZXNcIiwgZnVuY3Rpb24oKSB7IGluamVjdEVkZ2VMYWJlbFByb3hpZXMoZyk7IH0pO1xuICB0aW1lKFwiICAgIHJlbW92ZUVtcHR5UmFua3NcIiwgICAgICAgZnVuY3Rpb24oKSB7IHJlbW92ZUVtcHR5UmFua3MoZyk7IH0pO1xuICB0aW1lKFwiICAgIG5lc3RpbmdHcmFwaC5jbGVhbnVwXCIsICAgZnVuY3Rpb24oKSB7IG5lc3RpbmdHcmFwaC5jbGVhbnVwKGcpOyB9KTtcbiAgdGltZShcIiAgICBub3JtYWxpemVSYW5rc1wiLCAgICAgICAgIGZ1bmN0aW9uKCkgeyBub3JtYWxpemVSYW5rcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgYXNzaWduUmFua01pbk1heFwiLCAgICAgICBmdW5jdGlvbigpIHsgYXNzaWduUmFua01pbk1heChnKTsgfSk7XG4gIHRpbWUoXCIgICAgcmVtb3ZlRWRnZUxhYmVsUHJveGllc1wiLCBmdW5jdGlvbigpIHsgcmVtb3ZlRWRnZUxhYmVsUHJveGllcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgbm9ybWFsaXplLnJ1blwiLCAgICAgICAgICBmdW5jdGlvbigpIHsgbm9ybWFsaXplLnJ1bihnKTsgfSk7XG4gIHRpbWUoXCIgICAgcGFyZW50RHVtbXlDaGFpbnNcIiwgICAgICBmdW5jdGlvbigpIHsgcGFyZW50RHVtbXlDaGFpbnMoZyk7IH0pO1xuICB0aW1lKFwiICAgIGFkZEJvcmRlclNlZ21lbnRzXCIsICAgICAgZnVuY3Rpb24oKSB7IGFkZEJvcmRlclNlZ21lbnRzKGcpOyB9KTtcbiAgdGltZShcIiAgICBvcmRlclwiLCAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyBvcmRlcihnKTsgfSk7XG4gIHRpbWUoXCIgICAgaW5zZXJ0U2VsZkVkZ2VzXCIsICAgICAgICBmdW5jdGlvbigpIHsgaW5zZXJ0U2VsZkVkZ2VzKGcpOyB9KTtcbiAgdGltZShcIiAgICBhZGp1c3RDb29yZGluYXRlU3lzdGVtXCIsIGZ1bmN0aW9uKCkgeyBjb29yZGluYXRlU3lzdGVtLmFkanVzdChnKTsgfSk7XG4gIHRpbWUoXCIgICAgcG9zaXRpb25cIiwgICAgICAgICAgICAgICBmdW5jdGlvbigpIHsgcG9zaXRpb24oZyk7IH0pO1xuICB0aW1lKFwiICAgIHBvc2l0aW9uU2VsZkVkZ2VzXCIsICAgICAgZnVuY3Rpb24oKSB7IHBvc2l0aW9uU2VsZkVkZ2VzKGcpOyB9KTtcbiAgdGltZShcIiAgICByZW1vdmVCb3JkZXJOb2Rlc1wiLCAgICAgIGZ1bmN0aW9uKCkgeyByZW1vdmVCb3JkZXJOb2RlcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgbm9ybWFsaXplLnVuZG9cIiwgICAgICAgICBmdW5jdGlvbigpIHsgbm9ybWFsaXplLnVuZG8oZyk7IH0pO1xuICB0aW1lKFwiICAgIGZpeHVwRWRnZUxhYmVsQ29vcmRzXCIsICAgZnVuY3Rpb24oKSB7IGZpeHVwRWRnZUxhYmVsQ29vcmRzKGcpOyB9KTtcbiAgdGltZShcIiAgICB1bmRvQ29vcmRpbmF0ZVN5c3RlbVwiLCAgIGZ1bmN0aW9uKCkgeyBjb29yZGluYXRlU3lzdGVtLnVuZG8oZyk7IH0pO1xuICB0aW1lKFwiICAgIHRyYW5zbGF0ZUdyYXBoXCIsICAgICAgICAgZnVuY3Rpb24oKSB7IHRyYW5zbGF0ZUdyYXBoKGcpOyB9KTtcbiAgdGltZShcIiAgICBhc3NpZ25Ob2RlSW50ZXJzZWN0c1wiLCAgIGZ1bmN0aW9uKCkgeyBhc3NpZ25Ob2RlSW50ZXJzZWN0cyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgcmV2ZXJzZVBvaW50c1wiLCAgICAgICAgICBmdW5jdGlvbigpIHsgcmV2ZXJzZVBvaW50c0ZvclJldmVyc2VkRWRnZXMoZyk7IH0pO1xuICB0aW1lKFwiICAgIGFjeWNsaWMudW5kb1wiLCAgICAgICAgICAgZnVuY3Rpb24oKSB7IGFjeWNsaWMudW5kbyhnKTsgfSk7XG59XG5cbi8qXG4gKiBDb3BpZXMgZmluYWwgbGF5b3V0IGluZm9ybWF0aW9uIGZyb20gdGhlIGxheW91dCBncmFwaCBiYWNrIHRvIHRoZSBpbnB1dFxuICogZ3JhcGguIFRoaXMgcHJvY2VzcyBvbmx5IGNvcGllcyB3aGl0ZWxpc3RlZCBhdHRyaWJ1dGVzIGZyb20gdGhlIGxheW91dCBncmFwaFxuICogdG8gdGhlIGlucHV0IGdyYXBoLCBzbyBpdCBzZXJ2ZXMgYXMgYSBnb29kIHBsYWNlIHRvIGRldGVybWluZSB3aGF0XG4gKiBhdHRyaWJ1dGVzIGNhbiBpbmZsdWVuY2UgbGF5b3V0LlxuICovXG5mdW5jdGlvbiB1cGRhdGVJbnB1dEdyYXBoKGlucHV0R3JhcGgsIGxheW91dEdyYXBoKSB7XG4gIF8uZm9yRWFjaChpbnB1dEdyYXBoLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgaW5wdXRMYWJlbCA9IGlucHV0R3JhcGgubm9kZSh2KTtcbiAgICB2YXIgbGF5b3V0TGFiZWwgPSBsYXlvdXRHcmFwaC5ub2RlKHYpO1xuXG4gICAgaWYgKGlucHV0TGFiZWwpIHtcbiAgICAgIGlucHV0TGFiZWwueCA9IGxheW91dExhYmVsLng7XG4gICAgICBpbnB1dExhYmVsLnkgPSBsYXlvdXRMYWJlbC55O1xuXG4gICAgICBpZiAobGF5b3V0R3JhcGguY2hpbGRyZW4odikubGVuZ3RoKSB7XG4gICAgICAgIGlucHV0TGFiZWwud2lkdGggPSBsYXlvdXRMYWJlbC53aWR0aDtcbiAgICAgICAgaW5wdXRMYWJlbC5oZWlnaHQgPSBsYXlvdXRMYWJlbC5oZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBfLmZvckVhY2goaW5wdXRHcmFwaC5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGlucHV0TGFiZWwgPSBpbnB1dEdyYXBoLmVkZ2UoZSk7XG4gICAgdmFyIGxheW91dExhYmVsID0gbGF5b3V0R3JhcGguZWRnZShlKTtcblxuICAgIGlucHV0TGFiZWwucG9pbnRzID0gbGF5b3V0TGFiZWwucG9pbnRzO1xuICAgIGlmIChfLmhhcyhsYXlvdXRMYWJlbCwgXCJ4XCIpKSB7XG4gICAgICBpbnB1dExhYmVsLnggPSBsYXlvdXRMYWJlbC54O1xuICAgICAgaW5wdXRMYWJlbC55ID0gbGF5b3V0TGFiZWwueTtcbiAgICB9XG4gIH0pO1xuXG4gIGlucHV0R3JhcGguZ3JhcGgoKS53aWR0aCA9IGxheW91dEdyYXBoLmdyYXBoKCkud2lkdGg7XG4gIGlucHV0R3JhcGguZ3JhcGgoKS5oZWlnaHQgPSBsYXlvdXRHcmFwaC5ncmFwaCgpLmhlaWdodDtcbn1cblxudmFyIGdyYXBoTnVtQXR0cnMgPSBbXCJub2Rlc2VwXCIsIFwiZWRnZXNlcFwiLCBcInJhbmtzZXBcIiwgXCJtYXJnaW54XCIsIFwibWFyZ2lueVwiXTtcbnZhciBncmFwaERlZmF1bHRzID0geyByYW5rc2VwOiA1MCwgZWRnZXNlcDogMjAsIG5vZGVzZXA6IDUwLCByYW5rZGlyOiBcInRiXCIgfTtcbnZhciBncmFwaEF0dHJzID0gW1wiYWN5Y2xpY2VyXCIsIFwicmFua2VyXCIsIFwicmFua2RpclwiLCBcImFsaWduXCJdO1xudmFyIG5vZGVOdW1BdHRycyA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdO1xudmFyIG5vZGVEZWZhdWx0cyA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xudmFyIGVkZ2VOdW1BdHRycyA9IFtcIm1pbmxlblwiLCBcIndlaWdodFwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwibGFiZWxvZmZzZXRcIl07XG52YXIgZWRnZURlZmF1bHRzID0ge1xuICBtaW5sZW46IDEsIHdlaWdodDogMSwgd2lkdGg6IDAsIGhlaWdodDogMCxcbiAgbGFiZWxvZmZzZXQ6IDEwLCBsYWJlbHBvczogXCJyXCJcbn07XG52YXIgZWRnZUF0dHJzID0gW1wibGFiZWxwb3NcIl07XG5cbi8qXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGdyYXBoIGZyb20gdGhlIGlucHV0IGdyYXBoLCB3aGljaCBjYW4gYmUgdXNlZCBmb3IgbGF5b3V0LlxuICogVGhpcyBwcm9jZXNzIGNvcGllcyBvbmx5IHdoaXRlbGlzdGVkIGF0dHJpYnV0ZXMgZnJvbSB0aGUgaW5wdXQgZ3JhcGggdG8gdGhlXG4gKiBsYXlvdXQgZ3JhcGguIFRodXMgdGhpcyBmdW5jdGlvbiBzZXJ2ZXMgYXMgYSBnb29kIHBsYWNlIHRvIGRldGVybWluZSB3aGF0XG4gKiBhdHRyaWJ1dGVzIGNhbiBpbmZsdWVuY2UgbGF5b3V0LlxuICovXG5mdW5jdGlvbiBidWlsZExheW91dEdyYXBoKGlucHV0R3JhcGgpIHtcbiAgdmFyIGcgPSBuZXcgR3JhcGgoeyBtdWx0aWdyYXBoOiB0cnVlLCBjb21wb3VuZDogdHJ1ZSB9KTtcbiAgdmFyIGdyYXBoID0gY2Fub25pY2FsaXplKGlucHV0R3JhcGguZ3JhcGgoKSk7XG5cbiAgZy5zZXRHcmFwaChfLm1lcmdlKHt9LFxuICAgIGdyYXBoRGVmYXVsdHMsXG4gICAgc2VsZWN0TnVtYmVyQXR0cnMoZ3JhcGgsIGdyYXBoTnVtQXR0cnMpLFxuICAgIF8ucGljayhncmFwaCwgZ3JhcGhBdHRycykpKTtcblxuICBfLmZvckVhY2goaW5wdXRHcmFwaC5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBjYW5vbmljYWxpemUoaW5wdXRHcmFwaC5ub2RlKHYpKTtcbiAgICBnLnNldE5vZGUodiwgXy5kZWZhdWx0cyhzZWxlY3ROdW1iZXJBdHRycyhub2RlLCBub2RlTnVtQXR0cnMpLCBub2RlRGVmYXVsdHMpKTtcbiAgICBnLnNldFBhcmVudCh2LCBpbnB1dEdyYXBoLnBhcmVudCh2KSk7XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChpbnB1dEdyYXBoLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGNhbm9uaWNhbGl6ZShpbnB1dEdyYXBoLmVkZ2UoZSkpO1xuICAgIGcuc2V0RWRnZShlLCBfLm1lcmdlKHt9LFxuICAgICAgZWRnZURlZmF1bHRzLFxuICAgICAgc2VsZWN0TnVtYmVyQXR0cnMoZWRnZSwgZWRnZU51bUF0dHJzKSxcbiAgICAgIF8ucGljayhlZGdlLCBlZGdlQXR0cnMpKSk7XG4gIH0pO1xuXG4gIHJldHVybiBnO1xufVxuXG4vKlxuICogVGhpcyBpZGVhIGNvbWVzIGZyb20gdGhlIEdhbnNuZXIgcGFwZXI6IHRvIGFjY291bnQgZm9yIGVkZ2UgbGFiZWxzIGluIG91clxuICogbGF5b3V0IHdlIHNwbGl0IGVhY2ggcmFuayBpbiBoYWxmIGJ5IGRvdWJsaW5nIG1pbmxlbiBhbmQgaGFsdmluZyByYW5rc2VwLlxuICogVGhlbiB3ZSBjYW4gcGxhY2UgbGFiZWxzIGF0IHRoZXNlIG1pZC1wb2ludHMgYmV0d2VlbiBub2Rlcy5cbiAqXG4gKiBXZSBhbHNvIGFkZCBzb21lIG1pbmltYWwgcGFkZGluZyB0byB0aGUgd2lkdGggdG8gcHVzaCB0aGUgbGFiZWwgZm9yIHRoZSBlZGdlXG4gKiBhd2F5IGZyb20gdGhlIGVkZ2UgaXRzZWxmIGEgYml0LlxuICovXG5mdW5jdGlvbiBtYWtlU3BhY2VGb3JFZGdlTGFiZWxzKGcpIHtcbiAgdmFyIGdyYXBoID0gZy5ncmFwaCgpO1xuICBncmFwaC5yYW5rc2VwIC89IDI7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBlZGdlLm1pbmxlbiAqPSAyO1xuICAgIGlmIChlZGdlLmxhYmVscG9zLnRvTG93ZXJDYXNlKCkgIT09IFwiY1wiKSB7XG4gICAgICBpZiAoZ3JhcGgucmFua2RpciA9PT0gXCJUQlwiIHx8IGdyYXBoLnJhbmtkaXIgPT09IFwiQlRcIikge1xuICAgICAgICBlZGdlLndpZHRoICs9IGVkZ2UubGFiZWxvZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGdlLmhlaWdodCArPSBlZGdlLmxhYmVsb2Zmc2V0O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8qXG4gKiBDcmVhdGVzIHRlbXBvcmFyeSBkdW1teSBub2RlcyB0aGF0IGNhcHR1cmUgdGhlIHJhbmsgaW4gd2hpY2ggZWFjaCBlZGdlJ3NcbiAqIGxhYmVsIGlzIGdvaW5nIHRvLCBpZiBpdCBoYXMgb25lIG9mIG5vbi16ZXJvIHdpZHRoIGFuZCBoZWlnaHQuIFdlIGRvIHRoaXNcbiAqIHNvIHRoYXQgd2UgY2FuIHNhZmVseSByZW1vdmUgZW1wdHkgcmFua3Mgd2hpbGUgcHJlc2VydmluZyBiYWxhbmNlIGZvciB0aGVcbiAqIGxhYmVsJ3MgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGluamVjdEVkZ2VMYWJlbFByb3hpZXMoZykge1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgaWYgKGVkZ2Uud2lkdGggJiYgZWRnZS5oZWlnaHQpIHtcbiAgICAgIHZhciB2ID0gZy5ub2RlKGUudik7XG4gICAgICB2YXIgdyA9IGcubm9kZShlLncpO1xuICAgICAgdmFyIGxhYmVsID0geyByYW5rOiAody5yYW5rIC0gdi5yYW5rKSAvIDIgKyB2LnJhbmssIGU6IGUgfTtcbiAgICAgIHV0aWwuYWRkRHVtbXlOb2RlKGcsIFwiZWRnZS1wcm94eVwiLCBsYWJlbCwgXCJfZXBcIik7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYXNzaWduUmFua01pbk1heChnKSB7XG4gIHZhciBtYXhSYW5rID0gMDtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIGlmIChub2RlLmJvcmRlclRvcCkge1xuICAgICAgbm9kZS5taW5SYW5rID0gZy5ub2RlKG5vZGUuYm9yZGVyVG9wKS5yYW5rO1xuICAgICAgbm9kZS5tYXhSYW5rID0gZy5ub2RlKG5vZGUuYm9yZGVyQm90dG9tKS5yYW5rO1xuICAgICAgbWF4UmFuayA9IF8ubWF4KG1heFJhbmssIG5vZGUubWF4UmFuayk7XG4gICAgfVxuICB9KTtcbiAgZy5ncmFwaCgpLm1heFJhbmsgPSBtYXhSYW5rO1xufVxuXG5mdW5jdGlvbiByZW1vdmVFZGdlTGFiZWxQcm94aWVzKGcpIHtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIGlmIChub2RlLmR1bW15ID09PSBcImVkZ2UtcHJveHlcIikge1xuICAgICAgZy5lZGdlKG5vZGUuZSkubGFiZWxSYW5rID0gbm9kZS5yYW5rO1xuICAgICAgZy5yZW1vdmVOb2RlKHYpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUdyYXBoKGcpIHtcbiAgdmFyIG1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIHZhciBtYXhYID0gMDtcbiAgdmFyIG1pblkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIHZhciBtYXhZID0gMDtcbiAgdmFyIGdyYXBoTGFiZWwgPSBnLmdyYXBoKCk7XG4gIHZhciBtYXJnaW5YID0gZ3JhcGhMYWJlbC5tYXJnaW54IHx8IDA7XG4gIHZhciBtYXJnaW5ZID0gZ3JhcGhMYWJlbC5tYXJnaW55IHx8IDA7XG5cbiAgZnVuY3Rpb24gZ2V0RXh0cmVtZXMoYXR0cnMpIHtcbiAgICB2YXIgeCA9IGF0dHJzLng7XG4gICAgdmFyIHkgPSBhdHRycy55O1xuICAgIHZhciB3ID0gYXR0cnMud2lkdGg7XG4gICAgdmFyIGggPSBhdHRycy5oZWlnaHQ7XG4gICAgbWluWCA9IE1hdGgubWluKG1pblgsIHggLSB3IC8gMik7XG4gICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHggKyB3IC8gMik7XG4gICAgbWluWSA9IE1hdGgubWluKG1pblksIHkgLSBoIC8gMik7XG4gICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkgKyBoIC8gMik7XG4gIH1cblxuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7IGdldEV4dHJlbWVzKGcubm9kZSh2KSk7IH0pO1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgaWYgKF8uaGFzKGVkZ2UsIFwieFwiKSkge1xuICAgICAgZ2V0RXh0cmVtZXMoZWRnZSk7XG4gICAgfVxuICB9KTtcblxuICBtaW5YIC09IG1hcmdpblg7XG4gIG1pblkgLT0gbWFyZ2luWTtcblxuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgbm9kZS54IC09IG1pblg7XG4gICAgbm9kZS55IC09IG1pblk7XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBfLmZvckVhY2goZWRnZS5wb2ludHMsIGZ1bmN0aW9uKHApIHtcbiAgICAgIHAueCAtPSBtaW5YO1xuICAgICAgcC55IC09IG1pblk7XG4gICAgfSk7XG4gICAgaWYgKF8uaGFzKGVkZ2UsIFwieFwiKSkgeyBlZGdlLnggLT0gbWluWDsgfVxuICAgIGlmIChfLmhhcyhlZGdlLCBcInlcIikpIHsgZWRnZS55IC09IG1pblk7IH1cbiAgfSk7XG5cbiAgZ3JhcGhMYWJlbC53aWR0aCA9IG1heFggLSBtaW5YICsgbWFyZ2luWDtcbiAgZ3JhcGhMYWJlbC5oZWlnaHQgPSBtYXhZIC0gbWluWSArIG1hcmdpblk7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbk5vZGVJbnRlcnNlY3RzKGcpIHtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIHZhciBub2RlViA9IGcubm9kZShlLnYpO1xuICAgIHZhciBub2RlVyA9IGcubm9kZShlLncpO1xuICAgIHZhciBwMSwgcDI7XG4gICAgaWYgKCFlZGdlLnBvaW50cykge1xuICAgICAgZWRnZS5wb2ludHMgPSBbXTtcbiAgICAgIHAxID0gbm9kZVc7XG4gICAgICBwMiA9IG5vZGVWO1xuICAgIH0gZWxzZSB7XG4gICAgICBwMSA9IGVkZ2UucG9pbnRzWzBdO1xuICAgICAgcDIgPSBlZGdlLnBvaW50c1tlZGdlLnBvaW50cy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgZWRnZS5wb2ludHMudW5zaGlmdCh1dGlsLmludGVyc2VjdFJlY3Qobm9kZVYsIHAxKSk7XG4gICAgZWRnZS5wb2ludHMucHVzaCh1dGlsLmludGVyc2VjdFJlY3Qobm9kZVcsIHAyKSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmaXh1cEVkZ2VMYWJlbENvb3JkcyhnKSB7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBpZiAoXy5oYXMoZWRnZSwgXCJ4XCIpKSB7XG4gICAgICBpZiAoZWRnZS5sYWJlbHBvcyA9PT0gXCJsXCIgfHwgZWRnZS5sYWJlbHBvcyA9PT0gXCJyXCIpIHtcbiAgICAgICAgZWRnZS53aWR0aCAtPSBlZGdlLmxhYmVsb2Zmc2V0O1xuICAgICAgfVxuICAgICAgc3dpdGNoIChlZGdlLmxhYmVscG9zKSB7XG4gICAgICBjYXNlIFwibFwiOiBlZGdlLnggLT0gZWRnZS53aWR0aCAvIDIgKyBlZGdlLmxhYmVsb2Zmc2V0OyBicmVhaztcbiAgICAgIGNhc2UgXCJyXCI6IGVkZ2UueCArPSBlZGdlLndpZHRoIC8gMiArIGVkZ2UubGFiZWxvZmZzZXQ7IGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJldmVyc2VQb2ludHNGb3JSZXZlcnNlZEVkZ2VzKGcpIHtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIGlmIChlZGdlLnJldmVyc2VkKSB7XG4gICAgICBlZGdlLnBvaW50cy5yZXZlcnNlKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQm9yZGVyTm9kZXMoZykge1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgaWYgKGcuY2hpbGRyZW4odikubGVuZ3RoKSB7XG4gICAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICAgIHZhciB0ID0gZy5ub2RlKG5vZGUuYm9yZGVyVG9wKTtcbiAgICAgIHZhciBiID0gZy5ub2RlKG5vZGUuYm9yZGVyQm90dG9tKTtcbiAgICAgIHZhciBsID0gZy5ub2RlKF8ubGFzdChub2RlLmJvcmRlckxlZnQpKTtcbiAgICAgIHZhciByID0gZy5ub2RlKF8ubGFzdChub2RlLmJvcmRlclJpZ2h0KSk7XG5cbiAgICAgIG5vZGUud2lkdGggPSBNYXRoLmFicyhyLnggLSBsLngpO1xuICAgICAgbm9kZS5oZWlnaHQgPSBNYXRoLmFicyhiLnkgLSB0LnkpO1xuICAgICAgbm9kZS54ID0gbC54ICsgbm9kZS53aWR0aCAvIDI7XG4gICAgICBub2RlLnkgPSB0LnkgKyBub2RlLmhlaWdodCAvIDI7XG4gICAgfVxuICB9KTtcblxuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgaWYgKGcubm9kZSh2KS5kdW1teSA9PT0gXCJib3JkZXJcIikge1xuICAgICAgZy5yZW1vdmVOb2RlKHYpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNlbGZFZGdlcyhnKSB7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS52ID09PSBlLncpIHtcbiAgICAgIHZhciBub2RlID0gZy5ub2RlKGUudik7XG4gICAgICBpZiAoIW5vZGUuc2VsZkVkZ2VzKSB7XG4gICAgICAgIG5vZGUuc2VsZkVkZ2VzID0gW107XG4gICAgICB9XG4gICAgICBub2RlLnNlbGZFZGdlcy5wdXNoKHsgZTogZSwgbGFiZWw6IGcuZWRnZShlKSB9KTtcbiAgICAgIGcucmVtb3ZlRWRnZShlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTZWxmRWRnZXMoZykge1xuICB2YXIgbGF5ZXJzID0gdXRpbC5idWlsZExheWVyTWF0cml4KGcpO1xuICBfLmZvckVhY2gobGF5ZXJzLCBmdW5jdGlvbihsYXllcikge1xuICAgIHZhciBvcmRlclNoaWZ0ID0gMDtcbiAgICBfLmZvckVhY2gobGF5ZXIsIGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgICAgbm9kZS5vcmRlciA9IGkgKyBvcmRlclNoaWZ0O1xuICAgICAgXy5mb3JFYWNoKG5vZGUuc2VsZkVkZ2VzLCBmdW5jdGlvbihzZWxmRWRnZSkge1xuICAgICAgICB1dGlsLmFkZER1bW15Tm9kZShnLCBcInNlbGZlZGdlXCIsIHtcbiAgICAgICAgICB3aWR0aDogc2VsZkVkZ2UubGFiZWwud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBzZWxmRWRnZS5sYWJlbC5oZWlnaHQsXG4gICAgICAgICAgcmFuazogbm9kZS5yYW5rLFxuICAgICAgICAgIG9yZGVyOiBpICsgKCsrb3JkZXJTaGlmdCksXG4gICAgICAgICAgZTogc2VsZkVkZ2UuZSxcbiAgICAgICAgICBsYWJlbDogc2VsZkVkZ2UubGFiZWxcbiAgICAgICAgfSwgXCJfc2VcIik7XG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSBub2RlLnNlbGZFZGdlcztcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBvc2l0aW9uU2VsZkVkZ2VzKGcpIHtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIGlmIChub2RlLmR1bW15ID09PSBcInNlbGZlZGdlXCIpIHtcbiAgICAgIHZhciBzZWxmTm9kZSA9IGcubm9kZShub2RlLmUudik7XG4gICAgICB2YXIgeCA9IHNlbGZOb2RlLnggKyBzZWxmTm9kZS53aWR0aCAvIDI7XG4gICAgICB2YXIgeSA9IHNlbGZOb2RlLnk7XG4gICAgICB2YXIgZHggPSBub2RlLnggLSB4O1xuICAgICAgdmFyIGR5ID0gc2VsZk5vZGUuaGVpZ2h0IC8gMjtcbiAgICAgIGcuc2V0RWRnZShub2RlLmUsIG5vZGUubGFiZWwpO1xuICAgICAgZy5yZW1vdmVOb2RlKHYpO1xuICAgICAgbm9kZS5sYWJlbC5wb2ludHMgPSBbXG4gICAgICAgIHsgeDogeCArIDIgKiBkeCAvIDMsIHk6IHkgLSBkeSB9LFxuICAgICAgICB7IHg6IHggKyA1ICogZHggLyA2LCB5OiB5IC0gZHkgfSxcbiAgICAgICAgeyB4OiB4ICsgICAgIGR4ICAgICwgeTogeSB9LFxuICAgICAgICB7IHg6IHggKyA1ICogZHggLyA2LCB5OiB5ICsgZHkgfSxcbiAgICAgICAgeyB4OiB4ICsgMiAqIGR4IC8gMywgeTogeSArIGR5IH1cbiAgICAgIF07XG4gICAgICBub2RlLmxhYmVsLnggPSBub2RlLng7XG4gICAgICBub2RlLmxhYmVsLnkgPSBub2RlLnk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0TnVtYmVyQXR0cnMob2JqLCBhdHRycykge1xuICByZXR1cm4gXy5tYXBWYWx1ZXMoXy5waWNrKG9iaiwgYXR0cnMpLCBOdW1iZXIpO1xufVxuXG5mdW5jdGlvbiBjYW5vbmljYWxpemUoYXR0cnMpIHtcbiAgdmFyIG5ld0F0dHJzID0ge307XG4gIF8uZm9yRWFjaChhdHRycywgZnVuY3Rpb24odiwgaykge1xuICAgIG5ld0F0dHJzW2sudG9Mb3dlckNhc2UoKV0gPSB2O1xuICB9KTtcbiAgcmV0dXJuIG5ld0F0dHJzO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cblxudmFyIGxvZGFzaDtcblxuaWYgKHRydWUpIHtcbiAgdHJ5IHtcbiAgICBsb2Rhc2ggPSB7XG4gICAgICBjbG9uZURlZXA6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9jbG9uZURlZXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2Nsb25lRGVlcC5qc1wiKSxcbiAgICAgIGNvbnN0YW50OiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvY29uc3RhbnQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2NvbnN0YW50LmpzXCIpLFxuICAgICAgZGVmYXVsdHM6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9kZWZhdWx0cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZGVmYXVsdHMuanNcIiksXG4gICAgICBlYWNoOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvZWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZWFjaC5qc1wiKSxcbiAgICAgIGZpbHRlcjogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL2ZpbHRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZmlsdGVyLmpzXCIpLFxuICAgICAgZmluZDogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL2ZpbmQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2ZpbmQuanNcIiksXG4gICAgICBmbGF0dGVuOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvZmxhdHRlbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZmxhdHRlbi5qc1wiKSxcbiAgICAgIGZvckVhY2g6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9mb3JFYWNoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9mb3JFYWNoLmpzXCIpLFxuICAgICAgZm9ySW46IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9mb3JJbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZm9ySW4uanNcIiksXG4gICAgICBoYXM6ICBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9oYXMuanNcIiksXG4gICAgICBpc1VuZGVmaW5lZDogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL2lzVW5kZWZpbmVkICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1VuZGVmaW5lZC5qc1wiKSxcbiAgICAgIGxhc3Q6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9sYXN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9sYXN0LmpzXCIpLFxuICAgICAgbWFwOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvbWFwICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9tYXAuanNcIiksXG4gICAgICBtYXBWYWx1ZXM6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9tYXBWYWx1ZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL21hcFZhbHVlcy5qc1wiKSxcbiAgICAgIG1heDogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL21heCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbWF4LmpzXCIpLFxuICAgICAgbWVyZ2U6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9tZXJnZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbWVyZ2UuanNcIiksXG4gICAgICBtaW46IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9taW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL21pbi5qc1wiKSxcbiAgICAgIG1pbkJ5OiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvbWluQnkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL21pbkJ5LmpzXCIpLFxuICAgICAgbm93OiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvbm93ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9ub3cuanNcIiksXG4gICAgICBwaWNrOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvcGljayAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvcGljay5qc1wiKSxcbiAgICAgIHJhbmdlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvcmFuZ2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3JhbmdlLmpzXCIpLFxuICAgICAgcmVkdWNlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvcmVkdWNlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9yZWR1Y2UuanNcIiksXG4gICAgICBzb3J0Qnk6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9zb3J0QnkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3NvcnRCeS5qc1wiKSxcbiAgICAgIHVuaXF1ZUlkOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvdW5pcXVlSWQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3VuaXF1ZUlkLmpzXCIpLFxuICAgICAgdmFsdWVzOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvdmFsdWVzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC92YWx1ZXMuanNcIiksXG4gICAgICB6aXBPYmplY3Q6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC96aXBPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3ppcE9iamVjdC5qc1wiKSxcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICB9XG59XG5cbmlmICghbG9kYXNoKSB7XG4gIGxvZGFzaCA9IHdpbmRvdy5fO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZGFzaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL25lc3RpbmctZ3JhcGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbmVzdGluZy1ncmFwaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3V0aWwuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBydW46IHJ1bixcbiAgY2xlYW51cDogY2xlYW51cFxufTtcblxuLypcbiAqIEEgbmVzdGluZyBncmFwaCBjcmVhdGVzIGR1bW15IG5vZGVzIGZvciB0aGUgdG9wcyBhbmQgYm90dG9tcyBvZiBzdWJncmFwaHMsXG4gKiBhZGRzIGFwcHJvcHJpYXRlIGVkZ2VzIHRvIGVuc3VyZSB0aGF0IGFsbCBjbHVzdGVyIG5vZGVzIGFyZSBwbGFjZWQgYmV0d2VlblxuICogdGhlc2UgYm91bmRyaWVzLCBhbmQgZW5zdXJlcyB0aGF0IHRoZSBncmFwaCBpcyBjb25uZWN0ZWQuXG4gKlxuICogSW4gYWRkaXRpb24gd2UgZW5zdXJlLCB0aHJvdWdoIHRoZSB1c2Ugb2YgdGhlIG1pbmxlbiBwcm9wZXJ0eSwgdGhhdCBub2Rlc1xuICogYW5kIHN1YmdyYXBoIGJvcmRlciBub2RlcyB0byBub3QgZW5kIHVwIG9uIHRoZSBzYW1lIHJhbmsuXG4gKlxuICogUHJlY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBJbnB1dCBncmFwaCBpcyBhIERBR1xuICogICAgMi4gTm9kZXMgaW4gdGhlIGlucHV0IGdyYXBoIGhhcyBhIG1pbmxlbiBhdHRyaWJ1dGVcbiAqXG4gKiBQb3N0Y29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBJbnB1dCBncmFwaCBpcyBjb25uZWN0ZWQuXG4gKiAgICAyLiBEdW1teSBub2RlcyBhcmUgYWRkZWQgZm9yIHRoZSB0b3BzIGFuZCBib3R0b21zIG9mIHN1YmdyYXBocy5cbiAqICAgIDMuIFRoZSBtaW5sZW4gYXR0cmlidXRlIGZvciBub2RlcyBpcyBhZGp1c3RlZCB0byBlbnN1cmUgbm9kZXMgZG8gbm90XG4gKiAgICAgICBnZXQgcGxhY2VkIG9uIHRoZSBzYW1lIHJhbmsgYXMgc3ViZ3JhcGggYm9yZGVyIG5vZGVzLlxuICpcbiAqIFRoZSBuZXN0aW5nIGdyYXBoIGlkZWEgY29tZXMgZnJvbSBTYW5kZXIsIFwiTGF5b3V0IG9mIENvbXBvdW5kIERpcmVjdGVkXG4gKiBHcmFwaHMuXCJcbiAqL1xuZnVuY3Rpb24gcnVuKGcpIHtcbiAgdmFyIHJvb3QgPSB1dGlsLmFkZER1bW15Tm9kZShnLCBcInJvb3RcIiwge30sIFwiX3Jvb3RcIik7XG4gIHZhciBkZXB0aHMgPSB0cmVlRGVwdGhzKGcpO1xuICB2YXIgaGVpZ2h0ID0gXy5tYXgoXy52YWx1ZXMoZGVwdGhzKSkgLSAxOyAvLyBOb3RlOiBkZXB0aHMgaXMgYW4gT2JqZWN0IG5vdCBhbiBhcnJheVxuICB2YXIgbm9kZVNlcCA9IDIgKiBoZWlnaHQgKyAxO1xuXG4gIGcuZ3JhcGgoKS5uZXN0aW5nUm9vdCA9IHJvb3Q7XG5cbiAgLy8gTXVsdGlwbHkgbWlubGVuIGJ5IG5vZGVTZXAgdG8gYWxpZ24gbm9kZXMgb24gbm9uLWJvcmRlciByYW5rcy5cbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkgeyBnLmVkZ2UoZSkubWlubGVuICo9IG5vZGVTZXA7IH0pO1xuXG4gIC8vIENhbGN1bGF0ZSBhIHdlaWdodCB0aGF0IGlzIHN1ZmZpY2llbnQgdG8ga2VlcCBzdWJncmFwaHMgdmVydGljYWxseSBjb21wYWN0XG4gIHZhciB3ZWlnaHQgPSBzdW1XZWlnaHRzKGcpICsgMTtcblxuICAvLyBDcmVhdGUgYm9yZGVyIG5vZGVzIGFuZCBsaW5rIHRoZW0gdXBcbiAgXy5mb3JFYWNoKGcuY2hpbGRyZW4oKSwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICBkZnMoZywgcm9vdCwgbm9kZVNlcCwgd2VpZ2h0LCBoZWlnaHQsIGRlcHRocywgY2hpbGQpO1xuICB9KTtcblxuICAvLyBTYXZlIHRoZSBtdWx0aXBsaWVyIGZvciBub2RlIGxheWVycyBmb3IgbGF0ZXIgcmVtb3ZhbCBvZiBlbXB0eSBib3JkZXJcbiAgLy8gbGF5ZXJzLlxuICBnLmdyYXBoKCkubm9kZVJhbmtGYWN0b3IgPSBub2RlU2VwO1xufVxuXG5mdW5jdGlvbiBkZnMoZywgcm9vdCwgbm9kZVNlcCwgd2VpZ2h0LCBoZWlnaHQsIGRlcHRocywgdikge1xuICB2YXIgY2hpbGRyZW4gPSBnLmNoaWxkcmVuKHYpO1xuICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGlmICh2ICE9PSByb290KSB7XG4gICAgICBnLnNldEVkZ2Uocm9vdCwgdiwgeyB3ZWlnaHQ6IDAsIG1pbmxlbjogbm9kZVNlcCB9KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRvcCA9IHV0aWwuYWRkQm9yZGVyTm9kZShnLCBcIl9idFwiKTtcbiAgdmFyIGJvdHRvbSA9IHV0aWwuYWRkQm9yZGVyTm9kZShnLCBcIl9iYlwiKTtcbiAgdmFyIGxhYmVsID0gZy5ub2RlKHYpO1xuXG4gIGcuc2V0UGFyZW50KHRvcCwgdik7XG4gIGxhYmVsLmJvcmRlclRvcCA9IHRvcDtcbiAgZy5zZXRQYXJlbnQoYm90dG9tLCB2KTtcbiAgbGFiZWwuYm9yZGVyQm90dG9tID0gYm90dG9tO1xuXG4gIF8uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICBkZnMoZywgcm9vdCwgbm9kZVNlcCwgd2VpZ2h0LCBoZWlnaHQsIGRlcHRocywgY2hpbGQpO1xuXG4gICAgdmFyIGNoaWxkTm9kZSA9IGcubm9kZShjaGlsZCk7XG4gICAgdmFyIGNoaWxkVG9wID0gY2hpbGROb2RlLmJvcmRlclRvcCA/IGNoaWxkTm9kZS5ib3JkZXJUb3AgOiBjaGlsZDtcbiAgICB2YXIgY2hpbGRCb3R0b20gPSBjaGlsZE5vZGUuYm9yZGVyQm90dG9tID8gY2hpbGROb2RlLmJvcmRlckJvdHRvbSA6IGNoaWxkO1xuICAgIHZhciB0aGlzV2VpZ2h0ID0gY2hpbGROb2RlLmJvcmRlclRvcCA/IHdlaWdodCA6IDIgKiB3ZWlnaHQ7XG4gICAgdmFyIG1pbmxlbiA9IGNoaWxkVG9wICE9PSBjaGlsZEJvdHRvbSA/IDEgOiBoZWlnaHQgLSBkZXB0aHNbdl0gKyAxO1xuXG4gICAgZy5zZXRFZGdlKHRvcCwgY2hpbGRUb3AsIHtcbiAgICAgIHdlaWdodDogdGhpc1dlaWdodCxcbiAgICAgIG1pbmxlbjogbWlubGVuLFxuICAgICAgbmVzdGluZ0VkZ2U6IHRydWVcbiAgICB9KTtcblxuICAgIGcuc2V0RWRnZShjaGlsZEJvdHRvbSwgYm90dG9tLCB7XG4gICAgICB3ZWlnaHQ6IHRoaXNXZWlnaHQsXG4gICAgICBtaW5sZW46IG1pbmxlbixcbiAgICAgIG5lc3RpbmdFZGdlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xuXG4gIGlmICghZy5wYXJlbnQodikpIHtcbiAgICBnLnNldEVkZ2Uocm9vdCwgdG9wLCB7IHdlaWdodDogMCwgbWlubGVuOiBoZWlnaHQgKyBkZXB0aHNbdl0gfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJlZURlcHRocyhnKSB7XG4gIHZhciBkZXB0aHMgPSB7fTtcbiAgZnVuY3Rpb24gZGZzKHYsIGRlcHRoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gZy5jaGlsZHJlbih2KTtcbiAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBfLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGRmcyhjaGlsZCwgZGVwdGggKyAxKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkZXB0aHNbdl0gPSBkZXB0aDtcbiAgfVxuICBfLmZvckVhY2goZy5jaGlsZHJlbigpLCBmdW5jdGlvbih2KSB7IGRmcyh2LCAxKTsgfSk7XG4gIHJldHVybiBkZXB0aHM7XG59XG5cbmZ1bmN0aW9uIHN1bVdlaWdodHMoZykge1xuICByZXR1cm4gXy5yZWR1Y2UoZy5lZGdlcygpLCBmdW5jdGlvbihhY2MsIGUpIHtcbiAgICByZXR1cm4gYWNjICsgZy5lZGdlKGUpLndlaWdodDtcbiAgfSwgMCk7XG59XG5cbmZ1bmN0aW9uIGNsZWFudXAoZykge1xuICB2YXIgZ3JhcGhMYWJlbCA9IGcuZ3JhcGgoKTtcbiAgZy5yZW1vdmVOb2RlKGdyYXBoTGFiZWwubmVzdGluZ1Jvb3QpO1xuICBkZWxldGUgZ3JhcGhMYWJlbC5uZXN0aW5nUm9vdDtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIGlmIChlZGdlLm5lc3RpbmdFZGdlKSB7XG4gICAgICBnLnJlbW92ZUVkZ2UoZSk7XG4gICAgfVxuICB9KTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL25vcm1hbGl6ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL25vcm1hbGl6ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvdXRpbC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJ1bjogcnVuLFxuICB1bmRvOiB1bmRvXG59O1xuXG4vKlxuICogQnJlYWtzIGFueSBsb25nIGVkZ2VzIGluIHRoZSBncmFwaCBpbnRvIHNob3J0IHNlZ21lbnRzIHRoYXQgc3BhbiAxIGxheWVyXG4gKiBlYWNoLiBUaGlzIG9wZXJhdGlvbiBpcyB1bmRvYWJsZSB3aXRoIHRoZSBkZW5vcm1hbGl6ZSBmdW5jdGlvbi5cbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBUaGUgaW5wdXQgZ3JhcGggaXMgYSBEQUcuXG4gKiAgICAyLiBFYWNoIG5vZGUgaW4gdGhlIGdyYXBoIGhhcyBhIFwicmFua1wiIHByb3BlcnR5LlxuICpcbiAqIFBvc3QtY29uZGl0aW9uOlxuICpcbiAqICAgIDEuIEFsbCBlZGdlcyBpbiB0aGUgZ3JhcGggaGF2ZSBhIGxlbmd0aCBvZiAxLlxuICogICAgMi4gRHVtbXkgbm9kZXMgYXJlIGFkZGVkIHdoZXJlIGVkZ2VzIGhhdmUgYmVlbiBzcGxpdCBpbnRvIHNlZ21lbnRzLlxuICogICAgMy4gVGhlIGdyYXBoIGlzIGF1Z21lbnRlZCB3aXRoIGEgXCJkdW1teUNoYWluc1wiIGF0dHJpYnV0ZSB3aGljaCBjb250YWluc1xuICogICAgICAgdGhlIGZpcnN0IGR1bW15IGluIGVhY2ggY2hhaW4gb2YgZHVtbXkgbm9kZXMgcHJvZHVjZWQuXG4gKi9cbmZ1bmN0aW9uIHJ1bihnKSB7XG4gIGcuZ3JhcGgoKS5kdW1teUNoYWlucyA9IFtdO1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlZGdlKSB7IG5vcm1hbGl6ZUVkZ2UoZywgZWRnZSk7IH0pO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVFZGdlKGcsIGUpIHtcbiAgdmFyIHYgPSBlLnY7XG4gIHZhciB2UmFuayA9IGcubm9kZSh2KS5yYW5rO1xuICB2YXIgdyA9IGUudztcbiAgdmFyIHdSYW5rID0gZy5ub2RlKHcpLnJhbms7XG4gIHZhciBuYW1lID0gZS5uYW1lO1xuICB2YXIgZWRnZUxhYmVsID0gZy5lZGdlKGUpO1xuICB2YXIgbGFiZWxSYW5rID0gZWRnZUxhYmVsLmxhYmVsUmFuaztcblxuICBpZiAod1JhbmsgPT09IHZSYW5rICsgMSkgcmV0dXJuO1xuXG4gIGcucmVtb3ZlRWRnZShlKTtcblxuICB2YXIgZHVtbXksIGF0dHJzLCBpO1xuICBmb3IgKGkgPSAwLCArK3ZSYW5rOyB2UmFuayA8IHdSYW5rOyArK2ksICsrdlJhbmspIHtcbiAgICBlZGdlTGFiZWwucG9pbnRzID0gW107XG4gICAgYXR0cnMgPSB7XG4gICAgICB3aWR0aDogMCwgaGVpZ2h0OiAwLFxuICAgICAgZWRnZUxhYmVsOiBlZGdlTGFiZWwsIGVkZ2VPYmo6IGUsXG4gICAgICByYW5rOiB2UmFua1xuICAgIH07XG4gICAgZHVtbXkgPSB1dGlsLmFkZER1bW15Tm9kZShnLCBcImVkZ2VcIiwgYXR0cnMsIFwiX2RcIik7XG4gICAgaWYgKHZSYW5rID09PSBsYWJlbFJhbmspIHtcbiAgICAgIGF0dHJzLndpZHRoID0gZWRnZUxhYmVsLndpZHRoO1xuICAgICAgYXR0cnMuaGVpZ2h0ID0gZWRnZUxhYmVsLmhlaWdodDtcbiAgICAgIGF0dHJzLmR1bW15ID0gXCJlZGdlLWxhYmVsXCI7XG4gICAgICBhdHRycy5sYWJlbHBvcyA9IGVkZ2VMYWJlbC5sYWJlbHBvcztcbiAgICB9XG4gICAgZy5zZXRFZGdlKHYsIGR1bW15LCB7IHdlaWdodDogZWRnZUxhYmVsLndlaWdodCB9LCBuYW1lKTtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgZy5ncmFwaCgpLmR1bW15Q2hhaW5zLnB1c2goZHVtbXkpO1xuICAgIH1cbiAgICB2ID0gZHVtbXk7XG4gIH1cblxuICBnLnNldEVkZ2UodiwgdywgeyB3ZWlnaHQ6IGVkZ2VMYWJlbC53ZWlnaHQgfSwgbmFtZSk7XG59XG5cbmZ1bmN0aW9uIHVuZG8oZykge1xuICBfLmZvckVhY2goZy5ncmFwaCgpLmR1bW15Q2hhaW5zLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgdmFyIG9yaWdMYWJlbCA9IG5vZGUuZWRnZUxhYmVsO1xuICAgIHZhciB3O1xuICAgIGcuc2V0RWRnZShub2RlLmVkZ2VPYmosIG9yaWdMYWJlbCk7XG4gICAgd2hpbGUgKG5vZGUuZHVtbXkpIHtcbiAgICAgIHcgPSBnLnN1Y2Nlc3NvcnModilbMF07XG4gICAgICBnLnJlbW92ZU5vZGUodik7XG4gICAgICBvcmlnTGFiZWwucG9pbnRzLnB1c2goeyB4OiBub2RlLngsIHk6IG5vZGUueSB9KTtcbiAgICAgIGlmIChub2RlLmR1bW15ID09PSBcImVkZ2UtbGFiZWxcIikge1xuICAgICAgICBvcmlnTGFiZWwueCA9IG5vZGUueDtcbiAgICAgICAgb3JpZ0xhYmVsLnkgPSBub2RlLnk7XG4gICAgICAgIG9yaWdMYWJlbC53aWR0aCA9IG5vZGUud2lkdGg7XG4gICAgICAgIG9yaWdMYWJlbC5oZWlnaHQgPSBub2RlLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIHYgPSB3O1xuICAgICAgbm9kZSA9IGcubm9kZSh2KTtcbiAgICB9XG4gIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvYWRkLXN1YmdyYXBoLWNvbnN0cmFpbnRzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvYWRkLXN1YmdyYXBoLWNvbnN0cmFpbnRzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkU3ViZ3JhcGhDb25zdHJhaW50cztcblxuZnVuY3Rpb24gYWRkU3ViZ3JhcGhDb25zdHJhaW50cyhnLCBjZywgdnMpIHtcbiAgdmFyIHByZXYgPSB7fSxcbiAgICByb290UHJldjtcblxuICBfLmZvckVhY2godnMsIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgY2hpbGQgPSBnLnBhcmVudCh2KSxcbiAgICAgIHBhcmVudCxcbiAgICAgIHByZXZDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIHBhcmVudCA9IGcucGFyZW50KGNoaWxkKTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcHJldkNoaWxkID0gcHJldltwYXJlbnRdO1xuICAgICAgICBwcmV2W3BhcmVudF0gPSBjaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZDaGlsZCA9IHJvb3RQcmV2O1xuICAgICAgICByb290UHJldiA9IGNoaWxkO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZDaGlsZCAmJiBwcmV2Q2hpbGQgIT09IGNoaWxkKSB7XG4gICAgICAgIGNnLnNldEVkZ2UocHJldkNoaWxkLCBjaGlsZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gcGFyZW50O1xuICAgIH1cbiAgfSk7XG5cbiAgLypcbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB2ID8gZy5jaGlsZHJlbih2KSA6IGcuY2hpbGRyZW4oKTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgIHN1YmdyYXBocyA9IFtdO1xuICAgICAgXy5lYWNoKGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGRNaW4gPSBkZnMoY2hpbGQpO1xuICAgICAgICBpZiAoZy5jaGlsZHJlbihjaGlsZCkubGVuZ3RoKSB7XG4gICAgICAgICAgc3ViZ3JhcGhzLnB1c2goeyB2OiBjaGlsZCwgb3JkZXI6IGNoaWxkTWluIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgY2hpbGRNaW4pO1xuICAgICAgfSk7XG4gICAgICBfLnJlZHVjZShfLnNvcnRCeShzdWJncmFwaHMsIFwib3JkZXJcIiksIGZ1bmN0aW9uKHByZXYsIGN1cnIpIHtcbiAgICAgICAgY2cuc2V0RWRnZShwcmV2LnYsIGN1cnIudik7XG4gICAgICAgIHJldHVybiBjdXJyO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICByZXR1cm4gZy5ub2RlKHYpLm9yZGVyO1xuICB9XG4gIGRmcyh1bmRlZmluZWQpO1xuICAqL1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvYmFyeWNlbnRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9iYXJ5Y2VudGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhcnljZW50ZXI7XG5cbmZ1bmN0aW9uIGJhcnljZW50ZXIoZywgbW92YWJsZSkge1xuICByZXR1cm4gXy5tYXAobW92YWJsZSwgZnVuY3Rpb24odikge1xuICAgIHZhciBpblYgPSBnLmluRWRnZXModik7XG4gICAgaWYgKCFpblYubGVuZ3RoKSB7XG4gICAgICByZXR1cm4geyB2OiB2IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXN1bHQgPSBfLnJlZHVjZShpblYsIGZ1bmN0aW9uKGFjYywgZSkge1xuICAgICAgICB2YXIgZWRnZSA9IGcuZWRnZShlKSxcbiAgICAgICAgICBub2RlVSA9IGcubm9kZShlLnYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1bTogYWNjLnN1bSArIChlZGdlLndlaWdodCAqIG5vZGVVLm9yZGVyKSxcbiAgICAgICAgICB3ZWlnaHQ6IGFjYy53ZWlnaHQgKyBlZGdlLndlaWdodFxuICAgICAgICB9O1xuICAgICAgfSwgeyBzdW06IDAsIHdlaWdodDogMCB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdjogdixcbiAgICAgICAgYmFyeWNlbnRlcjogcmVzdWx0LnN1bSAvIHJlc3VsdC53ZWlnaHQsXG4gICAgICAgIHdlaWdodDogcmVzdWx0LndlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9idWlsZC1sYXllci1ncmFwaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvYnVpbGQtbGF5ZXItZ3JhcGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xudmFyIEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZ3JhcGhsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2dyYXBobGliLmpzXCIpLkdyYXBoO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkTGF5ZXJHcmFwaDtcblxuLypcbiAqIENvbnN0cnVjdHMgYSBncmFwaCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNvcnQgYSBsYXllciBvZiBub2Rlcy4gVGhlIGdyYXBoIHdpbGxcbiAqIGNvbnRhaW4gYWxsIGJhc2UgYW5kIHN1YmdyYXBoIG5vZGVzIGZyb20gdGhlIHJlcXVlc3QgbGF5ZXIgaW4gdGhlaXIgb3JpZ2luYWxcbiAqIGhpZXJhcmNoeSBhbmQgYW55IGVkZ2VzIHRoYXQgYXJlIGluY2lkZW50IG9uIHRoZXNlIG5vZGVzIGFuZCBhcmUgb2YgdGhlIHR5cGVcbiAqIHJlcXVlc3RlZCBieSB0aGUgXCJyZWxhdGlvbnNoaXBcIiBwYXJhbWV0ZXIuXG4gKlxuICogTm9kZXMgZnJvbSB0aGUgcmVxdWVzdGVkIHJhbmsgdGhhdCBkbyBub3QgaGF2ZSBwYXJlbnRzIGFyZSBhc3NpZ25lZCBhIHJvb3RcbiAqIG5vZGUgaW4gdGhlIG91dHB1dCBncmFwaCwgd2hpY2ggaXMgc2V0IGluIHRoZSByb290IGdyYXBoIGF0dHJpYnV0ZS4gVGhpc1xuICogbWFrZXMgaXQgZWFzeSB0byB3YWxrIHRoZSBoaWVyYXJjaHkgb2YgbW92YWJsZSBub2RlcyBkdXJpbmcgb3JkZXJpbmcuXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gSW5wdXQgZ3JhcGggaXMgYSBEQUdcbiAqICAgIDIuIEJhc2Ugbm9kZXMgaW4gdGhlIGlucHV0IGdyYXBoIGhhdmUgYSByYW5rIGF0dHJpYnV0ZVxuICogICAgMy4gU3ViZ3JhcGggbm9kZXMgaW4gdGhlIGlucHV0IGdyYXBoIGhhcyBtaW5SYW5rIGFuZCBtYXhSYW5rIGF0dHJpYnV0ZXNcbiAqICAgIDQuIEVkZ2VzIGhhdmUgYW4gYXNzaWduZWQgd2VpZ2h0XG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIE91dHB1dCBncmFwaCBoYXMgYWxsIG5vZGVzIGluIHRoZSBtb3ZhYmxlIHJhbmsgd2l0aCBwcmVzZXJ2ZWRcbiAqICAgICAgIGhpZXJhcmNoeS5cbiAqICAgIDIuIFJvb3Qgbm9kZXMgaW4gdGhlIG1vdmFibGUgbGF5ZXIgYXJlIG1hZGUgY2hpbGRyZW4gb2YgdGhlIG5vZGVcbiAqICAgICAgIGluZGljYXRlZCBieSB0aGUgcm9vdCBhdHRyaWJ1dGUgb2YgdGhlIGdyYXBoLlxuICogICAgMy4gTm9uLW1vdmFibGUgbm9kZXMgaW5jaWRlbnQgb24gbW92YWJsZSBub2Rlcywgc2VsZWN0ZWQgYnkgdGhlXG4gKiAgICAgICByZWxhdGlvbnNoaXAgcGFyYW1ldGVyLCBhcmUgaW5jbHVkZWQgaW4gdGhlIGdyYXBoICh3aXRob3V0IGhpZXJhcmNoeSkuXG4gKiAgICA0LiBFZGdlcyBpbmNpZGVudCBvbiBtb3ZhYmxlIG5vZGVzLCBzZWxlY3RlZCBieSB0aGUgcmVsYXRpb25zaGlwXG4gKiAgICAgICBwYXJhbWV0ZXIsIGFyZSBhZGRlZCB0byB0aGUgb3V0cHV0IGdyYXBoLlxuICogICAgNS4gVGhlIHdlaWdodHMgZm9yIGNvcGllZCBlZGdlcyBhcmUgYWdncmVnYXRlZCBhcyBuZWVkLCBzaW5jZSB0aGUgb3V0cHV0XG4gKiAgICAgICBncmFwaCBpcyBub3QgYSBtdWx0aS1ncmFwaC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRMYXllckdyYXBoKGcsIHJhbmssIHJlbGF0aW9uc2hpcCkge1xuICB2YXIgcm9vdCA9IGNyZWF0ZVJvb3ROb2RlKGcpLFxuICAgIHJlc3VsdCA9IG5ldyBHcmFwaCh7IGNvbXBvdW5kOiB0cnVlIH0pLnNldEdyYXBoKHsgcm9vdDogcm9vdCB9KVxuICAgICAgLnNldERlZmF1bHROb2RlTGFiZWwoZnVuY3Rpb24odikgeyByZXR1cm4gZy5ub2RlKHYpOyB9KTtcblxuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodiksXG4gICAgICBwYXJlbnQgPSBnLnBhcmVudCh2KTtcblxuICAgIGlmIChub2RlLnJhbmsgPT09IHJhbmsgfHwgbm9kZS5taW5SYW5rIDw9IHJhbmsgJiYgcmFuayA8PSBub2RlLm1heFJhbmspIHtcbiAgICAgIHJlc3VsdC5zZXROb2RlKHYpO1xuICAgICAgcmVzdWx0LnNldFBhcmVudCh2LCBwYXJlbnQgfHwgcm9vdCk7XG5cbiAgICAgIC8vIFRoaXMgYXNzdW1lcyB3ZSBoYXZlIG9ubHkgc2hvcnQgZWRnZXMhXG4gICAgICBfLmZvckVhY2goZ1tyZWxhdGlvbnNoaXBdKHYpLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB1ID0gZS52ID09PSB2ID8gZS53IDogZS52LFxuICAgICAgICAgIGVkZ2UgPSByZXN1bHQuZWRnZSh1LCB2KSxcbiAgICAgICAgICB3ZWlnaHQgPSAhXy5pc1VuZGVmaW5lZChlZGdlKSA/IGVkZ2Uud2VpZ2h0IDogMDtcbiAgICAgICAgcmVzdWx0LnNldEVkZ2UodSwgdiwgeyB3ZWlnaHQ6IGcuZWRnZShlKS53ZWlnaHQgKyB3ZWlnaHQgfSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKF8uaGFzKG5vZGUsIFwibWluUmFua1wiKSkge1xuICAgICAgICByZXN1bHQuc2V0Tm9kZSh2LCB7XG4gICAgICAgICAgYm9yZGVyTGVmdDogbm9kZS5ib3JkZXJMZWZ0W3JhbmtdLFxuICAgICAgICAgIGJvcmRlclJpZ2h0OiBub2RlLmJvcmRlclJpZ2h0W3JhbmtdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUm9vdE5vZGUoZykge1xuICB2YXIgdjtcbiAgd2hpbGUgKGcuaGFzTm9kZSgodiA9IF8udW5pcXVlSWQoXCJfcm9vdFwiKSkpKTtcbiAgcmV0dXJuIHY7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9jcm9zcy1jb3VudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvY3Jvc3MtY291bnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyb3NzQ291bnQ7XG5cbi8qXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBsYXllcmluZyAoYW4gYXJyYXkgb2YgbGF5ZXJzLCBlYWNoIHdpdGggYW4gYXJyYXkgb2ZcbiAqIG9yZGVyZXJkIG5vZGVzKSBhbmQgYSBncmFwaCBhbmQgcmV0dXJucyBhIHdlaWdodGVkIGNyb3NzaW5nIGNvdW50LlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIElucHV0IGdyYXBoIG11c3QgYmUgc2ltcGxlIChub3QgYSBtdWx0aWdyYXBoKSwgZGlyZWN0ZWQsIGFuZCBpbmNsdWRlXG4gKiAgICAgICBvbmx5IHNpbXBsZSBlZGdlcy5cbiAqICAgIDIuIEVkZ2VzIGluIHRoZSBpbnB1dCBncmFwaCBtdXN0IGhhdmUgYXNzaWduZWQgd2VpZ2h0cy5cbiAqXG4gKiBQb3N0LWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gVGhlIGdyYXBoIGFuZCBsYXllcmluZyBtYXRyaXggYXJlIGxlZnQgdW5jaGFuZ2VkLlxuICpcbiAqIFRoaXMgYWxnb3JpdGhtIGlzIGRlcml2ZWQgZnJvbSBCYXJ0aCwgZXQgYWwuLCBcIkJpbGF5ZXIgQ3Jvc3MgQ291bnRpbmcuXCJcbiAqL1xuZnVuY3Rpb24gY3Jvc3NDb3VudChnLCBsYXllcmluZykge1xuICB2YXIgY2MgPSAwO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxheWVyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgY2MgKz0gdHdvTGF5ZXJDcm9zc0NvdW50KGcsIGxheWVyaW5nW2ktMV0sIGxheWVyaW5nW2ldKTtcbiAgfVxuICByZXR1cm4gY2M7XG59XG5cbmZ1bmN0aW9uIHR3b0xheWVyQ3Jvc3NDb3VudChnLCBub3J0aExheWVyLCBzb3V0aExheWVyKSB7XG4gIC8vIFNvcnQgYWxsIG9mIHRoZSBlZGdlcyBiZXR3ZWVuIHRoZSBub3J0aCBhbmQgc291dGggbGF5ZXJzIGJ5IHRoZWlyIHBvc2l0aW9uXG4gIC8vIGluIHRoZSBub3J0aCBsYXllciBhbmQgdGhlbiB0aGUgc291dGguIE1hcCB0aGVzZSBlZGdlcyB0byB0aGUgcG9zaXRpb24gb2ZcbiAgLy8gdGhlaXIgaGVhZCBpbiB0aGUgc291dGggbGF5ZXIuXG4gIHZhciBzb3V0aFBvcyA9IF8uemlwT2JqZWN0KHNvdXRoTGF5ZXIsXG4gICAgXy5tYXAoc291dGhMYXllciwgZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIGk7IH0pKTtcbiAgdmFyIHNvdXRoRW50cmllcyA9IF8uZmxhdHRlbihfLm1hcChub3J0aExheWVyLCBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIF8uc29ydEJ5KF8ubWFwKGcub3V0RWRnZXModiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiB7IHBvczogc291dGhQb3NbZS53XSwgd2VpZ2h0OiBnLmVkZ2UoZSkud2VpZ2h0IH07XG4gICAgfSksIFwicG9zXCIpO1xuICB9KSwgdHJ1ZSk7XG5cbiAgLy8gQnVpbGQgdGhlIGFjY3VtdWxhdG9yIHRyZWVcbiAgdmFyIGZpcnN0SW5kZXggPSAxO1xuICB3aGlsZSAoZmlyc3RJbmRleCA8IHNvdXRoTGF5ZXIubGVuZ3RoKSBmaXJzdEluZGV4IDw8PSAxO1xuICB2YXIgdHJlZVNpemUgPSAyICogZmlyc3RJbmRleCAtIDE7XG4gIGZpcnN0SW5kZXggLT0gMTtcbiAgdmFyIHRyZWUgPSBfLm1hcChuZXcgQXJyYXkodHJlZVNpemUpLCBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH0pO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgd2VpZ2h0ZWQgY3Jvc3NpbmdzXG4gIHZhciBjYyA9IDA7XG4gIF8uZm9yRWFjaChzb3V0aEVudHJpZXMuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkge1xuICAgIHZhciBpbmRleCA9IGVudHJ5LnBvcyArIGZpcnN0SW5kZXg7XG4gICAgdHJlZVtpbmRleF0gKz0gZW50cnkud2VpZ2h0O1xuICAgIHZhciB3ZWlnaHRTdW0gPSAwO1xuICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgIGlmIChpbmRleCAlIDIpIHtcbiAgICAgICAgd2VpZ2h0U3VtICs9IHRyZWVbaW5kZXggKyAxXTtcbiAgICAgIH1cbiAgICAgIGluZGV4ID0gKGluZGV4IC0gMSkgPj4gMTtcbiAgICAgIHRyZWVbaW5kZXhdICs9IGVudHJ5LndlaWdodDtcbiAgICB9XG4gICAgY2MgKz0gZW50cnkud2VpZ2h0ICogd2VpZ2h0U3VtO1xuICB9KSk7XG5cbiAgcmV0dXJuIGNjO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2xvZGFzaC5qc1wiKTtcbnZhciBpbml0T3JkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2luaXQtb3JkZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL2luaXQtb3JkZXIuanNcIik7XG52YXIgY3Jvc3NDb3VudCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY3Jvc3MtY291bnQgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL2Nyb3NzLWNvdW50LmpzXCIpO1xudmFyIHNvcnRTdWJncmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc29ydC1zdWJncmFwaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvc29ydC1zdWJncmFwaC5qc1wiKTtcbnZhciBidWlsZExheWVyR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2J1aWxkLWxheWVyLWdyYXBoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9idWlsZC1sYXllci1ncmFwaC5qc1wiKTtcbnZhciBhZGRTdWJncmFwaENvbnN0cmFpbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hZGQtc3ViZ3JhcGgtY29uc3RyYWludHMgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL2FkZC1zdWJncmFwaC1jb25zdHJhaW50cy5qc1wiKTtcbnZhciBHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2dyYXBobGliICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9ncmFwaGxpYi5qc1wiKS5HcmFwaDtcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvdXRpbC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBvcmRlcjtcblxuLypcbiAqIEFwcGxpZXMgaGV1cmlzdGljcyB0byBtaW5pbWl6ZSBlZGdlIGNyb3NzaW5ncyBpbiB0aGUgZ3JhcGggYW5kIHNldHMgdGhlIGJlc3RcbiAqIG9yZGVyIHNvbHV0aW9uIGFzIGFuIG9yZGVyIGF0dHJpYnV0ZSBvbiBlYWNoIG5vZGUuXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gR3JhcGggbXVzdCBiZSBEQUdcbiAqICAgIDIuIEdyYXBoIG5vZGVzIG11c3QgYmUgb2JqZWN0cyB3aXRoIGEgXCJyYW5rXCIgYXR0cmlidXRlXG4gKiAgICAzLiBHcmFwaCBlZGdlcyBtdXN0IGhhdmUgdGhlIFwid2VpZ2h0XCIgYXR0cmlidXRlXG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEdyYXBoIG5vZGVzIHdpbGwgaGF2ZSBhbiBcIm9yZGVyXCIgYXR0cmlidXRlIGJhc2VkIG9uIHRoZSByZXN1bHRzIG9mIHRoZVxuICogICAgICAgYWxnb3JpdGhtLlxuICovXG5mdW5jdGlvbiBvcmRlcihnKSB7XG4gIHZhciBtYXhSYW5rID0gdXRpbC5tYXhSYW5rKGcpLFxuICAgIGRvd25MYXllckdyYXBocyA9IGJ1aWxkTGF5ZXJHcmFwaHMoZywgXy5yYW5nZSgxLCBtYXhSYW5rICsgMSksIFwiaW5FZGdlc1wiKSxcbiAgICB1cExheWVyR3JhcGhzID0gYnVpbGRMYXllckdyYXBocyhnLCBfLnJhbmdlKG1heFJhbmsgLSAxLCAtMSwgLTEpLCBcIm91dEVkZ2VzXCIpO1xuXG4gIHZhciBsYXllcmluZyA9IGluaXRPcmRlcihnKTtcbiAgYXNzaWduT3JkZXIoZywgbGF5ZXJpbmcpO1xuXG4gIHZhciBiZXN0Q0MgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgYmVzdDtcblxuICBmb3IgKHZhciBpID0gMCwgbGFzdEJlc3QgPSAwOyBsYXN0QmVzdCA8IDQ7ICsraSwgKytsYXN0QmVzdCkge1xuICAgIHN3ZWVwTGF5ZXJHcmFwaHMoaSAlIDIgPyBkb3duTGF5ZXJHcmFwaHMgOiB1cExheWVyR3JhcGhzLCBpICUgNCA+PSAyKTtcblxuICAgIGxheWVyaW5nID0gdXRpbC5idWlsZExheWVyTWF0cml4KGcpO1xuICAgIHZhciBjYyA9IGNyb3NzQ291bnQoZywgbGF5ZXJpbmcpO1xuICAgIGlmIChjYyA8IGJlc3RDQykge1xuICAgICAgbGFzdEJlc3QgPSAwO1xuICAgICAgYmVzdCA9IF8uY2xvbmVEZWVwKGxheWVyaW5nKTtcbiAgICAgIGJlc3RDQyA9IGNjO1xuICAgIH1cbiAgfVxuXG4gIGFzc2lnbk9yZGVyKGcsIGJlc3QpO1xufVxuXG5mdW5jdGlvbiBidWlsZExheWVyR3JhcGhzKGcsIHJhbmtzLCByZWxhdGlvbnNoaXApIHtcbiAgcmV0dXJuIF8ubWFwKHJhbmtzLCBmdW5jdGlvbihyYW5rKSB7XG4gICAgcmV0dXJuIGJ1aWxkTGF5ZXJHcmFwaChnLCByYW5rLCByZWxhdGlvbnNoaXApO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc3dlZXBMYXllckdyYXBocyhsYXllckdyYXBocywgYmlhc1JpZ2h0KSB7XG4gIHZhciBjZyA9IG5ldyBHcmFwaCgpO1xuICBfLmZvckVhY2gobGF5ZXJHcmFwaHMsIGZ1bmN0aW9uKGxnKSB7XG4gICAgdmFyIHJvb3QgPSBsZy5ncmFwaCgpLnJvb3Q7XG4gICAgdmFyIHNvcnRlZCA9IHNvcnRTdWJncmFwaChsZywgcm9vdCwgY2csIGJpYXNSaWdodCk7XG4gICAgXy5mb3JFYWNoKHNvcnRlZC52cywgZnVuY3Rpb24odiwgaSkge1xuICAgICAgbGcubm9kZSh2KS5vcmRlciA9IGk7XG4gICAgfSk7XG4gICAgYWRkU3ViZ3JhcGhDb25zdHJhaW50cyhsZywgY2csIHNvcnRlZC52cyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25PcmRlcihnLCBsYXllcmluZykge1xuICBfLmZvckVhY2gobGF5ZXJpbmcsIGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgXy5mb3JFYWNoKGxheWVyLCBmdW5jdGlvbih2LCBpKSB7XG4gICAgICBnLm5vZGUodikub3JkZXIgPSBpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL2luaXQtb3JkZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvaW5pdC1vcmRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2xvZGFzaC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbml0T3JkZXI7XG5cbi8qXG4gKiBBc3NpZ25zIGFuIGluaXRpYWwgb3JkZXIgdmFsdWUgZm9yIGVhY2ggbm9kZSBieSBwZXJmb3JtaW5nIGEgREZTIHNlYXJjaFxuICogc3RhcnRpbmcgZnJvbSBub2RlcyBpbiB0aGUgZmlyc3QgcmFuay4gTm9kZXMgYXJlIGFzc2lnbmVkIGFuIG9yZGVyIGluIHRoZWlyXG4gKiByYW5rIGFzIHRoZXkgYXJlIGZpcnN0IHZpc2l0ZWQuXG4gKlxuICogVGhpcyBhcHByb2FjaCBjb21lcyBmcm9tIEdhbnNuZXIsIGV0IGFsLiwgXCJBIFRlY2huaXF1ZSBmb3IgRHJhd2luZyBEaXJlY3RlZFxuICogR3JhcGhzLlwiXG4gKlxuICogUmV0dXJucyBhIGxheWVyaW5nIG1hdHJpeCB3aXRoIGFuIGFycmF5IHBlciBsYXllciBhbmQgZWFjaCBsYXllciBzb3J0ZWQgYnlcbiAqIHRoZSBvcmRlciBvZiBpdHMgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGluaXRPcmRlcihnKSB7XG4gIHZhciB2aXNpdGVkID0ge307XG4gIHZhciBzaW1wbGVOb2RlcyA9IF8uZmlsdGVyKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHJldHVybiAhZy5jaGlsZHJlbih2KS5sZW5ndGg7XG4gIH0pO1xuICB2YXIgbWF4UmFuayA9IF8ubWF4KF8ubWFwKHNpbXBsZU5vZGVzLCBmdW5jdGlvbih2KSB7IHJldHVybiBnLm5vZGUodikucmFuazsgfSkpO1xuICB2YXIgbGF5ZXJzID0gXy5tYXAoXy5yYW5nZShtYXhSYW5rICsgMSksIGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH0pO1xuXG4gIGZ1bmN0aW9uIGRmcyh2KSB7XG4gICAgaWYgKF8uaGFzKHZpc2l0ZWQsIHYpKSByZXR1cm47XG4gICAgdmlzaXRlZFt2XSA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgbGF5ZXJzW25vZGUucmFua10ucHVzaCh2KTtcbiAgICBfLmZvckVhY2goZy5zdWNjZXNzb3JzKHYpLCBkZnMpO1xuICB9XG5cbiAgdmFyIG9yZGVyZWRWcyA9IF8uc29ydEJ5KHNpbXBsZU5vZGVzLCBmdW5jdGlvbih2KSB7IHJldHVybiBnLm5vZGUodikucmFuazsgfSk7XG4gIF8uZm9yRWFjaChvcmRlcmVkVnMsIGRmcyk7XG5cbiAgcmV0dXJuIGxheWVycztcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL3Jlc29sdmUtY29uZmxpY3RzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9yZXNvbHZlLWNvbmZsaWN0cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZUNvbmZsaWN0cztcblxuLypcbiAqIEdpdmVuIGEgbGlzdCBvZiBlbnRyaWVzIG9mIHRoZSBmb3JtIHt2LCBiYXJ5Y2VudGVyLCB3ZWlnaHR9IGFuZCBhXG4gKiBjb25zdHJhaW50IGdyYXBoIHRoaXMgZnVuY3Rpb24gd2lsbCByZXNvbHZlIGFueSBjb25mbGljdHMgYmV0d2VlbiB0aGVcbiAqIGNvbnN0cmFpbnQgZ3JhcGggYW5kIHRoZSBiYXJ5Y2VudGVycyBmb3IgdGhlIGVudHJpZXMuIElmIHRoZSBiYXJ5Y2VudGVycyBmb3JcbiAqIGFuIGVudHJ5IHdvdWxkIHZpb2xhdGUgYSBjb25zdHJhaW50IGluIHRoZSBjb25zdHJhaW50IGdyYXBoIHRoZW4gd2UgY29hbGVzY2VcbiAqIHRoZSBub2RlcyBpbiB0aGUgY29uZmxpY3QgaW50byBhIG5ldyBub2RlIHRoYXQgcmVzcGVjdHMgdGhlIGNvbnRyYWludCBhbmRcbiAqIGFnZ3JlZ2F0ZXMgYmFyeWNlbnRlciBhbmQgd2VpZ2h0IGluZm9ybWF0aW9uLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdGhlIGRlc2NyaXB0aW9uIGluIEZvcnN0ZXIsIFwiQSBGYXN0IGFuZFxuICogU2ltcGxlIEh1ZXJpc3RpYyBmb3IgQ29uc3RyYWluZWQgVHdvLUxldmVsIENyb3NzaW5nIFJlZHVjdGlvbixcIiB0aG91Z2h0IGl0XG4gKiBkaWZmZXJzIGluIHNvbWUgc3BlY2lmaWMgZGV0YWlscy5cbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBFYWNoIGVudHJ5IGhhcyB0aGUgZm9ybSB7diwgYmFyeWNlbnRlciwgd2VpZ2h0fSwgb3IgaWYgdGhlIG5vZGUgaGFzXG4gKiAgICAgICBubyBiYXJ5Y2VudGVyLCB0aGVuIHt2fS5cbiAqXG4gKiBSZXR1cm5zOlxuICpcbiAqICAgIEEgbmV3IGxpc3Qgb2YgZW50cmllcyBvZiB0aGUgZm9ybSB7dnMsIGksIGJhcnljZW50ZXIsIHdlaWdodH0uIFRoZSBsaXN0XG4gKiAgICBgdnNgIG1heSBlaXRoZXIgYmUgYSBzaW5nbGV0b24gb3IgaXQgbWF5IGJlIGFuIGFnZ3JlZ2F0aW9uIG9mIG5vZGVzXG4gKiAgICBvcmRlcmVkIHN1Y2ggdGhhdCB0aGV5IGRvIG5vdCB2aW9sYXRlIGNvbnN0cmFpbnRzIGZyb20gdGhlIGNvbnN0cmFpbnRcbiAqICAgIGdyYXBoLiBUaGUgcHJvcGVydHkgYGlgIGlzIHRoZSBsb3dlc3Qgb3JpZ2luYWwgaW5kZXggb2YgYW55IG9mIHRoZVxuICogICAgZWxlbWVudHMgaW4gYHZzYC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUNvbmZsaWN0cyhlbnRyaWVzLCBjZykge1xuICB2YXIgbWFwcGVkRW50cmllcyA9IHt9O1xuICBfLmZvckVhY2goZW50cmllcywgZnVuY3Rpb24oZW50cnksIGkpIHtcbiAgICB2YXIgdG1wID0gbWFwcGVkRW50cmllc1tlbnRyeS52XSA9IHtcbiAgICAgIGluZGVncmVlOiAwLFxuICAgICAgXCJpblwiOiBbXSxcbiAgICAgIG91dDogW10sXG4gICAgICB2czogW2VudHJ5LnZdLFxuICAgICAgaTogaVxuICAgIH07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGVudHJ5LmJhcnljZW50ZXIpKSB7XG4gICAgICB0bXAuYmFyeWNlbnRlciA9IGVudHJ5LmJhcnljZW50ZXI7XG4gICAgICB0bXAud2VpZ2h0ID0gZW50cnkud2VpZ2h0O1xuICAgIH1cbiAgfSk7XG5cbiAgXy5mb3JFYWNoKGNnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZW50cnlWID0gbWFwcGVkRW50cmllc1tlLnZdO1xuICAgIHZhciBlbnRyeVcgPSBtYXBwZWRFbnRyaWVzW2Uud107XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGVudHJ5VikgJiYgIV8uaXNVbmRlZmluZWQoZW50cnlXKSkge1xuICAgICAgZW50cnlXLmluZGVncmVlKys7XG4gICAgICBlbnRyeVYub3V0LnB1c2gobWFwcGVkRW50cmllc1tlLnddKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBzb3VyY2VTZXQgPSBfLmZpbHRlcihtYXBwZWRFbnRyaWVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgIHJldHVybiAhZW50cnkuaW5kZWdyZWU7XG4gIH0pO1xuXG4gIHJldHVybiBkb1Jlc29sdmVDb25mbGljdHMoc291cmNlU2V0KTtcbn1cblxuZnVuY3Rpb24gZG9SZXNvbHZlQ29uZmxpY3RzKHNvdXJjZVNldCkge1xuICB2YXIgZW50cmllcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUluKHZFbnRyeSkge1xuICAgIHJldHVybiBmdW5jdGlvbih1RW50cnkpIHtcbiAgICAgIGlmICh1RW50cnkubWVyZ2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHVFbnRyeS5iYXJ5Y2VudGVyKSB8fFxuICAgICAgICAgIF8uaXNVbmRlZmluZWQodkVudHJ5LmJhcnljZW50ZXIpIHx8XG4gICAgICAgICAgdUVudHJ5LmJhcnljZW50ZXIgPj0gdkVudHJ5LmJhcnljZW50ZXIpIHtcbiAgICAgICAgbWVyZ2VFbnRyaWVzKHZFbnRyeSwgdUVudHJ5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlT3V0KHZFbnRyeSkge1xuICAgIHJldHVybiBmdW5jdGlvbih3RW50cnkpIHtcbiAgICAgIHdFbnRyeVtcImluXCJdLnB1c2godkVudHJ5KTtcbiAgICAgIGlmICgtLXdFbnRyeS5pbmRlZ3JlZSA9PT0gMCkge1xuICAgICAgICBzb3VyY2VTZXQucHVzaCh3RW50cnkpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB3aGlsZSAoc291cmNlU2V0Lmxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IHNvdXJjZVNldC5wb3AoKTtcbiAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgIF8uZm9yRWFjaChlbnRyeVtcImluXCJdLnJldmVyc2UoKSwgaGFuZGxlSW4oZW50cnkpKTtcbiAgICBfLmZvckVhY2goZW50cnkub3V0LCBoYW5kbGVPdXQoZW50cnkpKTtcbiAgfVxuXG4gIHJldHVybiBfLm1hcChfLmZpbHRlcihlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSkgeyByZXR1cm4gIWVudHJ5Lm1lcmdlZDsgfSksXG4gICAgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgIHJldHVybiBfLnBpY2soZW50cnksIFtcInZzXCIsIFwiaVwiLCBcImJhcnljZW50ZXJcIiwgXCJ3ZWlnaHRcIl0pO1xuICAgIH0pO1xuXG59XG5cbmZ1bmN0aW9uIG1lcmdlRW50cmllcyh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIHdlaWdodCA9IDA7XG5cbiAgaWYgKHRhcmdldC53ZWlnaHQpIHtcbiAgICBzdW0gKz0gdGFyZ2V0LmJhcnljZW50ZXIgKiB0YXJnZXQud2VpZ2h0O1xuICAgIHdlaWdodCArPSB0YXJnZXQud2VpZ2h0O1xuICB9XG5cbiAgaWYgKHNvdXJjZS53ZWlnaHQpIHtcbiAgICBzdW0gKz0gc291cmNlLmJhcnljZW50ZXIgKiBzb3VyY2Uud2VpZ2h0O1xuICAgIHdlaWdodCArPSBzb3VyY2Uud2VpZ2h0O1xuICB9XG5cbiAgdGFyZ2V0LnZzID0gc291cmNlLnZzLmNvbmNhdCh0YXJnZXQudnMpO1xuICB0YXJnZXQuYmFyeWNlbnRlciA9IHN1bSAvIHdlaWdodDtcbiAgdGFyZ2V0LndlaWdodCA9IHdlaWdodDtcbiAgdGFyZ2V0LmkgPSBNYXRoLm1pbihzb3VyY2UuaSwgdGFyZ2V0LmkpO1xuICBzb3VyY2UubWVyZ2VkID0gdHJ1ZTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL3NvcnQtc3ViZ3JhcGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvc29ydC1zdWJncmFwaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2xvZGFzaC5qc1wiKTtcbnZhciBiYXJ5Y2VudGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXJ5Y2VudGVyICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9iYXJ5Y2VudGVyLmpzXCIpO1xudmFyIHJlc29sdmVDb25mbGljdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Jlc29sdmUtY29uZmxpY3RzICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9yZXNvbHZlLWNvbmZsaWN0cy5qc1wiKTtcbnZhciBzb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9zb3J0LmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRTdWJncmFwaDtcblxuZnVuY3Rpb24gc29ydFN1YmdyYXBoKGcsIHYsIGNnLCBiaWFzUmlnaHQpIHtcbiAgdmFyIG1vdmFibGUgPSBnLmNoaWxkcmVuKHYpO1xuICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgdmFyIGJsID0gbm9kZSA/IG5vZGUuYm9yZGVyTGVmdCA6IHVuZGVmaW5lZDtcbiAgdmFyIGJyID0gbm9kZSA/IG5vZGUuYm9yZGVyUmlnaHQ6IHVuZGVmaW5lZDtcbiAgdmFyIHN1YmdyYXBocyA9IHt9O1xuXG4gIGlmIChibCkge1xuICAgIG1vdmFibGUgPSBfLmZpbHRlcihtb3ZhYmxlLCBmdW5jdGlvbih3KSB7XG4gICAgICByZXR1cm4gdyAhPT0gYmwgJiYgdyAhPT0gYnI7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgYmFyeWNlbnRlcnMgPSBiYXJ5Y2VudGVyKGcsIG1vdmFibGUpO1xuICBfLmZvckVhY2goYmFyeWNlbnRlcnMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgaWYgKGcuY2hpbGRyZW4oZW50cnkudikubGVuZ3RoKSB7XG4gICAgICB2YXIgc3ViZ3JhcGhSZXN1bHQgPSBzb3J0U3ViZ3JhcGgoZywgZW50cnkudiwgY2csIGJpYXNSaWdodCk7XG4gICAgICBzdWJncmFwaHNbZW50cnkudl0gPSBzdWJncmFwaFJlc3VsdDtcbiAgICAgIGlmIChfLmhhcyhzdWJncmFwaFJlc3VsdCwgXCJiYXJ5Y2VudGVyXCIpKSB7XG4gICAgICAgIG1lcmdlQmFyeWNlbnRlcnMoZW50cnksIHN1YmdyYXBoUmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBlbnRyaWVzID0gcmVzb2x2ZUNvbmZsaWN0cyhiYXJ5Y2VudGVycywgY2cpO1xuICBleHBhbmRTdWJncmFwaHMoZW50cmllcywgc3ViZ3JhcGhzKTtcblxuICB2YXIgcmVzdWx0ID0gc29ydChlbnRyaWVzLCBiaWFzUmlnaHQpO1xuXG4gIGlmIChibCkge1xuICAgIHJlc3VsdC52cyA9IF8uZmxhdHRlbihbYmwsIHJlc3VsdC52cywgYnJdLCB0cnVlKTtcbiAgICBpZiAoZy5wcmVkZWNlc3NvcnMoYmwpLmxlbmd0aCkge1xuICAgICAgdmFyIGJsUHJlZCA9IGcubm9kZShnLnByZWRlY2Vzc29ycyhibClbMF0pLFxuICAgICAgICBiclByZWQgPSBnLm5vZGUoZy5wcmVkZWNlc3NvcnMoYnIpWzBdKTtcbiAgICAgIGlmICghXy5oYXMocmVzdWx0LCBcImJhcnljZW50ZXJcIikpIHtcbiAgICAgICAgcmVzdWx0LmJhcnljZW50ZXIgPSAwO1xuICAgICAgICByZXN1bHQud2VpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5iYXJ5Y2VudGVyID0gKHJlc3VsdC5iYXJ5Y2VudGVyICogcmVzdWx0LndlaWdodCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBibFByZWQub3JkZXIgKyBiclByZWQub3JkZXIpIC8gKHJlc3VsdC53ZWlnaHQgKyAyKTtcbiAgICAgIHJlc3VsdC53ZWlnaHQgKz0gMjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBleHBhbmRTdWJncmFwaHMoZW50cmllcywgc3ViZ3JhcGhzKSB7XG4gIF8uZm9yRWFjaChlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgIGVudHJ5LnZzID0gXy5mbGF0dGVuKGVudHJ5LnZzLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoc3ViZ3JhcGhzW3ZdKSB7XG4gICAgICAgIHJldHVybiBzdWJncmFwaHNbdl0udnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9KSwgdHJ1ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtZXJnZUJhcnljZW50ZXJzKHRhcmdldCwgb3RoZXIpIHtcbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHRhcmdldC5iYXJ5Y2VudGVyKSkge1xuICAgIHRhcmdldC5iYXJ5Y2VudGVyID0gKHRhcmdldC5iYXJ5Y2VudGVyICogdGFyZ2V0LndlaWdodCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIuYmFyeWNlbnRlciAqIG90aGVyLndlaWdodCkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgKHRhcmdldC53ZWlnaHQgKyBvdGhlci53ZWlnaHQpO1xuICAgIHRhcmdldC53ZWlnaHQgKz0gb3RoZXIud2VpZ2h0O1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5iYXJ5Y2VudGVyID0gb3RoZXIuYmFyeWNlbnRlcjtcbiAgICB0YXJnZXQud2VpZ2h0ID0gb3RoZXIud2VpZ2h0O1xuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9zb3J0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL3NvcnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3V0aWwuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gc29ydDtcblxuZnVuY3Rpb24gc29ydChlbnRyaWVzLCBiaWFzUmlnaHQpIHtcbiAgdmFyIHBhcnRzID0gdXRpbC5wYXJ0aXRpb24oZW50cmllcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICByZXR1cm4gXy5oYXMoZW50cnksIFwiYmFyeWNlbnRlclwiKTtcbiAgfSk7XG4gIHZhciBzb3J0YWJsZSA9IHBhcnRzLmxocyxcbiAgICB1bnNvcnRhYmxlID0gXy5zb3J0QnkocGFydHMucmhzLCBmdW5jdGlvbihlbnRyeSkgeyByZXR1cm4gLWVudHJ5Lmk7IH0pLFxuICAgIHZzID0gW10sXG4gICAgc3VtID0gMCxcbiAgICB3ZWlnaHQgPSAwLFxuICAgIHZzSW5kZXggPSAwO1xuXG4gIHNvcnRhYmxlLnNvcnQoY29tcGFyZVdpdGhCaWFzKCEhYmlhc1JpZ2h0KSk7XG5cbiAgdnNJbmRleCA9IGNvbnN1bWVVbnNvcnRhYmxlKHZzLCB1bnNvcnRhYmxlLCB2c0luZGV4KTtcblxuICBfLmZvckVhY2goc29ydGFibGUsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHZzSW5kZXggKz0gZW50cnkudnMubGVuZ3RoO1xuICAgIHZzLnB1c2goZW50cnkudnMpO1xuICAgIHN1bSArPSBlbnRyeS5iYXJ5Y2VudGVyICogZW50cnkud2VpZ2h0O1xuICAgIHdlaWdodCArPSBlbnRyeS53ZWlnaHQ7XG4gICAgdnNJbmRleCA9IGNvbnN1bWVVbnNvcnRhYmxlKHZzLCB1bnNvcnRhYmxlLCB2c0luZGV4KTtcbiAgfSk7XG5cbiAgdmFyIHJlc3VsdCA9IHsgdnM6IF8uZmxhdHRlbih2cywgdHJ1ZSkgfTtcbiAgaWYgKHdlaWdodCkge1xuICAgIHJlc3VsdC5iYXJ5Y2VudGVyID0gc3VtIC8gd2VpZ2h0O1xuICAgIHJlc3VsdC53ZWlnaHQgPSB3ZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY29uc3VtZVVuc29ydGFibGUodnMsIHVuc29ydGFibGUsIGluZGV4KSB7XG4gIHZhciBsYXN0O1xuICB3aGlsZSAodW5zb3J0YWJsZS5sZW5ndGggJiYgKGxhc3QgPSBfLmxhc3QodW5zb3J0YWJsZSkpLmkgPD0gaW5kZXgpIHtcbiAgICB1bnNvcnRhYmxlLnBvcCgpO1xuICAgIHZzLnB1c2gobGFzdC52cyk7XG4gICAgaW5kZXgrKztcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVXaXRoQmlhcyhiaWFzKSB7XG4gIHJldHVybiBmdW5jdGlvbihlbnRyeVYsIGVudHJ5Vykge1xuICAgIGlmIChlbnRyeVYuYmFyeWNlbnRlciA8IGVudHJ5Vy5iYXJ5Y2VudGVyKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChlbnRyeVYuYmFyeWNlbnRlciA+IGVudHJ5Vy5iYXJ5Y2VudGVyKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gIWJpYXMgPyBlbnRyeVYuaSAtIGVudHJ5Vy5pIDogZW50cnlXLmkgLSBlbnRyeVYuaTtcbiAgfTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3BhcmVudC1kdW1teS1jaGFpbnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcGFyZW50LWR1bW15LWNoYWlucy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudER1bW15Q2hhaW5zO1xuXG5mdW5jdGlvbiBwYXJlbnREdW1teUNoYWlucyhnKSB7XG4gIHZhciBwb3N0b3JkZXJOdW1zID0gcG9zdG9yZGVyKGcpO1xuXG4gIF8uZm9yRWFjaChnLmdyYXBoKCkuZHVtbXlDaGFpbnMsIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICB2YXIgZWRnZU9iaiA9IG5vZGUuZWRnZU9iajtcbiAgICB2YXIgcGF0aERhdGEgPSBmaW5kUGF0aChnLCBwb3N0b3JkZXJOdW1zLCBlZGdlT2JqLnYsIGVkZ2VPYmoudyk7XG4gICAgdmFyIHBhdGggPSBwYXRoRGF0YS5wYXRoO1xuICAgIHZhciBsY2EgPSBwYXRoRGF0YS5sY2E7XG4gICAgdmFyIHBhdGhJZHggPSAwO1xuICAgIHZhciBwYXRoViA9IHBhdGhbcGF0aElkeF07XG4gICAgdmFyIGFzY2VuZGluZyA9IHRydWU7XG5cbiAgICB3aGlsZSAodiAhPT0gZWRnZU9iai53KSB7XG4gICAgICBub2RlID0gZy5ub2RlKHYpO1xuXG4gICAgICBpZiAoYXNjZW5kaW5nKSB7XG4gICAgICAgIHdoaWxlICgocGF0aFYgPSBwYXRoW3BhdGhJZHhdKSAhPT0gbGNhICYmXG4gICAgICAgICAgICAgICBnLm5vZGUocGF0aFYpLm1heFJhbmsgPCBub2RlLnJhbmspIHtcbiAgICAgICAgICBwYXRoSWR4Kys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0aFYgPT09IGxjYSkge1xuICAgICAgICAgIGFzY2VuZGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYXNjZW5kaW5nKSB7XG4gICAgICAgIHdoaWxlIChwYXRoSWR4IDwgcGF0aC5sZW5ndGggLSAxICYmXG4gICAgICAgICAgICAgICBnLm5vZGUocGF0aFYgPSBwYXRoW3BhdGhJZHggKyAxXSkubWluUmFuayA8PSBub2RlLnJhbmspIHtcbiAgICAgICAgICBwYXRoSWR4Kys7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aFYgPSBwYXRoW3BhdGhJZHhdO1xuICAgICAgfVxuXG4gICAgICBnLnNldFBhcmVudCh2LCBwYXRoVik7XG4gICAgICB2ID0gZy5zdWNjZXNzb3JzKHYpWzBdO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIEZpbmQgYSBwYXRoIGZyb20gdiB0byB3IHRocm91Z2ggdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3IgKExDQSkuIFJldHVybiB0aGVcbi8vIGZ1bGwgcGF0aCBhbmQgdGhlIExDQS5cbmZ1bmN0aW9uIGZpbmRQYXRoKGcsIHBvc3RvcmRlck51bXMsIHYsIHcpIHtcbiAgdmFyIHZQYXRoID0gW107XG4gIHZhciB3UGF0aCA9IFtdO1xuICB2YXIgbG93ID0gTWF0aC5taW4ocG9zdG9yZGVyTnVtc1t2XS5sb3csIHBvc3RvcmRlck51bXNbd10ubG93KTtcbiAgdmFyIGxpbSA9IE1hdGgubWF4KHBvc3RvcmRlck51bXNbdl0ubGltLCBwb3N0b3JkZXJOdW1zW3ddLmxpbSk7XG4gIHZhciBwYXJlbnQ7XG4gIHZhciBsY2E7XG5cbiAgLy8gVHJhdmVyc2UgdXAgZnJvbSB2IHRvIGZpbmQgdGhlIExDQVxuICBwYXJlbnQgPSB2O1xuICBkbyB7XG4gICAgcGFyZW50ID0gZy5wYXJlbnQocGFyZW50KTtcbiAgICB2UGF0aC5wdXNoKHBhcmVudCk7XG4gIH0gd2hpbGUgKHBhcmVudCAmJlxuICAgICAgICAgICAocG9zdG9yZGVyTnVtc1twYXJlbnRdLmxvdyA+IGxvdyB8fCBsaW0gPiBwb3N0b3JkZXJOdW1zW3BhcmVudF0ubGltKSk7XG4gIGxjYSA9IHBhcmVudDtcblxuICAvLyBUcmF2ZXJzZSBmcm9tIHcgdG8gTENBXG4gIHBhcmVudCA9IHc7XG4gIHdoaWxlICgocGFyZW50ID0gZy5wYXJlbnQocGFyZW50KSkgIT09IGxjYSkge1xuICAgIHdQYXRoLnB1c2gocGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiB7IHBhdGg6IHZQYXRoLmNvbmNhdCh3UGF0aC5yZXZlcnNlKCkpLCBsY2E6IGxjYSB9O1xufVxuXG5mdW5jdGlvbiBwb3N0b3JkZXIoZykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBsaW0gPSAwO1xuXG4gIGZ1bmN0aW9uIGRmcyh2KSB7XG4gICAgdmFyIGxvdyA9IGxpbTtcbiAgICBfLmZvckVhY2goZy5jaGlsZHJlbih2KSwgZGZzKTtcbiAgICByZXN1bHRbdl0gPSB7IGxvdzogbG93LCBsaW06IGxpbSsrIH07XG4gIH1cbiAgXy5mb3JFYWNoKGcuY2hpbGRyZW4oKSwgZGZzKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcG9zaXRpb24vYmsuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3Bvc2l0aW9uL2JrLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2xvZGFzaC5qc1wiKTtcbnZhciBHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2dyYXBobGliICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9ncmFwaGxpYi5qc1wiKS5HcmFwaDtcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvdXRpbC5qc1wiKTtcblxuLypcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGNvb3JkaW5hdGUgYXNzaWdubWVudCBiYXNlZCBvbiBCcmFuZGVzIGFuZCBLw7ZwZiwgXCJGYXN0XG4gKiBhbmQgU2ltcGxlIEhvcml6b250YWwgQ29vcmRpbmF0ZSBBc3NpZ25tZW50LlwiXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBvc2l0aW9uWDogcG9zaXRpb25YLFxuICBmaW5kVHlwZTFDb25mbGljdHM6IGZpbmRUeXBlMUNvbmZsaWN0cyxcbiAgZmluZFR5cGUyQ29uZmxpY3RzOiBmaW5kVHlwZTJDb25mbGljdHMsXG4gIGFkZENvbmZsaWN0OiBhZGRDb25mbGljdCxcbiAgaGFzQ29uZmxpY3Q6IGhhc0NvbmZsaWN0LFxuICB2ZXJ0aWNhbEFsaWdubWVudDogdmVydGljYWxBbGlnbm1lbnQsXG4gIGhvcml6b250YWxDb21wYWN0aW9uOiBob3Jpem9udGFsQ29tcGFjdGlvbixcbiAgYWxpZ25Db29yZGluYXRlczogYWxpZ25Db29yZGluYXRlcyxcbiAgZmluZFNtYWxsZXN0V2lkdGhBbGlnbm1lbnQ6IGZpbmRTbWFsbGVzdFdpZHRoQWxpZ25tZW50LFxuICBiYWxhbmNlOiBiYWxhbmNlXG59O1xuXG4vKlxuICogTWFya3MgYWxsIGVkZ2VzIGluIHRoZSBncmFwaCB3aXRoIGEgdHlwZS0xIGNvbmZsaWN0IHdpdGggdGhlIFwidHlwZTFDb25mbGljdFwiXG4gKiBwcm9wZXJ0eS4gQSB0eXBlLTEgY29uZmxpY3QgaXMgb25lIHdoZXJlIGEgbm9uLWlubmVyIHNlZ21lbnQgY3Jvc3NlcyBhblxuICogaW5uZXIgc2VnbWVudC4gQW4gaW5uZXIgc2VnbWVudCBpcyBhbiBlZGdlIHdpdGggYm90aCBpbmNpZGVudCBub2RlcyBtYXJrZWRcbiAqIHdpdGggdGhlIFwiZHVtbXlcIiBwcm9wZXJ0eS5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBzY2FucyBsYXllciBieSBsYXllciwgc3RhcnRpbmcgd2l0aCB0aGUgc2Vjb25kLCBmb3IgdHlwZS0xXG4gKiBjb25mbGljdHMgYmV0d2VlbiB0aGUgY3VycmVudCBsYXllciBhbmQgdGhlIHByZXZpb3VzIGxheWVyLiBGb3IgZWFjaCBsYXllclxuICogaXQgc2NhbnMgdGhlIG5vZGVzIGZyb20gbGVmdCB0byByaWdodCB1bnRpbCBpdCByZWFjaGVzIG9uZSB0aGF0IGlzIGluY2lkZW50XG4gKiBvbiBhbiBpbm5lciBzZWdtZW50LiBJdCB0aGVuIHNjYW5zIHByZWRlY2Vzc29ycyB0byBkZXRlcm1pbmUgaWYgdGhleSBoYXZlXG4gKiBlZGdlcyB0aGF0IGNyb3NzIHRoYXQgaW5uZXIgc2VnbWVudC4gQXQgdGhlIGVuZCBhIGZpbmFsIHNjYW4gaXMgZG9uZSBmb3IgYWxsXG4gKiBub2RlcyBvbiB0aGUgY3VycmVudCByYW5rIHRvIHNlZSBpZiB0aGV5IGNyb3NzIHRoZSBsYXN0IHZpc2l0ZWQgaW5uZXJcbiAqIHNlZ21lbnQuXG4gKlxuICogVGhpcyBhbGdvcml0aG0gKHNhZmVseSkgYXNzdW1lcyB0aGF0IGEgZHVtbXkgbm9kZSB3aWxsIG9ubHkgYmUgaW5jaWRlbnQgb24gYVxuICogc2luZ2xlIG5vZGUgaW4gdGhlIGxheWVycyBiZWluZyBzY2FubmVkLlxuICovXG5mdW5jdGlvbiBmaW5kVHlwZTFDb25mbGljdHMoZywgbGF5ZXJpbmcpIHtcbiAgdmFyIGNvbmZsaWN0cyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHZpc2l0TGF5ZXIocHJldkxheWVyLCBsYXllcikge1xuICAgIHZhclxuICAgICAgLy8gbGFzdCB2aXNpdGVkIG5vZGUgaW4gdGhlIHByZXZpb3VzIGxheWVyIHRoYXQgaXMgaW5jaWRlbnQgb24gYW4gaW5uZXJcbiAgICAgIC8vIHNlZ21lbnQuXG4gICAgICBrMCA9IDAsXG4gICAgICAvLyBUcmFja3MgdGhlIGxhc3Qgbm9kZSBpbiB0aGlzIGxheWVyIHNjYW5uZWQgZm9yIGNyb3NzaW5ncyB3aXRoIGEgdHlwZS0xXG4gICAgICAvLyBzZWdtZW50LlxuICAgICAgc2NhblBvcyA9IDAsXG4gICAgICBwcmV2TGF5ZXJMZW5ndGggPSBwcmV2TGF5ZXIubGVuZ3RoLFxuICAgICAgbGFzdE5vZGUgPSBfLmxhc3QobGF5ZXIpO1xuXG4gICAgXy5mb3JFYWNoKGxheWVyLCBmdW5jdGlvbih2LCBpKSB7XG4gICAgICB2YXIgdyA9IGZpbmRPdGhlcklubmVyU2VnbWVudE5vZGUoZywgdiksXG4gICAgICAgIGsxID0gdyA/IGcubm9kZSh3KS5vcmRlciA6IHByZXZMYXllckxlbmd0aDtcblxuICAgICAgaWYgKHcgfHwgdiA9PT0gbGFzdE5vZGUpIHtcbiAgICAgICAgXy5mb3JFYWNoKGxheWVyLnNsaWNlKHNjYW5Qb3MsIGkgKzEpLCBmdW5jdGlvbihzY2FuTm9kZSkge1xuICAgICAgICAgIF8uZm9yRWFjaChnLnByZWRlY2Vzc29ycyhzY2FuTm9kZSksIGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgICAgIHZhciB1TGFiZWwgPSBnLm5vZGUodSksXG4gICAgICAgICAgICAgIHVQb3MgPSB1TGFiZWwub3JkZXI7XG4gICAgICAgICAgICBpZiAoKHVQb3MgPCBrMCB8fCBrMSA8IHVQb3MpICYmXG4gICAgICAgICAgICAgICAgISh1TGFiZWwuZHVtbXkgJiYgZy5ub2RlKHNjYW5Ob2RlKS5kdW1teSkpIHtcbiAgICAgICAgICAgICAgYWRkQ29uZmxpY3QoY29uZmxpY3RzLCB1LCBzY2FuTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzY2FuUG9zID0gaSArIDE7XG4gICAgICAgIGswID0gazE7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbGF5ZXI7XG4gIH1cblxuICBfLnJlZHVjZShsYXllcmluZywgdmlzaXRMYXllcik7XG4gIHJldHVybiBjb25mbGljdHM7XG59XG5cbmZ1bmN0aW9uIGZpbmRUeXBlMkNvbmZsaWN0cyhnLCBsYXllcmluZykge1xuICB2YXIgY29uZmxpY3RzID0ge307XG5cbiAgZnVuY3Rpb24gc2Nhbihzb3V0aCwgc291dGhQb3MsIHNvdXRoRW5kLCBwcmV2Tm9ydGhCb3JkZXIsIG5leHROb3J0aEJvcmRlcikge1xuICAgIHZhciB2O1xuICAgIF8uZm9yRWFjaChfLnJhbmdlKHNvdXRoUG9zLCBzb3V0aEVuZCksIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHYgPSBzb3V0aFtpXTtcbiAgICAgIGlmIChnLm5vZGUodikuZHVtbXkpIHtcbiAgICAgICAgXy5mb3JFYWNoKGcucHJlZGVjZXNzb3JzKHYpLCBmdW5jdGlvbih1KSB7XG4gICAgICAgICAgdmFyIHVOb2RlID0gZy5ub2RlKHUpO1xuICAgICAgICAgIGlmICh1Tm9kZS5kdW1teSAmJlxuICAgICAgICAgICAgICAodU5vZGUub3JkZXIgPCBwcmV2Tm9ydGhCb3JkZXIgfHwgdU5vZGUub3JkZXIgPiBuZXh0Tm9ydGhCb3JkZXIpKSB7XG4gICAgICAgICAgICBhZGRDb25mbGljdChjb25mbGljdHMsIHUsIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHZpc2l0TGF5ZXIobm9ydGgsIHNvdXRoKSB7XG4gICAgdmFyIHByZXZOb3J0aFBvcyA9IC0xLFxuICAgICAgbmV4dE5vcnRoUG9zLFxuICAgICAgc291dGhQb3MgPSAwO1xuXG4gICAgXy5mb3JFYWNoKHNvdXRoLCBmdW5jdGlvbih2LCBzb3V0aExvb2thaGVhZCkge1xuICAgICAgaWYgKGcubm9kZSh2KS5kdW1teSA9PT0gXCJib3JkZXJcIikge1xuICAgICAgICB2YXIgcHJlZGVjZXNzb3JzID0gZy5wcmVkZWNlc3NvcnModik7XG4gICAgICAgIGlmIChwcmVkZWNlc3NvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgbmV4dE5vcnRoUG9zID0gZy5ub2RlKHByZWRlY2Vzc29yc1swXSkub3JkZXI7XG4gICAgICAgICAgc2Nhbihzb3V0aCwgc291dGhQb3MsIHNvdXRoTG9va2FoZWFkLCBwcmV2Tm9ydGhQb3MsIG5leHROb3J0aFBvcyk7XG4gICAgICAgICAgc291dGhQb3MgPSBzb3V0aExvb2thaGVhZDtcbiAgICAgICAgICBwcmV2Tm9ydGhQb3MgPSBuZXh0Tm9ydGhQb3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNjYW4oc291dGgsIHNvdXRoUG9zLCBzb3V0aC5sZW5ndGgsIG5leHROb3J0aFBvcywgbm9ydGgubGVuZ3RoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzb3V0aDtcbiAgfVxuXG4gIF8ucmVkdWNlKGxheWVyaW5nLCB2aXNpdExheWVyKTtcbiAgcmV0dXJuIGNvbmZsaWN0cztcbn1cblxuZnVuY3Rpb24gZmluZE90aGVySW5uZXJTZWdtZW50Tm9kZShnLCB2KSB7XG4gIGlmIChnLm5vZGUodikuZHVtbXkpIHtcbiAgICByZXR1cm4gXy5maW5kKGcucHJlZGVjZXNzb3JzKHYpLCBmdW5jdGlvbih1KSB7XG4gICAgICByZXR1cm4gZy5ub2RlKHUpLmR1bW15O1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZENvbmZsaWN0KGNvbmZsaWN0cywgdiwgdykge1xuICBpZiAodiA+IHcpIHtcbiAgICB2YXIgdG1wID0gdjtcbiAgICB2ID0gdztcbiAgICB3ID0gdG1wO1xuICB9XG5cbiAgdmFyIGNvbmZsaWN0c1YgPSBjb25mbGljdHNbdl07XG4gIGlmICghY29uZmxpY3RzVikge1xuICAgIGNvbmZsaWN0c1t2XSA9IGNvbmZsaWN0c1YgPSB7fTtcbiAgfVxuICBjb25mbGljdHNWW3ddID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaGFzQ29uZmxpY3QoY29uZmxpY3RzLCB2LCB3KSB7XG4gIGlmICh2ID4gdykge1xuICAgIHZhciB0bXAgPSB2O1xuICAgIHYgPSB3O1xuICAgIHcgPSB0bXA7XG4gIH1cbiAgcmV0dXJuIF8uaGFzKGNvbmZsaWN0c1t2XSwgdyk7XG59XG5cbi8qXG4gKiBUcnkgdG8gYWxpZ24gbm9kZXMgaW50byB2ZXJ0aWNhbCBcImJsb2Nrc1wiIHdoZXJlIHBvc3NpYmxlLiBUaGlzIGFsZ29yaXRobVxuICogYXR0ZW1wdHMgdG8gYWxpZ24gYSBub2RlIHdpdGggb25lIG9mIGl0cyBtZWRpYW4gbmVpZ2hib3JzLiBJZiB0aGUgZWRnZVxuICogY29ubmVjdGluZyBhIG5laWdoYm9yIGlzIGEgdHlwZS0xIGNvbmZsaWN0IHRoZW4gd2UgaWdub3JlIHRoYXQgcG9zc2liaWxpdHkuXG4gKiBJZiBhIHByZXZpb3VzIG5vZGUgaGFzIGFscmVhZHkgZm9ybWVkIGEgYmxvY2sgd2l0aCBhIG5vZGUgYWZ0ZXIgdGhlIG5vZGVcbiAqIHdlJ3JlIHRyeWluZyB0byBmb3JtIGEgYmxvY2sgd2l0aCwgd2UgYWxzbyBpZ25vcmUgdGhhdCBwb3NzaWJpbGl0eSAtIG91clxuICogYmxvY2tzIHdvdWxkIGJlIHNwbGl0IGluIHRoYXQgc2NlbmFyaW8uXG4gKi9cbmZ1bmN0aW9uIHZlcnRpY2FsQWxpZ25tZW50KGcsIGxheWVyaW5nLCBjb25mbGljdHMsIG5laWdoYm9yRm4pIHtcbiAgdmFyIHJvb3QgPSB7fSxcbiAgICBhbGlnbiA9IHt9LFxuICAgIHBvcyA9IHt9O1xuXG4gIC8vIFdlIGNhY2hlIHRoZSBwb3NpdGlvbiBoZXJlIGJhc2VkIG9uIHRoZSBsYXllcmluZyBiZWNhdXNlIHRoZSBncmFwaCBhbmRcbiAgLy8gbGF5ZXJpbmcgbWF5IGJlIG91dCBvZiBzeW5jLiBUaGUgbGF5ZXJpbmcgbWF0cml4IGlzIG1hbmlwdWxhdGVkIHRvXG4gIC8vIGdlbmVyYXRlIGRpZmZlcmVudCBleHRyZW1lIGFsaWdubWVudHMuXG4gIF8uZm9yRWFjaChsYXllcmluZywgZnVuY3Rpb24obGF5ZXIpIHtcbiAgICBfLmZvckVhY2gobGF5ZXIsIGZ1bmN0aW9uKHYsIG9yZGVyKSB7XG4gICAgICByb290W3ZdID0gdjtcbiAgICAgIGFsaWduW3ZdID0gdjtcbiAgICAgIHBvc1t2XSA9IG9yZGVyO1xuICAgIH0pO1xuICB9KTtcblxuICBfLmZvckVhY2gobGF5ZXJpbmcsIGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgdmFyIHByZXZJZHggPSAtMTtcbiAgICBfLmZvckVhY2gobGF5ZXIsIGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhciB3cyA9IG5laWdoYm9yRm4odik7XG4gICAgICBpZiAod3MubGVuZ3RoKSB7XG4gICAgICAgIHdzID0gXy5zb3J0Qnkod3MsIGZ1bmN0aW9uKHcpIHsgcmV0dXJuIHBvc1t3XTsgfSk7XG4gICAgICAgIHZhciBtcCA9ICh3cy5sZW5ndGggLSAxKSAvIDI7XG4gICAgICAgIGZvciAodmFyIGkgPSBNYXRoLmZsb29yKG1wKSwgaWwgPSBNYXRoLmNlaWwobXApOyBpIDw9IGlsOyArK2kpIHtcbiAgICAgICAgICB2YXIgdyA9IHdzW2ldO1xuICAgICAgICAgIGlmIChhbGlnblt2XSA9PT0gdiAmJlxuICAgICAgICAgICAgICBwcmV2SWR4IDwgcG9zW3ddICYmXG4gICAgICAgICAgICAgICFoYXNDb25mbGljdChjb25mbGljdHMsIHYsIHcpKSB7XG4gICAgICAgICAgICBhbGlnblt3XSA9IHY7XG4gICAgICAgICAgICBhbGlnblt2XSA9IHJvb3Rbdl0gPSByb290W3ddO1xuICAgICAgICAgICAgcHJldklkeCA9IHBvc1t3XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgcm9vdDogcm9vdCwgYWxpZ246IGFsaWduIH07XG59XG5cbmZ1bmN0aW9uIGhvcml6b250YWxDb21wYWN0aW9uKGcsIGxheWVyaW5nLCByb290LCBhbGlnbiwgcmV2ZXJzZVNlcCkge1xuICAvLyBUaGlzIHBvcnRpb24gb2YgdGhlIGFsZ29yaXRobSBkaWZmZXJzIGZyb20gQksgZHVlIHRvIGEgbnVtYmVyIG9mIHByb2JsZW1zLlxuICAvLyBJbnN0ZWFkIG9mIHRoZWlyIGFsZ29yaXRobSB3ZSBjb25zdHJ1Y3QgYSBuZXcgYmxvY2sgZ3JhcGggYW5kIGRvIHR3b1xuICAvLyBzd2VlcHMuIFRoZSBmaXJzdCBzd2VlcCBwbGFjZXMgYmxvY2tzIHdpdGggdGhlIHNtYWxsZXN0IHBvc3NpYmxlXG4gIC8vIGNvb3JkaW5hdGVzLiBUaGUgc2Vjb25kIHN3ZWVwIHJlbW92ZXMgdW51c2VkIHNwYWNlIGJ5IG1vdmluZyBibG9ja3MgdG8gdGhlXG4gIC8vIGdyZWF0ZXN0IGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlvbGF0aW5nIHNlcGFyYXRpb24uXG4gIHZhciB4cyA9IHt9LFxuICAgIGJsb2NrRyA9IGJ1aWxkQmxvY2tHcmFwaChnLCBsYXllcmluZywgcm9vdCwgcmV2ZXJzZVNlcCksXG4gICAgYm9yZGVyVHlwZSA9IHJldmVyc2VTZXAgPyBcImJvcmRlckxlZnRcIiA6IFwiYm9yZGVyUmlnaHRcIjtcblxuICBmdW5jdGlvbiBpdGVyYXRlKHNldFhzRnVuYywgbmV4dE5vZGVzRnVuYykge1xuICAgIHZhciBzdGFjayA9IGJsb2NrRy5ub2RlcygpO1xuICAgIHZhciBlbGVtID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgICB3aGlsZSAoZWxlbSkge1xuICAgICAgaWYgKHZpc2l0ZWRbZWxlbV0pIHtcbiAgICAgICAgc2V0WHNGdW5jKGVsZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlzaXRlZFtlbGVtXSA9IHRydWU7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbSk7XG4gICAgICAgIHN0YWNrID0gc3RhY2suY29uY2F0KG5leHROb2Rlc0Z1bmMoZWxlbSkpO1xuICAgICAgfVxuXG4gICAgICBlbGVtID0gc3RhY2sucG9wKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRmlyc3QgcGFzcywgYXNzaWduIHNtYWxsZXN0IGNvb3JkaW5hdGVzXG4gIGZ1bmN0aW9uIHBhc3MxKGVsZW0pIHtcbiAgICB4c1tlbGVtXSA9IGJsb2NrRy5pbkVkZ2VzKGVsZW0pLnJlZHVjZShmdW5jdGlvbihhY2MsIGUpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChhY2MsIHhzW2Uudl0gKyBibG9ja0cuZWRnZShlKSk7XG4gICAgfSwgMCk7XG4gIH1cblxuICAvLyBTZWNvbmQgcGFzcywgYXNzaWduIGdyZWF0ZXN0IGNvb3JkaW5hdGVzXG4gIGZ1bmN0aW9uIHBhc3MyKGVsZW0pIHtcbiAgICB2YXIgbWluID0gYmxvY2tHLm91dEVkZ2VzKGVsZW0pLnJlZHVjZShmdW5jdGlvbihhY2MsIGUpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihhY2MsIHhzW2Uud10gLSBibG9ja0cuZWRnZShlKSk7XG4gICAgfSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcblxuICAgIHZhciBub2RlID0gZy5ub2RlKGVsZW0pO1xuICAgIGlmIChtaW4gIT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJiBub2RlLmJvcmRlclR5cGUgIT09IGJvcmRlclR5cGUpIHtcbiAgICAgIHhzW2VsZW1dID0gTWF0aC5tYXgoeHNbZWxlbV0sIG1pbik7XG4gICAgfVxuICB9XG5cbiAgaXRlcmF0ZShwYXNzMSwgYmxvY2tHLnByZWRlY2Vzc29ycy5iaW5kKGJsb2NrRykpO1xuICBpdGVyYXRlKHBhc3MyLCBibG9ja0cuc3VjY2Vzc29ycy5iaW5kKGJsb2NrRykpO1xuXG4gIC8vIEFzc2lnbiB4IGNvb3JkaW5hdGVzIHRvIGFsbCBub2Rlc1xuICBfLmZvckVhY2goYWxpZ24sIGZ1bmN0aW9uKHYpIHtcbiAgICB4c1t2XSA9IHhzW3Jvb3Rbdl1dO1xuICB9KTtcblxuICByZXR1cm4geHM7XG59XG5cblxuZnVuY3Rpb24gYnVpbGRCbG9ja0dyYXBoKGcsIGxheWVyaW5nLCByb290LCByZXZlcnNlU2VwKSB7XG4gIHZhciBibG9ja0dyYXBoID0gbmV3IEdyYXBoKCksXG4gICAgZ3JhcGhMYWJlbCA9IGcuZ3JhcGgoKSxcbiAgICBzZXBGbiA9IHNlcChncmFwaExhYmVsLm5vZGVzZXAsIGdyYXBoTGFiZWwuZWRnZXNlcCwgcmV2ZXJzZVNlcCk7XG5cbiAgXy5mb3JFYWNoKGxheWVyaW5nLCBmdW5jdGlvbihsYXllcikge1xuICAgIHZhciB1O1xuICAgIF8uZm9yRWFjaChsYXllciwgZnVuY3Rpb24odikge1xuICAgICAgdmFyIHZSb290ID0gcm9vdFt2XTtcbiAgICAgIGJsb2NrR3JhcGguc2V0Tm9kZSh2Um9vdCk7XG4gICAgICBpZiAodSkge1xuICAgICAgICB2YXIgdVJvb3QgPSByb290W3VdLFxuICAgICAgICAgIHByZXZNYXggPSBibG9ja0dyYXBoLmVkZ2UodVJvb3QsIHZSb290KTtcbiAgICAgICAgYmxvY2tHcmFwaC5zZXRFZGdlKHVSb290LCB2Um9vdCwgTWF0aC5tYXgoc2VwRm4oZywgdiwgdSksIHByZXZNYXggfHwgMCkpO1xuICAgICAgfVxuICAgICAgdSA9IHY7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBibG9ja0dyYXBoO1xufVxuXG4vKlxuICogUmV0dXJucyB0aGUgYWxpZ25tZW50IHRoYXQgaGFzIHRoZSBzbWFsbGVzdCB3aWR0aCBvZiB0aGUgZ2l2ZW4gYWxpZ25tZW50cy5cbiAqL1xuZnVuY3Rpb24gZmluZFNtYWxsZXN0V2lkdGhBbGlnbm1lbnQoZywgeHNzKSB7XG4gIHJldHVybiBfLm1pbkJ5KF8udmFsdWVzKHhzcyksIGZ1bmN0aW9uICh4cykge1xuICAgIHZhciBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAgIF8uZm9ySW4oeHMsIGZ1bmN0aW9uICh4LCB2KSB7XG4gICAgICB2YXIgaGFsZldpZHRoID0gd2lkdGgoZywgdikgLyAyO1xuXG4gICAgICBtYXggPSBNYXRoLm1heCh4ICsgaGFsZldpZHRoLCBtYXgpO1xuICAgICAgbWluID0gTWF0aC5taW4oeCAtIGhhbGZXaWR0aCwgbWluKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBtYXggLSBtaW47XG4gIH0pO1xufVxuXG4vKlxuICogQWxpZ24gdGhlIGNvb3JkaW5hdGVzIG9mIGVhY2ggb2YgdGhlIGxheW91dCBhbGlnbm1lbnRzIHN1Y2ggdGhhdFxuICogbGVmdC1iaWFzZWQgYWxpZ25tZW50cyBoYXZlIHRoZWlyIG1pbmltdW0gY29vcmRpbmF0ZSBhdCB0aGUgc2FtZSBwb2ludCBhc1xuICogdGhlIG1pbmltdW0gY29vcmRpbmF0ZSBvZiB0aGUgc21hbGxlc3Qgd2lkdGggYWxpZ25tZW50IGFuZCByaWdodC1iaWFzZWRcbiAqIGFsaWdubWVudHMgaGF2ZSB0aGVpciBtYXhpbXVtIGNvb3JkaW5hdGUgYXQgdGhlIHNhbWUgcG9pbnQgYXMgdGhlIG1heGltdW1cbiAqIGNvb3JkaW5hdGUgb2YgdGhlIHNtYWxsZXN0IHdpZHRoIGFsaWdubWVudC5cbiAqL1xuZnVuY3Rpb24gYWxpZ25Db29yZGluYXRlcyh4c3MsIGFsaWduVG8pIHtcbiAgdmFyIGFsaWduVG9WYWxzID0gXy52YWx1ZXMoYWxpZ25UbyksXG4gICAgYWxpZ25Ub01pbiA9IF8ubWluKGFsaWduVG9WYWxzKSxcbiAgICBhbGlnblRvTWF4ID0gXy5tYXgoYWxpZ25Ub1ZhbHMpO1xuXG4gIF8uZm9yRWFjaChbXCJ1XCIsIFwiZFwiXSwgZnVuY3Rpb24odmVydCkge1xuICAgIF8uZm9yRWFjaChbXCJsXCIsIFwiclwiXSwgZnVuY3Rpb24oaG9yaXopIHtcbiAgICAgIHZhciBhbGlnbm1lbnQgPSB2ZXJ0ICsgaG9yaXosXG4gICAgICAgIHhzID0geHNzW2FsaWdubWVudF0sXG4gICAgICAgIGRlbHRhO1xuICAgICAgaWYgKHhzID09PSBhbGlnblRvKSByZXR1cm47XG5cbiAgICAgIHZhciB4c1ZhbHMgPSBfLnZhbHVlcyh4cyk7XG4gICAgICBkZWx0YSA9IGhvcml6ID09PSBcImxcIiA/IGFsaWduVG9NaW4gLSBfLm1pbih4c1ZhbHMpIDogYWxpZ25Ub01heCAtIF8ubWF4KHhzVmFscyk7XG5cbiAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICB4c3NbYWxpZ25tZW50XSA9IF8ubWFwVmFsdWVzKHhzLCBmdW5jdGlvbih4KSB7IHJldHVybiB4ICsgZGVsdGE7IH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYmFsYW5jZSh4c3MsIGFsaWduKSB7XG4gIHJldHVybiBfLm1hcFZhbHVlcyh4c3MudWwsIGZ1bmN0aW9uKGlnbm9yZSwgdikge1xuICAgIGlmIChhbGlnbikge1xuICAgICAgcmV0dXJuIHhzc1thbGlnbi50b0xvd2VyQ2FzZSgpXVt2XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHhzID0gXy5zb3J0QnkoXy5tYXAoeHNzLCB2KSk7XG4gICAgICByZXR1cm4gKHhzWzFdICsgeHNbMl0pIC8gMjtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwb3NpdGlvblgoZykge1xuICB2YXIgbGF5ZXJpbmcgPSB1dGlsLmJ1aWxkTGF5ZXJNYXRyaXgoZyk7XG4gIHZhciBjb25mbGljdHMgPSBfLm1lcmdlKFxuICAgIGZpbmRUeXBlMUNvbmZsaWN0cyhnLCBsYXllcmluZyksXG4gICAgZmluZFR5cGUyQ29uZmxpY3RzKGcsIGxheWVyaW5nKSk7XG5cbiAgdmFyIHhzcyA9IHt9O1xuICB2YXIgYWRqdXN0ZWRMYXllcmluZztcbiAgXy5mb3JFYWNoKFtcInVcIiwgXCJkXCJdLCBmdW5jdGlvbih2ZXJ0KSB7XG4gICAgYWRqdXN0ZWRMYXllcmluZyA9IHZlcnQgPT09IFwidVwiID8gbGF5ZXJpbmcgOiBfLnZhbHVlcyhsYXllcmluZykucmV2ZXJzZSgpO1xuICAgIF8uZm9yRWFjaChbXCJsXCIsIFwiclwiXSwgZnVuY3Rpb24oaG9yaXopIHtcbiAgICAgIGlmIChob3JpeiA9PT0gXCJyXCIpIHtcbiAgICAgICAgYWRqdXN0ZWRMYXllcmluZyA9IF8ubWFwKGFkanVzdGVkTGF5ZXJpbmcsIGZ1bmN0aW9uKGlubmVyKSB7XG4gICAgICAgICAgcmV0dXJuIF8udmFsdWVzKGlubmVyKS5yZXZlcnNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmVpZ2hib3JGbiA9ICh2ZXJ0ID09PSBcInVcIiA/IGcucHJlZGVjZXNzb3JzIDogZy5zdWNjZXNzb3JzKS5iaW5kKGcpO1xuICAgICAgdmFyIGFsaWduID0gdmVydGljYWxBbGlnbm1lbnQoZywgYWRqdXN0ZWRMYXllcmluZywgY29uZmxpY3RzLCBuZWlnaGJvckZuKTtcbiAgICAgIHZhciB4cyA9IGhvcml6b250YWxDb21wYWN0aW9uKGcsIGFkanVzdGVkTGF5ZXJpbmcsXG4gICAgICAgIGFsaWduLnJvb3QsIGFsaWduLmFsaWduLCBob3JpeiA9PT0gXCJyXCIpO1xuICAgICAgaWYgKGhvcml6ID09PSBcInJcIikge1xuICAgICAgICB4cyA9IF8ubWFwVmFsdWVzKHhzLCBmdW5jdGlvbih4KSB7IHJldHVybiAteDsgfSk7XG4gICAgICB9XG4gICAgICB4c3NbdmVydCArIGhvcml6XSA9IHhzO1xuICAgIH0pO1xuICB9KTtcblxuICB2YXIgc21hbGxlc3RXaWR0aCA9IGZpbmRTbWFsbGVzdFdpZHRoQWxpZ25tZW50KGcsIHhzcyk7XG4gIGFsaWduQ29vcmRpbmF0ZXMoeHNzLCBzbWFsbGVzdFdpZHRoKTtcbiAgcmV0dXJuIGJhbGFuY2UoeHNzLCBnLmdyYXBoKCkuYWxpZ24pO1xufVxuXG5mdW5jdGlvbiBzZXAobm9kZVNlcCwgZWRnZVNlcCwgcmV2ZXJzZVNlcCkge1xuICByZXR1cm4gZnVuY3Rpb24oZywgdiwgdykge1xuICAgIHZhciB2TGFiZWwgPSBnLm5vZGUodik7XG4gICAgdmFyIHdMYWJlbCA9IGcubm9kZSh3KTtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgZGVsdGE7XG5cbiAgICBzdW0gKz0gdkxhYmVsLndpZHRoIC8gMjtcbiAgICBpZiAoXy5oYXModkxhYmVsLCBcImxhYmVscG9zXCIpKSB7XG4gICAgICBzd2l0Y2ggKHZMYWJlbC5sYWJlbHBvcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlIFwibFwiOiBkZWx0YSA9IC12TGFiZWwud2lkdGggLyAyOyBicmVhaztcbiAgICAgIGNhc2UgXCJyXCI6IGRlbHRhID0gdkxhYmVsLndpZHRoIC8gMjsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWx0YSkge1xuICAgICAgc3VtICs9IHJldmVyc2VTZXAgPyBkZWx0YSA6IC1kZWx0YTtcbiAgICB9XG4gICAgZGVsdGEgPSAwO1xuXG4gICAgc3VtICs9ICh2TGFiZWwuZHVtbXkgPyBlZGdlU2VwIDogbm9kZVNlcCkgLyAyO1xuICAgIHN1bSArPSAod0xhYmVsLmR1bW15ID8gZWRnZVNlcCA6IG5vZGVTZXApIC8gMjtcblxuICAgIHN1bSArPSB3TGFiZWwud2lkdGggLyAyO1xuICAgIGlmIChfLmhhcyh3TGFiZWwsIFwibGFiZWxwb3NcIikpIHtcbiAgICAgIHN3aXRjaCAod0xhYmVsLmxhYmVscG9zLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJsXCI6IGRlbHRhID0gd0xhYmVsLndpZHRoIC8gMjsgYnJlYWs7XG4gICAgICBjYXNlIFwiclwiOiBkZWx0YSA9IC13TGFiZWwud2lkdGggLyAyOyBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBzdW0gKz0gcmV2ZXJzZVNlcCA/IGRlbHRhIDogLWRlbHRhO1xuICAgIH1cbiAgICBkZWx0YSA9IDA7XG5cbiAgICByZXR1cm4gc3VtO1xuICB9O1xufVxuXG5mdW5jdGlvbiB3aWR0aChnLCB2KSB7XG4gIHJldHVybiBnLm5vZGUodikud2lkdGg7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9wb3NpdGlvbi9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcG9zaXRpb24vaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi91dGlsLmpzXCIpO1xudmFyIHBvc2l0aW9uWCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYmsgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3Bvc2l0aW9uL2JrLmpzXCIpLnBvc2l0aW9uWDtcblxubW9kdWxlLmV4cG9ydHMgPSBwb3NpdGlvbjtcblxuZnVuY3Rpb24gcG9zaXRpb24oZykge1xuICBnID0gdXRpbC5hc05vbkNvbXBvdW5kR3JhcGgoZyk7XG5cbiAgcG9zaXRpb25ZKGcpO1xuICBfLmZvckVhY2gocG9zaXRpb25YKGcpLCBmdW5jdGlvbih4LCB2KSB7XG4gICAgZy5ub2RlKHYpLnggPSB4O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcG9zaXRpb25ZKGcpIHtcbiAgdmFyIGxheWVyaW5nID0gdXRpbC5idWlsZExheWVyTWF0cml4KGcpO1xuICB2YXIgcmFua1NlcCA9IGcuZ3JhcGgoKS5yYW5rc2VwO1xuICB2YXIgcHJldlkgPSAwO1xuICBfLmZvckVhY2gobGF5ZXJpbmcsIGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgdmFyIG1heEhlaWdodCA9IF8ubWF4KF8ubWFwKGxheWVyLCBmdW5jdGlvbih2KSB7IHJldHVybiBnLm5vZGUodikuaGVpZ2h0OyB9KSk7XG4gICAgXy5mb3JFYWNoKGxheWVyLCBmdW5jdGlvbih2KSB7XG4gICAgICBnLm5vZGUodikueSA9IHByZXZZICsgbWF4SGVpZ2h0IC8gMjtcbiAgICB9KTtcbiAgICBwcmV2WSArPSBtYXhIZWlnaHQgKyByYW5rU2VwO1xuICB9KTtcbn1cblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcmFuay9mZWFzaWJsZS10cmVlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcmFuay9mZWFzaWJsZS10cmVlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG52YXIgR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ncmFwaGxpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvZ3JhcGhsaWIuanNcIikuR3JhcGg7XG52YXIgc2xhY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3JhbmsvdXRpbC5qc1wiKS5zbGFjaztcblxubW9kdWxlLmV4cG9ydHMgPSBmZWFzaWJsZVRyZWU7XG5cbi8qXG4gKiBDb25zdHJ1Y3RzIGEgc3Bhbm5pbmcgdHJlZSB3aXRoIHRpZ2h0IGVkZ2VzIGFuZCBhZGp1c3RlZCB0aGUgaW5wdXQgbm9kZSdzXG4gKiByYW5rcyB0byBhY2hpZXZlIHRoaXMuIEEgdGlnaHQgZWRnZSBpcyBvbmUgdGhhdCBpcyBoYXMgYSBsZW5ndGggdGhhdCBtYXRjaGVzXG4gKiBpdHMgXCJtaW5sZW5cIiBhdHRyaWJ1dGUuXG4gKlxuICogVGhlIGJhc2ljIHN0cnVjdHVyZSBmb3IgdGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gR2Fuc25lciwgZXQgYWwuLCBcIkFcbiAqIFRlY2huaXF1ZSBmb3IgRHJhd2luZyBEaXJlY3RlZCBHcmFwaHMuXCJcbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBHcmFwaCBtdXN0IGJlIGEgREFHLlxuICogICAgMi4gR3JhcGggbXVzdCBiZSBjb25uZWN0ZWQuXG4gKiAgICAzLiBHcmFwaCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIG5vZGUuXG4gKiAgICA1LiBHcmFwaCBub2RlcyBtdXN0IGhhdmUgYmVlbiBwcmV2aW91c2x5IGFzc2lnbmVkIGEgXCJyYW5rXCIgcHJvcGVydHkgdGhhdFxuICogICAgICAgcmVzcGVjdHMgdGhlIFwibWlubGVuXCIgcHJvcGVydHkgb2YgaW5jaWRlbnQgZWRnZXMuXG4gKiAgICA2LiBHcmFwaCBlZGdlcyBtdXN0IGhhdmUgYSBcIm1pbmxlblwiIHByb3BlcnR5LlxuICpcbiAqIFBvc3QtY29uZGl0aW9uczpcbiAqXG4gKiAgICAtIEdyYXBoIG5vZGVzIHdpbGwgaGF2ZSB0aGVpciByYW5rIGFkanVzdGVkIHRvIGVuc3VyZSB0aGF0IGFsbCBlZGdlcyBhcmVcbiAqICAgICAgdGlnaHQuXG4gKlxuICogUmV0dXJucyBhIHRyZWUgKHVuZGlyZWN0ZWQgZ3JhcGgpIHRoYXQgaXMgY29uc3RydWN0ZWQgdXNpbmcgb25seSBcInRpZ2h0XCJcbiAqIGVkZ2VzLlxuICovXG5mdW5jdGlvbiBmZWFzaWJsZVRyZWUoZykge1xuICB2YXIgdCA9IG5ldyBHcmFwaCh7IGRpcmVjdGVkOiBmYWxzZSB9KTtcblxuICAvLyBDaG9vc2UgYXJiaXRyYXJ5IG5vZGUgZnJvbSB3aGljaCB0byBzdGFydCBvdXIgdHJlZVxuICB2YXIgc3RhcnQgPSBnLm5vZGVzKClbMF07XG4gIHZhciBzaXplID0gZy5ub2RlQ291bnQoKTtcbiAgdC5zZXROb2RlKHN0YXJ0LCB7fSk7XG5cbiAgdmFyIGVkZ2UsIGRlbHRhO1xuICB3aGlsZSAodGlnaHRUcmVlKHQsIGcpIDwgc2l6ZSkge1xuICAgIGVkZ2UgPSBmaW5kTWluU2xhY2tFZGdlKHQsIGcpO1xuICAgIGRlbHRhID0gdC5oYXNOb2RlKGVkZ2UudikgPyBzbGFjayhnLCBlZGdlKSA6IC1zbGFjayhnLCBlZGdlKTtcbiAgICBzaGlmdFJhbmtzKHQsIGcsIGRlbHRhKTtcbiAgfVxuXG4gIHJldHVybiB0O1xufVxuXG4vKlxuICogRmluZHMgYSBtYXhpbWFsIHRyZWUgb2YgdGlnaHQgZWRnZXMgYW5kIHJldHVybnMgdGhlIG51bWJlciBvZiBub2RlcyBpbiB0aGVcbiAqIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRpZ2h0VHJlZSh0LCBnKSB7XG4gIGZ1bmN0aW9uIGRmcyh2KSB7XG4gICAgXy5mb3JFYWNoKGcubm9kZUVkZ2VzKHYpLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgZWRnZVYgPSBlLnYsXG4gICAgICAgIHcgPSAodiA9PT0gZWRnZVYpID8gZS53IDogZWRnZVY7XG4gICAgICBpZiAoIXQuaGFzTm9kZSh3KSAmJiAhc2xhY2soZywgZSkpIHtcbiAgICAgICAgdC5zZXROb2RlKHcsIHt9KTtcbiAgICAgICAgdC5zZXRFZGdlKHYsIHcsIHt9KTtcbiAgICAgICAgZGZzKHcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgXy5mb3JFYWNoKHQubm9kZXMoKSwgZGZzKTtcbiAgcmV0dXJuIHQubm9kZUNvdW50KCk7XG59XG5cbi8qXG4gKiBGaW5kcyB0aGUgZWRnZSB3aXRoIHRoZSBzbWFsbGVzdCBzbGFjayB0aGF0IGlzIGluY2lkZW50IG9uIHRyZWUgYW5kIHJldHVybnNcbiAqIGl0LlxuICovXG5mdW5jdGlvbiBmaW5kTWluU2xhY2tFZGdlKHQsIGcpIHtcbiAgcmV0dXJuIF8ubWluQnkoZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHQuaGFzTm9kZShlLnYpICE9PSB0Lmhhc05vZGUoZS53KSkge1xuICAgICAgcmV0dXJuIHNsYWNrKGcsIGUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNoaWZ0UmFua3ModCwgZywgZGVsdGEpIHtcbiAgXy5mb3JFYWNoKHQubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIGcubm9kZSh2KS5yYW5rICs9IGRlbHRhO1xuICB9KTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3JhbmsvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcmFuay9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHJhbmtVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9yYW5rL3V0aWwuanNcIik7XG52YXIgbG9uZ2VzdFBhdGggPSByYW5rVXRpbC5sb25nZXN0UGF0aDtcbnZhciBmZWFzaWJsZVRyZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZlYXNpYmxlLXRyZWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3JhbmsvZmVhc2libGUtdHJlZS5qc1wiKTtcbnZhciBuZXR3b3JrU2ltcGxleCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbmV0d29yay1zaW1wbGV4ICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9yYW5rL25ldHdvcmstc2ltcGxleC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSByYW5rO1xuXG4vKlxuICogQXNzaWducyBhIHJhbmsgdG8gZWFjaCBub2RlIGluIHRoZSBpbnB1dCBncmFwaCB0aGF0IHJlc3BlY3RzIHRoZSBcIm1pbmxlblwiXG4gKiBjb25zdHJhaW50IHNwZWNpZmllZCBvbiBlZGdlcyBiZXR3ZWVuIG5vZGVzLlxuICpcbiAqIFRoaXMgYmFzaWMgc3RydWN0dXJlIGlzIGRlcml2ZWQgZnJvbSBHYW5zbmVyLCBldCBhbC4sIFwiQSBUZWNobmlxdWUgZm9yXG4gKiBEcmF3aW5nIERpcmVjdGVkIEdyYXBocy5cIlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEdyYXBoIG11c3QgYmUgYSBjb25uZWN0ZWQgREFHXG4gKiAgICAyLiBHcmFwaCBub2RlcyBtdXN0IGJlIG9iamVjdHNcbiAqICAgIDMuIEdyYXBoIGVkZ2VzIG11c3QgaGF2ZSBcIndlaWdodFwiIGFuZCBcIm1pbmxlblwiIGF0dHJpYnV0ZXNcbiAqXG4gKiBQb3N0LWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gR3JhcGggbm9kZXMgd2lsbCBoYXZlIGEgXCJyYW5rXCIgYXR0cmlidXRlIGJhc2VkIG9uIHRoZSByZXN1bHRzIG9mIHRoZVxuICogICAgICAgYWxnb3JpdGhtLiBSYW5rcyBjYW4gc3RhcnQgYXQgYW55IGluZGV4IChpbmNsdWRpbmcgbmVnYXRpdmUpLCB3ZSdsbFxuICogICAgICAgZml4IHRoZW0gdXAgbGF0ZXIuXG4gKi9cbmZ1bmN0aW9uIHJhbmsoZykge1xuICBzd2l0Y2goZy5ncmFwaCgpLnJhbmtlcikge1xuICBjYXNlIFwibmV0d29yay1zaW1wbGV4XCI6IG5ldHdvcmtTaW1wbGV4UmFua2VyKGcpOyBicmVhaztcbiAgY2FzZSBcInRpZ2h0LXRyZWVcIjogdGlnaHRUcmVlUmFua2VyKGcpOyBicmVhaztcbiAgY2FzZSBcImxvbmdlc3QtcGF0aFwiOiBsb25nZXN0UGF0aFJhbmtlcihnKTsgYnJlYWs7XG4gIGRlZmF1bHQ6IG5ldHdvcmtTaW1wbGV4UmFua2VyKGcpO1xuICB9XG59XG5cbi8vIEEgZmFzdCBhbmQgc2ltcGxlIHJhbmtlciwgYnV0IHJlc3VsdHMgYXJlIGZhciBmcm9tIG9wdGltYWwuXG52YXIgbG9uZ2VzdFBhdGhSYW5rZXIgPSBsb25nZXN0UGF0aDtcblxuZnVuY3Rpb24gdGlnaHRUcmVlUmFua2VyKGcpIHtcbiAgbG9uZ2VzdFBhdGgoZyk7XG4gIGZlYXNpYmxlVHJlZShnKTtcbn1cblxuZnVuY3Rpb24gbmV0d29ya1NpbXBsZXhSYW5rZXIoZykge1xuICBuZXR3b3JrU2ltcGxleChnKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3JhbmsvbmV0d29yay1zaW1wbGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9yYW5rL25ldHdvcmstc2ltcGxleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG52YXIgZmVhc2libGVUcmVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mZWFzaWJsZS10cmVlICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9yYW5rL2ZlYXNpYmxlLXRyZWUuanNcIik7XG52YXIgc2xhY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3JhbmsvdXRpbC5qc1wiKS5zbGFjaztcbnZhciBpbml0UmFuayA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcmFuay91dGlsLmpzXCIpLmxvbmdlc3RQYXRoO1xudmFyIHByZW9yZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZ3JhcGhsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2dyYXBobGliLmpzXCIpLmFsZy5wcmVvcmRlcjtcbnZhciBwb3N0b3JkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ncmFwaGxpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvZ3JhcGhsaWIuanNcIikuYWxnLnBvc3RvcmRlcjtcbnZhciBzaW1wbGlmeSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3V0aWwuanNcIikuc2ltcGxpZnk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV0d29ya1NpbXBsZXg7XG5cbi8vIEV4cG9zZSBzb21lIGludGVybmFscyBmb3IgdGVzdGluZyBwdXJwb3Nlc1xubmV0d29ya1NpbXBsZXguaW5pdExvd0xpbVZhbHVlcyA9IGluaXRMb3dMaW1WYWx1ZXM7XG5uZXR3b3JrU2ltcGxleC5pbml0Q3V0VmFsdWVzID0gaW5pdEN1dFZhbHVlcztcbm5ldHdvcmtTaW1wbGV4LmNhbGNDdXRWYWx1ZSA9IGNhbGNDdXRWYWx1ZTtcbm5ldHdvcmtTaW1wbGV4LmxlYXZlRWRnZSA9IGxlYXZlRWRnZTtcbm5ldHdvcmtTaW1wbGV4LmVudGVyRWRnZSA9IGVudGVyRWRnZTtcbm5ldHdvcmtTaW1wbGV4LmV4Y2hhbmdlRWRnZXMgPSBleGNoYW5nZUVkZ2VzO1xuXG4vKlxuICogVGhlIG5ldHdvcmsgc2ltcGxleCBhbGdvcml0aG0gYXNzaWducyByYW5rcyB0byBlYWNoIG5vZGUgaW4gdGhlIGlucHV0IGdyYXBoXG4gKiBhbmQgaXRlcmF0aXZlbHkgaW1wcm92ZXMgdGhlIHJhbmtpbmcgdG8gcmVkdWNlIHRoZSBsZW5ndGggb2YgZWRnZXMuXG4gKlxuICogUHJlY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBUaGUgaW5wdXQgZ3JhcGggbXVzdCBiZSBhIERBRy5cbiAqICAgIDIuIEFsbCBub2RlcyBpbiB0aGUgZ3JhcGggbXVzdCBoYXZlIGFuIG9iamVjdCB2YWx1ZS5cbiAqICAgIDMuIEFsbCBlZGdlcyBpbiB0aGUgZ3JhcGggbXVzdCBoYXZlIFwibWlubGVuXCIgYW5kIFwid2VpZ2h0XCIgYXR0cmlidXRlcy5cbiAqXG4gKiBQb3N0Y29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBBbGwgbm9kZXMgaW4gdGhlIGdyYXBoIHdpbGwgaGF2ZSBhbiBhc3NpZ25lZCBcInJhbmtcIiBhdHRyaWJ1dGUgdGhhdCBoYXNcbiAqICAgICAgIGJlZW4gb3B0aW1pemVkIGJ5IHRoZSBuZXR3b3JrIHNpbXBsZXggYWxnb3JpdGhtLiBSYW5rcyBzdGFydCBhdCAwLlxuICpcbiAqXG4gKiBBIHJvdWdoIHNrZXRjaCBvZiB0aGUgYWxnb3JpdGhtIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogICAgMS4gQXNzaWduIGluaXRpYWwgcmFua3MgdG8gZWFjaCBub2RlLiBXZSB1c2UgdGhlIGxvbmdlc3QgcGF0aCBhbGdvcml0aG0sXG4gKiAgICAgICB3aGljaCBhc3NpZ25zIHJhbmtzIHRvIHRoZSBsb3dlc3QgcG9zaXRpb24gcG9zc2libGUuIEluIGdlbmVyYWwgdGhpc1xuICogICAgICAgbGVhZHMgdG8gdmVyeSB3aWRlIGJvdHRvbSByYW5rcyBhbmQgdW5uZWNlc3NhcmlseSBsb25nIGVkZ2VzLlxuICogICAgMi4gQ29uc3RydWN0IGEgZmVhc2libGUgdGlnaHQgdHJlZS4gQSB0aWdodCB0cmVlIGlzIG9uZSBzdWNoIHRoYXQgYWxsXG4gKiAgICAgICBlZGdlcyBpbiB0aGUgdHJlZSBoYXZlIG5vIHNsYWNrIChkaWZmZXJlbmNlIGJldHdlZW4gbGVuZ3RoIG9mIGVkZ2VcbiAqICAgICAgIGFuZCBtaW5sZW4gZm9yIHRoZSBlZGdlKS4gVGhpcyBieSBpdHNlbGYgZ3JlYXRseSBpbXByb3ZlcyB0aGUgYXNzaWduZWRcbiAqICAgICAgIHJhbmtpbmdzIGJ5IHNob3J0aW5nIGVkZ2VzLlxuICogICAgMy4gSXRlcmF0aXZlbHkgZmluZCBlZGdlcyB0aGF0IGhhdmUgbmVnYXRpdmUgY3V0IHZhbHVlcy4gR2VuZXJhbGx5IGFcbiAqICAgICAgIG5lZ2F0aXZlIGN1dCB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZWRnZSBjb3VsZCBiZSByZW1vdmVkIGFuZCBhIG5ld1xuICogICAgICAgdHJlZSBlZGdlIGNvdWxkIGJlIGFkZGVkIHRvIHByb2R1Y2UgYSBtb3JlIGNvbXBhY3QgZ3JhcGguXG4gKlxuICogTXVjaCBvZiB0aGUgYWxnb3JpdGhtcyBoZXJlIGFyZSBkZXJpdmVkIGZyb20gR2Fuc25lciwgZXQgYWwuLCBcIkEgVGVjaG5pcXVlXG4gKiBmb3IgRHJhd2luZyBEaXJlY3RlZCBHcmFwaHMuXCIgVGhlIHN0cnVjdHVyZSBvZiB0aGUgZmlsZSByb3VnaGx5IGZvbGxvd3MgdGhlXG4gKiBzdHJ1Y3R1cmUgb2YgdGhlIG92ZXJhbGwgYWxnb3JpdGhtLlxuICovXG5mdW5jdGlvbiBuZXR3b3JrU2ltcGxleChnKSB7XG4gIGcgPSBzaW1wbGlmeShnKTtcbiAgaW5pdFJhbmsoZyk7XG4gIHZhciB0ID0gZmVhc2libGVUcmVlKGcpO1xuICBpbml0TG93TGltVmFsdWVzKHQpO1xuICBpbml0Q3V0VmFsdWVzKHQsIGcpO1xuXG4gIHZhciBlLCBmO1xuICB3aGlsZSAoKGUgPSBsZWF2ZUVkZ2UodCkpKSB7XG4gICAgZiA9IGVudGVyRWRnZSh0LCBnLCBlKTtcbiAgICBleGNoYW5nZUVkZ2VzKHQsIGcsIGUsIGYpO1xuICB9XG59XG5cbi8qXG4gKiBJbml0aWFsaXplcyBjdXQgdmFsdWVzIGZvciBhbGwgZWRnZXMgaW4gdGhlIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDdXRWYWx1ZXModCwgZykge1xuICB2YXIgdnMgPSBwb3N0b3JkZXIodCwgdC5ub2RlcygpKTtcbiAgdnMgPSB2cy5zbGljZSgwLCB2cy5sZW5ndGggLSAxKTtcbiAgXy5mb3JFYWNoKHZzLCBmdW5jdGlvbih2KSB7XG4gICAgYXNzaWduQ3V0VmFsdWUodCwgZywgdik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25DdXRWYWx1ZSh0LCBnLCBjaGlsZCkge1xuICB2YXIgY2hpbGRMYWIgPSB0Lm5vZGUoY2hpbGQpO1xuICB2YXIgcGFyZW50ID0gY2hpbGRMYWIucGFyZW50O1xuICB0LmVkZ2UoY2hpbGQsIHBhcmVudCkuY3V0dmFsdWUgPSBjYWxjQ3V0VmFsdWUodCwgZywgY2hpbGQpO1xufVxuXG4vKlxuICogR2l2ZW4gdGhlIHRpZ2h0IHRyZWUsIGl0cyBncmFwaCwgYW5kIGEgY2hpbGQgaW4gdGhlIGdyYXBoIGNhbGN1bGF0ZSBhbmRcbiAqIHJldHVybiB0aGUgY3V0IHZhbHVlIGZvciB0aGUgZWRnZSBiZXR3ZWVuIHRoZSBjaGlsZCBhbmQgaXRzIHBhcmVudC5cbiAqL1xuZnVuY3Rpb24gY2FsY0N1dFZhbHVlKHQsIGcsIGNoaWxkKSB7XG4gIHZhciBjaGlsZExhYiA9IHQubm9kZShjaGlsZCk7XG4gIHZhciBwYXJlbnQgPSBjaGlsZExhYi5wYXJlbnQ7XG4gIC8vIFRydWUgaWYgdGhlIGNoaWxkIGlzIG9uIHRoZSB0YWlsIGVuZCBvZiB0aGUgZWRnZSBpbiB0aGUgZGlyZWN0ZWQgZ3JhcGhcbiAgdmFyIGNoaWxkSXNUYWlsID0gdHJ1ZTtcbiAgLy8gVGhlIGdyYXBoJ3MgdmlldyBvZiB0aGUgdHJlZSBlZGdlIHdlJ3JlIGluc3BlY3RpbmdcbiAgdmFyIGdyYXBoRWRnZSA9IGcuZWRnZShjaGlsZCwgcGFyZW50KTtcbiAgLy8gVGhlIGFjY3VtdWxhdGVkIGN1dCB2YWx1ZSBmb3IgdGhlIGVkZ2UgYmV0d2VlbiB0aGlzIG5vZGUgYW5kIGl0cyBwYXJlbnRcbiAgdmFyIGN1dFZhbHVlID0gMDtcblxuICBpZiAoIWdyYXBoRWRnZSkge1xuICAgIGNoaWxkSXNUYWlsID0gZmFsc2U7XG4gICAgZ3JhcGhFZGdlID0gZy5lZGdlKHBhcmVudCwgY2hpbGQpO1xuICB9XG5cbiAgY3V0VmFsdWUgPSBncmFwaEVkZ2Uud2VpZ2h0O1xuXG4gIF8uZm9yRWFjaChnLm5vZGVFZGdlcyhjaGlsZCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgaXNPdXRFZGdlID0gZS52ID09PSBjaGlsZCxcbiAgICAgIG90aGVyID0gaXNPdXRFZGdlID8gZS53IDogZS52O1xuXG4gICAgaWYgKG90aGVyICE9PSBwYXJlbnQpIHtcbiAgICAgIHZhciBwb2ludHNUb0hlYWQgPSBpc091dEVkZ2UgPT09IGNoaWxkSXNUYWlsLFxuICAgICAgICBvdGhlcldlaWdodCA9IGcuZWRnZShlKS53ZWlnaHQ7XG5cbiAgICAgIGN1dFZhbHVlICs9IHBvaW50c1RvSGVhZCA/IG90aGVyV2VpZ2h0IDogLW90aGVyV2VpZ2h0O1xuICAgICAgaWYgKGlzVHJlZUVkZ2UodCwgY2hpbGQsIG90aGVyKSkge1xuICAgICAgICB2YXIgb3RoZXJDdXRWYWx1ZSA9IHQuZWRnZShjaGlsZCwgb3RoZXIpLmN1dHZhbHVlO1xuICAgICAgICBjdXRWYWx1ZSArPSBwb2ludHNUb0hlYWQgPyAtb3RoZXJDdXRWYWx1ZSA6IG90aGVyQ3V0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY3V0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIGluaXRMb3dMaW1WYWx1ZXModHJlZSwgcm9vdCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICByb290ID0gdHJlZS5ub2RlcygpWzBdO1xuICB9XG4gIGRmc0Fzc2lnbkxvd0xpbSh0cmVlLCB7fSwgMSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIGRmc0Fzc2lnbkxvd0xpbSh0cmVlLCB2aXNpdGVkLCBuZXh0TGltLCB2LCBwYXJlbnQpIHtcbiAgdmFyIGxvdyA9IG5leHRMaW07XG4gIHZhciBsYWJlbCA9IHRyZWUubm9kZSh2KTtcblxuICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgXy5mb3JFYWNoKHRyZWUubmVpZ2hib3JzKHYpLCBmdW5jdGlvbih3KSB7XG4gICAgaWYgKCFfLmhhcyh2aXNpdGVkLCB3KSkge1xuICAgICAgbmV4dExpbSA9IGRmc0Fzc2lnbkxvd0xpbSh0cmVlLCB2aXNpdGVkLCBuZXh0TGltLCB3LCB2KTtcbiAgICB9XG4gIH0pO1xuXG4gIGxhYmVsLmxvdyA9IGxvdztcbiAgbGFiZWwubGltID0gbmV4dExpbSsrO1xuICBpZiAocGFyZW50KSB7XG4gICAgbGFiZWwucGFyZW50ID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8gc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgd2hlbiB3ZSBpbmNyZW1lbnRhbGx5IHVwZGF0ZSBsb3cgbGltXG4gICAgZGVsZXRlIGxhYmVsLnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBuZXh0TGltO1xufVxuXG5mdW5jdGlvbiBsZWF2ZUVkZ2UodHJlZSkge1xuICByZXR1cm4gXy5maW5kKHRyZWUuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB0cmVlLmVkZ2UoZSkuY3V0dmFsdWUgPCAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZW50ZXJFZGdlKHQsIGcsIGVkZ2UpIHtcbiAgdmFyIHYgPSBlZGdlLnY7XG4gIHZhciB3ID0gZWRnZS53O1xuXG4gIC8vIEZvciB0aGUgcmVzdCBvZiB0aGlzIGZ1bmN0aW9uIHdlIGFzc3VtZSB0aGF0IHYgaXMgdGhlIHRhaWwgYW5kIHcgaXMgdGhlXG4gIC8vIGhlYWQsIHNvIGlmIHdlIGRvbid0IGhhdmUgdGhpcyBlZGdlIGluIHRoZSBncmFwaCB3ZSBzaG91bGQgZmxpcCBpdCB0b1xuICAvLyBtYXRjaCB0aGUgY29ycmVjdCBvcmllbnRhdGlvbi5cbiAgaWYgKCFnLmhhc0VkZ2UodiwgdykpIHtcbiAgICB2ID0gZWRnZS53O1xuICAgIHcgPSBlZGdlLnY7XG4gIH1cblxuICB2YXIgdkxhYmVsID0gdC5ub2RlKHYpO1xuICB2YXIgd0xhYmVsID0gdC5ub2RlKHcpO1xuICB2YXIgdGFpbExhYmVsID0gdkxhYmVsO1xuICB2YXIgZmxpcCA9IGZhbHNlO1xuXG4gIC8vIElmIHRoZSByb290IGlzIGluIHRoZSB0YWlsIG9mIHRoZSBlZGdlIHRoZW4gd2UgbmVlZCB0byBmbGlwIHRoZSBsb2dpYyB0aGF0XG4gIC8vIGNoZWNrcyBmb3IgdGhlIGhlYWQgYW5kIHRhaWwgbm9kZXMgaW4gdGhlIGNhbmRpZGF0ZXMgZnVuY3Rpb24gYmVsb3cuXG4gIGlmICh2TGFiZWwubGltID4gd0xhYmVsLmxpbSkge1xuICAgIHRhaWxMYWJlbCA9IHdMYWJlbDtcbiAgICBmbGlwID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBjYW5kaWRhdGVzID0gXy5maWx0ZXIoZy5lZGdlcygpLCBmdW5jdGlvbihlZGdlKSB7XG4gICAgcmV0dXJuIGZsaXAgPT09IGlzRGVzY2VuZGFudCh0LCB0Lm5vZGUoZWRnZS52KSwgdGFpbExhYmVsKSAmJlxuICAgICAgICAgICBmbGlwICE9PSBpc0Rlc2NlbmRhbnQodCwgdC5ub2RlKGVkZ2UudyksIHRhaWxMYWJlbCk7XG4gIH0pO1xuXG4gIHJldHVybiBfLm1pbkJ5KGNhbmRpZGF0ZXMsIGZ1bmN0aW9uKGVkZ2UpIHsgcmV0dXJuIHNsYWNrKGcsIGVkZ2UpOyB9KTtcbn1cblxuZnVuY3Rpb24gZXhjaGFuZ2VFZGdlcyh0LCBnLCBlLCBmKSB7XG4gIHZhciB2ID0gZS52O1xuICB2YXIgdyA9IGUudztcbiAgdC5yZW1vdmVFZGdlKHYsIHcpO1xuICB0LnNldEVkZ2UoZi52LCBmLncsIHt9KTtcbiAgaW5pdExvd0xpbVZhbHVlcyh0KTtcbiAgaW5pdEN1dFZhbHVlcyh0LCBnKTtcbiAgdXBkYXRlUmFua3ModCwgZyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJhbmtzKHQsIGcpIHtcbiAgdmFyIHJvb3QgPSBfLmZpbmQodC5ub2RlcygpLCBmdW5jdGlvbih2KSB7IHJldHVybiAhZy5ub2RlKHYpLnBhcmVudDsgfSk7XG4gIHZhciB2cyA9IHByZW9yZGVyKHQsIHJvb3QpO1xuICB2cyA9IHZzLnNsaWNlKDEpO1xuICBfLmZvckVhY2godnMsIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgcGFyZW50ID0gdC5ub2RlKHYpLnBhcmVudCxcbiAgICAgIGVkZ2UgPSBnLmVkZ2UodiwgcGFyZW50KSxcbiAgICAgIGZsaXBwZWQgPSBmYWxzZTtcblxuICAgIGlmICghZWRnZSkge1xuICAgICAgZWRnZSA9IGcuZWRnZShwYXJlbnQsIHYpO1xuICAgICAgZmxpcHBlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZy5ub2RlKHYpLnJhbmsgPSBnLm5vZGUocGFyZW50KS5yYW5rICsgKGZsaXBwZWQgPyBlZGdlLm1pbmxlbiA6IC1lZGdlLm1pbmxlbik7XG4gIH0pO1xufVxuXG4vKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBlZGdlIGlzIGluIHRoZSB0cmVlLlxuICovXG5mdW5jdGlvbiBpc1RyZWVFZGdlKHRyZWUsIHUsIHYpIHtcbiAgcmV0dXJuIHRyZWUuaGFzRWRnZSh1LCB2KTtcbn1cblxuLypcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIG5vZGUgaXMgZGVzY2VuZGFudCBvZiB0aGUgcm9vdCBub2RlIHBlciB0aGVcbiAqIGFzc2lnbmVkIGxvdyBhbmQgbGltIGF0dHJpYnV0ZXMgaW4gdGhlIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIGlzRGVzY2VuZGFudCh0cmVlLCB2TGFiZWwsIHJvb3RMYWJlbCkge1xuICByZXR1cm4gcm9vdExhYmVsLmxvdyA8PSB2TGFiZWwubGltICYmIHZMYWJlbC5saW0gPD0gcm9vdExhYmVsLmxpbTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3JhbmsvdXRpbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3JhbmsvdXRpbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbG9uZ2VzdFBhdGg6IGxvbmdlc3RQYXRoLFxuICBzbGFjazogc2xhY2tcbn07XG5cbi8qXG4gKiBJbml0aWFsaXplcyByYW5rcyBmb3IgdGhlIGlucHV0IGdyYXBoIHVzaW5nIHRoZSBsb25nZXN0IHBhdGggYWxnb3JpdGhtLiBUaGlzXG4gKiBhbGdvcml0aG0gc2NhbGVzIHdlbGwgYW5kIGlzIGZhc3QgaW4gcHJhY3RpY2UsIGl0IHlpZWxkcyByYXRoZXIgcG9vclxuICogc29sdXRpb25zLiBOb2RlcyBhcmUgcHVzaGVkIHRvIHRoZSBsb3dlc3QgbGF5ZXIgcG9zc2libGUsIGxlYXZpbmcgdGhlIGJvdHRvbVxuICogcmFua3Mgd2lkZSBhbmQgbGVhdmluZyBlZGdlcyBsb25nZXIgdGhhbiBuZWNlc3NhcnkuIEhvd2V2ZXIsIGR1ZSB0byBpdHNcbiAqIHNwZWVkLCB0aGlzIGFsZ29yaXRobSBpcyBnb29kIGZvciBnZXR0aW5nIGFuIGluaXRpYWwgcmFua2luZyB0aGF0IGNhbiBiZSBmZWRcbiAqIGludG8gb3RoZXIgYWxnb3JpdGhtcy5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBkb2VzIG5vdCBub3JtYWxpemUgbGF5ZXJzIGJlY2F1c2UgaXQgd2lsbCBiZSB1c2VkIGJ5IG90aGVyXG4gKiBhbGdvcml0aG1zIGluIG1vc3QgY2FzZXMuIElmIHVzaW5nIHRoaXMgYWxnb3JpdGhtIGRpcmVjdGx5LCBiZSBzdXJlIHRvXG4gKiBydW4gbm9ybWFsaXplIGF0IHRoZSBlbmQuXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gSW5wdXQgZ3JhcGggaXMgYSBEQUcuXG4gKiAgICAyLiBJbnB1dCBncmFwaCBub2RlIGxhYmVscyBjYW4gYmUgYXNzaWduZWQgcHJvcGVydGllcy5cbiAqXG4gKiBQb3N0LWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gRWFjaCBub2RlIHdpbGwgYmUgYXNzaWduIGFuICh1bm5vcm1hbGl6ZWQpIFwicmFua1wiIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBsb25nZXN0UGF0aChnKSB7XG4gIHZhciB2aXNpdGVkID0ge307XG5cbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICB2YXIgbGFiZWwgPSBnLm5vZGUodik7XG4gICAgaWYgKF8uaGFzKHZpc2l0ZWQsIHYpKSB7XG4gICAgICByZXR1cm4gbGFiZWwucmFuaztcbiAgICB9XG4gICAgdmlzaXRlZFt2XSA9IHRydWU7XG5cbiAgICB2YXIgcmFuayA9IF8ubWluKF8ubWFwKGcub3V0RWRnZXModiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiBkZnMoZS53KSAtIGcuZWRnZShlKS5taW5sZW47XG4gICAgfSkpO1xuXG4gICAgaWYgKHJhbmsgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fCAvLyByZXR1cm4gdmFsdWUgb2YgXy5tYXAoW10pIGZvciBMb2Rhc2ggM1xuICAgICAgICByYW5rID09PSB1bmRlZmluZWQgfHwgLy8gcmV0dXJuIHZhbHVlIG9mIF8ubWFwKFtdKSBmb3IgTG9kYXNoIDRcbiAgICAgICAgcmFuayA9PT0gbnVsbCkgeyAvLyByZXR1cm4gdmFsdWUgb2YgXy5tYXAoW251bGxdKVxuICAgICAgcmFuayA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIChsYWJlbC5yYW5rID0gcmFuayk7XG4gIH1cblxuICBfLmZvckVhY2goZy5zb3VyY2VzKCksIGRmcyk7XG59XG5cbi8qXG4gKiBSZXR1cm5zIHRoZSBhbW91bnQgb2Ygc2xhY2sgZm9yIHRoZSBnaXZlbiBlZGdlLiBUaGUgc2xhY2sgaXMgZGVmaW5lZCBhcyB0aGVcbiAqIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbGVuZ3RoIG9mIHRoZSBlZGdlIGFuZCBpdHMgbWluaW11bSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHNsYWNrKGcsIGUpIHtcbiAgcmV0dXJuIGcubm9kZShlLncpLnJhbmsgLSBnLm5vZGUoZS52KS5yYW5rIC0gZy5lZGdlKGUpLm1pbmxlbjtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3V0aWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvdXRpbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQgXCJuby1jb25zb2xlXCI6IG9mZiAqL1xuXG5cblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xudmFyIEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ncmFwaGxpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvZ3JhcGhsaWIuanNcIikuR3JhcGg7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGREdW1teU5vZGU6IGFkZER1bW15Tm9kZSxcbiAgc2ltcGxpZnk6IHNpbXBsaWZ5LFxuICBhc05vbkNvbXBvdW5kR3JhcGg6IGFzTm9uQ29tcG91bmRHcmFwaCxcbiAgc3VjY2Vzc29yV2VpZ2h0czogc3VjY2Vzc29yV2VpZ2h0cyxcbiAgcHJlZGVjZXNzb3JXZWlnaHRzOiBwcmVkZWNlc3NvcldlaWdodHMsXG4gIGludGVyc2VjdFJlY3Q6IGludGVyc2VjdFJlY3QsXG4gIGJ1aWxkTGF5ZXJNYXRyaXg6IGJ1aWxkTGF5ZXJNYXRyaXgsXG4gIG5vcm1hbGl6ZVJhbmtzOiBub3JtYWxpemVSYW5rcyxcbiAgcmVtb3ZlRW1wdHlSYW5rczogcmVtb3ZlRW1wdHlSYW5rcyxcbiAgYWRkQm9yZGVyTm9kZTogYWRkQm9yZGVyTm9kZSxcbiAgbWF4UmFuazogbWF4UmFuayxcbiAgcGFydGl0aW9uOiBwYXJ0aXRpb24sXG4gIHRpbWU6IHRpbWUsXG4gIG5vdGltZTogbm90aW1lXG59O1xuXG4vKlxuICogQWRkcyBhIGR1bW15IG5vZGUgdG8gdGhlIGdyYXBoIGFuZCByZXR1cm4gdi5cbiAqL1xuZnVuY3Rpb24gYWRkRHVtbXlOb2RlKGcsIHR5cGUsIGF0dHJzLCBuYW1lKSB7XG4gIHZhciB2O1xuICBkbyB7XG4gICAgdiA9IF8udW5pcXVlSWQobmFtZSk7XG4gIH0gd2hpbGUgKGcuaGFzTm9kZSh2KSk7XG5cbiAgYXR0cnMuZHVtbXkgPSB0eXBlO1xuICBnLnNldE5vZGUodiwgYXR0cnMpO1xuICByZXR1cm4gdjtcbn1cblxuLypcbiAqIFJldHVybnMgYSBuZXcgZ3JhcGggd2l0aCBvbmx5IHNpbXBsZSBlZGdlcy4gSGFuZGxlcyBhZ2dyZWdhdGlvbiBvZiBkYXRhXG4gKiBhc3NvY2lhdGVkIHdpdGggbXVsdGktZWRnZXMuXG4gKi9cbmZ1bmN0aW9uIHNpbXBsaWZ5KGcpIHtcbiAgdmFyIHNpbXBsaWZpZWQgPSBuZXcgR3JhcGgoKS5zZXRHcmFwaChnLmdyYXBoKCkpO1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7IHNpbXBsaWZpZWQuc2V0Tm9kZSh2LCBnLm5vZGUodikpOyB9KTtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBzaW1wbGVMYWJlbCA9IHNpbXBsaWZpZWQuZWRnZShlLnYsIGUudykgfHwgeyB3ZWlnaHQ6IDAsIG1pbmxlbjogMSB9O1xuICAgIHZhciBsYWJlbCA9IGcuZWRnZShlKTtcbiAgICBzaW1wbGlmaWVkLnNldEVkZ2UoZS52LCBlLncsIHtcbiAgICAgIHdlaWdodDogc2ltcGxlTGFiZWwud2VpZ2h0ICsgbGFiZWwud2VpZ2h0LFxuICAgICAgbWlubGVuOiBNYXRoLm1heChzaW1wbGVMYWJlbC5taW5sZW4sIGxhYmVsLm1pbmxlbilcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzaW1wbGlmaWVkO1xufVxuXG5mdW5jdGlvbiBhc05vbkNvbXBvdW5kR3JhcGgoZykge1xuICB2YXIgc2ltcGxpZmllZCA9IG5ldyBHcmFwaCh7IG11bHRpZ3JhcGg6IGcuaXNNdWx0aWdyYXBoKCkgfSkuc2V0R3JhcGgoZy5ncmFwaCgpKTtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIGlmICghZy5jaGlsZHJlbih2KS5sZW5ndGgpIHtcbiAgICAgIHNpbXBsaWZpZWQuc2V0Tm9kZSh2LCBnLm5vZGUodikpO1xuICAgIH1cbiAgfSk7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICBzaW1wbGlmaWVkLnNldEVkZ2UoZSwgZy5lZGdlKGUpKTtcbiAgfSk7XG4gIHJldHVybiBzaW1wbGlmaWVkO1xufVxuXG5mdW5jdGlvbiBzdWNjZXNzb3JXZWlnaHRzKGcpIHtcbiAgdmFyIHdlaWdodE1hcCA9IF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBzdWNzID0ge307XG4gICAgXy5mb3JFYWNoKGcub3V0RWRnZXModiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHN1Y3NbZS53XSA9IChzdWNzW2Uud10gfHwgMCkgKyBnLmVkZ2UoZSkud2VpZ2h0O1xuICAgIH0pO1xuICAgIHJldHVybiBzdWNzO1xuICB9KTtcbiAgcmV0dXJuIF8uemlwT2JqZWN0KGcubm9kZXMoKSwgd2VpZ2h0TWFwKTtcbn1cblxuZnVuY3Rpb24gcHJlZGVjZXNzb3JXZWlnaHRzKGcpIHtcbiAgdmFyIHdlaWdodE1hcCA9IF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBwcmVkcyA9IHt9O1xuICAgIF8uZm9yRWFjaChnLmluRWRnZXModiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHByZWRzW2Uudl0gPSAocHJlZHNbZS52XSB8fCAwKSArIGcuZWRnZShlKS53ZWlnaHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByZWRzO1xuICB9KTtcbiAgcmV0dXJuIF8uemlwT2JqZWN0KGcubm9kZXMoKSwgd2VpZ2h0TWFwKTtcbn1cblxuLypcbiAqIEZpbmRzIHdoZXJlIGEgbGluZSBzdGFydGluZyBhdCBwb2ludCAoe3gsIHl9KSB3b3VsZCBpbnRlcnNlY3QgYSByZWN0YW5nbGVcbiAqICh7eCwgeSwgd2lkdGgsIGhlaWdodH0pIGlmIGl0IHdlcmUgcG9pbnRpbmcgYXQgdGhlIHJlY3RhbmdsZSdzIGNlbnRlci5cbiAqL1xuZnVuY3Rpb24gaW50ZXJzZWN0UmVjdChyZWN0LCBwb2ludCkge1xuICB2YXIgeCA9IHJlY3QueDtcbiAgdmFyIHkgPSByZWN0Lnk7XG5cbiAgLy8gUmVjdGFuZ2xlIGludGVyc2VjdGlvbiBhbGdvcml0aG0gZnJvbTpcbiAgLy8gaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzEwODExMy9maW5kLWVkZ2UtYmV0d2Vlbi10d28tYm94ZXNcbiAgdmFyIGR4ID0gcG9pbnQueCAtIHg7XG4gIHZhciBkeSA9IHBvaW50LnkgLSB5O1xuICB2YXIgdyA9IHJlY3Qud2lkdGggLyAyO1xuICB2YXIgaCA9IHJlY3QuaGVpZ2h0IC8gMjtcblxuICBpZiAoIWR4ICYmICFkeSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBwb3NzaWJsZSB0byBmaW5kIGludGVyc2VjdGlvbiBpbnNpZGUgb2YgdGhlIHJlY3RhbmdsZVwiKTtcbiAgfVxuXG4gIHZhciBzeCwgc3k7XG4gIGlmIChNYXRoLmFicyhkeSkgKiB3ID4gTWF0aC5hYnMoZHgpICogaCkge1xuICAgIC8vIEludGVyc2VjdGlvbiBpcyB0b3Agb3IgYm90dG9tIG9mIHJlY3QuXG4gICAgaWYgKGR5IDwgMCkge1xuICAgICAgaCA9IC1oO1xuICAgIH1cbiAgICBzeCA9IGggKiBkeCAvIGR5O1xuICAgIHN5ID0gaDtcbiAgfSBlbHNlIHtcbiAgICAvLyBJbnRlcnNlY3Rpb24gaXMgbGVmdCBvciByaWdodCBvZiByZWN0LlxuICAgIGlmIChkeCA8IDApIHtcbiAgICAgIHcgPSAtdztcbiAgICB9XG4gICAgc3ggPSB3O1xuICAgIHN5ID0gdyAqIGR5IC8gZHg7XG4gIH1cblxuICByZXR1cm4geyB4OiB4ICsgc3gsIHk6IHkgKyBzeSB9O1xufVxuXG4vKlxuICogR2l2ZW4gYSBEQUcgd2l0aCBlYWNoIG5vZGUgYXNzaWduZWQgXCJyYW5rXCIgYW5kIFwib3JkZXJcIiBwcm9wZXJ0aWVzLCB0aGlzXG4gKiBmdW5jdGlvbiB3aWxsIHByb2R1Y2UgYSBtYXRyaXggd2l0aCB0aGUgaWRzIG9mIGVhY2ggbm9kZS5cbiAqL1xuZnVuY3Rpb24gYnVpbGRMYXllck1hdHJpeChnKSB7XG4gIHZhciBsYXllcmluZyA9IF8ubWFwKF8ucmFuZ2UobWF4UmFuayhnKSArIDEpLCBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIHZhciByYW5rID0gbm9kZS5yYW5rO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChyYW5rKSkge1xuICAgICAgbGF5ZXJpbmdbcmFua11bbm9kZS5vcmRlcl0gPSB2O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsYXllcmluZztcbn1cblxuLypcbiAqIEFkanVzdHMgdGhlIHJhbmtzIGZvciBhbGwgbm9kZXMgaW4gdGhlIGdyYXBoIHN1Y2ggdGhhdCBhbGwgbm9kZXMgdiBoYXZlXG4gKiByYW5rKHYpID49IDAgYW5kIGF0IGxlYXN0IG9uZSBub2RlIHcgaGFzIHJhbmsodykgPSAwLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVSYW5rcyhnKSB7XG4gIHZhciBtaW4gPSBfLm1pbihfLm1hcChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcubm9kZSh2KS5yYW5rOyB9KSk7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICBpZiAoXy5oYXMobm9kZSwgXCJyYW5rXCIpKSB7XG4gICAgICBub2RlLnJhbmsgLT0gbWluO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUVtcHR5UmFua3MoZykge1xuICAvLyBSYW5rcyBtYXkgbm90IHN0YXJ0IGF0IDAsIHNvIHdlIG5lZWQgdG8gb2Zmc2V0IHRoZW1cbiAgdmFyIG9mZnNldCA9IF8ubWluKF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikgeyByZXR1cm4gZy5ub2RlKHYpLnJhbms7IH0pKTtcblxuICB2YXIgbGF5ZXJzID0gW107XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgcmFuayA9IGcubm9kZSh2KS5yYW5rIC0gb2Zmc2V0O1xuICAgIGlmICghbGF5ZXJzW3JhbmtdKSB7XG4gICAgICBsYXllcnNbcmFua10gPSBbXTtcbiAgICB9XG4gICAgbGF5ZXJzW3JhbmtdLnB1c2godik7XG4gIH0pO1xuXG4gIHZhciBkZWx0YSA9IDA7XG4gIHZhciBub2RlUmFua0ZhY3RvciA9IGcuZ3JhcGgoKS5ub2RlUmFua0ZhY3RvcjtcbiAgXy5mb3JFYWNoKGxheWVycywgZnVuY3Rpb24odnMsIGkpIHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh2cykgJiYgaSAlIG5vZGVSYW5rRmFjdG9yICE9PSAwKSB7XG4gICAgICAtLWRlbHRhO1xuICAgIH0gZWxzZSBpZiAoZGVsdGEpIHtcbiAgICAgIF8uZm9yRWFjaCh2cywgZnVuY3Rpb24odikgeyBnLm5vZGUodikucmFuayArPSBkZWx0YTsgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkQm9yZGVyTm9kZShnLCBwcmVmaXgsIHJhbmssIG9yZGVyKSB7XG4gIHZhciBub2RlID0ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9O1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSB7XG4gICAgbm9kZS5yYW5rID0gcmFuaztcbiAgICBub2RlLm9yZGVyID0gb3JkZXI7XG4gIH1cbiAgcmV0dXJuIGFkZER1bW15Tm9kZShnLCBcImJvcmRlclwiLCBub2RlLCBwcmVmaXgpO1xufVxuXG5mdW5jdGlvbiBtYXhSYW5rKGcpIHtcbiAgcmV0dXJuIF8ubWF4KF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciByYW5rID0gZy5ub2RlKHYpLnJhbms7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHJhbmspKSB7XG4gICAgICByZXR1cm4gcmFuaztcbiAgICB9XG4gIH0pKTtcbn1cblxuLypcbiAqIFBhcnRpdGlvbiBhIGNvbGxlY3Rpb24gaW50byB0d28gZ3JvdXBzOiBgbGhzYCBhbmQgYHJoc2AuIElmIHRoZSBzdXBwbGllZFxuICogZnVuY3Rpb24gcmV0dXJucyB0cnVlIGZvciBhbiBlbnRyeSBpdCBnb2VzIGludG8gYGxoc2AuIE90aGVyd2lzZSBpdCBnb2VzXG4gKiBpbnRvIGByaHMuXG4gKi9cbmZ1bmN0aW9uIHBhcnRpdGlvbihjb2xsZWN0aW9uLCBmbikge1xuICB2YXIgcmVzdWx0ID0geyBsaHM6IFtdLCByaHM6IFtdIH07XG4gIF8uZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmIChmbih2YWx1ZSkpIHtcbiAgICAgIHJlc3VsdC5saHMucHVzaCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5yaHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLypcbiAqIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZm5gIHdpdGggYSB0aW1lci4gVGhlIHdyYXBwZXIgbG9ncyB0aGVcbiAqIHRpbWUgaXQgdGFrZXMgdG8gZXhlY3V0ZSB0aGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRpbWUobmFtZSwgZm4pIHtcbiAgdmFyIHN0YXJ0ID0gXy5ub3coKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjb25zb2xlLmxvZyhuYW1lICsgXCIgdGltZTogXCIgKyAoXy5ub3coKSAtIHN0YXJ0KSArIFwibXNcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm90aW1lKG5hbWUsIGZuKSB7XG4gIHJldHVybiBmbigpO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvdmVyc2lvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi92ZXJzaW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiMC44LjVcIjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIENocmlzIFBldHRpdHRcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGNvcHlyaWdodCBob2xkZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG4gKiBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dFxuICogc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuICogQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAqIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEVcbiAqIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXG4gKiBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUlxuICogU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVJcbiAqIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksXG4gKiBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG52YXIgbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2luZGV4LmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR3JhcGg6IGxpYi5HcmFwaCxcbiAganNvbjogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saWIvanNvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvanNvbi5qc1wiKSxcbiAgYWxnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xpYi9hbGcgKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9pbmRleC5qc1wiKSxcbiAgdmVyc2lvbjogbGliLnZlcnNpb25cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvY29tcG9uZW50cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL2NvbXBvbmVudHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvbG9kYXNoLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBvbmVudHM7XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHMoZykge1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuICB2YXIgY21wdHMgPSBbXTtcbiAgdmFyIGNtcHQ7XG5cbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICBpZiAoXy5oYXModmlzaXRlZCwgdikpIHJldHVybjtcbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICBjbXB0LnB1c2godik7XG4gICAgXy5lYWNoKGcuc3VjY2Vzc29ycyh2KSwgZGZzKTtcbiAgICBfLmVhY2goZy5wcmVkZWNlc3NvcnModiksIGRmcyk7XG4gIH1cblxuICBfLmVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgY21wdCA9IFtdO1xuICAgIGRmcyh2KTtcbiAgICBpZiAoY21wdC5sZW5ndGgpIHtcbiAgICAgIGNtcHRzLnB1c2goY21wdCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY21wdHM7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvZGZzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9kZnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9sb2Rhc2guanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZGZzO1xuXG4vKlxuICogQSBoZWxwZXIgdGhhdCBwcmVmb3JtcyBhIHByZS0gb3IgcG9zdC1vcmRlciB0cmF2ZXJzYWwgb24gdGhlIGlucHV0IGdyYXBoXG4gKiBhbmQgcmV0dXJucyB0aGUgbm9kZXMgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSB2aXNpdGVkLiBJZiB0aGUgZ3JhcGggaXNcbiAqIHVuZGlyZWN0ZWQgdGhlbiB0aGlzIGFsZ29yaXRobSB3aWxsIG5hdmlnYXRlIHVzaW5nIG5laWdoYm9ycy4gSWYgdGhlIGdyYXBoXG4gKiBpcyBkaXJlY3RlZCB0aGVuIHRoaXMgYWxnb3JpdGhtIHdpbGwgbmF2aWdhdGUgdXNpbmcgc3VjY2Vzc29ycy5cbiAqXG4gKiBPcmRlciBtdXN0IGJlIG9uZSBvZiBcInByZVwiIG9yIFwicG9zdFwiLlxuICovXG5mdW5jdGlvbiBkZnMoZywgdnMsIG9yZGVyKSB7XG4gIGlmICghXy5pc0FycmF5KHZzKSkge1xuICAgIHZzID0gW3ZzXTtcbiAgfVxuXG4gIHZhciBuYXZpZ2F0aW9uID0gKGcuaXNEaXJlY3RlZCgpID8gZy5zdWNjZXNzb3JzIDogZy5uZWlnaGJvcnMpLmJpbmQoZyk7XG5cbiAgdmFyIGFjYyA9IFtdO1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuICBfLmVhY2godnMsIGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoIWcuaGFzTm9kZSh2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR3JhcGggZG9lcyBub3QgaGF2ZSBub2RlOiBcIiArIHYpO1xuICAgIH1cblxuICAgIGRvRGZzKGcsIHYsIG9yZGVyID09PSBcInBvc3RcIiwgdmlzaXRlZCwgbmF2aWdhdGlvbiwgYWNjKTtcbiAgfSk7XG4gIHJldHVybiBhY2M7XG59XG5cbmZ1bmN0aW9uIGRvRGZzKGcsIHYsIHBvc3RvcmRlciwgdmlzaXRlZCwgbmF2aWdhdGlvbiwgYWNjKSB7XG4gIGlmICghXy5oYXModmlzaXRlZCwgdikpIHtcbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcblxuICAgIGlmICghcG9zdG9yZGVyKSB7IGFjYy5wdXNoKHYpOyB9XG4gICAgXy5lYWNoKG5hdmlnYXRpb24odiksIGZ1bmN0aW9uKHcpIHtcbiAgICAgIGRvRGZzKGcsIHcsIHBvc3RvcmRlciwgdmlzaXRlZCwgbmF2aWdhdGlvbiwgYWNjKTtcbiAgICB9KTtcbiAgICBpZiAocG9zdG9yZGVyKSB7IGFjYy5wdXNoKHYpOyB9XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9kaWprc3RyYS1hbGwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL2RpamtzdHJhLWFsbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRpamtzdHJhID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kaWprc3RyYSAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL2RpamtzdHJhLmpzXCIpO1xudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2xvZGFzaC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkaWprc3RyYUFsbDtcblxuZnVuY3Rpb24gZGlqa3N0cmFBbGwoZywgd2VpZ2h0RnVuYywgZWRnZUZ1bmMpIHtcbiAgcmV0dXJuIF8udHJhbnNmb3JtKGcubm9kZXMoKSwgZnVuY3Rpb24oYWNjLCB2KSB7XG4gICAgYWNjW3ZdID0gZGlqa3N0cmEoZywgdiwgd2VpZ2h0RnVuYywgZWRnZUZ1bmMpO1xuICB9LCB7fSk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvZGlqa3N0cmEuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvZGlqa3N0cmEuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2xvZGFzaC5qc1wiKTtcbnZhciBQcmlvcml0eVF1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS9wcmlvcml0eS1xdWV1ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvZGF0YS9wcmlvcml0eS1xdWV1ZS5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkaWprc3RyYTtcblxudmFyIERFRkFVTFRfV0VJR0hUX0ZVTkMgPSBfLmNvbnN0YW50KDEpO1xuXG5mdW5jdGlvbiBkaWprc3RyYShnLCBzb3VyY2UsIHdlaWdodEZuLCBlZGdlRm4pIHtcbiAgcmV0dXJuIHJ1bkRpamtzdHJhKGcsIFN0cmluZyhzb3VyY2UpLFxuICAgIHdlaWdodEZuIHx8IERFRkFVTFRfV0VJR0hUX0ZVTkMsXG4gICAgZWRnZUZuIHx8IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcub3V0RWRnZXModik7IH0pO1xufVxuXG5mdW5jdGlvbiBydW5EaWprc3RyYShnLCBzb3VyY2UsIHdlaWdodEZuLCBlZGdlRm4pIHtcbiAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgdmFyIHBxID0gbmV3IFByaW9yaXR5UXVldWUoKTtcbiAgdmFyIHYsIHZFbnRyeTtcblxuICB2YXIgdXBkYXRlTmVpZ2hib3JzID0gZnVuY3Rpb24oZWRnZSkge1xuICAgIHZhciB3ID0gZWRnZS52ICE9PSB2ID8gZWRnZS52IDogZWRnZS53O1xuICAgIHZhciB3RW50cnkgPSByZXN1bHRzW3ddO1xuICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbihlZGdlKTtcbiAgICB2YXIgZGlzdGFuY2UgPSB2RW50cnkuZGlzdGFuY2UgKyB3ZWlnaHQ7XG5cbiAgICBpZiAod2VpZ2h0IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlqa3N0cmEgZG9lcyBub3QgYWxsb3cgbmVnYXRpdmUgZWRnZSB3ZWlnaHRzLiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgXCJCYWQgZWRnZTogXCIgKyBlZGdlICsgXCIgV2VpZ2h0OiBcIiArIHdlaWdodCk7XG4gICAgfVxuXG4gICAgaWYgKGRpc3RhbmNlIDwgd0VudHJ5LmRpc3RhbmNlKSB7XG4gICAgICB3RW50cnkuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgIHdFbnRyeS5wcmVkZWNlc3NvciA9IHY7XG4gICAgICBwcS5kZWNyZWFzZSh3LCBkaXN0YW5jZSk7XG4gICAgfVxuICB9O1xuXG4gIGcubm9kZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgZGlzdGFuY2UgPSB2ID09PSBzb3VyY2UgPyAwIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHJlc3VsdHNbdl0gPSB7IGRpc3RhbmNlOiBkaXN0YW5jZSB9O1xuICAgIHBxLmFkZCh2LCBkaXN0YW5jZSk7XG4gIH0pO1xuXG4gIHdoaWxlIChwcS5zaXplKCkgPiAwKSB7XG4gICAgdiA9IHBxLnJlbW92ZU1pbigpO1xuICAgIHZFbnRyeSA9IHJlc3VsdHNbdl07XG4gICAgaWYgKHZFbnRyeS5kaXN0YW5jZSA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBlZGdlRm4odikuZm9yRWFjaCh1cGRhdGVOZWlnaGJvcnMpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvZmluZC1jeWNsZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvZmluZC1jeWNsZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2xvZGFzaC5qc1wiKTtcbnZhciB0YXJqYW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RhcmphbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL3Rhcmphbi5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kQ3ljbGVzO1xuXG5mdW5jdGlvbiBmaW5kQ3ljbGVzKGcpIHtcbiAgcmV0dXJuIF8uZmlsdGVyKHRhcmphbihnKSwgZnVuY3Rpb24oY21wdCkge1xuICAgIHJldHVybiBjbXB0Lmxlbmd0aCA+IDEgfHwgKGNtcHQubGVuZ3RoID09PSAxICYmIGcuaGFzRWRnZShjbXB0WzBdLCBjbXB0WzBdKSk7XG4gIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL2Zsb3lkLXdhcnNoYWxsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL2Zsb3lkLXdhcnNoYWxsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9sb2Rhc2guanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZmxveWRXYXJzaGFsbDtcblxudmFyIERFRkFVTFRfV0VJR0hUX0ZVTkMgPSBfLmNvbnN0YW50KDEpO1xuXG5mdW5jdGlvbiBmbG95ZFdhcnNoYWxsKGcsIHdlaWdodEZuLCBlZGdlRm4pIHtcbiAgcmV0dXJuIHJ1bkZsb3lkV2Fyc2hhbGwoZyxcbiAgICB3ZWlnaHRGbiB8fCBERUZBVUxUX1dFSUdIVF9GVU5DLFxuICAgIGVkZ2VGbiB8fCBmdW5jdGlvbih2KSB7IHJldHVybiBnLm91dEVkZ2VzKHYpOyB9KTtcbn1cblxuZnVuY3Rpb24gcnVuRmxveWRXYXJzaGFsbChnLCB3ZWlnaHRGbiwgZWRnZUZuKSB7XG4gIHZhciByZXN1bHRzID0ge307XG4gIHZhciBub2RlcyA9IGcubm9kZXMoKTtcblxuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICByZXN1bHRzW3ZdID0ge307XG4gICAgcmVzdWx0c1t2XVt2XSA9IHsgZGlzdGFuY2U6IDAgfTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcbiAgICAgIGlmICh2ICE9PSB3KSB7XG4gICAgICAgIHJlc3VsdHNbdl1bd10gPSB7IGRpc3RhbmNlOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlZGdlRm4odikuZm9yRWFjaChmdW5jdGlvbihlZGdlKSB7XG4gICAgICB2YXIgdyA9IGVkZ2UudiA9PT0gdiA/IGVkZ2UudyA6IGVkZ2UudjtcbiAgICAgIHZhciBkID0gd2VpZ2h0Rm4oZWRnZSk7XG4gICAgICByZXN1bHRzW3ZdW3ddID0geyBkaXN0YW5jZTogZCwgcHJlZGVjZXNzb3I6IHYgfTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgdmFyIHJvd0sgPSByZXN1bHRzW2tdO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIHJvd0kgPSByZXN1bHRzW2ldO1xuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihqKSB7XG4gICAgICAgIHZhciBpayA9IHJvd0lba107XG4gICAgICAgIHZhciBraiA9IHJvd0tbal07XG4gICAgICAgIHZhciBpaiA9IHJvd0lbal07XG4gICAgICAgIHZhciBhbHREaXN0YW5jZSA9IGlrLmRpc3RhbmNlICsga2ouZGlzdGFuY2U7XG4gICAgICAgIGlmIChhbHREaXN0YW5jZSA8IGlqLmRpc3RhbmNlKSB7XG4gICAgICAgICAgaWouZGlzdGFuY2UgPSBhbHREaXN0YW5jZTtcbiAgICAgICAgICBpai5wcmVkZWNlc3NvciA9IGtqLnByZWRlY2Vzc29yO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBvbmVudHM6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29tcG9uZW50cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL2NvbXBvbmVudHMuanNcIiksXG4gIGRpamtzdHJhOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RpamtzdHJhICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvZGlqa3N0cmEuanNcIiksXG4gIGRpamtzdHJhQWxsOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RpamtzdHJhLWFsbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL2RpamtzdHJhLWFsbC5qc1wiKSxcbiAgZmluZEN5Y2xlczogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9maW5kLWN5Y2xlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL2ZpbmQtY3ljbGVzLmpzXCIpLFxuICBmbG95ZFdhcnNoYWxsOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Zsb3lkLXdhcnNoYWxsICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvZmxveWQtd2Fyc2hhbGwuanNcIiksXG4gIGlzQWN5Y2xpYzogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hY3ljbGljICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvaXMtYWN5Y2xpYy5qc1wiKSxcbiAgcG9zdG9yZGVyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Bvc3RvcmRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL3Bvc3RvcmRlci5qc1wiKSxcbiAgcHJlb3JkZXI6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcHJlb3JkZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9wcmVvcmRlci5qc1wiKSxcbiAgcHJpbTogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wcmltICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvcHJpbS5qc1wiKSxcbiAgdGFyamFuOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RhcmphbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL3Rhcmphbi5qc1wiKSxcbiAgdG9wc29ydDogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90b3Bzb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvdG9wc29ydC5qc1wiKVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9pcy1hY3ljbGljLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvaXMtYWN5Y2xpYy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b3Bzb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90b3Bzb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvdG9wc29ydC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FjeWNsaWM7XG5cbmZ1bmN0aW9uIGlzQWN5Y2xpYyhnKSB7XG4gIHRyeSB7XG4gICAgdG9wc29ydChnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgdG9wc29ydC5DeWNsZUV4Y2VwdGlvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL3Bvc3RvcmRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvcG9zdG9yZGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZGZzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kZnMgKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9kZnMuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9zdG9yZGVyO1xuXG5mdW5jdGlvbiBwb3N0b3JkZXIoZywgdnMpIHtcbiAgcmV0dXJuIGRmcyhnLCB2cywgXCJwb3N0XCIpO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL3ByZW9yZGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL3ByZW9yZGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkZnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RmcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL2Rmcy5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwcmVvcmRlcjtcblxuZnVuY3Rpb24gcHJlb3JkZXIoZywgdnMpIHtcbiAgcmV0dXJuIGRmcyhnLCB2cywgXCJwcmVcIik7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvcHJpbS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL3ByaW0uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvbG9kYXNoLmpzXCIpO1xudmFyIEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZ3JhcGggKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2dyYXBoLmpzXCIpO1xudmFyIFByaW9yaXR5UXVldWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhL3ByaW9yaXR5LXF1ZXVlICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9kYXRhL3ByaW9yaXR5LXF1ZXVlLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByaW07XG5cbmZ1bmN0aW9uIHByaW0oZywgd2VpZ2h0RnVuYykge1xuICB2YXIgcmVzdWx0ID0gbmV3IEdyYXBoKCk7XG4gIHZhciBwYXJlbnRzID0ge307XG4gIHZhciBwcSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG4gIHZhciB2O1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZU5laWdoYm9ycyhlZGdlKSB7XG4gICAgdmFyIHcgPSBlZGdlLnYgPT09IHYgPyBlZGdlLncgOiBlZGdlLnY7XG4gICAgdmFyIHByaSA9IHBxLnByaW9yaXR5KHcpO1xuICAgIGlmIChwcmkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGVkZ2VXZWlnaHQgPSB3ZWlnaHRGdW5jKGVkZ2UpO1xuICAgICAgaWYgKGVkZ2VXZWlnaHQgPCBwcmkpIHtcbiAgICAgICAgcGFyZW50c1t3XSA9IHY7XG4gICAgICAgIHBxLmRlY3JlYXNlKHcsIGVkZ2VXZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChnLm5vZGVDb3VudCgpID09PSAwKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIF8uZWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBwcS5hZGQodiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICByZXN1bHQuc2V0Tm9kZSh2KTtcbiAgfSk7XG5cbiAgLy8gU3RhcnQgZnJvbSBhbiBhcmJpdHJhcnkgbm9kZVxuICBwcS5kZWNyZWFzZShnLm5vZGVzKClbMF0sIDApO1xuXG4gIHZhciBpbml0ID0gZmFsc2U7XG4gIHdoaWxlIChwcS5zaXplKCkgPiAwKSB7XG4gICAgdiA9IHBxLnJlbW92ZU1pbigpO1xuICAgIGlmIChfLmhhcyhwYXJlbnRzLCB2KSkge1xuICAgICAgcmVzdWx0LnNldEVkZ2UodiwgcGFyZW50c1t2XSk7XG4gICAgfSBlbHNlIGlmIChpbml0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBncmFwaCBpcyBub3QgY29ubmVjdGVkOiBcIiArIGcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbml0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBnLm5vZGVFZGdlcyh2KS5mb3JFYWNoKHVwZGF0ZU5laWdoYm9ycyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL3Rhcmphbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvdGFyamFuLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvbG9kYXNoLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRhcmphbjtcblxuZnVuY3Rpb24gdGFyamFuKGcpIHtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciB2aXNpdGVkID0ge307IC8vIG5vZGUgaWQgLT4geyBvblN0YWNrLCBsb3dsaW5rLCBpbmRleCB9XG4gIHZhciByZXN1bHRzID0gW107XG5cbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICB2YXIgZW50cnkgPSB2aXNpdGVkW3ZdID0ge1xuICAgICAgb25TdGFjazogdHJ1ZSxcbiAgICAgIGxvd2xpbms6IGluZGV4LFxuICAgICAgaW5kZXg6IGluZGV4KytcbiAgICB9O1xuICAgIHN0YWNrLnB1c2godik7XG5cbiAgICBnLnN1Y2Nlc3NvcnModikuZm9yRWFjaChmdW5jdGlvbih3KSB7XG4gICAgICBpZiAoIV8uaGFzKHZpc2l0ZWQsIHcpKSB7XG4gICAgICAgIGRmcyh3KTtcbiAgICAgICAgZW50cnkubG93bGluayA9IE1hdGgubWluKGVudHJ5Lmxvd2xpbmssIHZpc2l0ZWRbd10ubG93bGluayk7XG4gICAgICB9IGVsc2UgaWYgKHZpc2l0ZWRbd10ub25TdGFjaykge1xuICAgICAgICBlbnRyeS5sb3dsaW5rID0gTWF0aC5taW4oZW50cnkubG93bGluaywgdmlzaXRlZFt3XS5pbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoZW50cnkubG93bGluayA9PT0gZW50cnkuaW5kZXgpIHtcbiAgICAgIHZhciBjbXB0ID0gW107XG4gICAgICB2YXIgdztcbiAgICAgIGRvIHtcbiAgICAgICAgdyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2aXNpdGVkW3ddLm9uU3RhY2sgPSBmYWxzZTtcbiAgICAgICAgY21wdC5wdXNoKHcpO1xuICAgICAgfSB3aGlsZSAodiAhPT0gdyk7XG4gICAgICByZXN1bHRzLnB1c2goY21wdCk7XG4gICAgfVxuICB9XG5cbiAgZy5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgIGlmICghXy5oYXModmlzaXRlZCwgdikpIHtcbiAgICAgIGRmcyh2KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL3RvcHNvcnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy90b3Bzb3J0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2xvZGFzaC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0b3Bzb3J0O1xudG9wc29ydC5DeWNsZUV4Y2VwdGlvbiA9IEN5Y2xlRXhjZXB0aW9uO1xuXG5mdW5jdGlvbiB0b3Bzb3J0KGcpIHtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgdmFyIHN0YWNrID0ge307XG4gIHZhciByZXN1bHRzID0gW107XG5cbiAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xuICAgIGlmIChfLmhhcyhzdGFjaywgbm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBDeWNsZUV4Y2VwdGlvbigpO1xuICAgIH1cblxuICAgIGlmICghXy5oYXModmlzaXRlZCwgbm9kZSkpIHtcbiAgICAgIHN0YWNrW25vZGVdID0gdHJ1ZTtcbiAgICAgIHZpc2l0ZWRbbm9kZV0gPSB0cnVlO1xuICAgICAgXy5lYWNoKGcucHJlZGVjZXNzb3JzKG5vZGUpLCB2aXNpdCk7XG4gICAgICBkZWxldGUgc3RhY2tbbm9kZV07XG4gICAgICByZXN1bHRzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgXy5lYWNoKGcuc2lua3MoKSwgdmlzaXQpO1xuXG4gIGlmIChfLnNpemUodmlzaXRlZCkgIT09IGcubm9kZUNvdW50KCkpIHtcbiAgICB0aHJvdyBuZXcgQ3ljbGVFeGNlcHRpb24oKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBDeWNsZUV4Y2VwdGlvbigpIHt9XG5DeWNsZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTsgLy8gbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBFcnJvciB0byBwYXNzIHRlc3RpbmdcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9kYXRhL3ByaW9yaXR5LXF1ZXVlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2RhdGEvcHJpb3JpdHktcXVldWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9sb2Rhc2guanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJpb3JpdHlRdWV1ZTtcblxuLyoqXG4gKiBBIG1pbi1wcmlvcml0eSBxdWV1ZSBkYXRhIHN0cnVjdHVyZS4gVGhpcyBhbGdvcml0aG0gaXMgZGVyaXZlZCBmcm9tIENvcm1lbixcbiAqIGV0IGFsLiwgXCJJbnRyb2R1Y3Rpb24gdG8gQWxnb3JpdGhtc1wiLiBUaGUgYmFzaWMgaWRlYSBvZiBhIG1pbi1wcmlvcml0eVxuICogcXVldWUgaXMgdGhhdCB5b3UgY2FuIGVmZmljaWVudGx5IChpbiBPKDEpIHRpbWUpIGdldCB0aGUgc21hbGxlc3Qga2V5IGluXG4gKiB0aGUgcXVldWUuIEFkZGluZyBhbmQgcmVtb3ZpbmcgZWxlbWVudHMgdGFrZXMgTyhsb2cgbikgdGltZS4gQSBrZXkgY2FuXG4gKiBoYXZlIGl0cyBwcmlvcml0eSBkZWNyZWFzZWQgaW4gTyhsb2cgbikgdGltZS5cbiAqL1xuZnVuY3Rpb24gUHJpb3JpdHlRdWV1ZSgpIHtcbiAgdGhpcy5fYXJyID0gW107XG4gIHRoaXMuX2tleUluZGljZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHF1ZXVlLiBUYWtlcyBgTygxKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXJyLmxlbmd0aDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUga2V5cyB0aGF0IGFyZSBpbiB0aGUgcXVldWUuIFRha2VzIGBPKG4pYCB0aW1lLlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9hcnIubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHgua2V5OyB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgKiprZXkqKiBpcyBpbiB0aGUgcXVldWUgYW5kIGBmYWxzZWAgaWYgbm90LlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgcmV0dXJuIF8uaGFzKHRoaXMuX2tleUluZGljZXMsIGtleSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHByaW9yaXR5IGZvciAqKmtleSoqLiBJZiAqKmtleSoqIGlzIG5vdCBwcmVzZW50IGluIHRoZSBxdWV1ZVxuICogdGhlbiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAuIFRha2VzIGBPKDEpYCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBrZXlcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucHJpb3JpdHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fa2V5SW5kaWNlc1trZXldO1xuICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJbaW5kZXhdLnByaW9yaXR5O1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGtleSBmb3IgdGhlIG1pbmltdW0gZWxlbWVudCBpbiB0aGlzIHF1ZXVlLiBJZiB0aGUgcXVldWUgaXNcbiAqIGVtcHR5IHRoaXMgZnVuY3Rpb24gdGhyb3dzIGFuIEVycm9yLiBUYWtlcyBgTygxKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnNpemUoKSA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIHVuZGVyZmxvd1wiKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyWzBdLmtleTtcbn07XG5cbi8qKlxuICogSW5zZXJ0cyBhIG5ldyBrZXkgaW50byB0aGUgcHJpb3JpdHkgcXVldWUuIElmIHRoZSBrZXkgYWxyZWFkeSBleGlzdHMgaW5cbiAqIHRoZSBxdWV1ZSB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYDsgb3RoZXJ3aXNlIGl0IHdpbGwgcmV0dXJuIGB0cnVlYC5cbiAqIFRha2VzIGBPKG4pYCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBrZXkgdGhlIGtleSB0byBhZGRcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmlvcml0eSB0aGUgaW5pdGlhbCBwcmlvcml0eSBmb3IgdGhlIGtleVxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihrZXksIHByaW9yaXR5KSB7XG4gIHZhciBrZXlJbmRpY2VzID0gdGhpcy5fa2V5SW5kaWNlcztcbiAga2V5ID0gU3RyaW5nKGtleSk7XG4gIGlmICghXy5oYXMoa2V5SW5kaWNlcywga2V5KSkge1xuICAgIHZhciBhcnIgPSB0aGlzLl9hcnI7XG4gICAgdmFyIGluZGV4ID0gYXJyLmxlbmd0aDtcbiAgICBrZXlJbmRpY2VzW2tleV0gPSBpbmRleDtcbiAgICBhcnIucHVzaCh7a2V5OiBrZXksIHByaW9yaXR5OiBwcmlvcml0eX0pO1xuICAgIHRoaXMuX2RlY3JlYXNlKGluZGV4KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW5kIHJldHVybnMgdGhlIHNtYWxsZXN0IGtleSBpbiB0aGUgcXVldWUuIFRha2VzIGBPKGxvZyBuKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucmVtb3ZlTWluID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3N3YXAoMCwgdGhpcy5fYXJyLmxlbmd0aCAtIDEpO1xuICB2YXIgbWluID0gdGhpcy5fYXJyLnBvcCgpO1xuICBkZWxldGUgdGhpcy5fa2V5SW5kaWNlc1ttaW4ua2V5XTtcbiAgdGhpcy5faGVhcGlmeSgwKTtcbiAgcmV0dXJuIG1pbi5rZXk7XG59O1xuXG4vKipcbiAqIERlY3JlYXNlcyB0aGUgcHJpb3JpdHkgZm9yICoqa2V5KiogdG8gKipwcmlvcml0eSoqLiBJZiB0aGUgbmV3IHByaW9yaXR5IGlzXG4gKiBncmVhdGVyIHRoYW4gdGhlIHByZXZpb3VzIHByaW9yaXR5LCB0aGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGtleSB0aGUga2V5IGZvciB3aGljaCB0byByYWlzZSBwcmlvcml0eVxuICogQHBhcmFtIHtOdW1iZXJ9IHByaW9yaXR5IHRoZSBuZXcgcHJpb3JpdHkgZm9yIHRoZSBrZXlcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZGVjcmVhc2UgPSBmdW5jdGlvbihrZXksIHByaW9yaXR5KSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX2tleUluZGljZXNba2V5XTtcbiAgaWYgKHByaW9yaXR5ID4gdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5ldyBwcmlvcml0eSBpcyBncmVhdGVyIHRoYW4gY3VycmVudCBwcmlvcml0eS4gXCIgK1xuICAgICAgICBcIktleTogXCIgKyBrZXkgKyBcIiBPbGQ6IFwiICsgdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eSArIFwiIE5ldzogXCIgKyBwcmlvcml0eSk7XG4gIH1cbiAgdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eSA9IHByaW9yaXR5O1xuICB0aGlzLl9kZWNyZWFzZShpbmRleCk7XG59O1xuXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5faGVhcGlmeSA9IGZ1bmN0aW9uKGkpIHtcbiAgdmFyIGFyciA9IHRoaXMuX2FycjtcbiAgdmFyIGwgPSAyICogaTtcbiAgdmFyIHIgPSBsICsgMTtcbiAgdmFyIGxhcmdlc3QgPSBpO1xuICBpZiAobCA8IGFyci5sZW5ndGgpIHtcbiAgICBsYXJnZXN0ID0gYXJyW2xdLnByaW9yaXR5IDwgYXJyW2xhcmdlc3RdLnByaW9yaXR5ID8gbCA6IGxhcmdlc3Q7XG4gICAgaWYgKHIgPCBhcnIubGVuZ3RoKSB7XG4gICAgICBsYXJnZXN0ID0gYXJyW3JdLnByaW9yaXR5IDwgYXJyW2xhcmdlc3RdLnByaW9yaXR5ID8gciA6IGxhcmdlc3Q7XG4gICAgfVxuICAgIGlmIChsYXJnZXN0ICE9PSBpKSB7XG4gICAgICB0aGlzLl9zd2FwKGksIGxhcmdlc3QpO1xuICAgICAgdGhpcy5faGVhcGlmeShsYXJnZXN0KTtcbiAgICB9XG4gIH1cbn07XG5cblByaW9yaXR5UXVldWUucHJvdG90eXBlLl9kZWNyZWFzZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciBhcnIgPSB0aGlzLl9hcnI7XG4gIHZhciBwcmlvcml0eSA9IGFycltpbmRleF0ucHJpb3JpdHk7XG4gIHZhciBwYXJlbnQ7XG4gIHdoaWxlIChpbmRleCAhPT0gMCkge1xuICAgIHBhcmVudCA9IGluZGV4ID4+IDE7XG4gICAgaWYgKGFycltwYXJlbnRdLnByaW9yaXR5IDwgcHJpb3JpdHkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl9zd2FwKGluZGV4LCBwYXJlbnQpO1xuICAgIGluZGV4ID0gcGFyZW50O1xuICB9XG59O1xuXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5fc3dhcCA9IGZ1bmN0aW9uKGksIGopIHtcbiAgdmFyIGFyciA9IHRoaXMuX2FycjtcbiAgdmFyIGtleUluZGljZXMgPSB0aGlzLl9rZXlJbmRpY2VzO1xuICB2YXIgb3JpZ0FyckkgPSBhcnJbaV07XG4gIHZhciBvcmlnQXJySiA9IGFycltqXTtcbiAgYXJyW2ldID0gb3JpZ0Fycko7XG4gIGFycltqXSA9IG9yaWdBcnJJO1xuICBrZXlJbmRpY2VzW29yaWdBcnJKLmtleV0gPSBpO1xuICBrZXlJbmRpY2VzW29yaWdBcnJJLmtleV0gPSBqO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2dyYXBoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9ncmFwaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2xvZGFzaC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaDtcblxudmFyIERFRkFVTFRfRURHRV9OQU1FID0gXCJcXHgwMFwiO1xudmFyIEdSQVBIX05PREUgPSBcIlxceDAwXCI7XG52YXIgRURHRV9LRVlfREVMSU0gPSBcIlxceDAxXCI7XG5cbi8vIEltcGxlbWVudGF0aW9uIG5vdGVzOlxuLy9cbi8vICAqIE5vZGUgaWQgcXVlcnkgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gc3RyaW5nIGlkcyBmb3IgdGhlIG5vZGVzXG4vLyAgKiBFZGdlIGlkIHF1ZXJ5IGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIFwiZWRnZU9ialwiLCBlZGdlIG9iamVjdCwgdGhhdCBpc1xuLy8gICAgY29tcG9zZWQgb2YgZW5vdWdoIGluZm9ybWF0aW9uIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGFuIGVkZ2U6IHt2LCB3LCBuYW1lfS5cbi8vICAqIEludGVybmFsbHkgd2UgdXNlIGFuIFwiZWRnZUlkXCIsIGEgc3RyaW5naWZpZWQgZm9ybSBvZiB0aGUgZWRnZU9iaiwgdG9cbi8vICAgIHJlZmVyZW5jZSBlZGdlcy4gVGhpcyBpcyBiZWNhdXNlIHdlIG5lZWQgYSBwZXJmb3JtYW50IHdheSB0byBsb29rIHRoZXNlXG4vLyAgICBlZGdlcyB1cCBhbmQsIG9iamVjdCBwcm9wZXJ0aWVzLCB3aGljaCBoYXZlIHN0cmluZyBrZXlzLCBhcmUgdGhlIGNsb3Nlc3Rcbi8vICAgIHdlJ3JlIGdvaW5nIHRvIGdldCB0byBhIHBlcmZvcm1hbnQgaGFzaHRhYmxlIGluIEphdmFTY3JpcHQuXG5cbmZ1bmN0aW9uIEdyYXBoKG9wdHMpIHtcbiAgdGhpcy5faXNEaXJlY3RlZCA9IF8uaGFzKG9wdHMsIFwiZGlyZWN0ZWRcIikgPyBvcHRzLmRpcmVjdGVkIDogdHJ1ZTtcbiAgdGhpcy5faXNNdWx0aWdyYXBoID0gXy5oYXMob3B0cywgXCJtdWx0aWdyYXBoXCIpID8gb3B0cy5tdWx0aWdyYXBoIDogZmFsc2U7XG4gIHRoaXMuX2lzQ29tcG91bmQgPSBfLmhhcyhvcHRzLCBcImNvbXBvdW5kXCIpID8gb3B0cy5jb21wb3VuZCA6IGZhbHNlO1xuXG4gIC8vIExhYmVsIGZvciB0aGUgZ3JhcGggaXRzZWxmXG4gIHRoaXMuX2xhYmVsID0gdW5kZWZpbmVkO1xuXG4gIC8vIERlZmF1bHRzIHRvIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IG5vZGVcbiAgdGhpcy5fZGVmYXVsdE5vZGVMYWJlbEZuID0gXy5jb25zdGFudCh1bmRlZmluZWQpO1xuXG4gIC8vIERlZmF1bHRzIHRvIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IGVkZ2VcbiAgdGhpcy5fZGVmYXVsdEVkZ2VMYWJlbEZuID0gXy5jb25zdGFudCh1bmRlZmluZWQpO1xuXG4gIC8vIHYgLT4gbGFiZWxcbiAgdGhpcy5fbm9kZXMgPSB7fTtcblxuICBpZiAodGhpcy5faXNDb21wb3VuZCkge1xuICAgIC8vIHYgLT4gcGFyZW50XG4gICAgdGhpcy5fcGFyZW50ID0ge307XG5cbiAgICAvLyB2IC0+IGNoaWxkcmVuXG4gICAgdGhpcy5fY2hpbGRyZW4gPSB7fTtcbiAgICB0aGlzLl9jaGlsZHJlbltHUkFQSF9OT0RFXSA9IHt9O1xuICB9XG5cbiAgLy8gdiAtPiBlZGdlT2JqXG4gIHRoaXMuX2luID0ge307XG5cbiAgLy8gdSAtPiB2IC0+IE51bWJlclxuICB0aGlzLl9wcmVkcyA9IHt9O1xuXG4gIC8vIHYgLT4gZWRnZU9ialxuICB0aGlzLl9vdXQgPSB7fTtcblxuICAvLyB2IC0+IHcgLT4gTnVtYmVyXG4gIHRoaXMuX3N1Y3MgPSB7fTtcblxuICAvLyBlIC0+IGVkZ2VPYmpcbiAgdGhpcy5fZWRnZU9ianMgPSB7fTtcblxuICAvLyBlIC0+IGxhYmVsXG4gIHRoaXMuX2VkZ2VMYWJlbHMgPSB7fTtcbn1cblxuLyogTnVtYmVyIG9mIG5vZGVzIGluIHRoZSBncmFwaC4gU2hvdWxkIG9ubHkgYmUgY2hhbmdlZCBieSB0aGUgaW1wbGVtZW50YXRpb24uICovXG5HcmFwaC5wcm90b3R5cGUuX25vZGVDb3VudCA9IDA7XG5cbi8qIE51bWJlciBvZiBlZGdlcyBpbiB0aGUgZ3JhcGguIFNob3VsZCBvbmx5IGJlIGNoYW5nZWQgYnkgdGhlIGltcGxlbWVudGF0aW9uLiAqL1xuR3JhcGgucHJvdG90eXBlLl9lZGdlQ291bnQgPSAwO1xuXG5cbi8qID09PSBHcmFwaCBmdW5jdGlvbnMgPT09PT09PT09ICovXG5cbkdyYXBoLnByb3RvdHlwZS5pc0RpcmVjdGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pc0RpcmVjdGVkO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmlzTXVsdGlncmFwaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faXNNdWx0aWdyYXBoO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmlzQ29tcG91bmQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2lzQ29tcG91bmQ7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0R3JhcGggPSBmdW5jdGlvbihsYWJlbCkge1xuICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ncmFwaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbGFiZWw7XG59O1xuXG5cbi8qID09PSBOb2RlIGZ1bmN0aW9ucyA9PT09PT09PT09ICovXG5cbkdyYXBoLnByb3RvdHlwZS5zZXREZWZhdWx0Tm9kZUxhYmVsID0gZnVuY3Rpb24obmV3RGVmYXVsdCkge1xuICBpZiAoIV8uaXNGdW5jdGlvbihuZXdEZWZhdWx0KSkge1xuICAgIG5ld0RlZmF1bHQgPSBfLmNvbnN0YW50KG5ld0RlZmF1bHQpO1xuICB9XG4gIHRoaXMuX2RlZmF1bHROb2RlTGFiZWxGbiA9IG5ld0RlZmF1bHQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLm5vZGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZUNvdW50O1xufTtcblxuR3JhcGgucHJvdG90eXBlLm5vZGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBfLmtleXModGhpcy5fbm9kZXMpO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNvdXJjZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gXy5maWx0ZXIodGhpcy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIF8uaXNFbXB0eShzZWxmLl9pblt2XSk7XG4gIH0pO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNpbmtzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIF8uZmlsdGVyKHRoaXMubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHJldHVybiBfLmlzRW1wdHkoc2VsZi5fb3V0W3ZdKTtcbiAgfSk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0Tm9kZXMgPSBmdW5jdGlvbih2cywgdmFsdWUpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgXy5lYWNoKHZzLCBmdW5jdGlvbih2KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMSkge1xuICAgICAgc2VsZi5zZXROb2RlKHYsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5zZXROb2RlKHYpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNldE5vZGUgPSBmdW5jdGlvbih2LCB2YWx1ZSkge1xuICBpZiAoXy5oYXModGhpcy5fbm9kZXMsIHYpKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLl9ub2Rlc1t2XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX25vZGVzW3ZdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB2YWx1ZSA6IHRoaXMuX2RlZmF1bHROb2RlTGFiZWxGbih2KTtcbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICB0aGlzLl9wYXJlbnRbdl0gPSBHUkFQSF9OT0RFO1xuICAgIHRoaXMuX2NoaWxkcmVuW3ZdID0ge307XG4gICAgdGhpcy5fY2hpbGRyZW5bR1JBUEhfTk9ERV1bdl0gPSB0cnVlO1xuICB9XG4gIHRoaXMuX2luW3ZdID0ge307XG4gIHRoaXMuX3ByZWRzW3ZdID0ge307XG4gIHRoaXMuX291dFt2XSA9IHt9O1xuICB0aGlzLl9zdWNzW3ZdID0ge307XG4gICsrdGhpcy5fbm9kZUNvdW50O1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdGhpcy5fbm9kZXNbdl07XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaGFzTm9kZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIF8uaGFzKHRoaXMuX25vZGVzLCB2KTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5yZW1vdmVOb2RlID0gIGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoXy5oYXModGhpcy5fbm9kZXMsIHYpKSB7XG4gICAgdmFyIHJlbW92ZUVkZ2UgPSBmdW5jdGlvbihlKSB7IHNlbGYucmVtb3ZlRWRnZShzZWxmLl9lZGdlT2Jqc1tlXSk7IH07XG4gICAgZGVsZXRlIHRoaXMuX25vZGVzW3ZdO1xuICAgIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgICB0aGlzLl9yZW1vdmVGcm9tUGFyZW50c0NoaWxkTGlzdCh2KTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9wYXJlbnRbdl07XG4gICAgICBfLmVhY2godGhpcy5jaGlsZHJlbih2KSwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgc2VsZi5zZXRQYXJlbnQoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgICBkZWxldGUgdGhpcy5fY2hpbGRyZW5bdl07XG4gICAgfVxuICAgIF8uZWFjaChfLmtleXModGhpcy5faW5bdl0pLCByZW1vdmVFZGdlKTtcbiAgICBkZWxldGUgdGhpcy5faW5bdl07XG4gICAgZGVsZXRlIHRoaXMuX3ByZWRzW3ZdO1xuICAgIF8uZWFjaChfLmtleXModGhpcy5fb3V0W3ZdKSwgcmVtb3ZlRWRnZSk7XG4gICAgZGVsZXRlIHRoaXMuX291dFt2XTtcbiAgICBkZWxldGUgdGhpcy5fc3Vjc1t2XTtcbiAgICAtLXRoaXMuX25vZGVDb3VudDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zZXRQYXJlbnQgPSBmdW5jdGlvbih2LCBwYXJlbnQpIHtcbiAgaWYgKCF0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBwYXJlbnQgaW4gYSBub24tY29tcG91bmQgZ3JhcGhcIik7XG4gIH1cblxuICBpZiAoXy5pc1VuZGVmaW5lZChwYXJlbnQpKSB7XG4gICAgcGFyZW50ID0gR1JBUEhfTk9ERTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb2VyY2UgcGFyZW50IHRvIHN0cmluZ1xuICAgIHBhcmVudCArPSBcIlwiO1xuICAgIGZvciAodmFyIGFuY2VzdG9yID0gcGFyZW50O1xuICAgICAgIV8uaXNVbmRlZmluZWQoYW5jZXN0b3IpO1xuICAgICAgYW5jZXN0b3IgPSB0aGlzLnBhcmVudChhbmNlc3RvcikpIHtcbiAgICAgIGlmIChhbmNlc3RvciA9PT0gdikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXR0aW5nIFwiICsgcGFyZW50KyBcIiBhcyBwYXJlbnQgb2YgXCIgKyB2ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIHdvdWxkIGNyZWF0ZSBhIGN5Y2xlXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0Tm9kZShwYXJlbnQpO1xuICB9XG5cbiAgdGhpcy5zZXROb2RlKHYpO1xuICB0aGlzLl9yZW1vdmVGcm9tUGFyZW50c0NoaWxkTGlzdCh2KTtcbiAgdGhpcy5fcGFyZW50W3ZdID0gcGFyZW50O1xuICB0aGlzLl9jaGlsZHJlbltwYXJlbnRdW3ZdID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuX3JlbW92ZUZyb21QYXJlbnRzQ2hpbGRMaXN0ID0gZnVuY3Rpb24odikge1xuICBkZWxldGUgdGhpcy5fY2hpbGRyZW5bdGhpcy5fcGFyZW50W3ZdXVt2XTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbih2KSB7XG4gIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudFt2XTtcbiAgICBpZiAocGFyZW50ICE9PSBHUkFQSF9OT0RFKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24odikge1xuICBpZiAoXy5pc1VuZGVmaW5lZCh2KSkge1xuICAgIHYgPSBHUkFQSF9OT0RFO1xuICB9XG5cbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlblt2XTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBfLmtleXMoY2hpbGRyZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2ID09PSBHUkFQSF9OT0RFKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmhhc05vZGUodikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5wcmVkZWNlc3NvcnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBwcmVkc1YgPSB0aGlzLl9wcmVkc1t2XTtcbiAgaWYgKHByZWRzVikge1xuICAgIHJldHVybiBfLmtleXMocHJlZHNWKTtcbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLnN1Y2Nlc3NvcnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBzdWNzViA9IHRoaXMuX3N1Y3Nbdl07XG4gIGlmIChzdWNzVikge1xuICAgIHJldHVybiBfLmtleXMoc3Vjc1YpO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUubmVpZ2hib3JzID0gZnVuY3Rpb24odikge1xuICB2YXIgcHJlZHMgPSB0aGlzLnByZWRlY2Vzc29ycyh2KTtcbiAgaWYgKHByZWRzKSB7XG4gICAgcmV0dXJuIF8udW5pb24ocHJlZHMsIHRoaXMuc3VjY2Vzc29ycyh2KSk7XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5pc0xlYWYgPSBmdW5jdGlvbiAodikge1xuICB2YXIgbmVpZ2hib3JzO1xuICBpZiAodGhpcy5pc0RpcmVjdGVkKCkpIHtcbiAgICBuZWlnaGJvcnMgPSB0aGlzLnN1Y2Nlc3NvcnModik7XG4gIH0gZWxzZSB7XG4gICAgbmVpZ2hib3JzID0gdGhpcy5uZWlnaGJvcnModik7XG4gIH1cbiAgcmV0dXJuIG5laWdoYm9ycy5sZW5ndGggPT09IDA7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZmlsdGVyTm9kZXMgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgdmFyIGNvcHkgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgZGlyZWN0ZWQ6IHRoaXMuX2lzRGlyZWN0ZWQsXG4gICAgbXVsdGlncmFwaDogdGhpcy5faXNNdWx0aWdyYXBoLFxuICAgIGNvbXBvdW5kOiB0aGlzLl9pc0NvbXBvdW5kXG4gIH0pO1xuXG4gIGNvcHkuc2V0R3JhcGgodGhpcy5ncmFwaCgpKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIF8uZWFjaCh0aGlzLl9ub2RlcywgZnVuY3Rpb24odmFsdWUsIHYpIHtcbiAgICBpZiAoZmlsdGVyKHYpKSB7XG4gICAgICBjb3B5LnNldE5vZGUodiwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgXy5lYWNoKHRoaXMuX2VkZ2VPYmpzLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGNvcHkuaGFzTm9kZShlLnYpICYmIGNvcHkuaGFzTm9kZShlLncpKSB7XG4gICAgICBjb3B5LnNldEVkZ2UoZSwgc2VsZi5lZGdlKGUpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwYXJlbnRzID0ge307XG4gIGZ1bmN0aW9uIGZpbmRQYXJlbnQodikge1xuICAgIHZhciBwYXJlbnQgPSBzZWxmLnBhcmVudCh2KTtcbiAgICBpZiAocGFyZW50ID09PSB1bmRlZmluZWQgfHwgY29weS5oYXNOb2RlKHBhcmVudCkpIHtcbiAgICAgIHBhcmVudHNbdl0gPSBwYXJlbnQ7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH0gZWxzZSBpZiAocGFyZW50IGluIHBhcmVudHMpIHtcbiAgICAgIHJldHVybiBwYXJlbnRzW3BhcmVudF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmaW5kUGFyZW50KHBhcmVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICBfLmVhY2goY29weS5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgICBjb3B5LnNldFBhcmVudCh2LCBmaW5kUGFyZW50KHYpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufTtcblxuLyogPT09IEVkZ2UgZnVuY3Rpb25zID09PT09PT09PT0gKi9cblxuR3JhcGgucHJvdG90eXBlLnNldERlZmF1bHRFZGdlTGFiZWwgPSBmdW5jdGlvbihuZXdEZWZhdWx0KSB7XG4gIGlmICghXy5pc0Z1bmN0aW9uKG5ld0RlZmF1bHQpKSB7XG4gICAgbmV3RGVmYXVsdCA9IF8uY29uc3RhbnQobmV3RGVmYXVsdCk7XG4gIH1cbiAgdGhpcy5fZGVmYXVsdEVkZ2VMYWJlbEZuID0gbmV3RGVmYXVsdDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZWRnZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlQ291bnQ7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZWRnZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF8udmFsdWVzKHRoaXMuX2VkZ2VPYmpzKTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zZXRQYXRoID0gZnVuY3Rpb24odnMsIHZhbHVlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIF8ucmVkdWNlKHZzLCBmdW5jdGlvbih2LCB3KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMSkge1xuICAgICAgc2VsZi5zZXRFZGdlKHYsIHcsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5zZXRFZGdlKHYsIHcpO1xuICAgIH1cbiAgICByZXR1cm4gdztcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLypcbiAqIHNldEVkZ2UodiwgdywgW3ZhbHVlLCBbbmFtZV1dKVxuICogc2V0RWRnZSh7IHYsIHcsIFtuYW1lXSB9LCBbdmFsdWVdKVxuICovXG5HcmFwaC5wcm90b3R5cGUuc2V0RWRnZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdiwgdywgbmFtZSwgdmFsdWU7XG4gIHZhciB2YWx1ZVNwZWNpZmllZCA9IGZhbHNlO1xuICB2YXIgYXJnMCA9IGFyZ3VtZW50c1swXTtcblxuICBpZiAodHlwZW9mIGFyZzAgPT09IFwib2JqZWN0XCIgJiYgYXJnMCAhPT0gbnVsbCAmJiBcInZcIiBpbiBhcmcwKSB7XG4gICAgdiA9IGFyZzAudjtcbiAgICB3ID0gYXJnMC53O1xuICAgIG5hbWUgPSBhcmcwLm5hbWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFsdWVTcGVjaWZpZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ID0gYXJnMDtcbiAgICB3ID0gYXJndW1lbnRzWzFdO1xuICAgIG5hbWUgPSBhcmd1bWVudHNbM107XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICB2YWx1ZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhbHVlU3BlY2lmaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2ID0gXCJcIiArIHY7XG4gIHcgPSBcIlwiICsgdztcbiAgaWYgKCFfLmlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgbmFtZSA9IFwiXCIgKyBuYW1lO1xuICB9XG5cbiAgdmFyIGUgPSBlZGdlQXJnc1RvSWQodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSk7XG4gIGlmIChfLmhhcyh0aGlzLl9lZGdlTGFiZWxzLCBlKSkge1xuICAgIGlmICh2YWx1ZVNwZWNpZmllZCkge1xuICAgICAgdGhpcy5fZWRnZUxhYmVsc1tlXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICghXy5pc1VuZGVmaW5lZChuYW1lKSAmJiAhdGhpcy5faXNNdWx0aWdyYXBoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBhIG5hbWVkIGVkZ2Ugd2hlbiBpc011bHRpZ3JhcGggPSBmYWxzZVwiKTtcbiAgfVxuXG4gIC8vIEl0IGRpZG4ndCBleGlzdCwgc28gd2UgbmVlZCB0byBjcmVhdGUgaXQuXG4gIC8vIEZpcnN0IGVuc3VyZSB0aGUgbm9kZXMgZXhpc3QuXG4gIHRoaXMuc2V0Tm9kZSh2KTtcbiAgdGhpcy5zZXROb2RlKHcpO1xuXG4gIHRoaXMuX2VkZ2VMYWJlbHNbZV0gPSB2YWx1ZVNwZWNpZmllZCA/IHZhbHVlIDogdGhpcy5fZGVmYXVsdEVkZ2VMYWJlbEZuKHYsIHcsIG5hbWUpO1xuXG4gIHZhciBlZGdlT2JqID0gZWRnZUFyZ3NUb09iaih0aGlzLl9pc0RpcmVjdGVkLCB2LCB3LCBuYW1lKTtcbiAgLy8gRW5zdXJlIHdlIGFkZCB1bmRpcmVjdGVkIGVkZ2VzIGluIGEgY29uc2lzdGVudCB3YXkuXG4gIHYgPSBlZGdlT2JqLnY7XG4gIHcgPSBlZGdlT2JqLnc7XG5cbiAgT2JqZWN0LmZyZWV6ZShlZGdlT2JqKTtcbiAgdGhpcy5fZWRnZU9ianNbZV0gPSBlZGdlT2JqO1xuICBpbmNyZW1lbnRPckluaXRFbnRyeSh0aGlzLl9wcmVkc1t3XSwgdik7XG4gIGluY3JlbWVudE9ySW5pdEVudHJ5KHRoaXMuX3N1Y3Nbdl0sIHcpO1xuICB0aGlzLl9pblt3XVtlXSA9IGVkZ2VPYmo7XG4gIHRoaXMuX291dFt2XVtlXSA9IGVkZ2VPYmo7XG4gIHRoaXMuX2VkZ2VDb3VudCsrO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5lZGdlID0gZnVuY3Rpb24odiwgdywgbmFtZSkge1xuICB2YXIgZSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgPyBlZGdlT2JqVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCBhcmd1bWVudHNbMF0pXG4gICAgOiBlZGdlQXJnc1RvSWQodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSkpO1xuICByZXR1cm4gdGhpcy5fZWRnZUxhYmVsc1tlXTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5oYXNFZGdlID0gZnVuY3Rpb24odiwgdywgbmFtZSkge1xuICB2YXIgZSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgPyBlZGdlT2JqVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCBhcmd1bWVudHNbMF0pXG4gICAgOiBlZGdlQXJnc1RvSWQodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSkpO1xuICByZXR1cm4gXy5oYXModGhpcy5fZWRnZUxhYmVscywgZSk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUucmVtb3ZlRWRnZSA9IGZ1bmN0aW9uKHYsIHcsIG5hbWUpIHtcbiAgdmFyIGUgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgID8gZWRnZU9ialRvSWQodGhpcy5faXNEaXJlY3RlZCwgYXJndW1lbnRzWzBdKVxuICAgIDogZWRnZUFyZ3NUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIHYsIHcsIG5hbWUpKTtcbiAgdmFyIGVkZ2UgPSB0aGlzLl9lZGdlT2Jqc1tlXTtcbiAgaWYgKGVkZ2UpIHtcbiAgICB2ID0gZWRnZS52O1xuICAgIHcgPSBlZGdlLnc7XG4gICAgZGVsZXRlIHRoaXMuX2VkZ2VMYWJlbHNbZV07XG4gICAgZGVsZXRlIHRoaXMuX2VkZ2VPYmpzW2VdO1xuICAgIGRlY3JlbWVudE9yUmVtb3ZlRW50cnkodGhpcy5fcHJlZHNbd10sIHYpO1xuICAgIGRlY3JlbWVudE9yUmVtb3ZlRW50cnkodGhpcy5fc3Vjc1t2XSwgdyk7XG4gICAgZGVsZXRlIHRoaXMuX2luW3ddW2VdO1xuICAgIGRlbGV0ZSB0aGlzLl9vdXRbdl1bZV07XG4gICAgdGhpcy5fZWRnZUNvdW50LS07XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaW5FZGdlcyA9IGZ1bmN0aW9uKHYsIHUpIHtcbiAgdmFyIGluViA9IHRoaXMuX2luW3ZdO1xuICBpZiAoaW5WKSB7XG4gICAgdmFyIGVkZ2VzID0gXy52YWx1ZXMoaW5WKTtcbiAgICBpZiAoIXUpIHtcbiAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgcmV0dXJuIF8uZmlsdGVyKGVkZ2VzLCBmdW5jdGlvbihlZGdlKSB7IHJldHVybiBlZGdlLnYgPT09IHU7IH0pO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUub3V0RWRnZXMgPSBmdW5jdGlvbih2LCB3KSB7XG4gIHZhciBvdXRWID0gdGhpcy5fb3V0W3ZdO1xuICBpZiAob3V0Vikge1xuICAgIHZhciBlZGdlcyA9IF8udmFsdWVzKG91dFYpO1xuICAgIGlmICghdykge1xuICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICByZXR1cm4gXy5maWx0ZXIoZWRnZXMsIGZ1bmN0aW9uKGVkZ2UpIHsgcmV0dXJuIGVkZ2UudyA9PT0gdzsgfSk7XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ub2RlRWRnZXMgPSBmdW5jdGlvbih2LCB3KSB7XG4gIHZhciBpbkVkZ2VzID0gdGhpcy5pbkVkZ2VzKHYsIHcpO1xuICBpZiAoaW5FZGdlcykge1xuICAgIHJldHVybiBpbkVkZ2VzLmNvbmNhdCh0aGlzLm91dEVkZ2VzKHYsIHcpKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaW5jcmVtZW50T3JJbml0RW50cnkobWFwLCBrKSB7XG4gIGlmIChtYXBba10pIHtcbiAgICBtYXBba10rKztcbiAgfSBlbHNlIHtcbiAgICBtYXBba10gPSAxO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlY3JlbWVudE9yUmVtb3ZlRW50cnkobWFwLCBrKSB7XG4gIGlmICghLS1tYXBba10pIHsgZGVsZXRlIG1hcFtrXTsgfVxufVxuXG5mdW5jdGlvbiBlZGdlQXJnc1RvSWQoaXNEaXJlY3RlZCwgdl8sIHdfLCBuYW1lKSB7XG4gIHZhciB2ID0gXCJcIiArIHZfO1xuICB2YXIgdyA9IFwiXCIgKyB3XztcbiAgaWYgKCFpc0RpcmVjdGVkICYmIHYgPiB3KSB7XG4gICAgdmFyIHRtcCA9IHY7XG4gICAgdiA9IHc7XG4gICAgdyA9IHRtcDtcbiAgfVxuICByZXR1cm4gdiArIEVER0VfS0VZX0RFTElNICsgdyArIEVER0VfS0VZX0RFTElNICtcbiAgICAgICAgICAgICAoXy5pc1VuZGVmaW5lZChuYW1lKSA/IERFRkFVTFRfRURHRV9OQU1FIDogbmFtZSk7XG59XG5cbmZ1bmN0aW9uIGVkZ2VBcmdzVG9PYmooaXNEaXJlY3RlZCwgdl8sIHdfLCBuYW1lKSB7XG4gIHZhciB2ID0gXCJcIiArIHZfO1xuICB2YXIgdyA9IFwiXCIgKyB3XztcbiAgaWYgKCFpc0RpcmVjdGVkICYmIHYgPiB3KSB7XG4gICAgdmFyIHRtcCA9IHY7XG4gICAgdiA9IHc7XG4gICAgdyA9IHRtcDtcbiAgfVxuICB2YXIgZWRnZU9iaiA9ICB7IHY6IHYsIHc6IHcgfTtcbiAgaWYgKG5hbWUpIHtcbiAgICBlZGdlT2JqLm5hbWUgPSBuYW1lO1xuICB9XG4gIHJldHVybiBlZGdlT2JqO1xufVxuXG5mdW5jdGlvbiBlZGdlT2JqVG9JZChpc0RpcmVjdGVkLCBlZGdlT2JqKSB7XG4gIHJldHVybiBlZGdlQXJnc1RvSWQoaXNEaXJlY3RlZCwgZWRnZU9iai52LCBlZGdlT2JqLncsIGVkZ2VPYmoubmFtZSk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBJbmNsdWRlcyBvbmx5IHRoZSBcImNvcmVcIiBvZiBncmFwaGxpYlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdyYXBoOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dyYXBoICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9ncmFwaC5qc1wiKSxcbiAgdmVyc2lvbjogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92ZXJzaW9uICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi92ZXJzaW9uLmpzXCIpXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvanNvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9qc29uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9sb2Rhc2guanNcIik7XG52YXIgR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dyYXBoICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9ncmFwaC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHdyaXRlOiB3cml0ZSxcbiAgcmVhZDogcmVhZFxufTtcblxuZnVuY3Rpb24gd3JpdGUoZykge1xuICB2YXIganNvbiA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICBkaXJlY3RlZDogZy5pc0RpcmVjdGVkKCksXG4gICAgICBtdWx0aWdyYXBoOiBnLmlzTXVsdGlncmFwaCgpLFxuICAgICAgY29tcG91bmQ6IGcuaXNDb21wb3VuZCgpXG4gICAgfSxcbiAgICBub2Rlczogd3JpdGVOb2RlcyhnKSxcbiAgICBlZGdlczogd3JpdGVFZGdlcyhnKVxuICB9O1xuICBpZiAoIV8uaXNVbmRlZmluZWQoZy5ncmFwaCgpKSkge1xuICAgIGpzb24udmFsdWUgPSBfLmNsb25lKGcuZ3JhcGgoKSk7XG4gIH1cbiAgcmV0dXJuIGpzb247XG59XG5cbmZ1bmN0aW9uIHdyaXRlTm9kZXMoZykge1xuICByZXR1cm4gXy5tYXAoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGVWYWx1ZSA9IGcubm9kZSh2KTtcbiAgICB2YXIgcGFyZW50ID0gZy5wYXJlbnQodik7XG4gICAgdmFyIG5vZGUgPSB7IHY6IHYgfTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQobm9kZVZhbHVlKSkge1xuICAgICAgbm9kZS52YWx1ZSA9IG5vZGVWYWx1ZTtcbiAgICB9XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmVudCkpIHtcbiAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRWRnZXMoZykge1xuICByZXR1cm4gXy5tYXAoZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2VWYWx1ZSA9IGcuZWRnZShlKTtcbiAgICB2YXIgZWRnZSA9IHsgdjogZS52LCB3OiBlLncgfTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoZS5uYW1lKSkge1xuICAgICAgZWRnZS5uYW1lID0gZS5uYW1lO1xuICAgIH1cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoZWRnZVZhbHVlKSkge1xuICAgICAgZWRnZS52YWx1ZSA9IGVkZ2VWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGVkZ2U7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWFkKGpzb24pIHtcbiAgdmFyIGcgPSBuZXcgR3JhcGgoanNvbi5vcHRpb25zKS5zZXRHcmFwaChqc29uLnZhbHVlKTtcbiAgXy5lYWNoKGpzb24ubm9kZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgZy5zZXROb2RlKGVudHJ5LnYsIGVudHJ5LnZhbHVlKTtcbiAgICBpZiAoZW50cnkucGFyZW50KSB7XG4gICAgICBnLnNldFBhcmVudChlbnRyeS52LCBlbnRyeS5wYXJlbnQpO1xuICAgIH1cbiAgfSk7XG4gIF8uZWFjaChqc29uLmVkZ2VzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgIGcuc2V0RWRnZSh7IHY6IGVudHJ5LnYsIHc6IGVudHJ5LncsIG5hbWU6IGVudHJ5Lm5hbWUgfSwgZW50cnkudmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIGc7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9sb2Rhc2guanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9sb2Rhc2guanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG52YXIgbG9kYXNoO1xuXG5pZiAodHJ1ZSkge1xuICB0cnkge1xuICAgIGxvZGFzaCA9IHtcbiAgICAgIGNsb25lOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvY2xvbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2Nsb25lLmpzXCIpLFxuICAgICAgY29uc3RhbnQ6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9jb25zdGFudCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvY29uc3RhbnQuanNcIiksXG4gICAgICBlYWNoOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvZWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZWFjaC5qc1wiKSxcbiAgICAgIGZpbHRlcjogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL2ZpbHRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZmlsdGVyLmpzXCIpLFxuICAgICAgaGFzOiAgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaGFzLmpzXCIpLFxuICAgICAgaXNBcnJheTogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL2lzQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXkuanNcIiksXG4gICAgICBpc0VtcHR5OiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvaXNFbXB0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNFbXB0eS5qc1wiKSxcbiAgICAgIGlzRnVuY3Rpb246IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9pc0Z1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0Z1bmN0aW9uLmpzXCIpLFxuICAgICAgaXNVbmRlZmluZWQ6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9pc1VuZGVmaW5lZCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNVbmRlZmluZWQuanNcIiksXG4gICAgICBrZXlzOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gva2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gva2V5cy5qc1wiKSxcbiAgICAgIG1hcDogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL21hcCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbWFwLmpzXCIpLFxuICAgICAgcmVkdWNlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvcmVkdWNlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9yZWR1Y2UuanNcIiksXG4gICAgICBzaXplOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvc2l6ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvc2l6ZS5qc1wiKSxcbiAgICAgIHRyYW5zZm9ybTogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL3RyYW5zZm9ybSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdHJhbnNmb3JtLmpzXCIpLFxuICAgICAgdW5pb246IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC91bmlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdW5pb24uanNcIiksXG4gICAgICB2YWx1ZXM6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC92YWx1ZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3ZhbHVlcy5qc1wiKVxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG4gIH1cbn1cblxuaWYgKCFsb2Rhc2gpIHtcbiAgbG9kYXNoID0gd2luZG93Ll87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbG9kYXNoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvdmVyc2lvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi92ZXJzaW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9ICcyLjEuOCc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2lzYXJyYXlAMC4wLjFAaXNhcnJheS9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19pc2FycmF5QDAuMC4xQGlzYXJyYXkvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fRGF0YVZpZXcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fRGF0YVZpZXcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldE5hdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dldE5hdGl2ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldE5hdGl2ZS5qc1wiKSxcbiAgICByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcm9vdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3Jvb3QuanNcIik7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19IYXNoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fSGFzaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoYXNoQ2xlYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oYXNoQ2xlYXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19oYXNoQ2xlYXIuanNcIiksXG4gICAgaGFzaERlbGV0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hhc2hEZWxldGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19oYXNoRGVsZXRlLmpzXCIpLFxuICAgIGhhc2hHZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oYXNoR2V0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faGFzaEdldC5qc1wiKSxcbiAgICBoYXNoSGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGFzaEhhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2hhc2hIYXMuanNcIiksXG4gICAgaGFzaFNldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hhc2hTZXQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19oYXNoU2V0LmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX0xpc3RDYWNoZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fTGlzdENhY2hlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbGlzdENhY2hlQ2xlYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19saXN0Q2FjaGVDbGVhciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzXCIpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2xpc3RDYWNoZURlbGV0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qc1wiKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19saXN0Q2FjaGVHZXQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19saXN0Q2FjaGVHZXQuanNcIiksXG4gICAgbGlzdENhY2hlSGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbGlzdENhY2hlSGFzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbGlzdENhY2hlSGFzLmpzXCIpLFxuICAgIGxpc3RDYWNoZVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2xpc3RDYWNoZVNldCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2xpc3RDYWNoZVNldC5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19NYXAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX01hcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldE5hdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dldE5hdGl2ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldE5hdGl2ZS5qc1wiKSxcbiAgICByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcm9vdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3Jvb3QuanNcIik7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19NYXBDYWNoZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19NYXBDYWNoZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbWFwQ2FjaGVDbGVhciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX21hcENhY2hlQ2xlYXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzXCIpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbWFwQ2FjaGVEZWxldGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qc1wiKSxcbiAgICBtYXBDYWNoZUdldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX21hcENhY2hlR2V0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbWFwQ2FjaGVHZXQuanNcIiksXG4gICAgbWFwQ2FjaGVIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19tYXBDYWNoZUhhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hcENhY2hlSGFzLmpzXCIpLFxuICAgIG1hcENhY2hlU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbWFwQ2FjaGVTZXQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19tYXBDYWNoZVNldC5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fUHJvbWlzZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1Byb21pc2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0TmF0aXZlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0TmF0aXZlLmpzXCIpLFxuICAgIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yb290ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fcm9vdC5qc1wiKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1NldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0TmF0aXZlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0TmF0aXZlLmpzXCIpLFxuICAgIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yb290ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fcm9vdC5qc1wiKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1NldENhY2hlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1NldENhY2hlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBNYXBDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX01hcENhY2hlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fTWFwQ2FjaGUuanNcIiksXG4gICAgc2V0Q2FjaGVBZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zZXRDYWNoZUFkZCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3NldENhY2hlQWRkLmpzXCIpLFxuICAgIHNldENhY2hlSGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc2V0Q2FjaGVIYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zZXRDYWNoZUhhcy5qc1wiKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1N0YWNrLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1N0YWNrLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBMaXN0Q2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19MaXN0Q2FjaGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19MaXN0Q2FjaGUuanNcIiksXG4gICAgc3RhY2tDbGVhciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3N0YWNrQ2xlYXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdGFja0NsZWFyLmpzXCIpLFxuICAgIHN0YWNrRGVsZXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc3RhY2tEZWxldGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdGFja0RlbGV0ZS5qc1wiKSxcbiAgICBzdGFja0dldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3N0YWNrR2V0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc3RhY2tHZXQuanNcIiksXG4gICAgc3RhY2tIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zdGFja0hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3N0YWNrSGFzLmpzXCIpLFxuICAgIHN0YWNrU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc3RhY2tTZXQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdGFja1NldC5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1N5bWJvbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU3ltYm9sLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3Jvb3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19yb290LmpzXCIpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fVWludDhBcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1VpbnQ4QXJyYXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3Jvb3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19yb290LmpzXCIpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fV2Vha01hcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1dlYWtNYXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0TmF0aXZlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0TmF0aXZlLmpzXCIpLFxuICAgIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yb290ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fcm9vdC5qc1wiKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FwcGx5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FwcGx5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheUVhY2guanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FycmF5RWFjaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheUZpbHRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheUZpbHRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlGaWx0ZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlJbmNsdWRlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FycmF5SW5jbHVkZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUluZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSW5kZXhPZiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJbmRleE9mLmpzXCIpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlJbmNsdWRlc1dpdGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlJbmNsdWRlc1dpdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUluY2x1ZGVzV2l0aDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlVGltZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlVGltZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlVGltZXMuanNcIiksXG4gICAgaXNBcmd1bWVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJndW1lbnRzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FyZ3VtZW50cy5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5LmpzXCIpLFxuICAgIGlzQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0J1ZmZlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNCdWZmZXIuanNcIiksXG4gICAgaXNJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzSW5kZXggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc0luZGV4LmpzXCIpLFxuICAgIGlzVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNUeXBlZEFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1R5cGVkQXJyYXkuanNcIik7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FycmF5TWFwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FycmF5TWFwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlQdXNoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheVB1c2guanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlSZWR1Y2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlSZWR1Y2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FycmF5U29tZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlTb21lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hc2NpaVNpemUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FzY2lpU2l6ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VQcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VQcm9wZXJ0eS5qc1wiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBzaXplIG9mIGFuIEFTQ0lJIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICovXG52YXIgYXNjaWlTaXplID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc2NpaVNpemU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXNzaWduTWVyZ2VWYWx1ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Fzc2lnbk1lcmdlVmFsdWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUFzc2lnblZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUFzc2lnblZhbHVlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzXCIpLFxuICAgIGVxID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lcSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZXEuanNcIik7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduTWVyZ2VWYWx1ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hc3NpZ25WYWx1ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUFzc2lnblZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUFzc2lnblZhbHVlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzXCIpLFxuICAgIGVxID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lcSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZXEuanNcIik7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXNzb2NJbmRleE9mLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hc3NvY0luZGV4T2YuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBlcSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXEgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2VxLmpzXCIpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlQXNzaWduLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUFzc2lnbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjb3B5T2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY29weU9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvcHlPYmplY3QuanNcIiksXG4gICAga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4va2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gva2V5cy5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUFzc2lnbkluLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlQXNzaWduSW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjb3B5T2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY29weU9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvcHlPYmplY3QuanNcIiksXG4gICAga2V5c0luID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9rZXlzSW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2tleXNJbi5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25JbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZGVmaW5lUHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUNsb25lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlQ2xvbmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTdGFjayA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1N0YWNrICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU3RhY2suanNcIiksXG4gICAgYXJyYXlFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXJyYXlFYWNoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlFYWNoLmpzXCIpLFxuICAgIGFzc2lnblZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXNzaWduVmFsdWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hc3NpZ25WYWx1ZS5qc1wiKSxcbiAgICBiYXNlQXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUFzc2lnbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VBc3NpZ24uanNcIiksXG4gICAgYmFzZUFzc2lnbkluID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUFzc2lnbkluICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUFzc2lnbkluLmpzXCIpLFxuICAgIGNsb25lQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY2xvbmVCdWZmZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jbG9uZUJ1ZmZlci5qc1wiKSxcbiAgICBjb3B5QXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb3B5QXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jb3B5QXJyYXkuanNcIiksXG4gICAgY29weVN5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb3B5U3ltYm9scyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvcHlTeW1ib2xzLmpzXCIpLFxuICAgIGNvcHlTeW1ib2xzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb3B5U3ltYm9sc0luICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29weVN5bWJvbHNJbi5qc1wiKSxcbiAgICBnZXRBbGxLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0QWxsS2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldEFsbEtleXMuanNcIiksXG4gICAgZ2V0QWxsS2V5c0luID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0QWxsS2V5c0luICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0QWxsS2V5c0luLmpzXCIpLFxuICAgIGdldFRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dldFRhZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldFRhZy5qc1wiKSxcbiAgICBpbml0Q2xvbmVBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2luaXRDbG9uZUFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faW5pdENsb25lQXJyYXkuanNcIiksXG4gICAgaW5pdENsb25lQnlUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pbml0Q2xvbmVCeVRhZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzXCIpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2luaXRDbG9uZU9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5LmpzXCIpLFxuICAgIGlzQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0J1ZmZlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNCdWZmZXIuanNcIiksXG4gICAgaXNNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzTWFwICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc01hcC5qc1wiKSxcbiAgICBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0LmpzXCIpLFxuICAgIGlzU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1NldCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNTZXQuanNcIiksXG4gICAga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4va2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gva2V5cy5qc1wiKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIERlZXAgY2xvbmVcbiAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICB2YXIgcmVzdWx0LFxuICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gIGlmIChjdXN0b21pemVyKSB7XG4gICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gIGlmIChzdGFja2VkKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQ7XG4gIH1cbiAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNsb25lO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VDcmVhdGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlQ3JlYXRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNPYmplY3QuanNcIik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRWFjaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRWFjaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUZvck93biA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VGb3JPd24gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRm9yT3duLmpzXCIpLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY3JlYXRlQmFzZUVhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jcmVhdGVCYXNlRWFjaC5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUV4dHJlbXVtLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRXh0cmVtdW0uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNTeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzU3ltYm9sLmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5tYXhgIGFuZCBgXy5taW5gIHdoaWNoIGFjY2VwdHMgYVxuICogYGNvbXBhcmF0b3JgIHRvIGRldGVybWluZSB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlRXh0cmVtdW0oYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjdXJyZW50ID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgaWYgKGN1cnJlbnQgIT0gbnVsbCAmJiAoY29tcHV0ZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKGN1cnJlbnQgPT09IGN1cnJlbnQgJiYgIWlzU3ltYm9sKGN1cnJlbnQpKVxuICAgICAgICAgIDogY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZClcbiAgICAgICAgKSkge1xuICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCxcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRXh0cmVtdW07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZpbHRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VGaWx0ZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlRWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VFYWNoLmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbHRlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRmluZEluZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaW5kSW5kZXg7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZsYXR0ZW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZsYXR0ZW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5UHVzaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FycmF5UHVzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FycmF5UHVzaC5qc1wiKSxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNGbGF0dGVuYWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzRmxhdHRlbmFibGUuanNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGbGF0dGVuO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VGb3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRm9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNyZWF0ZUJhc2VGb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jcmVhdGVCYXNlRm9yICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY3JlYXRlQmFzZUZvci5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZvck93bi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VGb3JPd24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUZvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VGb3IgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRm9yLmpzXCIpLFxuICAgIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2tleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2tleXMuanNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yT3duO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VHZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlR2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNhc3RQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY2FzdFBhdGggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jYXN0UGF0aC5qc1wiKSxcbiAgICB0b0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvS2V5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fdG9LZXkuanNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlQdXNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXJyYXlQdXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlQdXNoLmpzXCIpLFxuICAgIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXkuanNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlR2V0VGFnLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUdldFRhZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19TeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19TeW1ib2wuanNcIiksXG4gICAgZ2V0UmF3VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0UmF3VGFnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0UmF3VGFnLmpzXCIpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0VG9TdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19vYmplY3RUb1N0cmluZy5qc1wiKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlR3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VHdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ndGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUhhcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VIYXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSGFzSW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VIYXNJbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJbmRleE9mLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJbmRleE9mLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlRmluZEluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUZpbmRJbmRleCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VGaW5kSW5kZXguanNcIiksXG4gICAgYmFzZUlzTmFOID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUlzTmFOICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzTmFOLmpzXCIpLFxuICAgIHN0cmljdEluZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zdHJpY3RJbmRleE9mICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc3RyaWN0SW5kZXhPZi5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW5kZXhPZjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VHZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlR2V0VGFnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUdldFRhZy5qc1wiKSxcbiAgICBpc09iamVjdExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzT2JqZWN0TGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNPYmplY3RMaWtlLmpzXCIpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNFcXVhbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNFcXVhbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUlzRXF1YWxEZWVwID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUlzRXF1YWxEZWVwICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzXCIpLFxuICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3RMaWtlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdExpa2UuanNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJc0VxdWFsRGVlcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU3RhY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19TdGFjayAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1N0YWNrLmpzXCIpLFxuICAgIGVxdWFsQXJyYXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZXF1YWxBcnJheXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19lcXVhbEFycmF5cy5qc1wiKSxcbiAgICBlcXVhbEJ5VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZXF1YWxCeVRhZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2VxdWFsQnlUYWcuanNcIiksXG4gICAgZXF1YWxPYmplY3RzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZXF1YWxPYmplY3RzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZXF1YWxPYmplY3RzLmpzXCIpLFxuICAgIGdldFRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dldFRhZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldFRhZy5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5LmpzXCIpLFxuICAgIGlzQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0J1ZmZlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNCdWZmZXIuanNcIiksXG4gICAgaXNUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1R5cGVkQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzVHlwZWRBcnJheS5qc1wiKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJc01hcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzTWFwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0VGFnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0VGFnLmpzXCIpLFxuICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3RMaWtlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdExpa2UuanNcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hcDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNNYXRjaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNNYXRjaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU3RhY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19TdGFjayAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1N0YWNrLmpzXCIpLFxuICAgIGJhc2VJc0VxdWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUlzRXF1YWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNFcXVhbC5qc1wiKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzTmFOLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNOYU4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmFOO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzTmF0aXZlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNGdW5jdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNGdW5jdGlvbi5qc1wiKSxcbiAgICBpc01hc2tlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzTWFza2VkICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNNYXNrZWQuanNcIiksXG4gICAgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzT2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdC5qc1wiKSxcbiAgICB0b1NvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvU291cmNlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fdG9Tb3VyY2UuanNcIik7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJc1NldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzU2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0VGFnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0VGFnLmpzXCIpLFxuICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3RMaWtlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdExpa2UuanNcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1NldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUdldFRhZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VHZXRUYWcuanNcIiksXG4gICAgaXNMZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzTGVuZ3RoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0xlbmd0aC5qc1wiKSxcbiAgICBpc09iamVjdExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzT2JqZWN0TGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNPYmplY3RMaWtlLmpzXCIpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXRlcmF0ZWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VNYXRjaGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZU1hdGNoZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlTWF0Y2hlcy5qc1wiKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanNcIiksXG4gICAgaWRlbnRpdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lkZW50aXR5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pZGVudGl0eS5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5LmpzXCIpLFxuICAgIHByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvcHJvcGVydHkuanNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUl0ZXJhdGVlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VLZXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VLZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc1Byb3RvdHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzUHJvdG90eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNQcm90b3R5cGUuanNcIiksXG4gICAgbmF0aXZlS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX25hdGl2ZUtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19uYXRpdmVLZXlzLmpzXCIpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUtleXNJbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VLZXlzSW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzT2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdC5qc1wiKSxcbiAgICBpc1Byb3RvdHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzUHJvdG90eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNQcm90b3R5cGUuanNcIiksXG4gICAgbmF0aXZlS2V5c0luID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbmF0aXZlS2V5c0luICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbmF0aXZlS2V5c0luLmpzXCIpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUx0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlTHQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubHRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlIDwgb3RoZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUx0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VNYXAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlTWFwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUVhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRWFjaC5qc1wiKSxcbiAgICBpc0FycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheUxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXlMaWtlLmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZU1hdGNoZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZU1hdGNoZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VJc01hdGNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUlzTWF0Y2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNNYXRjaC5qc1wiKSxcbiAgICBnZXRNYXRjaERhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRNYXRjaERhdGEgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRNYXRjaERhdGEuanNcIiksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlSXNFcXVhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VJc0VxdWFsICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzRXF1YWwuanNcIiksXG4gICAgZ2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2dldC5qc1wiKSxcbiAgICBoYXNJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaGFzSW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2hhc0luLmpzXCIpLFxuICAgIGlzS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNLZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc0tleS5qc1wiKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pc1N0cmljdENvbXBhcmFibGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanNcIiksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzXCIpLFxuICAgIHRvS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG9LZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL190b0tleS5qc1wiKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzUHJvcGVydHk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZU1lcmdlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlTWVyZ2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTdGFjayA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1N0YWNrICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU3RhY2suanNcIiksXG4gICAgYXNzaWduTWVyZ2VWYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Fzc2lnbk1lcmdlVmFsdWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzXCIpLFxuICAgIGJhc2VGb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlRm9yICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZvci5qc1wiKSxcbiAgICBiYXNlTWVyZ2VEZWVwID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZU1lcmdlRGVlcCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VNZXJnZURlZXAuanNcIiksXG4gICAgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzT2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdC5qc1wiKSxcbiAgICBrZXlzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2tleXNJbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gva2V5c0luLmpzXCIpLFxuICAgIHNhZmVHZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zYWZlR2V0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2FmZUdldC5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBrZXlzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlTWVyZ2VEZWVwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZU1lcmdlRGVlcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhc3NpZ25NZXJnZVZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXNzaWduTWVyZ2VWYWx1ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Fzc2lnbk1lcmdlVmFsdWUuanNcIiksXG4gICAgY2xvbmVCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jbG9uZUJ1ZmZlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nsb25lQnVmZmVyLmpzXCIpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Nsb25lVHlwZWRBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qc1wiKSxcbiAgICBjb3B5QXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb3B5QXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jb3B5QXJyYXkuanNcIiksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faW5pdENsb25lT2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzXCIpLFxuICAgIGlzQXJndW1lbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FyZ3VtZW50cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcmd1bWVudHMuanNcIiksXG4gICAgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheS5qc1wiKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheUxpa2VPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXlMaWtlT2JqZWN0LmpzXCIpLFxuICAgIGlzQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0J1ZmZlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNCdWZmZXIuanNcIiksXG4gICAgaXNGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNGdW5jdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNGdW5jdGlvbi5qc1wiKSxcbiAgICBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0LmpzXCIpLFxuICAgIGlzUGxhaW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzUGxhaW5PYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzUGxhaW5PYmplY3QuanNcIiksXG4gICAgaXNUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1R5cGVkQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzVHlwZWRBcnJheS5qc1wiKSxcbiAgICBzYWZlR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc2FmZUdldCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3NhZmVHZXQuanNcIiksXG4gICAgdG9QbGFpbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG9QbGFpbk9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdG9QbGFpbk9iamVjdC5qc1wiKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2VEZWVwO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VPcmRlckJ5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VPcmRlckJ5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcnJheU1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FycmF5TWFwICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlNYXAuanNcIiksXG4gICAgYmFzZUl0ZXJhdGVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUl0ZXJhdGVlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzXCIpLFxuICAgIGJhc2VNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlTWFwICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZU1hcC5qc1wiKSxcbiAgICBiYXNlU29ydEJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVNvcnRCeSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VTb3J0QnkuanNcIiksXG4gICAgYmFzZVVuYXJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVVuYXJ5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVVuYXJ5LmpzXCIpLFxuICAgIGNvbXBhcmVNdWx0aXBsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NvbXBhcmVNdWx0aXBsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvbXBhcmVNdWx0aXBsZS5qc1wiKSxcbiAgICBpZGVudGl0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaWRlbnRpdHkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lkZW50aXR5LmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICB2YXIgaW5kZXggPSAtMTtcbiAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLmxlbmd0aCA/IGl0ZXJhdGVlcyA6IFtpZGVudGl0eV0sIGJhc2VVbmFyeShiYXNlSXRlcmF0ZWUpKTtcblxuICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBmdW5jdGlvbihvYmplY3QsIG90aGVyKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlT3JkZXJCeTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlUGljay5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlUGljay5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZVBpY2tCeSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VQaWNrQnkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlUGlja0J5LmpzXCIpLFxuICAgIGhhc0luID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9oYXNJbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaGFzSW4uanNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwYXRocykge1xuICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUGljaztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlUGlja0J5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVBpY2tCeS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUdldCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VHZXQuanNcIiksXG4gICAgYmFzZVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VTZXQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlU2V0LmpzXCIpLFxuICAgIGNhc3RQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY2FzdFBhdGggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jYXN0UGF0aC5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2tCeTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlUHJvcGVydHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VQcm9wZXJ0eS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUdldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VHZXQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlR2V0LmpzXCIpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHlEZWVwO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VSYW5nZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVJhbmdlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbCxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAqIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgc3RhcnQgKz0gc3RlcDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSYW5nZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlUmVkdWNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVJlZHVjZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgLCB3aXRob3V0IHN1cHBvcnRcbiAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyBgZWFjaEZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEFjY3VtIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudCBvZlxuICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBlYWNoRnVuYykge1xuICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuICAgICAgPyAoaW5pdEFjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVkdWNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VSZXN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VSZXN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpZGVudGl0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaWRlbnRpdHkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lkZW50aXR5LmpzXCIpLFxuICAgIG92ZXJSZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb3ZlclJlc3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19vdmVyUmVzdC5qc1wiKSxcbiAgICBzZXRUb1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3NldFRvU3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2V0VG9TdHJpbmcuanNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VTZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlU2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFzc2lnblZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXNzaWduVmFsdWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hc3NpZ25WYWx1ZS5qc1wiKSxcbiAgICBjYXN0UGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Nhc3RQYXRoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2FzdFBhdGguanNcIiksXG4gICAgaXNJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzSW5kZXggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc0luZGV4LmpzXCIpLFxuICAgIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNPYmplY3QuanNcIiksXG4gICAgdG9LZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190b0tleSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3RvS2V5LmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY29uc3RhbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnN0YW50ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9jb25zdGFudC5qc1wiKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2RlZmluZVByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZGVmaW5lUHJvcGVydHkuanNcIiksXG4gICAgaWRlbnRpdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lkZW50aXR5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pZGVudGl0eS5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VTb3J0QnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlU29ydEJ5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gKiB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU29ydEJ5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VUaW1lcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVRpbWVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlVG9TdHJpbmcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1N5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1N5bWJvbC5qc1wiKSxcbiAgICBhcnJheU1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FycmF5TWFwICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlNYXAuanNcIiksXG4gICAgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheS5qc1wiKSxcbiAgICBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNTeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzU3ltYm9sLmpzXCIpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlVW5hcnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VVbmFyeS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlVW5pcS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlVW5pcS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU2V0Q2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19TZXRDYWNoZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1NldENhY2hlLmpzXCIpLFxuICAgIGFycmF5SW5jbHVkZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hcnJheUluY2x1ZGVzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlJbmNsdWRlcy5qc1wiKSxcbiAgICBhcnJheUluY2x1ZGVzV2l0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FycmF5SW5jbHVkZXNXaXRoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlJbmNsdWRlc1dpdGguanNcIiksXG4gICAgY2FjaGVIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jYWNoZUhhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NhY2hlSGFzLmpzXCIpLFxuICAgIGNyZWF0ZVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NyZWF0ZVNldCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NyZWF0ZVNldC5qc1wiKSxcbiAgICBzZXRUb0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc2V0VG9BcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3NldFRvQXJyYXkuanNcIik7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgfVxuICBlbHNlIGlmIChsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgIGlmIChzZXQpIHtcbiAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XG4gICAgfVxuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICB9XG4gIGVsc2Uge1xuICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICB9XG4gIG91dGVyOlxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaW5jbHVkZXMoc2VlbiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0KSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuaXE7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVZhbHVlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VWYWx1ZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hcnJheU1hcCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FycmF5TWFwLmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVmFsdWVzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VaaXBPYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlWmlwT2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGlzIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uemlwT2JqZWN0YCB3aGljaCBhc3NpZ25zIHZhbHVlcyB1c2luZyBgYXNzaWduRnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduRnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VaaXBPYmplY3QocHJvcHMsIHZhbHVlcywgYXNzaWduRnVuYykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgIHZhbHNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBpbmRleCA8IHZhbHNMZW5ndGggPyB2YWx1ZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgIGFzc2lnbkZ1bmMocmVzdWx0LCBwcm9wc1tpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VaaXBPYmplY3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2FjaGVIYXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2FjaGVIYXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FjaGVIYXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2FzdEZ1bmN0aW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jYXN0RnVuY3Rpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpZGVudGl0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaWRlbnRpdHkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lkZW50aXR5LmpzXCIpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RGdW5jdGlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jYXN0UGF0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jYXN0UGF0aC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheS5qc1wiKSxcbiAgICBpc0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzS2V5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNLZXkuanNcIiksXG4gICAgc3RyaW5nVG9QYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc3RyaW5nVG9QYXRoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc3RyaW5nVG9QYXRoLmpzXCIpLFxuICAgIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90b1N0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdG9TdHJpbmcuanNcIik7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVWludDhBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1VpbnQ4QXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19VaW50OEFycmF5LmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jbG9uZUJ1ZmZlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jbG9uZUJ1ZmZlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24obW9kdWxlKSB7dmFyIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yb290ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fcm9vdC5qc1wiKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9ICB0cnVlICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vLi4vX3dlYnBhY2tANC40Mi4xQHdlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9fd2VicGFja0A0LjQyLjFAd2VicGFjay9idWlsZGluL21vZHVsZS5qc1wiKShtb2R1bGUpKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2xvbmVEYXRhVmlldy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nsb25lRGF0YVZpZXcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY2xvbmVBcnJheUJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Nsb25lQXJyYXlCdWZmZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGF0YVZpZXc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2xvbmVSZWdFeHAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2xvbmVSZWdFeHAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVJlZ0V4cDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jbG9uZVN5bWJvbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jbG9uZVN5bWJvbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fU3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU3ltYm9sLmpzXCIpO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTeW1ib2w7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjbG9uZUFycmF5QnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY2xvbmVBcnJheUJ1ZmZlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanNcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvbXBhcmVBc2NlbmRpbmcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jb21wYXJlQXNjZW5kaW5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1N5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNTeW1ib2wuanNcIik7XG5cbi8qKlxuICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlQXNjZW5kaW5nO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvbXBhcmVNdWx0aXBsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29tcGFyZU11bHRpcGxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY29tcGFyZUFzY2VuZGluZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NvbXBhcmVBc2NlbmRpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jb21wYXJlQXNjZW5kaW5nLmpzXCIpO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gKlxuICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAqIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgIH1cbiAgfVxuICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAvL1xuICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVNdWx0aXBsZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jb3B5QXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvcHlBcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvcHlPYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jb3B5T2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFzc2lnblZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXNzaWduVmFsdWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hc3NpZ25WYWx1ZS5qc1wiKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlQXNzaWduVmFsdWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanNcIik7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29weVN5bWJvbHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29weVN5bWJvbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNvcHlPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb3B5T2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29weU9iamVjdC5qc1wiKSxcbiAgICBnZXRTeW1ib2xzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0U3ltYm9scyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldFN5bWJvbHMuanNcIik7XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9scztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29weVN5bWJvbHNJbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjb3B5T2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY29weU9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvcHlPYmplY3QuanNcIiksXG4gICAgZ2V0U3ltYm9sc0luID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0U3ltYm9sc0luICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0U3ltYm9sc0luLmpzXCIpO1xuXG4vKipcbiAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHNJbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jb3JlSnNEYXRhLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29yZUpzRGF0YS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcm9vdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3Jvb3QuanNcIik7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZVJlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlUmVzdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VSZXN0LmpzXCIpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNJdGVyYXRlZUNhbGwgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jcmVhdGVCYXNlRWFjaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jcmVhdGVCYXNlRWFjaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXlMaWtlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5TGlrZS5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRWFjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY3JlYXRlRmluZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NyZWF0ZUZpbmQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUl0ZXJhdGVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUl0ZXJhdGVlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzXCIpLFxuICAgIGlzQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5TGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheUxpa2UuanNcIiksXG4gICAga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4va2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gva2V5cy5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgIHZhciBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24oa2V5KSB7IHJldHVybiBpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKTsgfTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpdGVyYWJsZVtpdGVyYXRlZSA/IGNvbGxlY3Rpb25baW5kZXhdIDogaW5kZXhdIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUZpbmQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY3JlYXRlUmFuZ2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY3JlYXRlUmFuZ2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VSYW5nZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VSYW5nZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VSYW5nZS5qc1wiKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzSXRlcmF0ZWVDYWxsICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNJdGVyYXRlZUNhbGwuanNcIiksXG4gICAgdG9GaW5pdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvRmluaXRlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC90b0Zpbml0ZS5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYF8ucmFuZ2VgIG9yIGBfLnJhbmdlUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJhbmdlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSYW5nZShmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICBpZiAoc3RlcCAmJiB0eXBlb2Ygc3RlcCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdGFydCwgZW5kLCBzdGVwKSkge1xuICAgICAgZW5kID0gc3RlcCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gRW5zdXJlIHRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAoc3RhcnQgPCBlbmQgPyAxIDogLTEpIDogdG9GaW5pdGUoc3RlcCk7XG4gICAgcmV0dXJuIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJhbmdlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NyZWF0ZVNldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY3JlYXRlU2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fU2V0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU2V0LmpzXCIpLFxuICAgIG5vb3AgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL25vb3AgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL25vb3AuanNcIiksXG4gICAgc2V0VG9BcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3NldFRvQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zZXRUb0FycmF5LmpzXCIpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gKi9cbnZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVNldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0TmF0aXZlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0TmF0aXZlLmpzXCIpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19lcXVhbEFycmF5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19lcXVhbEFycmF5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU2V0Q2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19TZXRDYWNoZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1NldENhY2hlLmpzXCIpLFxuICAgIGFycmF5U29tZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FycmF5U29tZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FycmF5U29tZS5qc1wiKSxcbiAgICBjYWNoZUhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NhY2hlSGFzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2FjaGVIYXMuanNcIik7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZXF1YWxCeVRhZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2VxdWFsQnlUYWcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fU3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU3ltYm9sLmpzXCIpLFxuICAgIFVpbnQ4QXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19VaW50OEFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fVWludDhBcnJheS5qc1wiKSxcbiAgICBlcSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXEgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2VxLmpzXCIpLFxuICAgIGVxdWFsQXJyYXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZXF1YWxBcnJheXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19lcXVhbEFycmF5cy5qc1wiKSxcbiAgICBtYXBUb0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbWFwVG9BcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hcFRvQXJyYXkuanNcIiksXG4gICAgc2V0VG9BcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3NldFRvQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zZXRUb0FycmF5LmpzXCIpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQnlUYWc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZXF1YWxPYmplY3RzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19lcXVhbE9iamVjdHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRBbGxLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0QWxsS2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldEFsbEtleXMuanNcIik7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsT2JqZWN0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19mbGF0UmVzdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19mbGF0UmVzdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmxhdHRlbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmxhdHRlbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZmxhdHRlbi5qc1wiKSxcbiAgICBvdmVyUmVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX292ZXJSZXN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fb3ZlclJlc3QuanNcIiksXG4gICAgc2V0VG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zZXRUb1N0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3NldFRvU3RyaW5nLmpzXCIpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbiksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdFJlc3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZnJlZUdsb2JhbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2ZyZWVHbG9iYWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi9fd2VicGFja0A0LjQyLjFAd2VicGFjay9idWlsZGluL2dsb2JhbC5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL193ZWJwYWNrQDQuNDIuMUB3ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXCIpKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0QWxsS2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldEFsbEtleXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUdldEFsbEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlR2V0QWxsS2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzXCIpLFxuICAgIGdldFN5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRTeW1ib2xzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0U3ltYm9scy5qc1wiKSxcbiAgICBrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9rZXlzLmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0QWxsS2V5c0luLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRBbGxLZXlzSW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0QWxsS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VHZXRBbGxLZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUdldEFsbEtleXMuanNcIiksXG4gICAgZ2V0U3ltYm9sc0luID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0U3ltYm9sc0luICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0U3ltYm9sc0luLmpzXCIpLFxuICAgIGtleXNJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4va2V5c0luICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9rZXlzSW4uanNcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5c0luO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldE1hcERhdGEuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRNYXBEYXRhLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzS2V5YWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzS2V5YWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzS2V5YWJsZS5qc1wiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0TWF0Y2hEYXRhLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRNYXRjaERhdGEuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc1N0cmljdENvbXBhcmFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pc1N0cmljdENvbXBhcmFibGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanNcIiksXG4gICAga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4va2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gva2V5cy5qc1wiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldE5hdGl2ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0TmF0aXZlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUlzTmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUlzTmF0aXZlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzTmF0aXZlLmpzXCIpLFxuICAgIGdldFZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0VmFsdWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRWYWx1ZS5qc1wiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0UHJvdG90eXBlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRQcm90b3R5cGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBvdmVyQXJnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb3ZlckFyZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX292ZXJBcmcuanNcIik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRSYXdUYWcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldFJhd1RhZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1N5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1N5bWJvbC5qc1wiKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRTeW1ib2xzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0U3ltYm9scy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcnJheUZpbHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FycmF5RmlsdGVyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlGaWx0ZXIuanNcIiksXG4gICAgc3R1YkFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zdHViQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3N0dWJBcnJheS5qc1wiKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0U3ltYm9sc0luLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRTeW1ib2xzSW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcnJheVB1c2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hcnJheVB1c2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheVB1c2guanNcIiksXG4gICAgZ2V0UHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0UHJvdG90eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0UHJvdG90eXBlLmpzXCIpLFxuICAgIGdldFN5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRTeW1ib2xzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0U3ltYm9scy5qc1wiKSxcbiAgICBzdHViQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0dWJBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvc3R1YkFycmF5LmpzXCIpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHNJbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRUYWcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldFRhZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIERhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fRGF0YVZpZXcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19EYXRhVmlldy5qc1wiKSxcbiAgICBNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19NYXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19NYXAuanNcIiksXG4gICAgUHJvbWlzZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1Byb21pc2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19Qcm9taXNlLmpzXCIpLFxuICAgIFNldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1NldCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1NldC5qc1wiKSxcbiAgICBXZWFrTWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fV2Vha01hcCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1dlYWtNYXAuanNcIiksXG4gICAgYmFzZUdldFRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VHZXRUYWcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlR2V0VGFnLmpzXCIpLFxuICAgIHRvU291cmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG9Tb3VyY2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL190b1NvdXJjZS5qc1wiKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0VmFsdWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0VmFsdWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faGFzUGF0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2hhc1BhdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY2FzdFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jYXN0UGF0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nhc3RQYXRoLmpzXCIpLFxuICAgIGlzQXJndW1lbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FyZ3VtZW50cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcmd1bWVudHMuanNcIiksXG4gICAgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheS5qc1wiKSxcbiAgICBpc0luZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNJbmRleCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzSW5kZXguanNcIiksXG4gICAgaXNMZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzTGVuZ3RoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0xlbmd0aC5qc1wiKSxcbiAgICB0b0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvS2V5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fdG9LZXkuanNcIik7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faGFzVW5pY29kZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2hhc1VuaWNvZGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNVbmljb2RlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2hhc2hDbGVhci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faGFzaENsZWFyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbmF0aXZlQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbmF0aXZlQ3JlYXRlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzXCIpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faGFzaERlbGV0ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2hhc2hEZWxldGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faGFzaEdldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2hhc2hHZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbmF0aXZlQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbmF0aXZlQ3JlYXRlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzXCIpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19oYXNoSGFzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faGFzaEhhcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBuYXRpdmVDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19uYXRpdmVDcmVhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19uYXRpdmVDcmVhdGUuanNcIik7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2hhc2hTZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19oYXNoU2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIG5hdGl2ZUNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX25hdGl2ZUNyZWF0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qc1wiKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUFycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjbG9uZUFycmF5QnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY2xvbmVBcnJheUJ1ZmZlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanNcIiksXG4gICAgY2xvbmVEYXRhVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Nsb25lRGF0YVZpZXcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jbG9uZURhdGFWaWV3LmpzXCIpLFxuICAgIGNsb25lUmVnRXhwID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY2xvbmVSZWdFeHAgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jbG9uZVJlZ0V4cC5qc1wiKSxcbiAgICBjbG9uZVN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Nsb25lU3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2xvbmVTeW1ib2wuanNcIiksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY2xvbmVUeXBlZEFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzXCIpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVCeVRhZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlQ3JlYXRlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUNyZWF0ZS5qc1wiKSxcbiAgICBnZXRQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRQcm90b3R5cGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRQcm90b3R5cGUuanNcIiksXG4gICAgaXNQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pc1Byb3RvdHlwZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzUHJvdG90eXBlLmpzXCIpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzRmxhdHRlbmFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1N5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1N5bWJvbC5qc1wiKSxcbiAgICBpc0FyZ3VtZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcmd1bWVudHMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJndW1lbnRzLmpzXCIpLFxuICAgIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXkuanNcIik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxhdHRlbmFibGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNJbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzSW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZXEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VxICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9lcS5qc1wiKSxcbiAgICBpc0FycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheUxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXlMaWtlLmpzXCIpLFxuICAgIGlzSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pc0luZGV4ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNJbmRleC5qc1wiKSxcbiAgICBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0LmpzXCIpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNLZXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNLZXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXkuanNcIiksXG4gICAgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzU3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1N5bWJvbC5qc1wiKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzS2V5YWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNLZXlhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzTWFza2VkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzTWFza2VkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjb3JlSnNEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY29yZUpzRGF0YSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvcmVKc0RhdGEuanNcIik7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNQcm90b3R5cGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNQcm90b3R5cGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzU3RyaWN0Q29tcGFyYWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzT2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdC5qc1wiKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhc3NvY0luZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hc3NvY0luZGV4T2YgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hc3NvY0luZGV4T2YuanNcIik7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbGlzdENhY2hlR2V0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19saXN0Q2FjaGVHZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhc3NvY0luZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hc3NvY0luZGV4T2YgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hc3NvY0luZGV4T2YuanNcIik7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2xpc3RDYWNoZUhhcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbGlzdENhY2hlSGFzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXNzb2NJbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXNzb2NJbmRleE9mICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXNzb2NJbmRleE9mLmpzXCIpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbGlzdENhY2hlU2V0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19saXN0Q2FjaGVTZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhc3NvY0luZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hc3NvY0luZGV4T2YgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hc3NvY0luZGV4T2YuanNcIik7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbWFwQ2FjaGVDbGVhci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgSGFzaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX0hhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19IYXNoLmpzXCIpLFxuICAgIExpc3RDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX0xpc3RDYWNoZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX0xpc3RDYWNoZS5qc1wiKSxcbiAgICBNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19NYXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19NYXAuanNcIik7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRNYXBEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0TWFwRGF0YSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldE1hcERhdGEuanNcIik7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hcENhY2hlR2V0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hcENhY2hlR2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRNYXBEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0TWFwRGF0YSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldE1hcERhdGEuanNcIik7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19tYXBDYWNoZUhhcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19tYXBDYWNoZUhhcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TWFwRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dldE1hcERhdGEgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRNYXBEYXRhLmpzXCIpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hcENhY2hlU2V0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hcENhY2hlU2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRNYXBEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0TWFwRGF0YSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldE1hcERhdGEuanNcIik7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19tYXBUb0FycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbWFwVG9BcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21lbW9pemVDYXBwZWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbWVtb2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWVtb2l6ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbWVtb2l6ZS5qc1wiKTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19uYXRpdmVDcmVhdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXROYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXROYXRpdmUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXROYXRpdmUuanNcIik7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX25hdGl2ZUtleXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19uYXRpdmVLZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIG92ZXJBcmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vdmVyQXJnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fb3ZlckFyZy5qc1wiKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbmF0aXZlS2V5c0luLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19uYXRpdmVLZXlzSW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19ub2RlVXRpbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19ub2RlVXRpbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24obW9kdWxlKSB7dmFyIGZyZWVHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19mcmVlR2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZnJlZUdsb2JhbC5qc1wiKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9ICB0cnVlICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vLi4vX3dlYnBhY2tANC40Mi4xQHdlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9fd2VicGFja0A0LjQyLjFAd2VicGFjay9idWlsZGluL21vZHVsZS5qc1wiKShtb2R1bGUpKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fb3ZlckFyZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX292ZXJBcmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX292ZXJSZXN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX292ZXJSZXN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcHBseSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FwcGx5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXBwbHkuanNcIik7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fcm9vdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3Jvb3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZnJlZUdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2ZyZWVHbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19mcmVlR2xvYmFsLmpzXCIpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zYWZlR2V0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2FmZUdldC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiIG9yIFwiY29uc3RydWN0b3JcIi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhZmVHZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2V0Q2FjaGVBZGQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2V0Q2FjaGVBZGQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVBZGQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2V0Q2FjaGVIYXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2V0Q2FjaGVIYXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3NldFRvQXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zZXRUb0FycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3NldFRvU3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3NldFRvU3RyaW5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlU2V0VG9TdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanNcIiksXG4gICAgc2hvcnRPdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zaG9ydE91dCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3Nob3J0T3V0LmpzXCIpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3Nob3J0T3V0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3Nob3J0T3V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydE91dDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdGFja0NsZWFyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc3RhY2tDbGVhci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBMaXN0Q2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19MaXN0Q2FjaGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19MaXN0Q2FjaGUuanNcIik7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdGFja0RlbGV0ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdGFja0RlbGV0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc3RhY2tHZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc3RhY2tHZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3N0YWNrSGFzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3N0YWNrSGFzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc3RhY2tTZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc3RhY2tTZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIExpc3RDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX0xpc3RDYWNoZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX0xpc3RDYWNoZS5qc1wiKSxcbiAgICBNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19NYXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19NYXAuanNcIiksXG4gICAgTWFwQ2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19NYXBDYWNoZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX01hcENhY2hlLmpzXCIpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdHJpY3RJbmRleE9mLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc3RyaWN0SW5kZXhPZi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpY3RJbmRleE9mO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3N0cmluZ1NpemUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdHJpbmdTaXplLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFzY2lpU2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FzY2lpU2l6ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FzY2lpU2l6ZS5qc1wiKSxcbiAgICBoYXNVbmljb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGFzVW5pY29kZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2hhc1VuaWNvZGUuanNcIiksXG4gICAgdW5pY29kZVNpemUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL191bmljb2RlU2l6ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3VuaWNvZGVTaXplLmpzXCIpO1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBzeW1ib2xzIGluIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICovXG5mdW5jdGlvbiBzdHJpbmdTaXplKHN0cmluZykge1xuICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgPyB1bmljb2RlU2l6ZShzdHJpbmcpXG4gICAgOiBhc2NpaVNpemUoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdTaXplO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3N0cmluZ1RvUGF0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc3RyaW5nVG9QYXRoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbWVtb2l6ZUNhcHBlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX21lbW9pemVDYXBwZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzXCIpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9QYXRoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3RvS2V5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3RvS2V5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNTeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzU3ltYm9sLmpzXCIpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0tleTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL190b1NvdXJjZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL190b1NvdXJjZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fdW5pY29kZVNpemUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fdW5pY29kZVNpemUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBzaXplIG9mIGEgVW5pY29kZSBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVNpemUoc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSByZVVuaWNvZGUubGFzdEluZGV4ID0gMDtcbiAgd2hpbGUgKHJlVW5pY29kZS50ZXN0KHN0cmluZykpIHtcbiAgICArK3Jlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaWNvZGVTaXplO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvY2xvbmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2Nsb25lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VDbG9uZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VDbG9uZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VDbG9uZS5qc1wiKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lRGVlcFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2Nsb25lRGVlcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2Nsb25lRGVlcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUNsb25lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUNsb25lICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUNsb25lLmpzXCIpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEZWVwO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvY29uc3RhbnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2NvbnN0YW50LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9kZWZhdWx0cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZGVmYXVsdHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZVJlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlUmVzdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VSZXN0LmpzXCIpLFxuICAgIGVxID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lcSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZXEuanNcIiksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pc0l0ZXJhdGVlQ2FsbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzXCIpLFxuICAgIGtleXNJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4va2V5c0luICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9rZXlzSW4uanNcIik7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0XG4gKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gKiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xudmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xO1xuICB2YXIgbGVuZ3RoID0gc291cmNlcy5sZW5ndGg7XG4gIHZhciBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICBsZW5ndGggPSAxO1xuICB9XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgdmFyIHByb3BzID0ga2V5c0luKHNvdXJjZSk7XG4gICAgdmFyIHByb3BzSW5kZXggPSAtMTtcbiAgICB2YXIgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytwcm9wc0luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1twcm9wc0luZGV4XTtcbiAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIChlcSh2YWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2VhY2guanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZWFjaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvckVhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2ZvckVhY2guanNcIik7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9lcS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZXEuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2ZpbHRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2ZpbHRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlGaWx0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hcnJheUZpbHRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FycmF5RmlsdGVyLmpzXCIpLFxuICAgIGJhc2VGaWx0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlRmlsdGVyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZpbHRlci5qc1wiKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXRlcmF0ZWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXRlcmF0ZWUuanNcIiksXG4gICAgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheS5qc1wiKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogKipOb3RlOioqIFVubGlrZSBgXy5yZW1vdmVgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqIEBzZWUgXy5yZWplY3RcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gKiBdO1xuICpcbiAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKi9cbmZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmlsdGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZmluZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9maW5kLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY3JlYXRlRmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NyZWF0ZUZpbmQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jcmVhdGVGaW5kLmpzXCIpLFxuICAgIGZpbmRJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmluZEluZGV4ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9maW5kSW5kZXguanNcIik7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdwZWJibGVzJ1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICovXG52YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZmluZEluZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZmluZEluZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlRmluZEluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUZpbmRJbmRleCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VGaW5kSW5kZXguanNcIiksXG4gICAgYmFzZUl0ZXJhdGVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUl0ZXJhdGVlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzXCIpLFxuICAgIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG9JbnRlZ2VyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC90b0ludGVnZXIuanNcIik7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICogLy8gPT4gMVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gMlxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gIH1cbiAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZEluZGV4O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZmxhdHRlbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9mbGF0dGVuLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUZsYXR0ZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlRmxhdHRlbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzXCIpO1xuXG4vKipcbiAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZm9yRWFjaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9mb3JFYWNoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXJyYXlFYWNoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlFYWNoLmpzXCIpLFxuICAgIGJhc2VFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUVhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRWFjaC5qc1wiKSxcbiAgICBjYXN0RnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jYXN0RnVuY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jYXN0RnVuY3Rpb24uanNcIiksXG4gICAgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheS5qc1wiKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAYWxpYXMgZWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gKlxuICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICogICBjb25zb2xlLmxvZyhrZXkpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgY2FzdEZ1bmN0aW9uKGl0ZXJhdGVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2ZvckluLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9mb3JJbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlRm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUZvciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VGb3IuanNcIiksXG4gICAgY2FzdEZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY2FzdEZ1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2FzdEZ1bmN0aW9uLmpzXCIpLFxuICAgIGtleXNJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4va2V5c0luICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9rZXlzSW4uanNcIik7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuXG4gKiBvYmplY3QgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0XG4gKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmZvckluUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JJbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgID8gb2JqZWN0XG4gICAgOiBiYXNlRm9yKG9iamVjdCwgY2FzdEZ1bmN0aW9uKGl0ZXJhdGVlKSwga2V5c0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JJbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2dldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2dldC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUdldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VHZXQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlR2V0LmpzXCIpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaGFzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaGFzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlSGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUhhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VIYXMuanNcIiksXG4gICAgaGFzUGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hhc1BhdGggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19oYXNQYXRoLmpzXCIpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAqIHZhciBvdGhlciA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9oYXNJbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaGFzSW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUhhc0luID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUhhc0luICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUhhc0luLmpzXCIpLFxuICAgIGhhc1BhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oYXNQYXRoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faGFzUGF0aC5qc1wiKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaWRlbnRpdHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lkZW50aXR5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJndW1lbnRzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FyZ3VtZW50cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlSXNBcmd1bWVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXNBcmd1bWVudHMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanNcIiksXG4gICAgaXNPYmplY3RMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdExpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1wiKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5TGlrZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheUxpa2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNGdW5jdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNGdW5jdGlvbi5qc1wiKSxcbiAgICBpc0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNMZW5ndGggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzTGVuZ3RoLmpzXCIpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXlMaWtlT2JqZWN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0FycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheUxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXlMaWtlLmpzXCIpLFxuICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3RMaWtlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdExpa2UuanNcIik7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQnVmZmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0J1ZmZlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihtb2R1bGUpIHt2YXIgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3Jvb3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19yb290LmpzXCIpLFxuICAgIHN0dWJGYWxzZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3R1YkZhbHNlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9zdHViRmFsc2UuanNcIik7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSAgdHJ1ZSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vLi4vX3dlYnBhY2tANC40Mi4xQHdlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9fd2VicGFja0A0LjQyLjFAd2VicGFjay9idWlsZGluL21vZHVsZS5qc1wiKShtb2R1bGUpKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0VtcHR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzRW1wdHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VLZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUtleXMuanNcIiksXG4gICAgZ2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0VGFnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0VGFnLmpzXCIpLFxuICAgIGlzQXJndW1lbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FyZ3VtZW50cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcmd1bWVudHMuanNcIiksXG4gICAgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheS5qc1wiKSxcbiAgICBpc0FycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheUxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXlMaWtlLmpzXCIpLFxuICAgIGlzQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0J1ZmZlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNCdWZmZXIuanNcIiksXG4gICAgaXNQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pc1Byb3RvdHlwZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzUHJvdG90eXBlLmpzXCIpLFxuICAgIGlzVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNUeXBlZEFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1R5cGVkQXJyYXkuanNcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICpcbiAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICogcHJvcGVydGllcy5cbiAqXG4gKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFbXB0eShudWxsKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkodHJ1ZSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICB9XG4gIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICB9XG4gIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFbXB0eTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzRnVuY3Rpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNGdW5jdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VHZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlR2V0VGFnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUdldFRhZy5qc1wiKSxcbiAgICBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0LmpzXCIpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0xlbmd0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNMZW5ndGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc01hcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNNYXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUlzTWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUlzTWFwICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzTWFwLmpzXCIpLFxuICAgIGJhc2VVbmFyeSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VVbmFyeSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VVbmFyeS5qc1wiKSxcbiAgICBub2RlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX25vZGVVdGlsICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbm9kZVV0aWwuanNcIik7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNPYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1BsYWluT2JqZWN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzUGxhaW5PYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUdldFRhZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VHZXRUYWcuanNcIiksXG4gICAgZ2V0UHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0UHJvdG90eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0UHJvdG90eXBlLmpzXCIpLFxuICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3RMaWtlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdExpa2UuanNcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNTZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzU2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VJc1NldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VJc1NldCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJc1NldC5qc1wiKSxcbiAgICBiYXNlVW5hcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlVW5hcnkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlVW5hcnkuanNcIiksXG4gICAgbm9kZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19ub2RlVXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX25vZGVVdGlsLmpzXCIpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNTdHJpbmcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzU3RyaW5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VHZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlR2V0VGFnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUdldFRhZy5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5LmpzXCIpLFxuICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3RMaWtlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdExpa2UuanNcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3RyaW5nKDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNTeW1ib2wuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzU3ltYm9sLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VHZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlR2V0VGFnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUdldFRhZy5qc1wiKSxcbiAgICBpc09iamVjdExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzT2JqZWN0TGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNPYmplY3RMaWtlLmpzXCIpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1R5cGVkQXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1R5cGVkQXJyYXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VJc1R5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXNUeXBlZEFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qc1wiKSxcbiAgICBiYXNlVW5hcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlVW5hcnkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlVW5hcnkuanNcIiksXG4gICAgbm9kZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19ub2RlVXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX25vZGVVdGlsLmpzXCIpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1VuZGVmaW5lZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNVbmRlZmluZWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNVbmRlZmluZWQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9rZXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2tleXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcnJheUxpa2VLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXJyYXlMaWtlS2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FycmF5TGlrZUtleXMuanNcIiksXG4gICAgYmFzZUtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlS2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VLZXlzLmpzXCIpLFxuICAgIGlzQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5TGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheUxpa2UuanNcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9rZXlzSW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9rZXlzSW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5TGlrZUtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hcnJheUxpa2VLZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlMaWtlS2V5cy5qc1wiKSxcbiAgICBiYXNlS2V5c0luID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUtleXNJbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VLZXlzSW4uanNcIiksXG4gICAgaXNBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXlMaWtlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5TGlrZS5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbGFzdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9sYXN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsYXN0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbWFwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbWFwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcnJheU1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FycmF5TWFwICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlNYXAuanNcIiksXG4gICAgYmFzZUl0ZXJhdGVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUl0ZXJhdGVlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzXCIpLFxuICAgIGJhc2VNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlTWFwICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZU1hcC5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5LmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdXG4gKlxuICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAqIF07XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICovXG5mdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9tYXBWYWx1ZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9tYXBWYWx1ZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VBc3NpZ25WYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VBc3NpZ25WYWx1ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qc1wiKSxcbiAgICBiYXNlRm9yT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUZvck93biAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VGb3JPd24uanNcIiksXG4gICAgYmFzZUl0ZXJhdGVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUl0ZXJhdGVlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZFxuICogYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1XG4gKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICogQHNlZSBfLm1hcEtleXNcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0ge1xuICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAqIH07XG4gKlxuICogXy5tYXBWYWx1ZXModXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlOyB9KTtcbiAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8ubWFwVmFsdWVzKHVzZXJzLCAnYWdlJyk7XG4gKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBWYWx1ZXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9tYXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9tYXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VFeHRyZW11bSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VFeHRyZW11bSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VFeHRyZW11bS5qc1wiKSxcbiAgICBiYXNlR3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlR3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlR3QuanNcIiksXG4gICAgaWRlbnRpdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lkZW50aXR5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pZGVudGl0eS5qc1wiKTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gKiAvLyA9PiA4XG4gKlxuICogXy5tYXgoW10pO1xuICogLy8gPT4gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIG1heChhcnJheSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VHdClcbiAgICA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXg7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9tZW1vaXplLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL21lbW9pemUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBNYXBDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX01hcENhY2hlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fTWFwQ2FjaGUuanNcIik7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbWVyZ2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL21lcmdlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VNZXJnZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VNZXJnZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VNZXJnZS5qc1wiKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NyZWF0ZUFzc2lnbmVyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY3JlYXRlQXNzaWduZXIuanNcIik7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjUuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0ge1xuICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICogfTtcbiAqXG4gKiB2YXIgb3RoZXIgPSB7XG4gKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gKiB9O1xuICpcbiAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gKi9cbnZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbWluLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbWluLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlRXh0cmVtdW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlRXh0cmVtdW0gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRXh0cmVtdW0uanNcIiksXG4gICAgYmFzZUx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUx0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUx0LmpzXCIpLFxuICAgIGlkZW50aXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pZGVudGl0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaWRlbnRpdHkuanNcIik7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICogLy8gPT4gMlxuICpcbiAqIF8ubWluKFtdKTtcbiAqIC8vID0+IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBtaW4oYXJyYXkpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlTHQpXG4gICAgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWluO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbWluQnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL21pbkJ5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VFeHRyZW11bSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VFeHRyZW11bSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VFeHRyZW11bS5qc1wiKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXRlcmF0ZWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXRlcmF0ZWUuanNcIiksXG4gICAgYmFzZUx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUx0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUx0LmpzXCIpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICpcbiAqIF8ubWluQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAqIC8vID0+IHsgJ24nOiAxIH1cbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8ubWluQnkob2JqZWN0cywgJ24nKTtcbiAqIC8vID0+IHsgJ24nOiAxIH1cbiAqL1xuZnVuY3Rpb24gbWluQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlTHQpXG4gICAgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWluQnk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9ub29wLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL25vb3AuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbm9vcDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL25vdy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL25vdy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3Jvb3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19yb290LmpzXCIpO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vdztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3BpY2suanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvcGljay5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VQaWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVBpY2sgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlUGljay5qc1wiKSxcbiAgICBmbGF0UmVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2ZsYXRSZXN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZmxhdFJlc3QuanNcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvcHJvcGVydHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3Byb3BlcnR5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VQcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VQcm9wZXJ0eS5qc1wiKSxcbiAgICBiYXNlUHJvcGVydHlEZWVwID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVByb3BlcnR5RGVlcCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanNcIiksXG4gICAgaXNLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pc0tleSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzS2V5LmpzXCIpLFxuICAgIHRvS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG9LZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL190b0tleS5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvcmFuZ2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3JhbmdlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNyZWF0ZVJhbmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY3JlYXRlUmFuZ2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jcmVhdGVSYW5nZS5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBBIHN0ZXAgb2YgYC0xYCBpcyB1c2VkIGlmIGEgbmVnYXRpdmVcbiAqIGBzdGFydGAgaXMgc3BlY2lmaWVkIHdpdGhvdXQgYW4gYGVuZGAgb3IgYHN0ZXBgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLFxuICogaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICpcbiAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ucmFuZ2UoNCk7XG4gKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAqXG4gKiBfLnJhbmdlKC00KTtcbiAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICpcbiAqIF8ucmFuZ2UoMSwgNSk7XG4gKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAqXG4gKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gKlxuICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gKlxuICogXy5yYW5nZSgxLCA0LCAwKTtcbiAqIC8vID0+IFsxLCAxLCAxXVxuICpcbiAqIF8ucmFuZ2UoMCk7XG4gKiAvLyA9PiBbXVxuICovXG52YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbmdlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvcmVkdWNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvcmVkdWNlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcnJheVJlZHVjZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FycmF5UmVkdWNlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlSZWR1Y2UuanNcIiksXG4gICAgYmFzZUVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlRWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VFYWNoLmpzXCIpLFxuICAgIGJhc2VJdGVyYXRlZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VJdGVyYXRlZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qc1wiKSxcbiAgICBiYXNlUmVkdWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVJlZHVjZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VSZWR1Y2UuanNcIiksXG4gICAgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheS5qc1wiKTtcblxuLyoqXG4gKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICogaXMgbm90IGdpdmVuLCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICogdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cbiAqXG4gKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYG9yZGVyQnlgLFxuICogYW5kIGBzb3J0QnlgXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQHNlZSBfLnJlZHVjZVJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24oc3VtLCBuKSB7XG4gKiAgIHJldHVybiBzdW0gKyBuO1xuICogfSwgMCk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICogICByZXR1cm4gcmVzdWx0O1xuICogfSwge30pO1xuICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZSxcbiAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWR1Y2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9zaXplLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3NpemUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VLZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUtleXMuanNcIiksXG4gICAgZ2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0VGFnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0VGFnLmpzXCIpLFxuICAgIGlzQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5TGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheUxpa2UuanNcIiksXG4gICAgaXNTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzU3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1N0cmluZy5qc1wiKSxcbiAgICBzdHJpbmdTaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc3RyaW5nU2l6ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3N0cmluZ1NpemUuanNcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29sbGVjdGlvbiBzaXplLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAqIC8vID0+IDJcbiAqXG4gKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAqIC8vID0+IDdcbiAqL1xuZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbikgPyBzdHJpbmdTaXplKGNvbGxlY3Rpb24pIDogY29sbGVjdGlvbi5sZW5ndGg7XG4gIH1cbiAgdmFyIHRhZyA9IGdldFRhZyhjb2xsZWN0aW9uKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgIHJldHVybiBjb2xsZWN0aW9uLnNpemU7XG4gIH1cbiAgcmV0dXJuIGJhc2VLZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaXplO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvc29ydEJ5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvc29ydEJ5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlRmxhdHRlbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VGbGF0dGVuICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZsYXR0ZW4uanNcIiksXG4gICAgYmFzZU9yZGVyQnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlT3JkZXJCeSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VPcmRlckJ5LmpzXCIpLFxuICAgIGJhc2VSZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVJlc3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlUmVzdC5qc1wiKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzSXRlcmF0ZWVDYWxsICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNJdGVyYXRlZUNhbGwuanNcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocnUgZWFjaCBpdGVyYXRlZS4gVGhpcyBtZXRob2RcbiAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICogZXF1YWwgZWxlbWVudHMuIFRoZSBpdGVyYXRlZXMgYXJlIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICogXTtcbiAqXG4gKiBfLnNvcnRCeSh1c2VycywgW2Z1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlcjsgfV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gKlxuICogXy5zb3J0QnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF0sIFsnZnJlZCcsIDQ4XV1cbiAqL1xudmFyIHNvcnRCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcykge1xuICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICBpdGVyYXRlZXMgPSBbXTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gIH1cbiAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRCeTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3N0dWJBcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3N0dWJBcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3N0dWJGYWxzZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3N0dWJGYWxzZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdG9GaW5pdGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3RvRmluaXRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvTnVtYmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90b051bWJlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdG9OdW1iZXIuanNcIik7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvRmluaXRlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdG9JbnRlZ2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdG9JbnRlZ2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0Zpbml0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG9GaW5pdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3RvRmluaXRlLmpzXCIpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvSW50ZWdlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3RvTnVtYmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC90b051bWJlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0LmpzXCIpLFxuICAgIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1N5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNTeW1ib2wuanNcIik7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3RvUGxhaW5PYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdG9QbGFpbk9iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNvcHlPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb3B5T2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29weU9iamVjdC5qc1wiKSxcbiAgICBrZXlzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2tleXNJbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gva2V5c0luLmpzXCIpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QbGFpbk9iamVjdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3RvU3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC90b1N0cmluZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlVG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlVG9TdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlVG9TdHJpbmcuanNcIik7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3RyYW5zZm9ybS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3RyYW5zZm9ybS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXJyYXlFYWNoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlFYWNoLmpzXCIpLFxuICAgIGJhc2VDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlQ3JlYXRlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUNyZWF0ZS5qc1wiKSxcbiAgICBiYXNlRm9yT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUZvck93biAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VGb3JPd24uanNcIiksXG4gICAgYmFzZUl0ZXJhdGVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUl0ZXJhdGVlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzXCIpLFxuICAgIGdldFByb3RvdHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dldFByb3RvdHlwZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldFByb3RvdHlwZS5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5LmpzXCIpLFxuICAgIGlzQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0J1ZmZlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNCdWZmZXIuanNcIiksXG4gICAgaXNGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNGdW5jdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNGdW5jdGlvbi5qc1wiKSxcbiAgICBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0LmpzXCIpLFxuICAgIGlzVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNUeXBlZEFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1R5cGVkQXJyYXkuanNcIik7XG5cbi8qKlxuICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93blxuICogZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyB0aHJ1IGBpdGVyYXRlZWAsIHdpdGggZWFjaCBpbnZvY2F0aW9uXG4gKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIElmIGBhY2N1bXVsYXRvcmAgaXMgbm90XG4gKiBwcm92aWRlZCwgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUgYFtbUHJvdG90eXBlXV1gIHdpbGwgYmUgdXNlZC4gVGhlXG4gKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAqICAgcmVzdWx0LnB1c2gobiAqPSBuKTtcbiAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gKiB9LCBbXSk7XG4gKiAvLyA9PiBbNCwgOV1cbiAqXG4gKiBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gKiB9LCB7fSk7XG4gKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBpc0Fyckxpa2UgPSBpc0FyciB8fCBpc0J1ZmZlcihvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuXG4gIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCA0KTtcbiAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICB2YXIgQ3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgaWYgKGlzQXJyTGlrZSkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpc0FyciA/IG5ldyBDdG9yIDogW107XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXNGdW5jdGlvbihDdG9yKSA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpIDoge307XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYWNjdW11bGF0b3IgPSB7fTtcbiAgICB9XG4gIH1cbiAgKGlzQXJyTGlrZSA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICByZXR1cm4gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgfSk7XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC91bmlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdW5pb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUZsYXR0ZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlRmxhdHRlbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzXCIpLFxuICAgIGJhc2VSZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVJlc3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlUmVzdC5qc1wiKSxcbiAgICBiYXNlVW5pcSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VVbmlxICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVVuaXEuanNcIiksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXlMaWtlT2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBnaXZlbiBhcnJheXMgdXNpbmdcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udW5pb24oWzJdLCBbMSwgMl0pO1xuICogLy8gPT4gWzIsIDFdXG4gKi9cbnZhciB1bmlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC91bmlxdWVJZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdW5pcXVlSWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvU3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC90b1N0cmluZy5qc1wiKTtcblxuLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcy4gKi9cbnZhciBpZENvdW50ZXIgPSAwO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgZ2l2ZW4sIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXg9JyddIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gKlxuICogXy51bmlxdWVJZCgpO1xuICogLy8gPT4gJzEwNSdcbiAqL1xuZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICByZXR1cm4gdG9TdHJpbmcocHJlZml4KSArIGlkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaXF1ZUlkO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdmFsdWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdmFsdWVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlVmFsdWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVZhbHVlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VWYWx1ZXMuanNcIiksXG4gICAga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4va2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gva2V5cy5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsdWVzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvemlwT2JqZWN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvemlwT2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhc3NpZ25WYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Fzc2lnblZhbHVlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXNzaWduVmFsdWUuanNcIiksXG4gICAgYmFzZVppcE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VaaXBPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlWmlwT2JqZWN0LmpzXCIpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZnJvbVBhaXJzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIHR3byBhcnJheXMsXG4gKiBvbmUgb2YgcHJvcGVydHkgaWRlbnRpZmllcnMgYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uemlwT2JqZWN0KFsnYScsICdiJ10sIFsxLCAyXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xuZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLCB2YWx1ZXMpIHtcbiAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYXNzaWduVmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHppcE9iamVjdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fcGFyc2Utc3ZnLXBhdGhAMC4xLjJAcGFyc2Utc3ZnLXBhdGgvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19wYXJzZS1zdmctcGF0aEAwLjEuMkBwYXJzZS1zdmctcGF0aC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlXG5cbi8qKlxuICogZXhwZWN0ZWQgYXJndW1lbnQgbGVuZ3Roc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG52YXIgbGVuZ3RoID0ge2E6IDcsIGM6IDYsIGg6IDEsIGw6IDIsIG06IDIsIHE6IDQsIHM6IDQsIHQ6IDIsIHY6IDEsIHo6IDB9XG5cbi8qKlxuICogc2VnbWVudCBwYXR0ZXJuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5cbnZhciBzZWdtZW50ID0gLyhbYXN0dnpxbWhsY10pKFteYXN0dnpxbWhsY10qKS9pZ1xuXG4vKipcbiAqIHBhcnNlIGFuIHN2ZyBwYXRoIGRhdGEgc3RyaW5nLiBHZW5lcmF0ZXMgYW4gQXJyYXlcbiAqIG9mIGNvbW1hbmRzIHdoZXJlIGVhY2ggY29tbWFuZCBpcyBhbiBBcnJheSBvZiB0aGVcbiAqIGZvcm0gYFtjb21tYW5kLCBhcmcxLCBhcmcyLCAuLi5dYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShwYXRoKSB7XG5cdHZhciBkYXRhID0gW11cblx0cGF0aC5yZXBsYWNlKHNlZ21lbnQsIGZ1bmN0aW9uKF8sIGNvbW1hbmQsIGFyZ3Mpe1xuXHRcdHZhciB0eXBlID0gY29tbWFuZC50b0xvd2VyQ2FzZSgpXG5cdFx0YXJncyA9IHBhcnNlVmFsdWVzKGFyZ3MpXG5cblx0XHQvLyBvdmVybG9hZGVkIG1vdmVUb1xuXHRcdGlmICh0eXBlID09ICdtJyAmJiBhcmdzLmxlbmd0aCA+IDIpIHtcblx0XHRcdGRhdGEucHVzaChbY29tbWFuZF0uY29uY2F0KGFyZ3Muc3BsaWNlKDAsIDIpKSlcblx0XHRcdHR5cGUgPSAnbCdcblx0XHRcdGNvbW1hbmQgPSBjb21tYW5kID09ICdtJyA/ICdsJyA6ICdMJ1xuXHRcdH1cblxuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRpZiAoYXJncy5sZW5ndGggPT0gbGVuZ3RoW3R5cGVdKSB7XG5cdFx0XHRcdGFyZ3MudW5zaGlmdChjb21tYW5kKVxuXHRcdFx0XHRyZXR1cm4gZGF0YS5wdXNoKGFyZ3MpXG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJncy5sZW5ndGggPCBsZW5ndGhbdHlwZV0pIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIHBhdGggZGF0YScpXG5cdFx0XHRkYXRhLnB1c2goW2NvbW1hbmRdLmNvbmNhdChhcmdzLnNwbGljZSgwLCBsZW5ndGhbdHlwZV0pKSlcblx0XHR9XG5cdH0pXG5cdHJldHVybiBkYXRhXG59XG5cbnZhciBudW1iZXIgPSAvLT9bMC05XSpcXC4/WzAtOV0rKD86ZVstK10/XFxkKyk/L2lnXG5cbmZ1bmN0aW9uIHBhcnNlVmFsdWVzKGFyZ3MpIHtcblx0dmFyIG51bWJlcnMgPSBhcmdzLm1hdGNoKG51bWJlcilcblx0cmV0dXJuIG51bWJlcnMgPyBudW1iZXJzLm1hcChOdW1iZXIpIDogW11cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fcG9pbnQtYXQtbGVuZ3RoQDEuMS4wQHBvaW50LWF0LWxlbmd0aC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fcG9pbnQtYXQtbGVuZ3RoQDEuMS4wQHBvaW50LWF0LWxlbmd0aC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcGFyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBwYXJzZS1zdmctcGF0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL19wYXJzZS1zdmctcGF0aEAwLjEuMkBwYXJzZS1zdmctcGF0aC9pbmRleC5qc1wiKTtcclxudmFyIGlzYXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBpc2FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2lzYXJyYXlAMC4wLjFAaXNhcnJheS9pbmRleC5qc1wiKTtcclxudmFyIGFicyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGFicy1zdmctcGF0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL19hYnMtc3ZnLXBhdGhAMC4xLjFAYWJzLXN2Zy1wYXRoL2luZGV4LmpzXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb2ludHM7XHJcblxyXG5mdW5jdGlvbiBQb2ludHMgKHBhdGgpIHtcclxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQb2ludHMpKSByZXR1cm4gbmV3IFBvaW50cyhwYXRoKTtcclxuICAgIHRoaXMuX3BhdGggPSBpc2FycmF5KHBhdGgpID8gcGF0aCA6IHBhcnNlKHBhdGgpO1xyXG4gICAgdGhpcy5fcGF0aCA9IGFicyh0aGlzLl9wYXRoKTtcclxuICAgIHRoaXMuX3BhdGggPSB6dmhUb0wodGhpcy5fcGF0aCk7XHJcbiAgICB0aGlzLl9wYXRoID0gbG9uZ2hhbmQodGhpcy5fcGF0aCk7XHJcbn1cclxuXHJcblBvaW50cy5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAocG9zLCBvcHRzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fd2Fsayhwb3MsIG9wdHMpLnBvcztcclxufTtcclxuXHJcblBvaW50cy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3dhbGsobnVsbCkubGVuZ3RoO1xyXG59O1xyXG5cclxuUG9pbnRzLnByb3RvdHlwZS5fd2FsayA9IGZ1bmN0aW9uIChwb3MsIG9wdHMpIHtcclxuICAgIHZhciBjdXIgPSBbIDAsIDAgXTtcclxuICAgIHZhciBwcmV2ID0gWyAwLCAwLCAwIF07XHJcbiAgICB2YXIgcDAgPSBbIDAsIDAgXTtcclxuICAgIHZhciBsZW4gPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBwID0gdGhpcy5fcGF0aFtpXTtcclxuICAgICAgICBpZiAocFswXSA9PT0gJ00nKSB7XHJcbiAgICAgICAgICAgIGN1clswXSA9IHBbMV07XHJcbiAgICAgICAgICAgIGN1clsxXSA9IHBbMl07XHJcbiAgICAgICAgICAgIGlmIChwb3MgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGxlbmd0aDogbGVuLCBwb3M6IGN1ciB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBbMF0gPT09ICdDJykge1xyXG4gICAgICAgICAgICBwcmV2WzBdID0gcDBbMF0gPSBjdXJbMF07XHJcbiAgICAgICAgICAgIHByZXZbMV0gPSBwMFsxXSA9IGN1clsxXTtcclxuICAgICAgICAgICAgcHJldlsyXSA9IGxlbjtcclxuXHJcbiAgICAgICAgICAgIHZhciBuID0gMTAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gaiAvIG47XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHhvZl9DKHAsIHQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSB5b2ZfQyhwLCB0KTtcclxuICAgICAgICAgICAgICAgIGxlbiArPSBkaXN0KGN1clswXSwgY3VyWzFdLCB4LCB5KTtcclxuXHJcbiAgICAgICAgICAgICAgICBjdXJbMF0gPSB4O1xyXG4gICAgICAgICAgICAgICAgY3VyWzFdID0geTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvcyA9PT0gJ251bWJlcicgJiYgbGVuID49IHBvcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkdiA9IChsZW4gLSBwb3MpIC8gKGxlbiAtIHByZXZbMl0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnBvcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyWzBdICogKDEgLSBkdikgKyBwcmV2WzBdICogZHYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clsxXSAqICgxIC0gZHYpICsgcHJldlsxXSAqIGR2XHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsZW5ndGg6IGxlbiwgcG9zOiBucG9zIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcmV2WzBdID0gY3VyWzBdO1xyXG4gICAgICAgICAgICAgICAgcHJldlsxXSA9IGN1clsxXTtcclxuICAgICAgICAgICAgICAgIHByZXZbMl0gPSBsZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocFswXSA9PT0gJ1EnKSB7XHJcbiAgICAgICAgICAgIHByZXZbMF0gPSBwMFswXSA9IGN1clswXTtcclxuICAgICAgICAgICAgcHJldlsxXSA9IHAwWzFdID0gY3VyWzFdO1xyXG4gICAgICAgICAgICBwcmV2WzJdID0gbGVuO1xyXG5cclxuICAgICAgICAgICAgdmFyIG4gPSAxMDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IG47IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBqIC8gbjtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0geG9mX1EocCwgdCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHlvZl9RKHAsIHQpO1xyXG4gICAgICAgICAgICAgICAgbGVuICs9IGRpc3QoY3VyWzBdLCBjdXJbMV0sIHgsIHkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1clswXSA9IHg7XHJcbiAgICAgICAgICAgICAgICBjdXJbMV0gPSB5O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9zID09PSAnbnVtYmVyJyAmJiBsZW4gPj0gcG9zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR2ID0gKGxlbiAtIHBvcykgLyAobGVuIC0gcHJldlsyXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBucG9zID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJbMF0gKiAoMSAtIGR2KSArIHByZXZbMF0gKiBkdixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyWzFdICogKDEgLSBkdikgKyBwcmV2WzFdICogZHZcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxlbmd0aDogbGVuLCBwb3M6IG5wb3MgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByZXZbMF0gPSBjdXJbMF07XHJcbiAgICAgICAgICAgICAgICBwcmV2WzFdID0gY3VyWzFdO1xyXG4gICAgICAgICAgICAgICAgcHJldlsyXSA9IGxlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwWzBdID09PSAnTCcpIHtcclxuICAgICAgICAgICAgcHJldlswXSA9IGN1clswXTtcclxuICAgICAgICAgICAgcHJldlsxXSA9IGN1clsxXTtcclxuICAgICAgICAgICAgcHJldlsyXSA9IGxlbjtcclxuXHJcbiAgICAgICAgICAgIGxlbiAgICs9IGRpc3QoY3VyWzBdLCBjdXJbMV0sIHBbMV0sIHBbMl0pO1xyXG4gICAgICAgICAgICBjdXJbMF0gPSBwWzFdO1xyXG4gICAgICAgICAgICBjdXJbMV0gPSBwWzJdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3MgPT09ICdudW1iZXInICYmIGxlbiA+PSBwb3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkdiA9IChsZW4gLSBwb3MpIC8gKGxlbiAtIHByZXZbMl0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5wb3MgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgY3VyWzBdICogKDEgLSBkdikgKyBwcmV2WzBdICogZHYsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VyWzFdICogKDEgLSBkdikgKyBwcmV2WzFdICogZHZcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBsZW5ndGg6IGxlbiwgcG9zOiBucG9zIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldlswXSA9IGN1clswXTtcclxuICAgICAgICAgICAgcHJldlsxXSA9IGN1clsxXTtcclxuICAgICAgICAgICAgcHJldlsyXSA9IGxlbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgbGVuZ3RoOiBsZW4sIHBvczogY3VyIH07XHJcbiAgICBmdW5jdGlvbiB4b2ZfQyAocCwgdCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnBvdygoMS10KSwgMykgKiBwMFswXVxyXG4gICAgICAgICAgICArIDMgKiBNYXRoLnBvdygoMS10KSwgMikgKiB0ICogcFsxXVxyXG4gICAgICAgICAgICArIDMgKiAoMS10KSAqIE1hdGgucG93KHQsIDIpICogcFszXVxyXG4gICAgICAgICAgICArIE1hdGgucG93KHQsIDMpICogcFs1XVxyXG4gICAgICAgIDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHlvZl9DIChwLCB0KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KCgxLXQpLCAzKSAqIHAwWzFdXHJcbiAgICAgICAgICAgICsgMyAqIE1hdGgucG93KCgxLXQpLCAyKSAqIHQgKiBwWzJdXHJcbiAgICAgICAgICAgICsgMyAqICgxLXQpICogTWF0aC5wb3codCwgMikgKiBwWzRdXHJcbiAgICAgICAgICAgICsgTWF0aC5wb3codCwgMykgKiBwWzZdXHJcbiAgICAgICAgO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHhvZl9RIChwLCB0KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KCgxLXQpLCAyKSAqIHAwWzBdXHJcbiAgICAgICAgICAgICsgMiAqICgxLXQpICogdCAqIHBbMV1cclxuICAgICAgICAgICAgKyBNYXRoLnBvdyh0LCAyKSAqIHBbM11cclxuICAgICAgICA7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB5b2ZfUSAocCwgdCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnBvdygoMS10KSwgMikgKiBwMFsxXVxyXG4gICAgICAgICAgICArIDIgKiAoMS10KSAqIHQgKiBwWzJdXHJcbiAgICAgICAgICAgICsgTWF0aC5wb3codCwgMikgKiBwWzRdXHJcbiAgICAgICAgO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gZGlzdCAoYXgsIGF5LCBieCwgYnkpIHtcclxuICAgIHZhciB4ID0gYXggLSBieDtcclxuICAgIHZhciB5ID0gYXkgLSBieTtcclxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcclxufVxyXG5cclxuLy8gRXhwYW5kIHNob3J0aGFuZCBjdXJ2ZSBjb21tYW5kcyB0byBmdWxsIHZlcnNpb25zOyBtdXRhdGVzIHRoZSBwYXRoIGluIHBsYWNlIGZvciBlZmZpY2llbmN5XHJcbi8vIFJlcXVpcmVzIGNvbW1hbmRzIGhhdmUgYWxyZWFkeSBiZWVuIGNvbnZlcnRlZCB0byBhYnNvbHV0ZSB2ZXJzaW9uc1xyXG5mdW5jdGlvbiBsb25naGFuZChwYXRoKXtcclxuICAgIHZhciBwcmV2LHgxPTAseTE9MDtcclxuICAgIHZhciBjb252ZXJzaW9uID0geyBTOnt0bzonQycseDozfSwgVDp7dG86J1EnLHg6MX0gfTtcclxuICAgIGZvcih2YXIgaT0wLCBsZW49cGF0aC5sZW5ndGg7IGk8bGVuOyBpKyspe1xyXG4gICAgICAgIHZhciBjbWQgPSBwYXRoW2ldO1xyXG4gICAgICAgIHZhciBjb252ZXJ0ID0gY29udmVyc2lvbltjbWRbMF1dO1xyXG5cclxuICAgICAgICBpZiAoY29udmVydCkge1xyXG4gICAgICAgICAgICBjbWRbMF0gPSBjb252ZXJ0LnRvO1xyXG4gICAgICAgICAgICBpZiAocHJldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZbMF0gPT09IGNvbnZlcnQudG8pIHtcclxuICAgICAgICAgICAgICAgICAgICB4MSA9IDIqcHJldltjb252ZXJ0LngrMl0tcHJldltjb252ZXJ0LnggIF07XHJcbiAgICAgICAgICAgICAgICAgICAgeTEgPSAyKnByZXZbY29udmVydC54KzNdLXByZXZbY29udmVydC54KzFdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4MSA9IHByZXZbcHJldi5sZW5ndGgtMl07XHJcbiAgICAgICAgICAgICAgICAgICAgeTEgPSBwcmV2W3ByZXYubGVuZ3RoLTFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNtZC5zcGxpY2UoMSwwLHgxLHkxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldj1jbWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aDtcclxufVxyXG5cclxuLy8gQ29udmVydCAnWicsICdWJyBhbmQgJ0gnIHNlZ21lbnRzIHRvICdMJyBzZWdtZW50c1xyXG5mdW5jdGlvbiB6dmhUb0wocGF0aCl7XHJcbiAgICB2YXIgcmV0ID0gW107XHJcbiAgICB2YXIgc3RhcnRQb2ludCA9IFsnTCcsMCwwXTtcclxuICAgIHZhciBsYXN0X3BvaW50O1xyXG5cclxuICAgIGZvcih2YXIgaT0wLCBsZW49cGF0aC5sZW5ndGg7IGk8bGVuOyBpKyspe1xyXG4gICAgICAgIHZhciBwdCA9IHBhdGhbaV07XHJcbiAgICAgICAgc3dpdGNoKHB0WzBdKXtcclxuICAgICAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgICAgICBzdGFydFBvaW50ID0gWydMJywgcHRbMV0sIHB0WzJdXTtcclxuICAgICAgICAgICAgICAgIHJldC5wdXNoKHB0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdaJzpcclxuICAgICAgICAgICAgICAgIHJldC5wdXNoKHN0YXJ0UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ0gnOlxyXG4gICAgICAgICAgICAgICAgbGFzdF9wb2ludCA9IHJldFtyZXQubGVuZ3RoIC0gMV0gfHwgWydMJywwLDBdO1xyXG4gICAgICAgICAgICAgICAgcmV0LnB1c2goIFsnTCcsIHB0WzFdLCBsYXN0X3BvaW50W2xhc3RfcG9pbnQubGVuZ3RoIC0gMV1dICk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnVic6XHJcbiAgICAgICAgICAgICAgICBsYXN0X3BvaW50ID0gcmV0W3JldC5sZW5ndGggLSAxXSB8fCBbJ0wnLDAsMF07XHJcbiAgICAgICAgICAgICAgICByZXQucHVzaCggWydMJywgbGFzdF9wb2ludFtsYXN0X3BvaW50Lmxlbmd0aCAtIDJdLCBwdFsxXV0gKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0LnB1c2gocHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19yZWdyZXNzaW9uQDIuMC4xQHJlZ3Jlc3Npb24vZGlzdC9yZWdyZXNzaW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19yZWdyZXNzaW9uQDIuMC4xQHJlZ3Jlc3Npb24vZGlzdC9yZWdyZXNzaW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIGlmICh0cnVlKSB7XG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW21vZHVsZV0sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICB9IGVsc2UgeyB2YXIgbW9kOyB9XG59KSh0aGlzLCBmdW5jdGlvbiAobW9kdWxlKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnIyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBERUZBVUxUX09QVElPTlMgPSB7IG9yZGVyOiAyLCBwcmVjaXNpb246IDIsIHBlcmlvZDogbnVsbCB9O1xuXG4gIC8qKlxuICAqIERldGVybWluZSB0aGUgY29lZmZpY2llbnQgb2YgZGV0ZXJtaW5hdGlvbiAocl4yKSBvZiBhIGZpdCBmcm9tIHRoZSBvYnNlcnZhdGlvbnNcbiAgKiBhbmQgcHJlZGljdGlvbnMuXG4gICpcbiAgKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBkYXRhIC0gUGFpcnMgb2Ygb2JzZXJ2ZWQgeC15IHZhbHVlc1xuICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHJlc3VsdHMgLSBQYWlycyBvZiBvYnNlcnZlZCBwcmVkaWN0ZWQgeC15IHZhbHVlc1xuICAqXG4gICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByXjIgdmFsdWUsIG9yIE5hTiBpZiBvbmUgY2Fubm90IGJlIGNhbGN1bGF0ZWQuXG4gICovXG4gIGZ1bmN0aW9uIGRldGVybWluYXRpb25Db2VmZmljaWVudChkYXRhLCByZXN1bHRzKSB7XG4gICAgdmFyIHByZWRpY3Rpb25zID0gW107XG4gICAgdmFyIG9ic2VydmF0aW9ucyA9IFtdO1xuXG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICBpZiAoZFsxXSAhPT0gbnVsbCkge1xuICAgICAgICBvYnNlcnZhdGlvbnMucHVzaChkKTtcbiAgICAgICAgcHJlZGljdGlvbnMucHVzaChyZXN1bHRzW2ldKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBzdW0gPSBvYnNlcnZhdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChhLCBvYnNlcnZhdGlvbikge1xuICAgICAgcmV0dXJuIGEgKyBvYnNlcnZhdGlvblsxXTtcbiAgICB9LCAwKTtcbiAgICB2YXIgbWVhbiA9IHN1bSAvIG9ic2VydmF0aW9ucy5sZW5ndGg7XG5cbiAgICB2YXIgc3N5eSA9IG9ic2VydmF0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKGEsIG9ic2VydmF0aW9uKSB7XG4gICAgICB2YXIgZGlmZmVyZW5jZSA9IG9ic2VydmF0aW9uWzFdIC0gbWVhbjtcbiAgICAgIHJldHVybiBhICsgZGlmZmVyZW5jZSAqIGRpZmZlcmVuY2U7XG4gICAgfSwgMCk7XG5cbiAgICB2YXIgc3NlID0gb2JzZXJ2YXRpb25zLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIG9ic2VydmF0aW9uLCBpbmRleCkge1xuICAgICAgdmFyIHByZWRpY3Rpb24gPSBwcmVkaWN0aW9uc1tpbmRleF07XG4gICAgICB2YXIgcmVzaWR1YWwgPSBvYnNlcnZhdGlvblsxXSAtIHByZWRpY3Rpb25bMV07XG4gICAgICByZXR1cm4gYWNjdW0gKyByZXNpZHVhbCAqIHJlc2lkdWFsO1xuICAgIH0sIDApO1xuXG4gICAgcmV0dXJuIDEgLSBzc2UgLyBzc3l5O1xuICB9XG5cbiAgLyoqXG4gICogRGV0ZXJtaW5lIHRoZSBzb2x1dGlvbiBvZiBhIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRpb25zIEEgKiB4ID0gYiB1c2luZ1xuICAqIEdhdXNzaWFuIGVsaW1pbmF0aW9uLlxuICAqXG4gICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gaW5wdXQgLSBBIDItZCBtYXRyaXggb2YgZGF0YSBpbiByb3ctbWFqb3IgZm9ybSBbIEEgfCBiIF1cbiAgKiBAcGFyYW0ge251bWJlcn0gb3JkZXIgLSBIb3cgbWFueSBkZWdyZWVzIHRvIHNvbHZlIGZvclxuICAqXG4gICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gLSBWZWN0b3Igb2Ygbm9ybWFsaXplZCBzb2x1dGlvbiBjb2VmZmljaWVudHMgbWF0cml4ICh4KVxuICAqL1xuICBmdW5jdGlvbiBnYXVzc2lhbkVsaW1pbmF0aW9uKGlucHV0LCBvcmRlcikge1xuICAgIHZhciBtYXRyaXggPSBpbnB1dDtcbiAgICB2YXIgbiA9IGlucHV0Lmxlbmd0aCAtIDE7XG4gICAgdmFyIGNvZWZmaWNpZW50cyA9IFtvcmRlcl07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgdmFyIG1heHJvdyA9IGk7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKG1hdHJpeFtpXVtqXSkgPiBNYXRoLmFicyhtYXRyaXhbaV1bbWF4cm93XSkpIHtcbiAgICAgICAgICBtYXhyb3cgPSBqO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGsgPSBpOyBrIDwgbiArIDE7IGsrKykge1xuICAgICAgICB2YXIgdG1wID0gbWF0cml4W2tdW2ldO1xuICAgICAgICBtYXRyaXhba11baV0gPSBtYXRyaXhba11bbWF4cm93XTtcbiAgICAgICAgbWF0cml4W2tdW21heHJvd10gPSB0bXA7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9qID0gaSArIDE7IF9qIDwgbjsgX2orKykge1xuICAgICAgICBmb3IgKHZhciBfayA9IG47IF9rID49IGk7IF9rLS0pIHtcbiAgICAgICAgICBtYXRyaXhbX2tdW19qXSAtPSBtYXRyaXhbX2tdW2ldICogbWF0cml4W2ldW19qXSAvIG1hdHJpeFtpXVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9qMiA9IG4gLSAxOyBfajIgPj0gMDsgX2oyLS0pIHtcbiAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICBmb3IgKHZhciBfazIgPSBfajIgKyAxOyBfazIgPCBuOyBfazIrKykge1xuICAgICAgICB0b3RhbCArPSBtYXRyaXhbX2syXVtfajJdICogY29lZmZpY2llbnRzW19rMl07XG4gICAgICB9XG5cbiAgICAgIGNvZWZmaWNpZW50c1tfajJdID0gKG1hdHJpeFtuXVtfajJdIC0gdG90YWwpIC8gbWF0cml4W19qMl1bX2oyXTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29lZmZpY2llbnRzO1xuICB9XG5cbiAgLyoqXG4gICogUm91bmQgYSBudW1iZXIgdG8gYSBwcmVjaXNpb24sIHNwZWNpZmljZWQgaW4gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gICpcbiAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIC0gVGhlIG51bWJlciB0byByb3VuZFxuICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVjaXNpb24gLSBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRvIHJvdW5kIHRvOlxuICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+IDAgbWVhbnMgZGVjaW1hbHMsIDwgMCBtZWFucyBwb3dlcnMgb2YgMTBcbiAgKlxuICAqXG4gICogQHJldHVybiB7bnVtYnJ9IC0gVGhlIG51bWJlciwgcm91bmRlZFxuICAqL1xuICBmdW5jdGlvbiByb3VuZChudW1iZXIsIHByZWNpc2lvbikge1xuICAgIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICB9XG5cbiAgLyoqXG4gICogVGhlIHNldCBvZiBhbGwgZml0dGluZyBtZXRob2RzXG4gICpcbiAgKiBAbmFtZXNwYWNlXG4gICovXG4gIHZhciBtZXRob2RzID0ge1xuICAgIGxpbmVhcjogZnVuY3Rpb24gbGluZWFyKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdW0gPSBbMCwgMCwgMCwgMCwgMF07XG4gICAgICB2YXIgbGVuID0gMDtcblxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBkYXRhLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGlmIChkYXRhW25dWzFdICE9PSBudWxsKSB7XG4gICAgICAgICAgbGVuKys7XG4gICAgICAgICAgc3VtWzBdICs9IGRhdGFbbl1bMF07XG4gICAgICAgICAgc3VtWzFdICs9IGRhdGFbbl1bMV07XG4gICAgICAgICAgc3VtWzJdICs9IGRhdGFbbl1bMF0gKiBkYXRhW25dWzBdO1xuICAgICAgICAgIHN1bVszXSArPSBkYXRhW25dWzBdICogZGF0YVtuXVsxXTtcbiAgICAgICAgICBzdW1bNF0gKz0gZGF0YVtuXVsxXSAqIGRhdGFbbl1bMV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJ1biA9IGxlbiAqIHN1bVsyXSAtIHN1bVswXSAqIHN1bVswXTtcbiAgICAgIHZhciByaXNlID0gbGVuICogc3VtWzNdIC0gc3VtWzBdICogc3VtWzFdO1xuICAgICAgdmFyIGdyYWRpZW50ID0gcnVuID09PSAwID8gMCA6IHJvdW5kKHJpc2UgLyBydW4sIG9wdGlvbnMucHJlY2lzaW9uKTtcbiAgICAgIHZhciBpbnRlcmNlcHQgPSByb3VuZChzdW1bMV0gLyBsZW4gLSBncmFkaWVudCAqIHN1bVswXSAvIGxlbiwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXG4gICAgICB2YXIgcHJlZGljdCA9IGZ1bmN0aW9uIHByZWRpY3QoeCkge1xuICAgICAgICByZXR1cm4gW3JvdW5kKHgsIG9wdGlvbnMucHJlY2lzaW9uKSwgcm91bmQoZ3JhZGllbnQgKiB4ICsgaW50ZXJjZXB0LCBvcHRpb25zLnByZWNpc2lvbildO1xuICAgICAgfTtcblxuICAgICAgdmFyIHBvaW50cyA9IGRhdGEubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICByZXR1cm4gcHJlZGljdChwb2ludFswXSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgIHByZWRpY3Q6IHByZWRpY3QsXG4gICAgICAgIGVxdWF0aW9uOiBbZ3JhZGllbnQsIGludGVyY2VwdF0sXG4gICAgICAgIHIyOiByb3VuZChkZXRlcm1pbmF0aW9uQ29lZmZpY2llbnQoZGF0YSwgcG9pbnRzKSwgb3B0aW9ucy5wcmVjaXNpb24pLFxuICAgICAgICBzdHJpbmc6IGludGVyY2VwdCA9PT0gMCA/ICd5ID0gJyArIGdyYWRpZW50ICsgJ3gnIDogJ3kgPSAnICsgZ3JhZGllbnQgKyAneCArICcgKyBpbnRlcmNlcHRcbiAgICAgIH07XG4gICAgfSxcbiAgICBleHBvbmVudGlhbDogZnVuY3Rpb24gZXhwb25lbnRpYWwoZGF0YSwgb3B0aW9ucykge1xuICAgICAgdmFyIHN1bSA9IFswLCAwLCAwLCAwLCAwLCAwXTtcblxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBkYXRhLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGlmIChkYXRhW25dWzFdICE9PSBudWxsKSB7XG4gICAgICAgICAgc3VtWzBdICs9IGRhdGFbbl1bMF07XG4gICAgICAgICAgc3VtWzFdICs9IGRhdGFbbl1bMV07XG4gICAgICAgICAgc3VtWzJdICs9IGRhdGFbbl1bMF0gKiBkYXRhW25dWzBdICogZGF0YVtuXVsxXTtcbiAgICAgICAgICBzdW1bM10gKz0gZGF0YVtuXVsxXSAqIE1hdGgubG9nKGRhdGFbbl1bMV0pO1xuICAgICAgICAgIHN1bVs0XSArPSBkYXRhW25dWzBdICogZGF0YVtuXVsxXSAqIE1hdGgubG9nKGRhdGFbbl1bMV0pO1xuICAgICAgICAgIHN1bVs1XSArPSBkYXRhW25dWzBdICogZGF0YVtuXVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGVub21pbmF0b3IgPSBzdW1bMV0gKiBzdW1bMl0gLSBzdW1bNV0gKiBzdW1bNV07XG4gICAgICB2YXIgYSA9IE1hdGguZXhwKChzdW1bMl0gKiBzdW1bM10gLSBzdW1bNV0gKiBzdW1bNF0pIC8gZGVub21pbmF0b3IpO1xuICAgICAgdmFyIGIgPSAoc3VtWzFdICogc3VtWzRdIC0gc3VtWzVdICogc3VtWzNdKSAvIGRlbm9taW5hdG9yO1xuICAgICAgdmFyIGNvZWZmQSA9IHJvdW5kKGEsIG9wdGlvbnMucHJlY2lzaW9uKTtcbiAgICAgIHZhciBjb2VmZkIgPSByb3VuZChiLCBvcHRpb25zLnByZWNpc2lvbik7XG4gICAgICB2YXIgcHJlZGljdCA9IGZ1bmN0aW9uIHByZWRpY3QoeCkge1xuICAgICAgICByZXR1cm4gW3JvdW5kKHgsIG9wdGlvbnMucHJlY2lzaW9uKSwgcm91bmQoY29lZmZBICogTWF0aC5leHAoY29lZmZCICogeCksIG9wdGlvbnMucHJlY2lzaW9uKV07XG4gICAgICB9O1xuXG4gICAgICB2YXIgcG9pbnRzID0gZGF0YS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBwcmVkaWN0KHBvaW50WzBdKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgcHJlZGljdDogcHJlZGljdCxcbiAgICAgICAgZXF1YXRpb246IFtjb2VmZkEsIGNvZWZmQl0sXG4gICAgICAgIHN0cmluZzogJ3kgPSAnICsgY29lZmZBICsgJ2VeKCcgKyBjb2VmZkIgKyAneCknLFxuICAgICAgICByMjogcm91bmQoZGV0ZXJtaW5hdGlvbkNvZWZmaWNpZW50KGRhdGEsIHBvaW50cyksIG9wdGlvbnMucHJlY2lzaW9uKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGxvZ2FyaXRobWljOiBmdW5jdGlvbiBsb2dhcml0aG1pYyhkYXRhLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc3VtID0gWzAsIDAsIDAsIDBdO1xuICAgICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIGlmIChkYXRhW25dWzFdICE9PSBudWxsKSB7XG4gICAgICAgICAgc3VtWzBdICs9IE1hdGgubG9nKGRhdGFbbl1bMF0pO1xuICAgICAgICAgIHN1bVsxXSArPSBkYXRhW25dWzFdICogTWF0aC5sb2coZGF0YVtuXVswXSk7XG4gICAgICAgICAgc3VtWzJdICs9IGRhdGFbbl1bMV07XG4gICAgICAgICAgc3VtWzNdICs9IE1hdGgucG93KE1hdGgubG9nKGRhdGFbbl1bMF0pLCAyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYSA9IChsZW4gKiBzdW1bMV0gLSBzdW1bMl0gKiBzdW1bMF0pIC8gKGxlbiAqIHN1bVszXSAtIHN1bVswXSAqIHN1bVswXSk7XG4gICAgICB2YXIgY29lZmZCID0gcm91bmQoYSwgb3B0aW9ucy5wcmVjaXNpb24pO1xuICAgICAgdmFyIGNvZWZmQSA9IHJvdW5kKChzdW1bMl0gLSBjb2VmZkIgKiBzdW1bMF0pIC8gbGVuLCBvcHRpb25zLnByZWNpc2lvbik7XG5cbiAgICAgIHZhciBwcmVkaWN0ID0gZnVuY3Rpb24gcHJlZGljdCh4KSB7XG4gICAgICAgIHJldHVybiBbcm91bmQoeCwgb3B0aW9ucy5wcmVjaXNpb24pLCByb3VuZChyb3VuZChjb2VmZkEgKyBjb2VmZkIgKiBNYXRoLmxvZyh4KSwgb3B0aW9ucy5wcmVjaXNpb24pLCBvcHRpb25zLnByZWNpc2lvbildO1xuICAgICAgfTtcblxuICAgICAgdmFyIHBvaW50cyA9IGRhdGEubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICByZXR1cm4gcHJlZGljdChwb2ludFswXSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgIHByZWRpY3Q6IHByZWRpY3QsXG4gICAgICAgIGVxdWF0aW9uOiBbY29lZmZBLCBjb2VmZkJdLFxuICAgICAgICBzdHJpbmc6ICd5ID0gJyArIGNvZWZmQSArICcgKyAnICsgY29lZmZCICsgJyBsbih4KScsXG4gICAgICAgIHIyOiByb3VuZChkZXRlcm1pbmF0aW9uQ29lZmZpY2llbnQoZGF0YSwgcG9pbnRzKSwgb3B0aW9ucy5wcmVjaXNpb24pXG4gICAgICB9O1xuICAgIH0sXG4gICAgcG93ZXI6IGZ1bmN0aW9uIHBvd2VyKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdW0gPSBbMCwgMCwgMCwgMCwgMF07XG4gICAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgaWYgKGRhdGFbbl1bMV0gIT09IG51bGwpIHtcbiAgICAgICAgICBzdW1bMF0gKz0gTWF0aC5sb2coZGF0YVtuXVswXSk7XG4gICAgICAgICAgc3VtWzFdICs9IE1hdGgubG9nKGRhdGFbbl1bMV0pICogTWF0aC5sb2coZGF0YVtuXVswXSk7XG4gICAgICAgICAgc3VtWzJdICs9IE1hdGgubG9nKGRhdGFbbl1bMV0pO1xuICAgICAgICAgIHN1bVszXSArPSBNYXRoLnBvdyhNYXRoLmxvZyhkYXRhW25dWzBdKSwgMik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGIgPSAobGVuICogc3VtWzFdIC0gc3VtWzBdICogc3VtWzJdKSAvIChsZW4gKiBzdW1bM10gLSBNYXRoLnBvdyhzdW1bMF0sIDIpKTtcbiAgICAgIHZhciBhID0gKHN1bVsyXSAtIGIgKiBzdW1bMF0pIC8gbGVuO1xuICAgICAgdmFyIGNvZWZmQSA9IHJvdW5kKE1hdGguZXhwKGEpLCBvcHRpb25zLnByZWNpc2lvbik7XG4gICAgICB2YXIgY29lZmZCID0gcm91bmQoYiwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXG4gICAgICB2YXIgcHJlZGljdCA9IGZ1bmN0aW9uIHByZWRpY3QoeCkge1xuICAgICAgICByZXR1cm4gW3JvdW5kKHgsIG9wdGlvbnMucHJlY2lzaW9uKSwgcm91bmQocm91bmQoY29lZmZBICogTWF0aC5wb3coeCwgY29lZmZCKSwgb3B0aW9ucy5wcmVjaXNpb24pLCBvcHRpb25zLnByZWNpc2lvbildO1xuICAgICAgfTtcblxuICAgICAgdmFyIHBvaW50cyA9IGRhdGEubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICByZXR1cm4gcHJlZGljdChwb2ludFswXSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgIHByZWRpY3Q6IHByZWRpY3QsXG4gICAgICAgIGVxdWF0aW9uOiBbY29lZmZBLCBjb2VmZkJdLFxuICAgICAgICBzdHJpbmc6ICd5ID0gJyArIGNvZWZmQSArICd4XicgKyBjb2VmZkIsXG4gICAgICAgIHIyOiByb3VuZChkZXRlcm1pbmF0aW9uQ29lZmZpY2llbnQoZGF0YSwgcG9pbnRzKSwgb3B0aW9ucy5wcmVjaXNpb24pXG4gICAgICB9O1xuICAgIH0sXG4gICAgcG9seW5vbWlhbDogZnVuY3Rpb24gcG9seW5vbWlhbChkYXRhLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGhzID0gW107XG4gICAgICB2YXIgcmhzID0gW107XG4gICAgICB2YXIgYSA9IDA7XG4gICAgICB2YXIgYiA9IDA7XG4gICAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICB2YXIgayA9IG9wdGlvbnMub3JkZXIgKyAxO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxlbjsgbCsrKSB7XG4gICAgICAgICAgaWYgKGRhdGFbbF1bMV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGEgKz0gTWF0aC5wb3coZGF0YVtsXVswXSwgaSkgKiBkYXRhW2xdWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxocy5wdXNoKGEpO1xuICAgICAgICBhID0gMDtcblxuICAgICAgICB2YXIgYyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGs7IGorKykge1xuICAgICAgICAgIGZvciAodmFyIF9sID0gMDsgX2wgPCBsZW47IF9sKyspIHtcbiAgICAgICAgICAgIGlmIChkYXRhW19sXVsxXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBiICs9IE1hdGgucG93KGRhdGFbX2xdWzBdLCBpICsgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGMucHVzaChiKTtcbiAgICAgICAgICBiID0gMDtcbiAgICAgICAgfVxuICAgICAgICByaHMucHVzaChjKTtcbiAgICAgIH1cbiAgICAgIHJocy5wdXNoKGxocyk7XG5cbiAgICAgIHZhciBjb2VmZmljaWVudHMgPSBnYXVzc2lhbkVsaW1pbmF0aW9uKHJocywgaykubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiByb3VuZCh2LCBvcHRpb25zLnByZWNpc2lvbik7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHByZWRpY3QgPSBmdW5jdGlvbiBwcmVkaWN0KHgpIHtcbiAgICAgICAgcmV0dXJuIFtyb3VuZCh4LCBvcHRpb25zLnByZWNpc2lvbiksIHJvdW5kKGNvZWZmaWNpZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgY29lZmYsIHBvd2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHN1bSArIGNvZWZmICogTWF0aC5wb3coeCwgcG93ZXIpO1xuICAgICAgICB9LCAwKSwgb3B0aW9ucy5wcmVjaXNpb24pXTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBwb2ludHMgPSBkYXRhLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY3QocG9pbnRbMF0pO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBzdHJpbmcgPSAneSA9ICc7XG4gICAgICBmb3IgKHZhciBfaSA9IGNvZWZmaWNpZW50cy5sZW5ndGggLSAxOyBfaSA+PSAwOyBfaS0tKSB7XG4gICAgICAgIGlmIChfaSA+IDEpIHtcbiAgICAgICAgICBzdHJpbmcgKz0gY29lZmZpY2llbnRzW19pXSArICd4XicgKyBfaSArICcgKyAnO1xuICAgICAgICB9IGVsc2UgaWYgKF9pID09PSAxKSB7XG4gICAgICAgICAgc3RyaW5nICs9IGNvZWZmaWNpZW50c1tfaV0gKyAneCArICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyaW5nICs9IGNvZWZmaWNpZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgICBwcmVkaWN0OiBwcmVkaWN0LFxuICAgICAgICBlcXVhdGlvbjogW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjb2VmZmljaWVudHMpKS5yZXZlcnNlKCksXG4gICAgICAgIHIyOiByb3VuZChkZXRlcm1pbmF0aW9uQ29lZmZpY2llbnQoZGF0YSwgcG9pbnRzKSwgb3B0aW9ucy5wcmVjaXNpb24pXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVyKCkge1xuICAgIHZhciByZWR1Y2UgPSBmdW5jdGlvbiByZWR1Y2UoYWNjdW11bGF0b3IsIG5hbWUpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIF9yb3VuZDogcm91bmRcbiAgICAgIH0sIGFjY3VtdWxhdG9yLCBfZGVmaW5lUHJvcGVydHkoe30sIG5hbWUsIGZ1bmN0aW9uIChkYXRhLCBzdXBwbGllZCkge1xuICAgICAgICByZXR1cm4gbWV0aG9kc1tuYW1lXShkYXRhLCBfZXh0ZW5kcyh7fSwgREVGQVVMVF9PUFRJT05TLCBzdXBwbGllZCkpO1xuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMobWV0aG9kcykucmVkdWNlKHJlZHVjZSwge30pO1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVXcmFwcGVyKCk7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fc2ltcGxlLXN0YXRpc3RpY3NANi4xLjFAc2ltcGxlLXN0YXRpc3RpY3MvZGlzdC9zaW1wbGUtc3RhdGlzdGljcy5taW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19zaW1wbGUtc3RhdGlzdGljc0A2LjEuMUBzaW1wbGUtc3RhdGlzdGljcy9kaXN0L3NpbXBsZS1zdGF0aXN0aWNzLm1pbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuIWZ1bmN0aW9uKHQscil7IHRydWU/cihleHBvcnRzKTp1bmRlZmluZWR9KHRoaXMsZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtpZigwPT09dC5sZW5ndGgpcmV0dXJuIDA7Zm9yKHZhciByLG49dFswXSxlPTAsYT0xO2E8dC5sZW5ndGg7YSsrKXI9bit0W2FdLE1hdGguYWJzKG4pPj1NYXRoLmFicyh0W2FdKT9lKz1uLXIrdFthXTplKz10W2FdLXIrbixuPXI7cmV0dXJuIG4rZX1mdW5jdGlvbiBnKHQpe2lmKDA9PT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJtZWFuIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO3JldHVybiByKHQpL3QubGVuZ3RofWZ1bmN0aW9uIG4odCxyKXt2YXIgbixlLGE9Zyh0KSxvPTA7aWYoMj09PXIpZm9yKGU9MDtlPHQubGVuZ3RoO2UrKylvKz0obj10W2VdLWEpKm47ZWxzZSBmb3IoZT0wO2U8dC5sZW5ndGg7ZSsrKW8rPU1hdGgucG93KHRbZV0tYSxyKTtyZXR1cm4gb31mdW5jdGlvbiBlKHQpe2lmKDA9PT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ2YXJpYW5jZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtyZXR1cm4gbih0LDIpL3QubGVuZ3RofWZ1bmN0aW9uIGEodCl7aWYoMT09PXQubGVuZ3RoKXJldHVybiAwO3ZhciByPWUodCk7cmV0dXJuIE1hdGguc3FydChyKX1mdW5jdGlvbiBvKHQpe2lmKDA9PT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJtb2RlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO2lmKDE9PT10Lmxlbmd0aClyZXR1cm4gdFswXTtmb3IodmFyIHI9dFswXSxuPU5hTixlPTAsYT0xLG89MTtvPHQubGVuZ3RoKzE7bysrKXRbb10hPT1yPyhlPGEmJihlPWEsbj1yKSxhPTEscj10W29dKTphKys7cmV0dXJuIG59ZnVuY3Rpb24gZih0KXtyZXR1cm4gdC5zbGljZSgpLnNvcnQoZnVuY3Rpb24odCxyKXtyZXR1cm4gdC1yfSl9ZnVuY3Rpb24gdSh0KXtpZigwPT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibWluIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO2Zvcih2YXIgcj10WzBdLG49MTtuPHQubGVuZ3RoO24rKyl0W25dPHImJihyPXRbbl0pO3JldHVybiByfWZ1bmN0aW9uIGgodCl7aWYoMD09PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIm1heCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtmb3IodmFyIHI9dFswXSxuPTE7bjx0Lmxlbmd0aDtuKyspdFtuXT5yJiYocj10W25dKTtyZXR1cm4gcn1mdW5jdGlvbiBpKHQscil7dmFyIG49dC5sZW5ndGgqcjtpZigwPT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwicXVhbnRpbGUgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnQuXCIpO2lmKHI8MHx8MTxyKXRocm93IG5ldyBFcnJvcihcInF1YW50aWxlcyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMVwiKTtyZXR1cm4gMT09PXI/dFt0Lmxlbmd0aC0xXTowPT09cj90WzBdOm4lMSE9MD90W01hdGguY2VpbChuKS0xXTp0Lmxlbmd0aCUyPT0wPyh0W24tMV0rdFtuXSkvMjp0W25dfWZ1bmN0aW9uIGModCxyLG4sZSl7Zm9yKG49bnx8MCxlPWV8fHQubGVuZ3RoLTE7bjxlOyl7aWYoNjAwPGUtbil7dmFyIGE9ZS1uKzEsbz1yLW4rMSxpPU1hdGgubG9nKGEpLHU9LjUqTWF0aC5leHAoMippLzMpLGg9LjUqTWF0aC5zcXJ0KGkqdSooYS11KS9hKTtvLWEvMjwwJiYoaCo9LTEpLGModCxyLE1hdGgubWF4KG4sTWF0aC5mbG9vcihyLW8qdS9hK2gpKSxNYXRoLm1pbihlLE1hdGguZmxvb3IocisoYS1vKSp1L2EraCkpKX12YXIgZj10W3JdLHM9bixsPWU7Zm9yKHAodCxuLHIpLHRbZV0+ZiYmcCh0LG4sZSk7czxsOyl7Zm9yKHAodCxzLGwpLHMrKyxsLS07dFtzXTxmOylzKys7Zm9yKDt0W2xdPmY7KWwtLX10W25dPT09Zj9wKHQsbixsKTpwKHQsKytsLGUpLGw8PXImJihuPWwrMSkscjw9bCYmKGU9bC0xKX19ZnVuY3Rpb24gcCh0LHIsbil7dmFyIGU9dFtyXTt0W3JdPXRbbl0sdFtuXT1lfWZ1bmN0aW9uIHModCxyKXt2YXIgbj10LnNsaWNlKCk7aWYoQXJyYXkuaXNBcnJheShyKSl7IWZ1bmN0aW9uKHQscil7Zm9yKHZhciBuPVswXSxlPTA7ZTxyLmxlbmd0aDtlKyspbi5wdXNoKHcodC5sZW5ndGgscltlXSkpO24ucHVzaCh0Lmxlbmd0aC0xKSxuLnNvcnQodik7dmFyIGE9WzAsbi5sZW5ndGgtMV07Zm9yKDthLmxlbmd0aDspe3ZhciBvPU1hdGguY2VpbChhLnBvcCgpKSxpPU1hdGguZmxvb3IoYS5wb3AoKSk7aWYoIShvLWk8PTEpKXt2YXIgdT1NYXRoLmZsb29yKChpK28pLzIpO2wodCxuW3VdLG5baV0sbltvXSksYS5wdXNoKGksdSx1LG8pfX19KG4scik7Zm9yKHZhciBlPVtdLGE9MDthPHIubGVuZ3RoO2ErKyllW2FdPWkobixyW2FdKTtyZXR1cm4gZX1yZXR1cm4gbChuLHcobi5sZW5ndGgsciksMCxuLmxlbmd0aC0xKSxpKG4scil9ZnVuY3Rpb24gbCh0LHIsbixlKXtyJTE9PTA/Yyh0LHIsbixlKTooYyh0LHI9TWF0aC5mbG9vcihyKSxuLGUpLGModCxyKzEscisxLGUpKX1mdW5jdGlvbiB2KHQscil7cmV0dXJuIHQtcn1mdW5jdGlvbiB3KHQscil7dmFyIG49dCpyO3JldHVybiAxPT09cj90LTE6MD09PXI/MDpuJTEhPTA/TWF0aC5jZWlsKG4pLTE6dCUyPT0wP24tLjU6bn1mdW5jdGlvbiBNKHQscil7aWYocjx0WzBdKXJldHVybiAwO2lmKHI+dFt0Lmxlbmd0aC0xXSlyZXR1cm4gMTt2YXIgbj1mdW5jdGlvbih0LHIpe3ZhciBuPTAsZT0wLGE9dC5sZW5ndGg7Zm9yKDtlPGE7KXI8PXRbbj1lK2E+Pj4xXT9hPW46ZT0tfm47cmV0dXJuIGV9KHQscik7aWYodFtuXSE9PXIpcmV0dXJuIG4vdC5sZW5ndGg7bisrO3ZhciBlPWZ1bmN0aW9uKHQscil7dmFyIG49MCxlPTAsYT10Lmxlbmd0aDtmb3IoO2U8YTspcj49dFtuPWUrYT4+PjFdP2U9LX5uOmE9bjtyZXR1cm4gZX0odCxyKTtpZihlPT09bilyZXR1cm4gbi90Lmxlbmd0aDt2YXIgYT1lLW4rMTtyZXR1cm4gYSooZStuKS8yL2EvdC5sZW5ndGh9ZnVuY3Rpb24gbSh0KXt2YXIgcj1zKHQsLjc1KSxuPXModCwuMjUpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiByJiZcIm51bWJlclwiPT10eXBlb2YgbilyZXR1cm4gci1ufWZ1bmN0aW9uIGQodCl7cmV0dXJuK3ModCwuNSl9ZnVuY3Rpb24gYih0KXtmb3IodmFyIHI9ZCh0KSxuPVtdLGU9MDtlPHQubGVuZ3RoO2UrKyluLnB1c2goTWF0aC5hYnModFtlXS1yKSk7cmV0dXJuIGQobil9ZnVuY3Rpb24gcSh0LHIpe3I9cnx8TWF0aC5yYW5kb207Zm9yKHZhciBuLGUsYT10Lmxlbmd0aDswPGE7KWU9TWF0aC5mbG9vcihyKCkqYS0tKSxuPXRbYV0sdFthXT10W2VdLHRbZV09bjtyZXR1cm4gdH1mdW5jdGlvbiBFKHQscil7cmV0dXJuIHEodC5zbGljZSgpLnNsaWNlKCkscil9ZnVuY3Rpb24geSh0KXtmb3IodmFyIHIsbj0wLGU9MDtlPHQubGVuZ3RoO2UrKykwIT09ZSYmdFtlXT09PXJ8fChyPXRbZV0sbisrKTtyZXR1cm4gbn1mdW5jdGlvbiBTKHQscil7Zm9yKHZhciBuPVtdLGU9MDtlPHQ7ZSsrKXtmb3IodmFyIGE9W10sbz0wO288cjtvKyspYS5wdXNoKDApO24ucHVzaChhKX1yZXR1cm4gbn1mdW5jdGlvbiB4KHQscixuLGUpe3ZhciBhO2lmKDA8dCl7dmFyIG89KG5bcl0tblt0LTFdKS8oci10KzEpO2E9ZVtyXS1lW3QtMV0tKHItdCsxKSpvKm99ZWxzZSBhPWVbcl0tbltyXSpuW3JdLyhyKzEpO3JldHVybiBhPDA/MDphfWZ1bmN0aW9uIFAodCxyLG4sZSxhLG8saSl7aWYoIShyPHQpKXt2YXIgdT1NYXRoLmZsb29yKCh0K3IpLzIpO2Vbbl1bdV09ZVtuLTFdW3UtMV0sYVtuXVt1XT11O3ZhciBoPW47bjx0JiYoaD1NYXRoLm1heChoLGFbbl1bdC0xXXx8MCkpLGg9TWF0aC5tYXgoaCxhW24tMV1bdV18fDApO3ZhciBmLHMsbCxjPXUtMTtyPGUubGVuZ3RoLTEmJihjPU1hdGgubWluKGMsYVtuXVtyKzFdfHwwKSk7Zm9yKHZhciBnPWM7aDw9ZyYmISgoZj14KGcsdSxvLGkpKStlW24tMV1baC0xXT49ZVtuXVt1XSk7LS1nKShzPXgoaCx1LG8saSkrZVtuLTFdW2gtMV0pPGVbbl1bdV0mJihlW25dW3VdPXMsYVtuXVt1XT1oKSxoKyssKGw9ZitlW24tMV1bZy0xXSk8ZVtuXVt1XSYmKGVbbl1bdV09bCxhW25dW3VdPWcpO1AodCx1LTEsbixlLGEsbyxpKSxQKHUrMSxyLG4sZSxhLG8saSl9fWZ1bmN0aW9uIGsodCxyKXtpZih0Lmxlbmd0aCE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNhbXBsZUNvdmFyaWFuY2UgcmVxdWlyZXMgc2FtcGxlcyB3aXRoIGVxdWFsIGxlbmd0aHNcIik7aWYodC5sZW5ndGg8Mil0aHJvdyBuZXcgRXJyb3IoXCJzYW1wbGVDb3ZhcmlhbmNlIHJlcXVpcmVzIGF0IGxlYXN0IHR3byBkYXRhIHBvaW50cyBpbiBlYWNoIHNhbXBsZVwiKTtmb3IodmFyIG49Zyh0KSxlPWcociksYT0wLG89MDtvPHQubGVuZ3RoO28rKylhKz0odFtvXS1uKSoocltvXS1lKTtyZXR1cm4gYS8odC5sZW5ndGgtMSl9ZnVuY3Rpb24gSSh0KXtpZih0Lmxlbmd0aDwyKXRocm93IG5ldyBFcnJvcihcInNhbXBsZVZhcmlhbmNlIHJlcXVpcmVzIGF0IGxlYXN0IHR3byBkYXRhIHBvaW50c1wiKTtyZXR1cm4gbih0LDIpLyh0Lmxlbmd0aC0xKX1mdW5jdGlvbiBEKHQpe3ZhciByPUkodCk7cmV0dXJuIE1hdGguc3FydChyKX1mdW5jdGlvbiBDKHQscixuLGUpe3JldHVybih0KnIrbiplKS8ocitlKX1mdW5jdGlvbiBUKHQpe2lmKDA9PT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJyb290TWVhblNxdWFyZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtmb3IodmFyIHI9MCxuPTA7bjx0Lmxlbmd0aDtuKyspcis9TWF0aC5wb3codFtuXSwyKTtyZXR1cm4gTWF0aC5zcXJ0KHIvdC5sZW5ndGgpfWZ1bmN0aW9uIF8oKXt0aGlzLnRvdGFsQ291bnQ9MCx0aGlzLmRhdGE9e319ZnVuY3Rpb24gRigpe3RoaXMud2VpZ2h0cz1bXSx0aGlzLmJpYXM9MH1fLnByb3RvdHlwZS50cmFpbj1mdW5jdGlvbih0LHIpe2Zvcih2YXIgbiBpbiB0aGlzLmRhdGFbcl18fCh0aGlzLmRhdGFbcl09e30pLHQpe3ZhciBlPXRbbl07dm9pZCAwPT09dGhpcy5kYXRhW3JdW25dJiYodGhpcy5kYXRhW3JdW25dPXt9KSx2b2lkIDA9PT10aGlzLmRhdGFbcl1bbl1bZV0mJih0aGlzLmRhdGFbcl1bbl1bZV09MCksdGhpcy5kYXRhW3JdW25dW2VdKyt9dGhpcy50b3RhbENvdW50Kyt9LF8ucHJvdG90eXBlLnNjb3JlPWZ1bmN0aW9uKHQpe3ZhciByLG49e307Zm9yKHZhciBlIGluIHQpe3ZhciBhPXRbZV07Zm9yKHIgaW4gdGhpcy5kYXRhKW5bcl09e30sdGhpcy5kYXRhW3JdW2VdP25bcl1bZStcIl9cIithXT0odGhpcy5kYXRhW3JdW2VdW2FdfHwwKS90aGlzLnRvdGFsQ291bnQ6bltyXVtlK1wiX1wiK2FdPTB9dmFyIG89e307Zm9yKHIgaW4gbilmb3IodmFyIGkgaW4gb1tyXT0wLG5bcl0pb1tyXSs9bltyXVtpXTtyZXR1cm4gb30sRi5wcm90b3R5cGUucHJlZGljdD1mdW5jdGlvbih0KXtpZih0Lmxlbmd0aCE9PXRoaXMud2VpZ2h0cy5sZW5ndGgpcmV0dXJuIG51bGw7Zm9yKHZhciByPTAsbj0wO248dGhpcy53ZWlnaHRzLmxlbmd0aDtuKyspcis9dGhpcy53ZWlnaHRzW25dKnRbbl07cmV0dXJuIDA8KHIrPXRoaXMuYmlhcyk/MTowfSxGLnByb3RvdHlwZS50cmFpbj1mdW5jdGlvbih0LHIpe2lmKDAhPT1yJiYxIT09cilyZXR1cm4gbnVsbDt0Lmxlbmd0aCE9PXRoaXMud2VpZ2h0cy5sZW5ndGgmJih0aGlzLndlaWdodHM9dCx0aGlzLmJpYXM9MSk7dmFyIG49dGhpcy5wcmVkaWN0KHQpO2lmKG4hPT1yKXtmb3IodmFyIGU9ci1uLGE9MDthPHRoaXMud2VpZ2h0cy5sZW5ndGg7YSsrKXRoaXMud2VpZ2h0c1thXSs9ZSp0W2FdO3RoaXMuYmlhcys9ZX1yZXR1cm4gdGhpc307dmFyIE49MWUtNDtmdW5jdGlvbiBSKHQpe2lmKHQ8MCl0aHJvdyBuZXcgRXJyb3IoXCJmYWN0b3JpYWwgcmVxdWlyZXMgYSBub24tbmVnYXRpdmUgdmFsdWVcIik7aWYoTWF0aC5mbG9vcih0KSE9PXQpdGhyb3cgbmV3IEVycm9yKFwiZmFjdG9yaWFsIHJlcXVpcmVzIGFuIGludGVnZXIgaW5wdXRcIik7Zm9yKHZhciByPTEsbj0yO248PXQ7bisrKXIqPW47cmV0dXJuIHJ9dmFyIEE9Wy45OTk5OTk5OTk5OTk5OTcxLDU3LjE1NjIzNTY2NTg2MjkyLC01OS41OTc5NjAzNTU0NzU0OSwxNC4xMzYwOTc5NzQ3NDE3NDYsLS40OTE5MTM4MTYwOTc2MjAyLDMzOTk0NjQ5OTg0ODExODllLTIwLDQ2NTIzNjI4OTI3MDQ4NThlLTIwLC05ODM3NDQ3NTMwNDg3OTU2ZS0yMCwuMDAwMTU4MDg4NzAzMjI0OTEyNSwtLjAwMDIxMDI2NDQ0MTcyNDEwNDg4LC4wMDAyMTc0Mzk2MTgxMTUyMTI2NSwtLjAwMDE2NDMxODEwNjUzNjc2MzksODQ0MTgyMjM5ODM4NTI3NWUtMjAsLTI2MTkwODM4NDAxNTgxNDA4ZS0yMSwzNjg5OTE4MjY1OTUzMTYyNWUtMjJdLHo9TWF0aC5sb2coTWF0aC5zcXJ0KDIqTWF0aC5QSSkpO3ZhciBWPXsxOnsuOTk1OjAsLjk5OjAsLjk3NTowLC45NTowLC45Oi4wMiwuNTouNDUsLjE6Mi43MSwuMDU6My44NCwuMDI1OjUuMDIsLjAxOjYuNjMsLjAwNTo3Ljg4fSwyOnsuOTk1Oi4wMSwuOTk6LjAyLC45NzU6LjA1LC45NTouMSwuOTouMjEsLjU6MS4zOSwuMTo0LjYxLC4wNTo1Ljk5LC4wMjU6Ny4zOCwuMDE6OS4yMSwuMDA1OjEwLjZ9LDM6ey45OTU6LjA3LC45OTouMTEsLjk3NTouMjIsLjk1Oi4zNSwuOTouNTgsLjU6Mi4zNywuMTo2LjI1LC4wNTo3LjgxLC4wMjU6OS4zNSwuMDE6MTEuMzQsLjAwNToxMi44NH0sNDp7Ljk5NTouMjEsLjk5Oi4zLC45NzU6LjQ4LC45NTouNzEsLjk6MS4wNiwuNTozLjM2LC4xOjcuNzgsLjA1OjkuNDksLjAyNToxMS4xNCwuMDE6MTMuMjgsLjAwNToxNC44Nn0sNTp7Ljk5NTouNDEsLjk5Oi41NSwuOTc1Oi44MywuOTU6MS4xNSwuOToxLjYxLC41OjQuMzUsLjE6OS4yNCwuMDU6MTEuMDcsLjAyNToxMi44MywuMDE6MTUuMDksLjAwNToxNi43NX0sNjp7Ljk5NTouNjgsLjk5Oi44NywuOTc1OjEuMjQsLjk1OjEuNjQsLjk6Mi4yLC41OjUuMzUsLjE6MTAuNjUsLjA1OjEyLjU5LC4wMjU6MTQuNDUsLjAxOjE2LjgxLC4wMDU6MTguNTV9LDc6ey45OTU6Ljk5LC45OToxLjI1LC45NzU6MS42OSwuOTU6Mi4xNywuOToyLjgzLC41OjYuMzUsLjE6MTIuMDIsLjA1OjE0LjA3LC4wMjU6MTYuMDEsLjAxOjE4LjQ4LC4wMDU6MjAuMjh9LDg6ey45OTU6MS4zNCwuOTk6MS42NSwuOTc1OjIuMTgsLjk1OjIuNzMsLjk6My40OSwuNTo3LjM0LC4xOjEzLjM2LC4wNToxNS41MSwuMDI1OjE3LjUzLC4wMToyMC4wOSwuMDA1OjIxLjk2fSw5OnsuOTk1OjEuNzMsLjk5OjIuMDksLjk3NToyLjcsLjk1OjMuMzMsLjk6NC4xNywuNTo4LjM0LC4xOjE0LjY4LC4wNToxNi45MiwuMDI1OjE5LjAyLC4wMToyMS42NywuMDA1OjIzLjU5fSwxMDp7Ljk5NToyLjE2LC45OToyLjU2LC45NzU6My4yNSwuOTU6My45NCwuOTo0Ljg3LC41OjkuMzQsLjE6MTUuOTksLjA1OjE4LjMxLC4wMjU6MjAuNDgsLjAxOjIzLjIxLC4wMDU6MjUuMTl9LDExOnsuOTk1OjIuNiwuOTk6My4wNSwuOTc1OjMuODIsLjk1OjQuNTcsLjk6NS41OCwuNToxMC4zNCwuMToxNy4yOCwuMDU6MTkuNjgsLjAyNToyMS45MiwuMDE6MjQuNzIsLjAwNToyNi43Nn0sMTI6ey45OTU6My4wNywuOTk6My41NywuOTc1OjQuNCwuOTU6NS4yMywuOTo2LjMsLjU6MTEuMzQsLjE6MTguNTUsLjA1OjIxLjAzLC4wMjU6MjMuMzQsLjAxOjI2LjIyLC4wMDU6MjguM30sMTM6ey45OTU6My41NywuOTk6NC4xMSwuOTc1OjUuMDEsLjk1OjUuODksLjk6Ny4wNCwuNToxMi4zNCwuMToxOS44MSwuMDU6MjIuMzYsLjAyNToyNC43NCwuMDE6MjcuNjksLjAwNToyOS44Mn0sMTQ6ey45OTU6NC4wNywuOTk6NC42NiwuOTc1OjUuNjMsLjk1OjYuNTcsLjk6Ny43OSwuNToxMy4zNCwuMToyMS4wNiwuMDU6MjMuNjgsLjAyNToyNi4xMiwuMDE6MjkuMTQsLjAwNTozMS4zMn0sMTU6ey45OTU6NC42LC45OTo1LjIzLC45NzU6Ni4yNywuOTU6Ny4yNiwuOTo4LjU1LC41OjE0LjM0LC4xOjIyLjMxLC4wNToyNSwuMDI1OjI3LjQ5LC4wMTozMC41OCwuMDA1OjMyLjh9LDE2OnsuOTk1OjUuMTQsLjk5OjUuODEsLjk3NTo2LjkxLC45NTo3Ljk2LC45OjkuMzEsLjU6MTUuMzQsLjE6MjMuNTQsLjA1OjI2LjMsLjAyNToyOC44NSwuMDE6MzIsLjAwNTozNC4yN30sMTc6ey45OTU6NS43LC45OTo2LjQxLC45NzU6Ny41NiwuOTU6OC42NywuOToxMC4wOSwuNToxNi4zNCwuMToyNC43NywuMDU6MjcuNTksLjAyNTozMC4xOSwuMDE6MzMuNDEsLjAwNTozNS43Mn0sMTg6ey45OTU6Ni4yNiwuOTk6Ny4wMSwuOTc1OjguMjMsLjk1OjkuMzksLjk6MTAuODcsLjU6MTcuMzQsLjE6MjUuOTksLjA1OjI4Ljg3LC4wMjU6MzEuNTMsLjAxOjM0LjgxLC4wMDU6MzcuMTZ9LDE5OnsuOTk1OjYuODQsLjk5OjcuNjMsLjk3NTo4LjkxLC45NToxMC4xMiwuOToxMS42NSwuNToxOC4zNCwuMToyNy4yLC4wNTozMC4xNCwuMDI1OjMyLjg1LC4wMTozNi4xOSwuMDA1OjM4LjU4fSwyMDp7Ljk5NTo3LjQzLC45OTo4LjI2LC45NzU6OS41OSwuOTU6MTAuODUsLjk6MTIuNDQsLjU6MTkuMzQsLjE6MjguNDEsLjA1OjMxLjQxLC4wMjU6MzQuMTcsLjAxOjM3LjU3LC4wMDU6NDB9LDIxOnsuOTk1OjguMDMsLjk5OjguOSwuOTc1OjEwLjI4LC45NToxMS41OSwuOToxMy4yNCwuNToyMC4zNCwuMToyOS42MiwuMDU6MzIuNjcsLjAyNTozNS40OCwuMDE6MzguOTMsLjAwNTo0MS40fSwyMjp7Ljk5NTo4LjY0LC45OTo5LjU0LC45NzU6MTAuOTgsLjk1OjEyLjM0LC45OjE0LjA0LC41OjIxLjM0LC4xOjMwLjgxLC4wNTozMy45MiwuMDI1OjM2Ljc4LC4wMTo0MC4yOSwuMDA1OjQyLjh9LDIzOnsuOTk1OjkuMjYsLjk5OjEwLjIsLjk3NToxMS42OSwuOTU6MTMuMDksLjk6MTQuODUsLjU6MjIuMzQsLjE6MzIuMDEsLjA1OjM1LjE3LC4wMjU6MzguMDgsLjAxOjQxLjY0LC4wMDU6NDQuMTh9LDI0OnsuOTk1OjkuODksLjk5OjEwLjg2LC45NzU6MTIuNCwuOTU6MTMuODUsLjk6MTUuNjYsLjU6MjMuMzQsLjE6MzMuMiwuMDU6MzYuNDIsLjAyNTozOS4zNiwuMDE6NDIuOTgsLjAwNTo0NS41Nn0sMjU6ey45OTU6MTAuNTIsLjk5OjExLjUyLC45NzU6MTMuMTIsLjk1OjE0LjYxLC45OjE2LjQ3LC41OjI0LjM0LC4xOjM0LjI4LC4wNTozNy42NSwuMDI1OjQwLjY1LC4wMTo0NC4zMSwuMDA1OjQ2LjkzfSwyNjp7Ljk5NToxMS4xNiwuOTk6MTIuMiwuOTc1OjEzLjg0LC45NToxNS4zOCwuOToxNy4yOSwuNToyNS4zNCwuMTozNS41NiwuMDU6MzguODksLjAyNTo0MS45MiwuMDE6NDUuNjQsLjAwNTo0OC4yOX0sMjc6ey45OTU6MTEuODEsLjk5OjEyLjg4LC45NzU6MTQuNTcsLjk1OjE2LjE1LC45OjE4LjExLC41OjI2LjM0LC4xOjM2Ljc0LC4wNTo0MC4xMSwuMDI1OjQzLjE5LC4wMTo0Ni45NiwuMDA1OjQ5LjY1fSwyODp7Ljk5NToxMi40NiwuOTk6MTMuNTcsLjk3NToxNS4zMSwuOTU6MTYuOTMsLjk6MTguOTQsLjU6MjcuMzQsLjE6MzcuOTIsLjA1OjQxLjM0LC4wMjU6NDQuNDYsLjAxOjQ4LjI4LC4wMDU6NTAuOTl9LDI5OnsuOTk1OjEzLjEyLC45OToxNC4yNiwuOTc1OjE2LjA1LC45NToxNy43MSwuOToxOS43NywuNToyOC4zNCwuMTozOS4wOSwuMDU6NDIuNTYsLjAyNTo0NS43MiwuMDE6NDkuNTksLjAwNTo1Mi4zNH0sMzA6ey45OTU6MTMuNzksLjk5OjE0Ljk1LC45NzU6MTYuNzksLjk1OjE4LjQ5LC45OjIwLjYsLjU6MjkuMzQsLjE6NDAuMjYsLjA1OjQzLjc3LC4wMjU6NDYuOTgsLjAxOjUwLjg5LC4wMDU6NTMuNjd9LDQwOnsuOTk1OjIwLjcxLC45OToyMi4xNiwuOTc1OjI0LjQzLC45NToyNi41MSwuOToyOS4wNSwuNTozOS4zNCwuMTo1MS44MSwuMDU6NTUuNzYsLjAyNTo1OS4zNCwuMDE6NjMuNjksLjAwNTo2Ni43N30sNTA6ey45OTU6MjcuOTksLjk5OjI5LjcxLC45NzU6MzIuMzYsLjk1OjM0Ljc2LC45OjM3LjY5LC41OjQ5LjMzLC4xOjYzLjE3LC4wNTo2Ny41LC4wMjU6NzEuNDIsLjAxOjc2LjE1LC4wMDU6NzkuNDl9LDYwOnsuOTk1OjM1LjUzLC45OTozNy40OCwuOTc1OjQwLjQ4LC45NTo0My4xOSwuOTo0Ni40NiwuNTo1OS4zMywuMTo3NC40LC4wNTo3OS4wOCwuMDI1OjgzLjMsLjAxOjg4LjM4LC4wMDU6OTEuOTV9LDcwOnsuOTk1OjQzLjI4LC45OTo0NS40NCwuOTc1OjQ4Ljc2LC45NTo1MS43NCwuOTo1NS4zMywuNTo2OS4zMywuMTo4NS41MywuMDU6OTAuNTMsLjAyNTo5NS4wMiwuMDE6MTAwLjQyLC4wMDU6MTA0LjIyfSw4MDp7Ljk5NTo1MS4xNywuOTk6NTMuNTQsLjk3NTo1Ny4xNSwuOTU6NjAuMzksLjk6NjQuMjgsLjU6NzkuMzMsLjE6OTYuNTgsLjA1OjEwMS44OCwuMDI1OjEwNi42MywuMDE6MTEyLjMzLC4wMDU6MTE2LjMyfSw5MDp7Ljk5NTo1OS4yLC45OTo2MS43NSwuOTc1OjY1LjY1LC45NTo2OS4xMywuOTo3My4yOSwuNTo4OS4zMywuMToxMDcuNTcsLjA1OjExMy4xNCwuMDI1OjExOC4xNCwuMDE6MTI0LjEyLC4wMDU6MTI4LjN9LDEwMDp7Ljk5NTo2Ny4zMywuOTk6NzAuMDYsLjk3NTo3NC4yMiwuOTU6NzcuOTMsLjk6ODIuMzYsLjU6OTkuMzMsLjE6MTE4LjUsLjA1OjEyNC4zNCwuMDI1OjEyOS41NiwuMDE6MTM1LjgxLC4wMDU6MTQwLjE3fX07dmFyIGo9TWF0aC5zcXJ0KDIqTWF0aC5QSSksQj17Z2F1c3NpYW46ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGguZXhwKC0uNSp0KnQpL2p9fSxLPXtucmQ6ZnVuY3Rpb24odCl7dmFyIHI9RCh0KSxuPW0odCk7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIG4mJihyPU1hdGgubWluKHIsbi8xLjM0KSksMS4wNipyKk1hdGgucG93KHQubGVuZ3RoLC0uMil9fTtmdW5jdGlvbiBPKGUsdCxyKXt2YXIgYSxvO2lmKHZvaWQgMD09PXQpYT1CLmdhdXNzaWFuO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe2lmKCFCW3RdKXRocm93IG5ldyBFcnJvcignVW5rbm93biBrZXJuZWwgXCInK3QrJ1wiJyk7YT1CW3RdfWVsc2UgYT10O2lmKHZvaWQgMD09PXIpbz1LLm5yZChlKTtlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiByKXtpZighS1tyXSl0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYmFuZHdpZHRoIG1ldGhvZCBcIicrcisnXCInKTtvPUtbcl0oZSl9ZWxzZSBvPXI7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciByPTAsbj0wO2ZvcihyPTA7cjxlLmxlbmd0aDtyKyspbis9YSgodC1lW3JdKS9vKTtyZXR1cm4gbi9vL2UubGVuZ3RofX12YXIgVT1NYXRoLnNxcnQoMipNYXRoLlBJKTtmdW5jdGlvbiBHKHQpe2Zvcih2YXIgcj10LG49dCxlPTE7ZTwxNTtlKyspcis9bio9dCp0LygyKmUrMSk7cmV0dXJuIE1hdGgucm91bmQoMWU0KiguNStyL1UqTWF0aC5leHAoLXQqdC8yKSkpLzFlNH1mb3IodmFyIEg9W10sTD0wO0w8PTMuMDk7TCs9LjAxKUgucHVzaChHKEwpKTtmdW5jdGlvbiBXKHQpe3ZhciByPTEvKDErLjUqTWF0aC5hYnModCkpLG49cipNYXRoLmV4cCgtTWF0aC5wb3codCwyKS0xLjI2NTUxMjIzKzEuMDAwMDIzNjgqcisuMzc0MDkxOTYqTWF0aC5wb3cociwyKSsuMDk2Nzg0MTgqTWF0aC5wb3cociwzKS0uMTg2Mjg4MDYqTWF0aC5wb3cociw0KSsuMjc4ODY4MDcqTWF0aC5wb3cociw1KS0xLjEzNTIwMzk4Kk1hdGgucG93KHIsNikrMS40ODg1MTU4NypNYXRoLnBvdyhyLDcpLS44MjIxNTIyMypNYXRoLnBvdyhyLDgpKy4xNzA4NzI3NypNYXRoLnBvdyhyLDkpKTtyZXR1cm4gMDw9dD8xLW46bi0xfWZ1bmN0aW9uIEoodCl7dmFyIHI9OCooTWF0aC5QSS0zKS8oMypNYXRoLlBJKig0LU1hdGguUEkpKSxuPU1hdGguc3FydChNYXRoLnNxcnQoTWF0aC5wb3coMi8oTWF0aC5QSSpyKStNYXRoLmxvZygxLXQqdCkvMiwyKS1NYXRoLmxvZygxLXQqdCkvciktKDIvKE1hdGguUEkqcikrTWF0aC5sb2coMS10KnQpLzIpKTtyZXR1cm4gMDw9dD9uOi1ufWZ1bmN0aW9uIFEodCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpcmV0dXJuIHQ8MD8tMTowPT09dD8wOjE7dGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCBhIG51bWJlclwiKX10LmxpbmVhclJlZ3Jlc3Npb249ZnVuY3Rpb24odCl7dmFyIHIsbixlPXQubGVuZ3RoO2lmKDE9PT1lKW49dFtyPTBdWzFdO2Vsc2V7Zm9yKHZhciBhLG8saSx1PTAsaD0wLGY9MCxzPTAsbD0wO2w8ZTtsKyspdSs9bz0oYT10W2xdKVswXSxoKz1pPWFbMV0sZis9bypvLHMrPW8qaTtuPWgvZS0ocj0oZSpzLXUqaCkvKGUqZi11KnUpKSp1L2V9cmV0dXJue206cixiOm59fSx0LmxpbmVhclJlZ3Jlc3Npb25MaW5lPWZ1bmN0aW9uKHIpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gci5iK3IubSp0fX0sdC5zdGFuZGFyZERldmlhdGlvbj1hLHQuclNxdWFyZWQ9ZnVuY3Rpb24odCxyKXtpZih0Lmxlbmd0aDwyKXJldHVybiAxO2Zvcih2YXIgbixlPTAsYT0wO2E8dC5sZW5ndGg7YSsrKWUrPXRbYV1bMV07bj1lL3QubGVuZ3RoO2Zvcih2YXIgbz0wLGk9MDtpPHQubGVuZ3RoO2krKylvKz1NYXRoLnBvdyhuLXRbaV1bMV0sMik7Zm9yKHZhciB1PTAsaD0wO2g8dC5sZW5ndGg7aCsrKXUrPU1hdGgucG93KHRbaF1bMV0tcih0W2hdWzBdKSwyKTtyZXR1cm4gMS11L299LHQubW9kZT1mdW5jdGlvbih0KXtyZXR1cm4gbyhmKHQpKX0sdC5tb2RlRmFzdD1mdW5jdGlvbih0KXtmb3IodmFyIHIsbj1uZXcgTWFwLGU9MCxhPTA7YTx0Lmxlbmd0aDthKyspe3ZhciBvPW4uZ2V0KHRbYV0pO3ZvaWQgMD09PW8/bz0xOm8rKyxlPG8mJihyPXRbYV0sZT1vKSxuLnNldCh0W2FdLG8pfWlmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIm1vZGUgcmVxdWlyZXMgYXQgbGFzdCBvbmUgZGF0YSBwb2ludFwiKTtyZXR1cm4gcn0sdC5tb2RlU29ydGVkPW8sdC5taW49dSx0Lm1heD1oLHQuZXh0ZW50PWZ1bmN0aW9uKHQpe2lmKDA9PT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJleHRlbnQgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7Zm9yKHZhciByPXRbMF0sbj10WzBdLGU9MTtlPHQubGVuZ3RoO2UrKyl0W2VdPm4mJihuPXRbZV0pLHRbZV08ciYmKHI9dFtlXSk7cmV0dXJuW3Isbl19LHQubWluU29ydGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSx0Lm1heFNvcnRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdFt0Lmxlbmd0aC0xXX0sdC5leHRlbnRTb3J0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuW3RbMF0sdFt0Lmxlbmd0aC0xXV19LHQuc3VtPXIsdC5zdW1TaW1wbGU9ZnVuY3Rpb24odCl7Zm9yKHZhciByPTAsbj0wO248dC5sZW5ndGg7bisrKXIrPXRbbl07cmV0dXJuIHJ9LHQucHJvZHVjdD1mdW5jdGlvbih0KXtmb3IodmFyIHI9MSxuPTA7bjx0Lmxlbmd0aDtuKyspcio9dFtuXTtyZXR1cm4gcn0sdC5xdWFudGlsZT1zLHQucXVhbnRpbGVTb3J0ZWQ9aSx0LnF1YW50aWxlUmFuaz1mdW5jdGlvbih0LHIpe3JldHVybiBNKGYodCkscil9LHQucXVhbnRpbGVSYW5rU29ydGVkPU0sdC5pbnRlcnF1YXJ0aWxlUmFuZ2U9bSx0Lmlxcj1tLHQubWVkaWFuQWJzb2x1dGVEZXZpYXRpb249Yix0Lm1hZD1iLHQuY2h1bms9ZnVuY3Rpb24odCxyKXt2YXIgbj1bXTtpZihyPDEpdGhyb3cgbmV3IEVycm9yKFwiY2h1bmsgc2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO2lmKE1hdGguZmxvb3IocikhPT1yKXRocm93IG5ldyBFcnJvcihcImNodW5rIHNpemUgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSs9ciluLnB1c2godC5zbGljZShlLGUrcikpO3JldHVybiBufSx0LnNhbXBsZVdpdGhSZXBsYWNlbWVudD1mdW5jdGlvbih0LHIsbil7aWYoMD09PXQubGVuZ3RoKXJldHVybltdO249bnx8TWF0aC5yYW5kb207Zm9yKHZhciBlPXQubGVuZ3RoLGE9W10sbz0wO288cjtvKyspe3ZhciBpPU1hdGguZmxvb3IobigpKmUpO2EucHVzaCh0W2ldKX1yZXR1cm4gYX0sdC5zaHVmZmxlPUUsdC5zaHVmZmxlSW5QbGFjZT1xLHQuc2FtcGxlPWZ1bmN0aW9uKHQscixuKXtyZXR1cm4gRSh0LG4pLnNsaWNlKDAscil9LHQuY2ttZWFucz1mdW5jdGlvbih0LHIpe2lmKHI+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGdlbmVyYXRlIG1vcmUgY2xhc3NlcyB0aGFuIHRoZXJlIGFyZSBkYXRhIHZhbHVlc1wiKTt2YXIgbj1mKHQpO2lmKDE9PT15KG4pKXJldHVybltuXTt2YXIgZT1TKHIsbi5sZW5ndGgpLGE9UyhyLG4ubGVuZ3RoKTshZnVuY3Rpb24odCxyLG4pe2Zvcih2YXIgZSxhPXJbMF0ubGVuZ3RoLG89dFtNYXRoLmZsb29yKGEvMildLGk9W10sdT1bXSxoPTA7aDxhOysraCllPXRbaF0tbywwPT09aD8oaS5wdXNoKGUpLHUucHVzaChlKmUpKTooaS5wdXNoKGlbaC0xXStlKSx1LnB1c2godVtoLTFdK2UqZSkpLHJbMF1baF09eCgwLGgsaSx1KSxuWzBdW2hdPTA7Zm9yKHZhciBmPTE7ZjxyLmxlbmd0aDsrK2YpUChmPHIubGVuZ3RoLTE/ZjphLTEsYS0xLGYscixuLGksdSl9KG4sZSxhKTtmb3IodmFyIG89W10saT1hWzBdLmxlbmd0aC0xLHU9YS5sZW5ndGgtMTswPD11O3UtLSl7dmFyIGg9YVt1XVtpXTtvW3VdPW4uc2xpY2UoaCxpKzEpLDA8dSYmKGk9aC0xKX1yZXR1cm4gb30sdC51bmlxdWVDb3VudFNvcnRlZD15LHQuc3VtTnRoUG93ZXJEZXZpYXRpb25zPW4sdC5lcXVhbEludGVydmFsQnJlYWtzPWZ1bmN0aW9uKHQscil7aWYodC5sZW5ndGg8MilyZXR1cm4gdDtmb3IodmFyIG49dSh0KSxlPWgodCksYT1bbl0sbz0oZS1uKS9yLGk9MTtpPHI7aSsrKWEucHVzaChhWzBdK28qaSk7cmV0dXJuIGEucHVzaChlKSxhfSx0LnNhbXBsZUNvdmFyaWFuY2U9ayx0LnNhbXBsZUNvcnJlbGF0aW9uPWZ1bmN0aW9uKHQscil7cmV0dXJuIGsodCxyKS9EKHQpL0Qocil9LHQuc2FtcGxlVmFyaWFuY2U9SSx0LnNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uPUQsdC5zYW1wbGVTa2V3bmVzcz1mdW5jdGlvbih0KXtpZih0Lmxlbmd0aDwzKXRocm93IG5ldyBFcnJvcihcInNhbXBsZVNrZXduZXNzIHJlcXVpcmVzIGF0IGxlYXN0IHRocmVlIGRhdGEgcG9pbnRzXCIpO2Zvcih2YXIgcixuPWcodCksZT0wLGE9MCxvPTA7bzx0Lmxlbmd0aDtvKyspZSs9KHI9dFtvXS1uKSpyLGErPXIqcipyO3ZhciBpPXQubGVuZ3RoLTEsdT1NYXRoLnNxcnQoZS9pKSxoPXQubGVuZ3RoO3JldHVybiBoKmEvKChoLTEpKihoLTIpKk1hdGgucG93KHUsMykpfSx0LnNhbXBsZUt1cnRvc2lzPWZ1bmN0aW9uKHQpe3ZhciByPXQubGVuZ3RoO2lmKHI8NCl0aHJvdyBuZXcgRXJyb3IoXCJzYW1wbGVLdXJ0b3NpcyByZXF1aXJlcyBhdCBsZWFzdCBmb3VyIGRhdGEgcG9pbnRzXCIpO2Zvcih2YXIgbixlPWcodCksYT0wLG89MCxpPTA7aTxyO2krKylhKz0obj10W2ldLWUpKm4sbys9bipuKm4qbjtyZXR1cm4oci0xKS8oKHItMikqKHItMykpKihyKihyKzEpKm8vKGEqYSktMyooci0xKSl9LHQucGVybXV0YXRpb25zSGVhcD1mdW5jdGlvbih0KXtmb3IodmFyIHI9bmV3IEFycmF5KHQubGVuZ3RoKSxuPVt0LnNsaWNlKCldLGU9MDtlPHQubGVuZ3RoO2UrKylyW2VdPTA7Zm9yKGU9MDtlPHQubGVuZ3RoOylpZihyW2VdPGUpe3ZhciBhPTA7ZSUyIT0wJiYoYT1yW2VdKTt2YXIgbz10W2FdO3RbYV09dFtlXSx0W2VdPW8sbi5wdXNoKHQuc2xpY2UoKSkscltlXSsrLGU9MH1lbHNlIHJbZV09MCxlKys7cmV0dXJuIG59LHQuY29tYmluYXRpb25zPWZ1bmN0aW9uIHQocixuKXt2YXIgZSxhLG8saSx1PVtdO2ZvcihlPTA7ZTxyLmxlbmd0aDtlKyspaWYoMT09PW4pdS5wdXNoKFtyW2VdXSk7ZWxzZSBmb3Iobz10KHIuc2xpY2UoZSsxLHIubGVuZ3RoKSxuLTEpLGE9MDthPG8ubGVuZ3RoO2ErKykoaT1vW2FdKS51bnNoaWZ0KHJbZV0pLHUucHVzaChpKTtyZXR1cm4gdX0sdC5jb21iaW5hdGlvbnNSZXBsYWNlbWVudD1mdW5jdGlvbiB0KHIsbil7Zm9yKHZhciBlPVtdLGE9MDthPHIubGVuZ3RoO2ErKylpZigxPT09billLnB1c2goW3JbYV1dKTtlbHNlIGZvcih2YXIgbz10KHIuc2xpY2UoYSxyLmxlbmd0aCksbi0xKSxpPTA7aTxvLmxlbmd0aDtpKyspZS5wdXNoKFtyW2FdXS5jb25jYXQob1tpXSkpO3JldHVybiBlfSx0LmFkZFRvTWVhbj1mdW5jdGlvbih0LHIsbil7cmV0dXJuIHQrKG4tdCkvKHIrMSl9LHQuY29tYmluZU1lYW5zPUMsdC5jb21iaW5lVmFyaWFuY2VzPWZ1bmN0aW9uKHQscixuLGUsYSxvKXt2YXIgaT1DKHIsbixhLG8pO3JldHVybihuKih0K01hdGgucG93KHItaSwyKSkrbyooZStNYXRoLnBvdyhhLWksMikpKS8obitvKX0sdC5nZW9tZXRyaWNNZWFuPWZ1bmN0aW9uKHQpe2lmKDA9PT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJnZW9tZXRyaWNNZWFuIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO2Zvcih2YXIgcj0xLG49MDtuPHQubGVuZ3RoO24rKyl7aWYodFtuXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJnZW9tZXRyaWNNZWFuIHJlcXVpcmVzIG9ubHkgcG9zaXRpdmUgbnVtYmVycyBhcyBpbnB1dFwiKTtyKj10W25dfXJldHVybiBNYXRoLnBvdyhyLDEvdC5sZW5ndGgpfSx0Lmhhcm1vbmljTWVhbj1mdW5jdGlvbih0KXtpZigwPT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaGFybW9uaWNNZWFuIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO2Zvcih2YXIgcj0wLG49MDtuPHQubGVuZ3RoO24rKyl7aWYodFtuXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJoYXJtb25pY01lYW4gcmVxdWlyZXMgb25seSBwb3NpdGl2ZSBudW1iZXJzIGFzIGlucHV0XCIpO3IrPTEvdFtuXX1yZXR1cm4gdC5sZW5ndGgvcn0sdC5hdmVyYWdlPWcsdC5tZWFuPWcsdC5tZWRpYW49ZCx0Lm1lZGlhblNvcnRlZD1mdW5jdGlvbih0KXtyZXR1cm4gaSh0LC41KX0sdC5zdWJ0cmFjdEZyb21NZWFuPWZ1bmN0aW9uKHQscixuKXtyZXR1cm4odCpyLW4pLyhyLTEpfSx0LnJvb3RNZWFuU3F1YXJlPVQsdC5ybXM9VCx0LnZhcmlhbmNlPWUsdC50VGVzdD1mdW5jdGlvbih0LHIpe3JldHVybihnKHQpLXIpLyhhKHQpL01hdGguc3FydCh0Lmxlbmd0aCkpfSx0LnRUZXN0VHdvU2FtcGxlPWZ1bmN0aW9uKHQscixuKXt2YXIgZT10Lmxlbmd0aCxhPXIubGVuZ3RoO2lmKCFlfHwhYSlyZXR1cm4gbnVsbDtufHwobj0wKTt2YXIgbz1nKHQpLGk9ZyhyKSx1PUkodCksaD1JKHIpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBvJiZcIm51bWJlclwiPT10eXBlb2YgaSYmXCJudW1iZXJcIj09dHlwZW9mIHUmJlwibnVtYmVyXCI9PXR5cGVvZiBoKXt2YXIgZj0oKGUtMSkqdSsoYS0xKSpoKS8oZSthLTIpO3JldHVybihvLWktbikvTWF0aC5zcXJ0KGYqKDEvZSsxL2EpKX19LHQuQmF5ZXNpYW5DbGFzc2lmaWVyPV8sdC5iYXllc2lhbj1fLHQuUGVyY2VwdHJvbk1vZGVsPUYsdC5wZXJjZXB0cm9uPUYsdC5lcHNpbG9uPU4sdC5mYWN0b3JpYWw9Uix0LmdhbW1hPWZ1bmN0aW9uIHQocil7aWYoXCJudW1iZXJcIj09dHlwZW9mKG49cikmJmlzRmluaXRlKG4pJiZNYXRoLmZsb29yKG4pPT09bilyZXR1cm4gcjw9MD9OYU46UihyLTEpO3ZhciBuO2lmKC0tcjwwKXJldHVybiBNYXRoLlBJLyhNYXRoLnNpbihNYXRoLlBJKi1yKSp0KC1yKSk7dmFyIGU9cisuMjU7cmV0dXJuIE1hdGgucG93KHIvTWF0aC5FLHIpKk1hdGguc3FydCgyKk1hdGguUEkqKHIrMS82KSkqKDErMS8xNDQvTWF0aC5wb3coZSwyKS0xLzEyOTYwL01hdGgucG93KGUsMyktMjU3LzIwNzM2MC9NYXRoLnBvdyhlLDQpLTUyLzI2MTI3MzYvTWF0aC5wb3coZSw1KSs1NzQxMTczLzk0MDU4NDk2MDAvTWF0aC5wb3coZSw2KSszNzUyOS8xODgxMTY5OTIwMC9NYXRoLnBvdyhlLDcpKX0sdC5nYW1tYWxuPWZ1bmN0aW9uKHQpe2lmKHQ8PTApcmV0dXJuIDEvMDt0LS07Zm9yKHZhciByPUFbMF0sbj0xO248MTU7bisrKXIrPUFbbl0vKHQrbik7dmFyIGU9NS4yNDIxODc1K3Q7cmV0dXJuIHorTWF0aC5sb2cociktZSsodCsuNSkqTWF0aC5sb2coZSl9LHQuYmVybm91bGxpRGlzdHJpYnV0aW9uPWZ1bmN0aW9uKHQpe2lmKHQ8MHx8MTx0KXRocm93IG5ldyBFcnJvcihcImJlcm5vdWxsaURpc3RyaWJ1dGlvbiByZXF1aXJlcyBwcm9iYWJpbGl0eSB0byBiZSBiZXR3ZWVuIDAgYW5kIDEgaW5jbHVzaXZlXCIpO3JldHVyblsxLXQsdF19LHQuYmlub21pYWxEaXN0cmlidXRpb249ZnVuY3Rpb24odCxyKXtpZighKHI8MHx8MTxyfHx0PD0wfHx0JTEhPTApKXtmb3IodmFyIG49MCxlPTAsYT1bXSxvPTE7YVtuXT1vKk1hdGgucG93KHIsbikqTWF0aC5wb3coMS1yLHQtbiksZSs9YVtuXSxvPW8qKHQtKytuKzEpL24sZTwxLU47KTtyZXR1cm4gYX19LHQucG9pc3NvbkRpc3RyaWJ1dGlvbj1mdW5jdGlvbih0KXtpZighKHQ8PTApKXtmb3IodmFyIHI9MCxuPTAsZT1bXSxhPTE7ZVtyXT1NYXRoLmV4cCgtdCkqTWF0aC5wb3codCxyKS9hLG4rPWVbcl0sYSo9KytyLG48MS1OOyk7cmV0dXJuIGV9fSx0LmNoaVNxdWFyZWREaXN0cmlidXRpb25UYWJsZT1WLHQuY2hpU3F1YXJlZEdvb2RuZXNzT2ZGaXQ9ZnVuY3Rpb24odCxyLG4pe2Zvcih2YXIgZSxhLG89MCxpPXIoZyh0KSksdT1bXSxoPVtdLGY9MDtmPHQubGVuZ3RoO2YrKyl2b2lkIDA9PT11W3RbZl1dJiYodVt0W2ZdXT0wKSx1W3RbZl1dKys7Zm9yKGY9MDtmPHUubGVuZ3RoO2YrKyl2b2lkIDA9PT11W2ZdJiYodVtmXT0wKTtmb3IoYSBpbiBpKWEgaW4gdSYmKGhbK2FdPWlbYV0qdC5sZW5ndGgpO2ZvcihhPWgubGVuZ3RoLTE7MDw9YTthLS0paFthXTwzJiYoaFthLTFdKz1oW2FdLGgucG9wKCksdVthLTFdKz11W2FdLHUucG9wKCkpO2ZvcihhPTA7YTx1Lmxlbmd0aDthKyspbys9TWF0aC5wb3codVthXS1oW2FdLDIpL2hbYV07cmV0dXJuIGU9dS5sZW5ndGgtMS0xLFZbZV1bbl08b30sdC5rZXJuZWxEZW5zaXR5RXN0aW1hdGlvbj1PLHQua2RlPU8sdC56U2NvcmU9ZnVuY3Rpb24odCxyLG4pe3JldHVybih0LXIpL259LHQuY3VtdWxhdGl2ZVN0ZE5vcm1hbFByb2JhYmlsaXR5PWZ1bmN0aW9uKHQpe3ZhciByPU1hdGguYWJzKHQpLG49TWF0aC5taW4oTWF0aC5yb3VuZCgxMDAqciksSC5sZW5ndGgtMSk7cmV0dXJuIDA8PXQ/SFtuXTorKDEtSFtuXSkudG9GaXhlZCg0KX0sdC5zdGFuZGFyZE5vcm1hbFRhYmxlPUgsdC5lcnJvckZ1bmN0aW9uPVcsdC5lcmY9Vyx0LmludmVyc2VFcnJvckZ1bmN0aW9uPUosdC5wcm9iaXQ9ZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10P3Q9TjoxPD10JiYodD0xLU4pLE1hdGguc3FydCgyKSpKKDIqdC0xKX0sdC5wZXJtdXRhdGlvblRlc3Q9ZnVuY3Rpb24odCxyLG4sZSl7aWYodm9pZCAwPT09ZSYmKGU9MWU0KSx2b2lkIDA9PT1uJiYobj1cInR3b19zaWRlXCIpLFwidHdvX3NpZGVcIiE9PW4mJlwiZ3JlYXRlclwiIT09biYmXCJsZXNzXCIhPT1uKXRocm93IG5ldyBFcnJvcihcImBhbHRlcm5hdGl2ZWAgbXVzdCBiZSBlaXRoZXIgJ3R3b19zaWRlJywgJ2dyZWF0ZXInLCBvciAnbGVzcydcIik7Zm9yKHZhciBhPWcodCktZyhyKSxvPW5ldyBBcnJheShlKSxpPXQuY29uY2F0KHIpLHU9TWF0aC5mbG9vcihpLmxlbmd0aC8yKSxoPTA7aDxlO2grKyl7cShpKTt2YXIgZj1pLnNsaWNlKDAsdSkscz1pLnNsaWNlKHUsaS5sZW5ndGgpLGw9ZyhmKS1nKHMpO29baF09bH12YXIgYz0wO2lmKFwidHdvX3NpZGVcIj09PW4pZm9yKGg9MDtoPD1lO2grKylNYXRoLmFicyhvW2hdKT49TWF0aC5hYnMoYSkmJihjKz0xKTtlbHNlIGlmKFwiZ3JlYXRlclwiPT09bilmb3IoaD0wO2g8PWU7aCsrKW9baF0+PWEmJihjKz0xKTtlbHNlIGZvcihoPTA7aDw9ZTtoKyspb1toXTw9YSYmKGMrPTEpO3JldHVybiBjL2V9LHQuYmlzZWN0PWZ1bmN0aW9uKHQscixuLGUsYSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiZnVuYyBtdXN0IGJlIGEgZnVuY3Rpb25cIik7Zm9yKHZhciBvPTA7bzxlO28rKyl7dmFyIGk9KHIrbikvMjtpZigwPT09dChpKXx8TWF0aC5hYnMoKG4tcikvMik8YSlyZXR1cm4gaTtRKHQoaSkpPT09USh0KHIpKT9yPWk6bj1pfXRocm93IG5ldyBFcnJvcihcIm1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgZXhjZWVkZWRcIil9LHQucXVpY2tzZWxlY3Q9Yyx0LnNpZ249USx0Lm51bWVyaWNTb3J0PWYsT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbXBsZS1zdGF0aXN0aWNzLm1pbi5qcy5tYXBcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fdG9wb2pzb24tY2xpZW50QDMuMS4wQHRvcG9qc29uLWNsaWVudC9kaXN0L3RvcG9qc29uLWNsaWVudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fdG9wb2pzb24tY2xpZW50QDMuMS4wQHRvcG9qc29uLWNsaWVudC9kaXN0L3RvcG9qc29uLWNsaWVudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdG9wb2pzb24vdG9wb2pzb24tY2xpZW50IHYzLjEuMCBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gdHJ1ZSA/IGZhY3RvcnkoZXhwb3J0cykgOlxudW5kZWZpbmVkO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgaWYgKHRyYW5zZm9ybSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhciB4MCxcbiAgICAgIHkwLFxuICAgICAga3ggPSB0cmFuc2Zvcm0uc2NhbGVbMF0sXG4gICAgICBreSA9IHRyYW5zZm9ybS5zY2FsZVsxXSxcbiAgICAgIGR4ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVswXSxcbiAgICAgIGR5ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVsxXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0LCBpKSB7XG4gICAgaWYgKCFpKSB4MCA9IHkwID0gMDtcbiAgICB2YXIgaiA9IDIsIG4gPSBpbnB1dC5sZW5ndGgsIG91dHB1dCA9IG5ldyBBcnJheShuKTtcbiAgICBvdXRwdXRbMF0gPSAoeDAgKz0gaW5wdXRbMF0pICoga3ggKyBkeDtcbiAgICBvdXRwdXRbMV0gPSAoeTAgKz0gaW5wdXRbMV0pICoga3kgKyBkeTtcbiAgICB3aGlsZSAoaiA8IG4pIG91dHB1dFtqXSA9IGlucHV0W2pdLCArK2o7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmJveCh0b3BvbG9neSkge1xuICB2YXIgdCA9IHRyYW5zZm9ybSh0b3BvbG9neS50cmFuc2Zvcm0pLCBrZXksXG4gICAgICB4MCA9IEluZmluaXR5LCB5MCA9IHgwLCB4MSA9IC14MCwgeTEgPSAteDA7XG5cbiAgZnVuY3Rpb24gYmJveFBvaW50KHApIHtcbiAgICBwID0gdChwKTtcbiAgICBpZiAocFswXSA8IHgwKSB4MCA9IHBbMF07XG4gICAgaWYgKHBbMF0gPiB4MSkgeDEgPSBwWzBdO1xuICAgIGlmIChwWzFdIDwgeTApIHkwID0gcFsxXTtcbiAgICBpZiAocFsxXSA+IHkxKSB5MSA9IHBbMV07XG4gIH1cblxuICBmdW5jdGlvbiBiYm94R2VvbWV0cnkobykge1xuICAgIHN3aXRjaCAoby50eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IG8uZ2VvbWV0cmllcy5mb3JFYWNoKGJib3hHZW9tZXRyeSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvaW50XCI6IGJib3hQb2ludChvLmNvb3JkaW5hdGVzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOiBvLmNvb3JkaW5hdGVzLmZvckVhY2goYmJveFBvaW50KTsgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdG9wb2xvZ3kuYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgIHZhciBpID0gLTEsIG4gPSBhcmMubGVuZ3RoLCBwO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBwID0gdChhcmNbaV0sIGkpO1xuICAgICAgaWYgKHBbMF0gPCB4MCkgeDAgPSBwWzBdO1xuICAgICAgaWYgKHBbMF0gPiB4MSkgeDEgPSBwWzBdO1xuICAgICAgaWYgKHBbMV0gPCB5MCkgeTAgPSBwWzFdO1xuICAgICAgaWYgKHBbMV0gPiB5MSkgeTEgPSBwWzFdO1xuICAgIH1cbiAgfSk7XG5cbiAgZm9yIChrZXkgaW4gdG9wb2xvZ3kub2JqZWN0cykge1xuICAgIGJib3hHZW9tZXRyeSh0b3BvbG9neS5vYmplY3RzW2tleV0pO1xuICB9XG5cbiAgcmV0dXJuIFt4MCwgeTAsIHgxLCB5MV07XG59XG5cbmZ1bmN0aW9uIHJldmVyc2UoYXJyYXksIG4pIHtcbiAgdmFyIHQsIGogPSBhcnJheS5sZW5ndGgsIGkgPSBqIC0gbjtcbiAgd2hpbGUgKGkgPCAtLWopIHQgPSBhcnJheVtpXSwgYXJyYXlbaSsrXSA9IGFycmF5W2pdLCBhcnJheVtqXSA9IHQ7XG59XG5cbmZ1bmN0aW9uIGZlYXR1cmUodG9wb2xvZ3ksIG8pIHtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSBvID0gdG9wb2xvZ3kub2JqZWN0c1tvXTtcbiAgcmV0dXJuIG8udHlwZSA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIlxuICAgICAgPyB7dHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiLCBmZWF0dXJlczogby5nZW9tZXRyaWVzLm1hcChmdW5jdGlvbihvKSB7IHJldHVybiBmZWF0dXJlJDEodG9wb2xvZ3ksIG8pOyB9KX1cbiAgICAgIDogZmVhdHVyZSQxKHRvcG9sb2d5LCBvKTtcbn1cblxuZnVuY3Rpb24gZmVhdHVyZSQxKHRvcG9sb2d5LCBvKSB7XG4gIHZhciBpZCA9IG8uaWQsXG4gICAgICBiYm94ID0gby5iYm94LFxuICAgICAgcHJvcGVydGllcyA9IG8ucHJvcGVydGllcyA9PSBudWxsID8ge30gOiBvLnByb3BlcnRpZXMsXG4gICAgICBnZW9tZXRyeSA9IG9iamVjdCh0b3BvbG9neSwgbyk7XG4gIHJldHVybiBpZCA9PSBudWxsICYmIGJib3ggPT0gbnVsbCA/IHt0eXBlOiBcIkZlYXR1cmVcIiwgcHJvcGVydGllczogcHJvcGVydGllcywgZ2VvbWV0cnk6IGdlb21ldHJ5fVxuICAgICAgOiBiYm94ID09IG51bGwgPyB7dHlwZTogXCJGZWF0dXJlXCIsIGlkOiBpZCwgcHJvcGVydGllczogcHJvcGVydGllcywgZ2VvbWV0cnk6IGdlb21ldHJ5fVxuICAgICAgOiB7dHlwZTogXCJGZWF0dXJlXCIsIGlkOiBpZCwgYmJveDogYmJveCwgcHJvcGVydGllczogcHJvcGVydGllcywgZ2VvbWV0cnk6IGdlb21ldHJ5fTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0KHRvcG9sb2d5LCBvKSB7XG4gIHZhciB0cmFuc2Zvcm1Qb2ludCA9IHRyYW5zZm9ybSh0b3BvbG9neS50cmFuc2Zvcm0pLFxuICAgICAgYXJjcyA9IHRvcG9sb2d5LmFyY3M7XG5cbiAgZnVuY3Rpb24gYXJjKGksIHBvaW50cykge1xuICAgIGlmIChwb2ludHMubGVuZ3RoKSBwb2ludHMucG9wKCk7XG4gICAgZm9yICh2YXIgYSA9IGFyY3NbaSA8IDAgPyB+aSA6IGldLCBrID0gMCwgbiA9IGEubGVuZ3RoOyBrIDwgbjsgKytrKSB7XG4gICAgICBwb2ludHMucHVzaCh0cmFuc2Zvcm1Qb2ludChhW2tdLCBrKSk7XG4gICAgfVxuICAgIGlmIChpIDwgMCkgcmV2ZXJzZShwb2ludHMsIG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9pbnQocCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1Qb2ludChwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmUoYXJjcykge1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFyY3MubGVuZ3RoOyBpIDwgbjsgKytpKSBhcmMoYXJjc1tpXSwgcG9pbnRzKTtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDIpIHBvaW50cy5wdXNoKHBvaW50c1swXSk7IC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiBwZXIgdGhlIHNwZWNpZmljYXRpb24uXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJpbmcoYXJjcykge1xuICAgIHZhciBwb2ludHMgPSBsaW5lKGFyY3MpO1xuICAgIHdoaWxlIChwb2ludHMubGVuZ3RoIDwgNCkgcG9pbnRzLnB1c2gocG9pbnRzWzBdKTsgLy8gVGhpcyBtYXkgaGFwcGVuIGlmIGFuIGFyYyBoYXMgb25seSB0d28gcG9pbnRzLlxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cblxuICBmdW5jdGlvbiBwb2x5Z29uKGFyY3MpIHtcbiAgICByZXR1cm4gYXJjcy5tYXAocmluZyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW9tZXRyeShvKSB7XG4gICAgdmFyIHR5cGUgPSBvLnR5cGUsIGNvb3JkaW5hdGVzO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiByZXR1cm4ge3R5cGU6IHR5cGUsIGdlb21ldHJpZXM6IG8uZ2VvbWV0cmllcy5tYXAoZ2VvbWV0cnkpfTtcbiAgICAgIGNhc2UgXCJQb2ludFwiOiBjb29yZGluYXRlcyA9IHBvaW50KG8uY29vcmRpbmF0ZXMpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6IGNvb3JkaW5hdGVzID0gby5jb29yZGluYXRlcy5tYXAocG9pbnQpOyBicmVhaztcbiAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6IGNvb3JkaW5hdGVzID0gbGluZShvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjogY29vcmRpbmF0ZXMgPSBvLmFyY3MubWFwKGxpbmUpOyBicmVhaztcbiAgICAgIGNhc2UgXCJQb2x5Z29uXCI6IGNvb3JkaW5hdGVzID0gcG9seWdvbihvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogY29vcmRpbmF0ZXMgPSBvLmFyY3MubWFwKHBvbHlnb24pOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge3R5cGU6IHR5cGUsIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc307XG4gIH1cblxuICByZXR1cm4gZ2VvbWV0cnkobyk7XG59XG5cbmZ1bmN0aW9uIHN0aXRjaCh0b3BvbG9neSwgYXJjcykge1xuICB2YXIgc3RpdGNoZWRBcmNzID0ge30sXG4gICAgICBmcmFnbWVudEJ5U3RhcnQgPSB7fSxcbiAgICAgIGZyYWdtZW50QnlFbmQgPSB7fSxcbiAgICAgIGZyYWdtZW50cyA9IFtdLFxuICAgICAgZW1wdHlJbmRleCA9IC0xO1xuXG4gIC8vIFN0aXRjaCBlbXB0eSBhcmNzIGZpcnN0LCBzaW5jZSB0aGV5IG1heSBiZSBzdWJzdW1lZCBieSBvdGhlciBhcmNzLlxuICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSwgaikge1xuICAgIHZhciBhcmMgPSB0b3BvbG9neS5hcmNzW2kgPCAwID8gfmkgOiBpXSwgdDtcbiAgICBpZiAoYXJjLmxlbmd0aCA8IDMgJiYgIWFyY1sxXVswXSAmJiAhYXJjWzFdWzFdKSB7XG4gICAgICB0ID0gYXJjc1srK2VtcHR5SW5kZXhdLCBhcmNzW2VtcHR5SW5kZXhdID0gaSwgYXJjc1tqXSA9IHQ7XG4gICAgfVxuICB9KTtcblxuICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgIHZhciBlID0gZW5kcyhpKSxcbiAgICAgICAgc3RhcnQgPSBlWzBdLFxuICAgICAgICBlbmQgPSBlWzFdLFxuICAgICAgICBmLCBnO1xuXG4gICAgaWYgKGYgPSBmcmFnbWVudEJ5RW5kW3N0YXJ0XSkge1xuICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZi5lbmRdO1xuICAgICAgZi5wdXNoKGkpO1xuICAgICAgZi5lbmQgPSBlbmQ7XG4gICAgICBpZiAoZyA9IGZyYWdtZW50QnlTdGFydFtlbmRdKSB7XG4gICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZy5zdGFydF07XG4gICAgICAgIHZhciBmZyA9IGcgPT09IGYgPyBmIDogZi5jb25jYXQoZyk7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtmZy5zdGFydCA9IGYuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmZy5lbmQgPSBnLmVuZF0gPSBmZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmRdID0gZjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGYgPSBmcmFnbWVudEJ5U3RhcnRbZW5kXSkge1xuICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XTtcbiAgICAgIGYudW5zaGlmdChpKTtcbiAgICAgIGYuc3RhcnQgPSBzdGFydDtcbiAgICAgIGlmIChnID0gZnJhZ21lbnRCeUVuZFtzdGFydF0pIHtcbiAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZy5lbmRdO1xuICAgICAgICB2YXIgZ2YgPSBnID09PSBmID8gZiA6IGcuY29uY2F0KGYpO1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZ2Yuc3RhcnQgPSBnLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZ2YuZW5kID0gZi5lbmRdID0gZ2Y7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kXSA9IGY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGYgPSBbaV07XG4gICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydCA9IHN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmQgPSBlbmRdID0gZjtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGVuZHMoaSkge1xuICAgIHZhciBhcmMgPSB0b3BvbG9neS5hcmNzW2kgPCAwID8gfmkgOiBpXSwgcDAgPSBhcmNbMF0sIHAxO1xuICAgIGlmICh0b3BvbG9neS50cmFuc2Zvcm0pIHAxID0gWzAsIDBdLCBhcmMuZm9yRWFjaChmdW5jdGlvbihkcCkgeyBwMVswXSArPSBkcFswXSwgcDFbMV0gKz0gZHBbMV07IH0pO1xuICAgIGVsc2UgcDEgPSBhcmNbYXJjLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBpIDwgMCA/IFtwMSwgcDBdIDogW3AwLCBwMV07XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaChmcmFnbWVudEJ5RW5kLCBmcmFnbWVudEJ5U3RhcnQpIHtcbiAgICBmb3IgKHZhciBrIGluIGZyYWdtZW50QnlFbmQpIHtcbiAgICAgIHZhciBmID0gZnJhZ21lbnRCeUVuZFtrXTtcbiAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICBkZWxldGUgZi5zdGFydDtcbiAgICAgIGRlbGV0ZSBmLmVuZDtcbiAgICAgIGYuZm9yRWFjaChmdW5jdGlvbihpKSB7IHN0aXRjaGVkQXJjc1tpIDwgMCA/IH5pIDogaV0gPSAxOyB9KTtcbiAgICAgIGZyYWdtZW50cy5wdXNoKGYpO1xuICAgIH1cbiAgfVxuXG4gIGZsdXNoKGZyYWdtZW50QnlFbmQsIGZyYWdtZW50QnlTdGFydCk7XG4gIGZsdXNoKGZyYWdtZW50QnlTdGFydCwgZnJhZ21lbnRCeUVuZCk7XG4gIGFyY3MuZm9yRWFjaChmdW5jdGlvbihpKSB7IGlmICghc3RpdGNoZWRBcmNzW2kgPCAwID8gfmkgOiBpXSkgZnJhZ21lbnRzLnB1c2goW2ldKTsgfSk7XG5cbiAgcmV0dXJuIGZyYWdtZW50cztcbn1cblxuZnVuY3Rpb24gbWVzaCh0b3BvbG9neSkge1xuICByZXR1cm4gb2JqZWN0KHRvcG9sb2d5LCBtZXNoQXJjcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbn1cblxuZnVuY3Rpb24gbWVzaEFyY3ModG9wb2xvZ3ksIG9iamVjdCwgZmlsdGVyKSB7XG4gIHZhciBhcmNzLCBpLCBuO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGFyY3MgPSBleHRyYWN0QXJjcyh0b3BvbG9neSwgb2JqZWN0LCBmaWx0ZXIpO1xuICBlbHNlIGZvciAoaSA9IDAsIGFyY3MgPSBuZXcgQXJyYXkobiA9IHRvcG9sb2d5LmFyY3MubGVuZ3RoKTsgaSA8IG47ICsraSkgYXJjc1tpXSA9IGk7XG4gIHJldHVybiB7dHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIiwgYXJjczogc3RpdGNoKHRvcG9sb2d5LCBhcmNzKX07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RBcmNzKHRvcG9sb2d5LCBvYmplY3QsIGZpbHRlcikge1xuICB2YXIgYXJjcyA9IFtdLFxuICAgICAgZ2VvbXNCeUFyYyA9IFtdLFxuICAgICAgZ2VvbTtcblxuICBmdW5jdGlvbiBleHRyYWN0MChpKSB7XG4gICAgdmFyIGogPSBpIDwgMCA/IH5pIDogaTtcbiAgICAoZ2VvbXNCeUFyY1tqXSB8fCAoZ2VvbXNCeUFyY1tqXSA9IFtdKSkucHVzaCh7aTogaSwgZzogZ2VvbX0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdDEoYXJjcykge1xuICAgIGFyY3MuZm9yRWFjaChleHRyYWN0MCk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0MihhcmNzKSB7XG4gICAgYXJjcy5mb3JFYWNoKGV4dHJhY3QxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QzKGFyY3MpIHtcbiAgICBhcmNzLmZvckVhY2goZXh0cmFjdDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VvbWV0cnkobykge1xuICAgIHN3aXRjaCAoZ2VvbSA9IG8sIG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaChnZW9tZXRyeSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjogZXh0cmFjdDEoby5hcmNzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6IGNhc2UgXCJQb2x5Z29uXCI6IGV4dHJhY3QyKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOiBleHRyYWN0MyhvLmFyY3MpOyBicmVhaztcbiAgICB9XG4gIH1cblxuICBnZW9tZXRyeShvYmplY3QpO1xuXG4gIGdlb21zQnlBcmMuZm9yRWFjaChmaWx0ZXIgPT0gbnVsbFxuICAgICAgPyBmdW5jdGlvbihnZW9tcykgeyBhcmNzLnB1c2goZ2VvbXNbMF0uaSk7IH1cbiAgICAgIDogZnVuY3Rpb24oZ2VvbXMpIHsgaWYgKGZpbHRlcihnZW9tc1swXS5nLCBnZW9tc1tnZW9tcy5sZW5ndGggLSAxXS5nKSkgYXJjcy5wdXNoKGdlb21zWzBdLmkpOyB9KTtcblxuICByZXR1cm4gYXJjcztcbn1cblxuZnVuY3Rpb24gcGxhbmFyUmluZ0FyZWEocmluZykge1xuICB2YXIgaSA9IC0xLCBuID0gcmluZy5sZW5ndGgsIGEsIGIgPSByaW5nW24gLSAxXSwgYXJlYSA9IDA7XG4gIHdoaWxlICgrK2kgPCBuKSBhID0gYiwgYiA9IHJpbmdbaV0sIGFyZWEgKz0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbiAgcmV0dXJuIE1hdGguYWJzKGFyZWEpOyAvLyBOb3RlOiBkb3VibGVkIGFyZWEhXG59XG5cbmZ1bmN0aW9uIG1lcmdlKHRvcG9sb2d5KSB7XG4gIHJldHVybiBvYmplY3QodG9wb2xvZ3ksIG1lcmdlQXJjcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VBcmNzKHRvcG9sb2d5LCBvYmplY3RzKSB7XG4gIHZhciBwb2x5Z29uc0J5QXJjID0ge30sXG4gICAgICBwb2x5Z29ucyA9IFtdLFxuICAgICAgZ3JvdXBzID0gW107XG5cbiAgb2JqZWN0cy5mb3JFYWNoKGdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBnZW9tZXRyeShvKSB7XG4gICAgc3dpdGNoIChvLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjogby5nZW9tZXRyaWVzLmZvckVhY2goZ2VvbWV0cnkpOyBicmVhaztcbiAgICAgIGNhc2UgXCJQb2x5Z29uXCI6IGV4dHJhY3Qoby5hcmNzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6IG8uYXJjcy5mb3JFYWNoKGV4dHJhY3QpOyBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0KHBvbHlnb24pIHtcbiAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgcmluZy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgICAocG9seWdvbnNCeUFyY1thcmMgPSBhcmMgPCAwID8gfmFyYyA6IGFyY10gfHwgKHBvbHlnb25zQnlBcmNbYXJjXSA9IFtdKSkucHVzaChwb2x5Z29uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBvbHlnb25zLnB1c2gocG9seWdvbik7XG4gIH1cblxuICBmdW5jdGlvbiBhcmVhKHJpbmcpIHtcbiAgICByZXR1cm4gcGxhbmFyUmluZ0FyZWEob2JqZWN0KHRvcG9sb2d5LCB7dHlwZTogXCJQb2x5Z29uXCIsIGFyY3M6IFtyaW5nXX0pLmNvb3JkaW5hdGVzWzBdKTtcbiAgfVxuXG4gIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgIGlmICghcG9seWdvbi5fKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBbXSxcbiAgICAgICAgICBuZWlnaGJvcnMgPSBbcG9seWdvbl07XG4gICAgICBwb2x5Z29uLl8gPSAxO1xuICAgICAgZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgICAgd2hpbGUgKHBvbHlnb24gPSBuZWlnaGJvcnMucG9wKCkpIHtcbiAgICAgICAgZ3JvdXAucHVzaChwb2x5Z29uKTtcbiAgICAgICAgcG9seWdvbi5mb3JFYWNoKGZ1bmN0aW9uKHJpbmcpIHtcbiAgICAgICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgICAgICBwb2x5Z29uc0J5QXJjW2FyYyA8IDAgPyB+YXJjIDogYXJjXS5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICAgICAgICAgICAgaWYgKCFwb2x5Z29uLl8pIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uLl8gPSAxO1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKHBvbHlnb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICBkZWxldGUgcG9seWdvbi5fO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiTXVsdGlQb2x5Z29uXCIsXG4gICAgYXJjczogZ3JvdXBzLm1hcChmdW5jdGlvbihwb2x5Z29ucykge1xuICAgICAgdmFyIGFyY3MgPSBbXSwgbjtcblxuICAgICAgLy8gRXh0cmFjdCB0aGUgZXh0ZXJpb3IgKHVuaXF1ZSkgYXJjcy5cbiAgICAgIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgICAgICAgIGlmIChwb2x5Z29uc0J5QXJjW2FyYyA8IDAgPyB+YXJjIDogYXJjXS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgIGFyY3MucHVzaChhcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTdGl0Y2ggdGhlIGFyY3MgaW50byBvbmUgb3IgbW9yZSByaW5ncy5cbiAgICAgIGFyY3MgPSBzdGl0Y2godG9wb2xvZ3ksIGFyY3MpO1xuXG4gICAgICAvLyBJZiBtb3JlIHRoYW4gb25lIHJpbmcgaXMgcmV0dXJuZWQsXG4gICAgICAvLyBhdCBtb3N0IG9uZSBvZiB0aGVzZSByaW5ncyBjYW4gYmUgdGhlIGV4dGVyaW9yO1xuICAgICAgLy8gY2hvb3NlIHRoZSBvbmUgd2l0aCB0aGUgZ3JlYXRlc3QgYWJzb2x1dGUgYXJlYS5cbiAgICAgIGlmICgobiA9IGFyY3MubGVuZ3RoKSA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGsgPSBhcmVhKGFyY3NbMF0pLCBraSwgdDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGlmICgoa2kgPSBhcmVhKGFyY3NbaV0pKSA+IGspIHtcbiAgICAgICAgICAgIHQgPSBhcmNzWzBdLCBhcmNzWzBdID0gYXJjc1tpXSwgYXJjc1tpXSA9IHQsIGsgPSBraTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyY3M7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGFyY3MpIHtcbiAgICAgIHJldHVybiBhcmNzLmxlbmd0aCA+IDA7XG4gICAgfSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmlzZWN0KGEsIHgpIHtcbiAgdmFyIGxvID0gMCwgaGkgPSBhLmxlbmd0aDtcbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICBpZiAoYVttaWRdIDwgeCkgbG8gPSBtaWQgKyAxO1xuICAgIGVsc2UgaGkgPSBtaWQ7XG4gIH1cbiAgcmV0dXJuIGxvO1xufVxuXG5mdW5jdGlvbiBuZWlnaGJvcnMob2JqZWN0cykge1xuICB2YXIgaW5kZXhlc0J5QXJjID0ge30sIC8vIGFyYyBpbmRleCAtPiBhcnJheSBvZiBvYmplY3QgaW5kZXhlc1xuICAgICAgbmVpZ2hib3JzID0gb2JqZWN0cy5tYXAoZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfSk7XG5cbiAgZnVuY3Rpb24gbGluZShhcmNzLCBpKSB7XG4gICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGlmIChhIDwgMCkgYSA9IH5hO1xuICAgICAgdmFyIG8gPSBpbmRleGVzQnlBcmNbYV07XG4gICAgICBpZiAobykgby5wdXNoKGkpO1xuICAgICAgZWxzZSBpbmRleGVzQnlBcmNbYV0gPSBbaV07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwb2x5Z29uKGFyY3MsIGkpIHtcbiAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7IGxpbmUoYXJjLCBpKTsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW9tZXRyeShvLCBpKSB7XG4gICAgaWYgKG8udHlwZSA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIikgby5nZW9tZXRyaWVzLmZvckVhY2goZnVuY3Rpb24obykgeyBnZW9tZXRyeShvLCBpKTsgfSk7XG4gICAgZWxzZSBpZiAoby50eXBlIGluIGdlb21ldHJ5VHlwZSkgZ2VvbWV0cnlUeXBlW28udHlwZV0oby5hcmNzLCBpKTtcbiAgfVxuXG4gIHZhciBnZW9tZXRyeVR5cGUgPSB7XG4gICAgTGluZVN0cmluZzogbGluZSxcbiAgICBNdWx0aUxpbmVTdHJpbmc6IHBvbHlnb24sXG4gICAgUG9seWdvbjogcG9seWdvbixcbiAgICBNdWx0aVBvbHlnb246IGZ1bmN0aW9uKGFyY3MsIGkpIHsgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykgeyBwb2x5Z29uKGFyYywgaSk7IH0pOyB9XG4gIH07XG5cbiAgb2JqZWN0cy5mb3JFYWNoKGdlb21ldHJ5KTtcblxuICBmb3IgKHZhciBpIGluIGluZGV4ZXNCeUFyYykge1xuICAgIGZvciAodmFyIGluZGV4ZXMgPSBpbmRleGVzQnlBcmNbaV0sIG0gPSBpbmRleGVzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IG07ICsraykge1xuICAgICAgICB2YXIgaWogPSBpbmRleGVzW2pdLCBpayA9IGluZGV4ZXNba10sIG47XG4gICAgICAgIGlmICgobiA9IG5laWdoYm9yc1tpal0pW2kgPSBiaXNlY3QobiwgaWspXSAhPT0gaWspIG4uc3BsaWNlKGksIDAsIGlrKTtcbiAgICAgICAgaWYgKChuID0gbmVpZ2hib3JzW2lrXSlbaSA9IGJpc2VjdChuLCBpaildICE9PSBpaikgbi5zcGxpY2UoaSwgMCwgaWopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWlnaGJvcnM7XG59XG5cbmZ1bmN0aW9uIHVudHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICBpZiAodHJhbnNmb3JtID09IG51bGwpIHJldHVybiBpZGVudGl0eTtcbiAgdmFyIHgwLFxuICAgICAgeTAsXG4gICAgICBreCA9IHRyYW5zZm9ybS5zY2FsZVswXSxcbiAgICAgIGt5ID0gdHJhbnNmb3JtLnNjYWxlWzFdLFxuICAgICAgZHggPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzBdLFxuICAgICAgZHkgPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzFdO1xuICByZXR1cm4gZnVuY3Rpb24oaW5wdXQsIGkpIHtcbiAgICBpZiAoIWkpIHgwID0geTAgPSAwO1xuICAgIHZhciBqID0gMixcbiAgICAgICAgbiA9IGlucHV0Lmxlbmd0aCxcbiAgICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KG4pLFxuICAgICAgICB4MSA9IE1hdGgucm91bmQoKGlucHV0WzBdIC0gZHgpIC8ga3gpLFxuICAgICAgICB5MSA9IE1hdGgucm91bmQoKGlucHV0WzFdIC0gZHkpIC8ga3kpO1xuICAgIG91dHB1dFswXSA9IHgxIC0geDAsIHgwID0geDE7XG4gICAgb3V0cHV0WzFdID0geTEgLSB5MCwgeTAgPSB5MTtcbiAgICB3aGlsZSAoaiA8IG4pIG91dHB1dFtqXSA9IGlucHV0W2pdLCArK2o7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcXVhbnRpemUodG9wb2xvZ3ksIHRyYW5zZm9ybSkge1xuICBpZiAodG9wb2xvZ3kudHJhbnNmb3JtKSB0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IHF1YW50aXplZFwiKTtcblxuICBpZiAoIXRyYW5zZm9ybSB8fCAhdHJhbnNmb3JtLnNjYWxlKSB7XG4gICAgaWYgKCEoKG4gPSBNYXRoLmZsb29yKHRyYW5zZm9ybSkpID49IDIpKSB0aHJvdyBuZXcgRXJyb3IoXCJuIG11c3QgYmUg4omlMlwiKTtcbiAgICBib3ggPSB0b3BvbG9neS5iYm94IHx8IGJib3godG9wb2xvZ3kpO1xuICAgIHZhciB4MCA9IGJveFswXSwgeTAgPSBib3hbMV0sIHgxID0gYm94WzJdLCB5MSA9IGJveFszXSwgbjtcbiAgICB0cmFuc2Zvcm0gPSB7c2NhbGU6IFt4MSAtIHgwID8gKHgxIC0geDApIC8gKG4gLSAxKSA6IDEsIHkxIC0geTAgPyAoeTEgLSB5MCkgLyAobiAtIDEpIDogMV0sIHRyYW5zbGF0ZTogW3gwLCB5MF19O1xuICB9IGVsc2Uge1xuICAgIGJveCA9IHRvcG9sb2d5LmJib3g7XG4gIH1cblxuICB2YXIgdCA9IHVudHJhbnNmb3JtKHRyYW5zZm9ybSksIGJveCwga2V5LCBpbnB1dHMgPSB0b3BvbG9neS5vYmplY3RzLCBvdXRwdXRzID0ge307XG5cbiAgZnVuY3Rpb24gcXVhbnRpemVQb2ludChwb2ludCkge1xuICAgIHJldHVybiB0KHBvaW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1YW50aXplR2VvbWV0cnkoaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0O1xuICAgIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvdXRwdXQgPSB7dHlwZTogXCJHZW9tZXRyeUNvbGxlY3Rpb25cIiwgZ2VvbWV0cmllczogaW5wdXQuZ2VvbWV0cmllcy5tYXAocXVhbnRpemVHZW9tZXRyeSl9OyBicmVhaztcbiAgICAgIGNhc2UgXCJQb2ludFwiOiBvdXRwdXQgPSB7dHlwZTogXCJQb2ludFwiLCBjb29yZGluYXRlczogcXVhbnRpemVQb2ludChpbnB1dC5jb29yZGluYXRlcyl9OyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6IG91dHB1dCA9IHt0eXBlOiBcIk11bHRpUG9pbnRcIiwgY29vcmRpbmF0ZXM6IGlucHV0LmNvb3JkaW5hdGVzLm1hcChxdWFudGl6ZVBvaW50KX07IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBpZiAoaW5wdXQuaWQgIT0gbnVsbCkgb3V0cHV0LmlkID0gaW5wdXQuaWQ7XG4gICAgaWYgKGlucHV0LmJib3ggIT0gbnVsbCkgb3V0cHV0LmJib3ggPSBpbnB1dC5iYm94O1xuICAgIGlmIChpbnB1dC5wcm9wZXJ0aWVzICE9IG51bGwpIG91dHB1dC5wcm9wZXJ0aWVzID0gaW5wdXQucHJvcGVydGllcztcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgZnVuY3Rpb24gcXVhbnRpemVBcmMoaW5wdXQpIHtcbiAgICB2YXIgaSA9IDAsIGogPSAxLCBuID0gaW5wdXQubGVuZ3RoLCBwLCBvdXRwdXQgPSBuZXcgQXJyYXkobik7IC8vIHBlc3NpbWlzdGljXG4gICAgb3V0cHV0WzBdID0gdChpbnB1dFswXSwgMCk7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICgocCA9IHQoaW5wdXRbaV0sIGkpKVswXSB8fCBwWzFdKSBvdXRwdXRbaisrXSA9IHA7IC8vIG5vbi1jb2luY2lkZW50IHBvaW50c1xuICAgIGlmIChqID09PSAxKSBvdXRwdXRbaisrXSA9IFswLCAwXTsgLy8gYW4gYXJjIG11c3QgaGF2ZSBhdCBsZWFzdCB0d28gcG9pbnRzXG4gICAgb3V0cHV0Lmxlbmd0aCA9IGo7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGlucHV0cykgb3V0cHV0c1trZXldID0gcXVhbnRpemVHZW9tZXRyeShpbnB1dHNba2V5XSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlRvcG9sb2d5XCIsXG4gICAgYmJveDogYm94LFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgIG9iamVjdHM6IG91dHB1dHMsXG4gICAgYXJjczogdG9wb2xvZ3kuYXJjcy5tYXAocXVhbnRpemVBcmMpXG4gIH07XG59XG5cbmV4cG9ydHMuYmJveCA9IGJib3g7XG5leHBvcnRzLmZlYXR1cmUgPSBmZWF0dXJlO1xuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuZXhwb3J0cy5tZXJnZUFyY3MgPSBtZXJnZUFyY3M7XG5leHBvcnRzLm1lc2ggPSBtZXNoO1xuZXhwb3J0cy5tZXNoQXJjcyA9IG1lc2hBcmNzO1xuZXhwb3J0cy5uZWlnaGJvcnMgPSBuZWlnaGJvcnM7XG5leHBvcnRzLnF1YW50aXplID0gcXVhbnRpemU7XG5leHBvcnRzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbmV4cG9ydHMudW50cmFuc2Zvcm0gPSB1bnRyYW5zZm9ybTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge3ZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgZ2xvYmFsLCBkZWZpbmUsIFN5c3RlbSwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG52YXIgX19leHRlbmRzO1xyXG52YXIgX19hc3NpZ247XHJcbnZhciBfX3Jlc3Q7XHJcbnZhciBfX2RlY29yYXRlO1xyXG52YXIgX19wYXJhbTtcclxudmFyIF9fbWV0YWRhdGE7XHJcbnZhciBfX2F3YWl0ZXI7XHJcbnZhciBfX2dlbmVyYXRvcjtcclxudmFyIF9fZXhwb3J0U3RhcjtcclxudmFyIF9fdmFsdWVzO1xyXG52YXIgX19yZWFkO1xyXG52YXIgX19zcHJlYWQ7XHJcbnZhciBfX3NwcmVhZEFycmF5cztcclxudmFyIF9fYXdhaXQ7XHJcbnZhciBfX2FzeW5jR2VuZXJhdG9yO1xyXG52YXIgX19hc3luY0RlbGVnYXRvcjtcclxudmFyIF9fYXN5bmNWYWx1ZXM7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdDtcclxudmFyIF9faW1wb3J0U3RhcjtcclxudmFyIF9faW1wb3J0RGVmYXVsdDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0O1xyXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6IHt9O1xyXG4gICAgaWYgKHRydWUpIHtcclxuICAgICAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbZXhwb3J0c10sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7IGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cykpKTsgfSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcclxuICAgIH1cclxuICAgIGVsc2Uge31cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMsIHByZXZpb3VzKSB7XHJcbiAgICAgICAgaWYgKGV4cG9ydHMgIT09IHJvb3QpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgdikgeyByZXR1cm4gZXhwb3J0c1tpZF0gPSBwcmV2aW91cyA/IHByZXZpb3VzKGlkLCB2KSA6IHY7IH07XHJcbiAgICB9XHJcbn0pXHJcbihmdW5jdGlvbiAoZXhwb3J0ZXIpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19yZXN0ID0gZnVuY3Rpb24gKHMsIGUpIHtcclxuICAgICAgICB2YXIgdCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2RlY29yYXRlID0gZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxuICAgIH07XHJcblxyXG4gICAgX19wYXJhbSA9IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXRlciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZXhwb3J0U3RhciA9IGZ1bmN0aW9uIChtLCBleHBvcnRzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgICAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgICAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIH07XHJcblxyXG4gICAgX19yZWFkID0gZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICAgICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgICAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgX19zcHJlYWRBcnJheXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNEZWxlZ2F0b3IgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBpLCBwO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jVmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgICAgICByZXR1cm4gY29va2VkO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2ltcG9ydFN0YXIgPSBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgICAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9faW1wb3J0RGVmYXVsdCA9IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xyXG4gICAgICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gZnVuY3Rpb24gKHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcml2YXRlTWFwLnNldChyZWNlaXZlciwgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnRlcihcIl9fZXh0ZW5kc1wiLCBfX2V4dGVuZHMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2Fzc2lnblwiLCBfX2Fzc2lnbik7XHJcbiAgICBleHBvcnRlcihcIl9fcmVzdFwiLCBfX3Jlc3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2RlY29yYXRlXCIsIF9fZGVjb3JhdGUpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3BhcmFtXCIsIF9fcGFyYW0pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX21ldGFkYXRhXCIsIF9fbWV0YWRhdGEpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2F3YWl0ZXJcIiwgX19hd2FpdGVyKTtcclxuICAgIGV4cG9ydGVyKFwiX19nZW5lcmF0b3JcIiwgX19nZW5lcmF0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2V4cG9ydFN0YXJcIiwgX19leHBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX192YWx1ZXNcIiwgX192YWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3JlYWRcIiwgX19yZWFkKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRcIiwgX19zcHJlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZEFycmF5c1wiLCBfX3NwcmVhZEFycmF5cyk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRcIiwgX19hd2FpdCk7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNHZW5lcmF0b3JcIiwgX19hc3luY0dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNEZWxlZ2F0b3JcIiwgX19hc3luY0RlbGVnYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNWYWx1ZXNcIiwgX19hc3luY1ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fbWFrZVRlbXBsYXRlT2JqZWN0XCIsIF9fbWFrZVRlbXBsYXRlT2JqZWN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnRTdGFyXCIsIF9faW1wb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9faW1wb3J0RGVmYXVsdFwiLCBfX2ltcG9ydERlZmF1bHQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRTZXQpO1xyXG59KTtcclxuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi9fd2VicGFja0A0LjQyLjFAd2VicGFjay9idWlsZGluL2dsb2JhbC5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL193ZWJwYWNrQDQuNDIuMUB3ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXCIpKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX3dlYnBhY2tANC40Mi4xQHdlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL193ZWJwYWNrQDQuNDIuMUB3ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fd29sZnk4Ny1ldmVudGVtaXR0ZXJANS4yLjlAd29sZnk4Ny1ldmVudGVtaXR0ZXIvRXZlbnRFbWl0dGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX3dvbGZ5ODctZXZlbnRlbWl0dGVyQDUuMi45QHdvbGZ5ODctZXZlbnRlbWl0dGVyL0V2ZW50RW1pdHRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiFcbiAqIEV2ZW50RW1pdHRlciB2NS4yLjkgLSBnaXQuaW8vZWVcbiAqIFVubGljZW5zZSAtIGh0dHA6Ly91bmxpY2Vuc2Uub3JnL1xuICogT2xpdmVyIENhbGR3ZWxsIC0gaHR0cHM6Ly9vbGkubWUudWsvXG4gKiBAcHJlc2VydmVcbiAqL1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgZm9yIG1hbmFnaW5nIGV2ZW50cy5cbiAgICAgKiBDYW4gYmUgZXh0ZW5kZWQgdG8gcHJvdmlkZSBldmVudCBmdW5jdGlvbmFsaXR5IGluIG90aGVyIGNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgRXZlbnRFbWl0dGVyIE1hbmFnZXMgZXZlbnQgcmVnaXN0ZXJpbmcgYW5kIGVtaXR0aW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHt9XG5cbiAgICAvLyBTaG9ydGN1dHMgdG8gaW1wcm92ZSBzcGVlZCBhbmQgc2l6ZVxuICAgIHZhciBwcm90byA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGU7XG4gICAgdmFyIG9yaWdpbmFsR2xvYmFsVmFsdWUgPSBleHBvcnRzLkV2ZW50RW1pdHRlcjtcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgbGlzdGVuZXIgZm9yIHRoZSBldmVudCBpbiBpdHMgc3RvcmFnZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gbGlzdGVuZXJzIEFycmF5IG9mIGxpc3RlbmVycyB0byBzZWFyY2ggdGhyb3VnaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gbG9vayBmb3IuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBJbmRleCBvZiB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyLCAtMSBpZiBub3QgZm91bmRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mTGlzdGVuZXIobGlzdGVuZXJzLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpYXMgYSBtZXRob2Qgd2hpbGUga2VlcGluZyB0aGUgY29udGV4dCBjb3JyZWN0LCB0byBhbGxvdyBmb3Igb3ZlcndyaXRpbmcgb2YgdGFyZ2V0IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0YXJnZXQgbWV0aG9kLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgYWxpYXNlZCBtZXRob2RcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbGlhcyhuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhbGlhc0Nsb3N1cmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tuYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3RlbmVyIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIFdpbGwgaW5pdGlhbGlzZSB0aGUgZXZlbnQgb2JqZWN0IGFuZCBsaXN0ZW5lciBhcnJheXMgaWYgcmVxdWlyZWQuXG4gICAgICogV2lsbCByZXR1cm4gYW4gb2JqZWN0IGlmIHlvdSB1c2UgYSByZWdleCBzZWFyY2guIFRoZSBvYmplY3QgY29udGFpbnMga2V5cyBmb3IgZWFjaCBtYXRjaGVkIGV2ZW50LiBTbyAvYmFbcnpdLyBtaWdodCByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYmFyIGFuZCBiYXouIEJ1dCBvbmx5IGlmIHlvdSBoYXZlIGVpdGhlciBkZWZpbmVkIHRoZW0gd2l0aCBkZWZpbmVFdmVudCBvciBhZGRlZCBzb21lIGxpc3RlbmVycyB0byB0aGVtLlxuICAgICAqIEVhY2ggcHJvcGVydHkgaW4gdGhlIG9iamVjdCByZXNwb25zZSBpcyBhbiBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZXR1cm4gdGhlIGxpc3RlbmVycyBmcm9tLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9uW118T2JqZWN0fSBBbGwgbGlzdGVuZXIgZnVuY3Rpb25zIGZvciB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgcHJvdG8uZ2V0TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKGV2dCkge1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZ2V0RXZlbnRzKCk7XG4gICAgICAgIHZhciByZXNwb25zZTtcbiAgICAgICAgdmFyIGtleTtcblxuICAgICAgICAvLyBSZXR1cm4gYSBjb25jYXRlbmF0ZWQgYXJyYXkgb2YgYWxsIG1hdGNoaW5nIGV2ZW50cyBpZlxuICAgICAgICAvLyB0aGUgc2VsZWN0b3IgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICAgIGlmIChldnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0ge307XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGtleSkgJiYgZXZ0LnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVtrZXldID0gZXZlbnRzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBldmVudHNbZXZ0XSB8fCAoZXZlbnRzW2V2dF0gPSBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgbGlzdCBvZiBsaXN0ZW5lciBvYmplY3RzIGFuZCBmbGF0dGVucyBpdCBpbnRvIGEgbGlzdCBvZiBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBsaXN0ZW5lcnMgUmF3IGxpc3RlbmVyIG9iamVjdHMuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb25bXX0gSnVzdCB0aGUgbGlzdGVuZXIgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIHByb3RvLmZsYXR0ZW5MaXN0ZW5lcnMgPSBmdW5jdGlvbiBmbGF0dGVuTGlzdGVuZXJzKGxpc3RlbmVycykge1xuICAgICAgICB2YXIgZmxhdExpc3RlbmVycyA9IFtdO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBmbGF0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXJzW2ldLmxpc3RlbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbGF0TGlzdGVuZXJzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSByZXF1ZXN0ZWQgbGlzdGVuZXJzIHZpYSBnZXRMaXN0ZW5lcnMgYnV0IHdpbGwgYWx3YXlzIHJldHVybiB0aGUgcmVzdWx0cyBpbnNpZGUgYW4gb2JqZWN0LiBUaGlzIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlIGJ1dCBvdGhlcnMgbWF5IGZpbmQgaXQgdXNlZnVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gcmV0dXJuIHRoZSBsaXN0ZW5lcnMgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFsbCBsaXN0ZW5lciBmdW5jdGlvbnMgZm9yIGFuIGV2ZW50IGluIGFuIG9iamVjdC5cbiAgICAgKi9cbiAgICBwcm90by5nZXRMaXN0ZW5lcnNBc09iamVjdCA9IGZ1bmN0aW9uIGdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnMoZXZ0KTtcbiAgICAgICAgdmFyIHJlc3BvbnNlO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB7fTtcbiAgICAgICAgICAgIHJlc3BvbnNlW2V2dF0gPSBsaXN0ZW5lcnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UgfHwgbGlzdGVuZXJzO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkTGlzdGVuZXIgKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicgfHwgbGlzdGVuZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXIgJiYgdHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRMaXN0ZW5lcihsaXN0ZW5lci5saXN0ZW5lcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogVGhlIGxpc3RlbmVyIHdpbGwgbm90IGJlIGFkZGVkIGlmIGl0IGlzIGEgZHVwbGljYXRlLlxuICAgICAqIElmIHRoZSBsaXN0ZW5lciByZXR1cm5zIHRydWUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgaXQgaXMgY2FsbGVkLlxuICAgICAqIElmIHlvdSBwYXNzIGEgcmVndWxhciBleHByZXNzaW9uIGFzIHRoZSBldmVudCBuYW1lIHRoZW4gdGhlIGxpc3RlbmVyIHdpbGwgYmUgYWRkZWQgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gYXR0YWNoIHRoZSBsaXN0ZW5lciB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgY2FsbGluZy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKGV2dCwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkTGlzdGVuZXIobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCk7XG4gICAgICAgIHZhciBsaXN0ZW5lcklzV3JhcHBlZCA9IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCc7XG4gICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgaW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVyc1trZXldLCBsaXN0ZW5lcikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2tleV0ucHVzaChsaXN0ZW5lcklzV3JhcHBlZCA/IGxpc3RlbmVyIDoge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uY2U6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgYWRkTGlzdGVuZXJcbiAgICAgKi9cbiAgICBwcm90by5vbiA9IGFsaWFzKCdhZGRMaXN0ZW5lcicpO1xuXG4gICAgLyoqXG4gICAgICogU2VtaS1hbGlhcyBvZiBhZGRMaXN0ZW5lci4gSXQgd2lsbCBhZGQgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmVcbiAgICAgKiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgYWZ0ZXIgaXRzIGZpcnN0IGV4ZWN1dGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHRoZW4gaXQgd2lsbCBiZSByZW1vdmVkIGFmdGVyIGNhbGxpbmcuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8uYWRkT25jZUxpc3RlbmVyID0gZnVuY3Rpb24gYWRkT25jZUxpc3RlbmVyKGV2dCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIoZXZ0LCB7XG4gICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiBhZGRPbmNlTGlzdGVuZXIuXG4gICAgICovXG4gICAgcHJvdG8ub25jZSA9IGFsaWFzKCdhZGRPbmNlTGlzdGVuZXInKTtcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgYW4gZXZlbnQgbmFtZS4gVGhpcyBpcyByZXF1aXJlZCBpZiB5b3Ugd2FudCB0byB1c2UgYSByZWdleCB0byBhZGQgYSBsaXN0ZW5lciB0byBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gSWYgeW91IGRvbid0IGRvIHRoaXMgdGhlbiBob3cgZG8geW91IGV4cGVjdCBpdCB0byBrbm93IHdoYXQgZXZlbnQgdG8gYWRkIHRvPyBTaG91bGQgaXQganVzdCBhZGQgdG8gZXZlcnkgcG9zc2libGUgbWF0Y2ggZm9yIGEgcmVnZXg/IE5vLiBUaGF0IGlzIHNjYXJ5IGFuZCBiYWQuXG4gICAgICogWW91IG5lZWQgdG8gdGVsbCBpdCB3aGF0IGV2ZW50IG5hbWVzIHNob3VsZCBiZSBtYXRjaGVkIGJ5IGEgcmVnZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGNyZWF0ZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5kZWZpbmVFdmVudCA9IGZ1bmN0aW9uIGRlZmluZUV2ZW50KGV2dCkge1xuICAgICAgICB0aGlzLmdldExpc3RlbmVycyhldnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlcyBkZWZpbmVFdmVudCB0byBkZWZpbmUgbXVsdGlwbGUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gZXZ0cyBBbiBhcnJheSBvZiBldmVudCBuYW1lcyB0byBkZWZpbmUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8uZGVmaW5lRXZlbnRzID0gZnVuY3Rpb24gZGVmaW5lRXZlbnRzKGV2dHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmluZUV2ZW50KGV2dHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgbGlzdGVuZXIgZnVuY3Rpb24gZnJvbSB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIFdoZW4gcGFzc2VkIGEgcmVndWxhciBleHByZXNzaW9uIGFzIHRoZSBldmVudCBuYW1lLCBpdCB3aWxsIHJlbW92ZSB0aGUgbGlzdGVuZXIgZnJvbSBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgTWV0aG9kIHRvIHJlbW92ZSBmcm9tIHRoZSBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2dCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcbiAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICB2YXIga2V5O1xuXG4gICAgICAgIGZvciAoa2V5IGluIGxpc3RlbmVycykge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleE9mTGlzdGVuZXIobGlzdGVuZXJzW2tleV0sIGxpc3RlbmVyKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2tleV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgcmVtb3ZlTGlzdGVuZXJcbiAgICAgKi9cbiAgICBwcm90by5vZmYgPSBhbGlhcygncmVtb3ZlTGlzdGVuZXInKTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgbGlzdGVuZXJzIGluIGJ1bGsgdXNpbmcgdGhlIG1hbmlwdWxhdGVMaXN0ZW5lcnMgbWV0aG9kLlxuICAgICAqIElmIHlvdSBwYXNzIGFuIG9iamVjdCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgeW91IGNhbiBhZGQgdG8gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4ga2V5IHZhbHVlIHBhaXJzIG9mIGV2ZW50cyBhbmQgbGlzdGVuZXJzIG9yIGxpc3RlbmVyIGFycmF5cy4gWW91IGNhbiBhbHNvIHBhc3MgaXQgYW4gZXZlbnQgbmFtZSBhbmQgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGJlIGFkZGVkLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGEgcmVndWxhciBleHByZXNzaW9uIHRvIGFkZCB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cbiAgICAgKiBZZWFoLCB0aGlzIGZ1bmN0aW9uIGRvZXMgcXVpdGUgYSBiaXQuIFRoYXQncyBwcm9iYWJseSBhIGJhZCB0aGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxSZWdFeHB9IGV2dCBBbiBldmVudCBuYW1lIGlmIHlvdSB3aWxsIHBhc3MgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIG5leHQuIEFuIG9iamVjdCBpZiB5b3Ugd2lzaCB0byBhZGQgdG8gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfSBbbGlzdGVuZXJzXSBBbiBvcHRpb25hbCBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLmFkZExpc3RlbmVycyA9IGZ1bmN0aW9uIGFkZExpc3RlbmVycyhldnQsIGxpc3RlbmVycykge1xuICAgICAgICAvLyBQYXNzIHRocm91Z2ggdG8gbWFuaXB1bGF0ZUxpc3RlbmVyc1xuICAgICAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRlTGlzdGVuZXJzKGZhbHNlLCBldnQsIGxpc3RlbmVycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGlzdGVuZXJzIGluIGJ1bGsgdXNpbmcgdGhlIG1hbmlwdWxhdGVMaXN0ZW5lcnMgbWV0aG9kLlxuICAgICAqIElmIHlvdSBwYXNzIGFuIG9iamVjdCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgeW91IGNhbiByZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiBrZXkgdmFsdWUgcGFpcnMgb2YgZXZlbnRzIGFuZCBsaXN0ZW5lcnMgb3IgbGlzdGVuZXIgYXJyYXlzLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGFuIGV2ZW50IG5hbWUgYW5kIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0byBiZSByZW1vdmVkLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGEgcmVndWxhciBleHByZXNzaW9uIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJzIGZyb20gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gZXZ0IEFuIGV2ZW50IG5hbWUgaWYgeW91IHdpbGwgcGFzcyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgbmV4dC4gQW4gb2JqZWN0IGlmIHlvdSB3aXNoIHRvIHJlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gW2xpc3RlbmVyc10gQW4gb3B0aW9uYWwgYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5yZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoZXZ0LCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gUGFzcyB0aHJvdWdoIHRvIG1hbmlwdWxhdGVMaXN0ZW5lcnNcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0ZUxpc3RlbmVycyh0cnVlLCBldnQsIGxpc3RlbmVycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVkaXRzIGxpc3RlbmVycyBpbiBidWxrLiBUaGUgYWRkTGlzdGVuZXJzIGFuZCByZW1vdmVMaXN0ZW5lcnMgbWV0aG9kcyBib3RoIHVzZSB0aGlzIHRvIGRvIHRoZWlyIGpvYi4gWW91IHNob3VsZCByZWFsbHkgdXNlIHRob3NlIGluc3RlYWQsIHRoaXMgaXMgYSBsaXR0bGUgbG93ZXIgbGV2ZWwuXG4gICAgICogVGhlIGZpcnN0IGFyZ3VtZW50IHdpbGwgZGV0ZXJtaW5lIGlmIHRoZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgKHRydWUpIG9yIGFkZGVkIChmYWxzZSkuXG4gICAgICogSWYgeW91IHBhc3MgYW4gb2JqZWN0IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgeW91IGNhbiBhZGQvcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4ga2V5IHZhbHVlIHBhaXJzIG9mIGV2ZW50cyBhbmQgbGlzdGVuZXJzIG9yIGxpc3RlbmVyIGFycmF5cy5cbiAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhbiBldmVudCBuYW1lIGFuZCBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYmUgYWRkZWQvcmVtb3ZlZC5cbiAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYW5pcHVsYXRlIHRoZSBsaXN0ZW5lcnMgb2YgYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmUgVHJ1ZSBpZiB5b3Ugd2FudCB0byByZW1vdmUgbGlzdGVuZXJzLCBmYWxzZSBpZiB5b3Ugd2FudCB0byBhZGQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gZXZ0IEFuIGV2ZW50IG5hbWUgaWYgeW91IHdpbGwgcGFzcyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgbmV4dC4gQW4gb2JqZWN0IGlmIHlvdSB3aXNoIHRvIGFkZC9yZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IFtsaXN0ZW5lcnNdIEFuIG9wdGlvbmFsIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0byBhZGQvcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLm1hbmlwdWxhdGVMaXN0ZW5lcnMgPSBmdW5jdGlvbiBtYW5pcHVsYXRlTGlzdGVuZXJzKHJlbW92ZSwgZXZ0LCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdmFyIHNpbmdsZSA9IHJlbW92ZSA/IHRoaXMucmVtb3ZlTGlzdGVuZXIgOiB0aGlzLmFkZExpc3RlbmVyO1xuICAgICAgICB2YXIgbXVsdGlwbGUgPSByZW1vdmUgPyB0aGlzLnJlbW92ZUxpc3RlbmVycyA6IHRoaXMuYWRkTGlzdGVuZXJzO1xuXG4gICAgICAgIC8vIElmIGV2dCBpcyBhbiBvYmplY3QgdGhlbiBwYXNzIGVhY2ggb2YgaXRzIHByb3BlcnRpZXMgdG8gdGhpcyBtZXRob2RcbiAgICAgICAgaWYgKHR5cGVvZiBldnQgPT09ICdvYmplY3QnICYmICEoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICAgICAgZm9yIChpIGluIGV2dCkge1xuICAgICAgICAgICAgICAgIGlmIChldnQuaGFzT3duUHJvcGVydHkoaSkgJiYgKHZhbHVlID0gZXZ0W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIHRoZSBzaW5nbGUgbGlzdGVuZXIgc3RyYWlnaHQgdGhyb3VnaCB0byB0aGUgc2luZ3VsYXIgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbmdsZS5jYWxsKHRoaXMsIGksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBwYXNzIGJhY2sgdG8gdGhlIG11bHRpcGxlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZS5jYWxsKHRoaXMsIGksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNvIGV2dCBtdXN0IGJlIGEgc3RyaW5nXG4gICAgICAgICAgICAvLyBBbmQgbGlzdGVuZXJzIG11c3QgYmUgYW4gYXJyYXkgb2YgbGlzdGVuZXJzXG4gICAgICAgICAgICAvLyBMb29wIG92ZXIgaXQgYW5kIHBhc3MgZWFjaCBvbmUgdG8gdGhlIG11bHRpcGxlIG1ldGhvZFxuICAgICAgICAgICAgaSA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgc2luZ2xlLmNhbGwodGhpcywgZXZ0LCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBmcm9tIGEgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIElmIHlvdSBkbyBub3Qgc3BlY2lmeSBhbiBldmVudCB0aGVuIGFsbCBsaXN0ZW5lcnMgd2lsbCBiZSByZW1vdmVkLlxuICAgICAqIFRoYXQgbWVhbnMgZXZlcnkgZXZlbnQgd2lsbCBiZSBlbXB0aWVkLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgcmVnZXggdG8gcmVtb3ZlIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gW2V2dF0gT3B0aW9uYWwgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yLiBXaWxsIHJlbW92ZSBmcm9tIGV2ZXJ5IGV2ZW50IGlmIG5vdCBwYXNzZWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8ucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiByZW1vdmVFdmVudChldnQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZXZ0O1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZ2V0RXZlbnRzKCk7XG4gICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGRpZmZlcmVudCB0aGluZ3MgZGVwZW5kaW5nIG9uIHRoZSBzdGF0ZSBvZiBldnRcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCBldmVudFxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1tldnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2dCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBldmVudHMgbWF0Y2hpbmcgdGhlIHJlZ2V4LlxuICAgICAgICAgICAgZm9yIChrZXkgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGV2dC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGluIGFsbCBldmVudHNcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgcmVtb3ZlRXZlbnQuXG4gICAgICpcbiAgICAgKiBBZGRlZCB0byBtaXJyb3IgdGhlIG5vZGUgQVBJLlxuICAgICAqL1xuICAgIHByb3RvLnJlbW92ZUFsbExpc3RlbmVycyA9IGFsaWFzKCdyZW1vdmVFdmVudCcpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgb2YgeW91ciBjaG9pY2UuXG4gICAgICogV2hlbiBlbWl0dGVkLCBldmVyeSBsaXN0ZW5lciBhdHRhY2hlZCB0byB0aGF0IGV2ZW50IHdpbGwgYmUgZXhlY3V0ZWQuXG4gICAgICogSWYgeW91IHBhc3MgdGhlIG9wdGlvbmFsIGFyZ3VtZW50IGFycmF5IHRoZW4gdGhvc2UgYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIHRvIGV2ZXJ5IGxpc3RlbmVyIHVwb24gZXhlY3V0aW9uLlxuICAgICAqIEJlY2F1c2UgaXQgdXNlcyBgYXBwbHlgLCB5b3VyIGFycmF5IG9mIGFyZ3VtZW50cyB3aWxsIGJlIHBhc3NlZCBhcyBpZiB5b3Ugd3JvdGUgdGhlbSBvdXQgc2VwYXJhdGVseS5cbiAgICAgKiBTbyB0aGV5IHdpbGwgbm90IGFycml2ZSB3aXRoaW4gdGhlIGFycmF5IG9uIHRoZSBvdGhlciBzaWRlLCB0aGV5IHdpbGwgYmUgc2VwYXJhdGUuXG4gICAgICogWW91IGNhbiBhbHNvIHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gZW1pdCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0IGFuZCBleGVjdXRlIGxpc3RlbmVycyBmb3IuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIE9wdGlvbmFsIGFycmF5IG9mIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gZWFjaCBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5lbWl0RXZlbnQgPSBmdW5jdGlvbiBlbWl0RXZlbnQoZXZ0LCBhcmdzKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnNNYXAgPSB0aGlzLmdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCk7XG4gICAgICAgIHZhciBsaXN0ZW5lcnM7XG4gICAgICAgIHZhciBsaXN0ZW5lcjtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIHZhciByZXNwb25zZTtcblxuICAgICAgICBmb3IgKGtleSBpbiBsaXN0ZW5lcnNNYXApIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVyc01hcFtrZXldLnNsaWNlKDApO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGlzdGVuZXIgcmV0dXJucyB0cnVlIHRoZW4gaXQgc2hhbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgZWl0aGVyIHdpdGggYSBiYXNpYyBjYWxsIG9yIGFuIGFwcGx5IGlmIHRoZXJlIGlzIGFuIGFyZ3MgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm9uY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lci5saXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGxpc3RlbmVyLmxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MgfHwgW10pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gdGhpcy5fZ2V0T25jZVJldHVyblZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lci5saXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgZW1pdEV2ZW50XG4gICAgICovXG4gICAgcHJvdG8udHJpZ2dlciA9IGFsaWFzKCdlbWl0RXZlbnQnKTtcblxuICAgIC8qKlxuICAgICAqIFN1YnRseSBkaWZmZXJlbnQgZnJvbSBlbWl0RXZlbnQgaW4gdGhhdCBpdCB3aWxsIHBhc3MgaXRzIGFyZ3VtZW50cyBvbiB0byB0aGUgbGlzdGVuZXJzLCBhcyBvcHBvc2VkIHRvIHRha2luZyBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyBvbi5cbiAgICAgKiBBcyB3aXRoIGVtaXRFdmVudCwgeW91IGNhbiBwYXNzIGEgcmVnZXggaW4gcGxhY2Ugb2YgdGhlIGV2ZW50IG5hbWUgdG8gZW1pdCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0IGFuZCBleGVjdXRlIGxpc3RlbmVycyBmb3IuXG4gICAgICogQHBhcmFtIHsuLi4qfSBPcHRpb25hbCBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gZWFjaCBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChldnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0RXZlbnQoZXZ0LCBhcmdzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCB2YWx1ZSB0byBjaGVjayBhZ2FpbnN0IHdoZW4gZXhlY3V0aW5nIGxpc3RlbmVycy4gSWYgYVxuICAgICAqIGxpc3RlbmVycyByZXR1cm4gdmFsdWUgbWF0Y2hlcyB0aGUgb25lIHNldCBoZXJlIHRoZW4gaXQgd2lsbCBiZSByZW1vdmVkXG4gICAgICogYWZ0ZXIgZXhlY3V0aW9uLiBUaGlzIHZhbHVlIGRlZmF1bHRzIHRvIHRydWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBuZXcgdmFsdWUgdG8gY2hlY2sgZm9yIHdoZW4gZXhlY3V0aW5nIGxpc3RlbmVycy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5zZXRPbmNlUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiBzZXRPbmNlUmV0dXJuVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb25jZVJldHVyblZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBjdXJyZW50IHZhbHVlIHRvIGNoZWNrIGFnYWluc3Qgd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLiBJZlxuICAgICAqIHRoZSBsaXN0ZW5lcnMgcmV0dXJuIHZhbHVlIG1hdGNoZXMgdGhpcyBvbmUgdGhlbiBpdCBzaG91bGQgYmUgcmVtb3ZlZFxuICAgICAqIGF1dG9tYXRpY2FsbHkuIEl0IHdpbGwgcmV0dXJuIHRydWUgYnkgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp8Qm9vbGVhbn0gVGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgZm9yIG9yIHRoZSBkZWZhdWx0LCB0cnVlLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIHByb3RvLl9nZXRPbmNlUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiBfZ2V0T25jZVJldHVyblZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnX29uY2VSZXR1cm5WYWx1ZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25jZVJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgZXZlbnRzIG9iamVjdCBhbmQgY3JlYXRlcyBvbmUgaWYgcmVxdWlyZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBldmVudHMgc3RvcmFnZSBvYmplY3QuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8uX2dldEV2ZW50cyA9IGZ1bmN0aW9uIF9nZXRFdmVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMgfHwgKHRoaXMuX2V2ZW50cyA9IHt9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgZ2xvYmFsIHtAbGluayBFdmVudEVtaXR0ZXJ9IHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIHZlcnNpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gTm9uIGNvbmZsaWN0aW5nIEV2ZW50RW1pdHRlciBjbGFzcy5cbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICAgIGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gb3JpZ2luYWxHbG9iYWxWYWx1ZTtcbiAgICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbiAgICB9O1xuXG4gICAgLy8gRXhwb3NlIHRoZSBjbGFzcyBlaXRoZXIgdmlhIEFNRCwgQ29tbW9uSlMgb3IgdGhlIGdsb2JhbCBvYmplY3RcbiAgICBpZiAodHJ1ZSkge1xuICAgICAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG4gICAgICAgIH0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICAgIH1cbiAgICBlbHNlIHt9XG59KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyB8fCB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2FwaS9nZW8udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9hcGkvZ2VvLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkM19nZW9fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLWdlbyAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1nZW9AMS42LjRAZDMtZ2VvL2J1aWxkL2QzLWdlby5qc1wiKTtcbnZhciBkM19nZW9fcHJvamVjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtZ2VvLXByb2plY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtZ2VvLXByb2plY3Rpb25AMi4xLjJAZDMtZ2VvLXByb2plY3Rpb24vYnVpbGQvZDMtZ2VvLXByb2plY3Rpb24uanNcIik7XG52YXIgdmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdmlldyAqLyBcIi4vc3JjL3ZpZXcudHNcIik7XG52YXIgZ2V0X2dlb19wcm9qZWN0aW9uXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2dldC1nZW8tcHJvamVjdGlvbiAqLyBcIi4vc3JjL3V0aWwvZ2V0LWdlby1wcm9qZWN0aW9uLnRzXCIpKTtcbnZhciBhcGkgPSB7XG4gICAgLy8gZ2VvIG1haW50YWluXG4gICAgZ2VvQXJlYTogZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgcmV0dXJuIGQzX2dlb18xLmdlb0FyZWEoZmVhdHVyZSk7XG4gICAgfSxcbiAgICBnZW9BcmVhQnlOYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gZDNfZ2VvXzEuZ2VvQXJlYSh0aGlzLmdlb0ZlYXR1cmVCeU5hbWUobmFtZSkpO1xuICAgIH0sXG4gICAgZ2VvQ2VudHJvaWQ6IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIHJldHVybiBkM19nZW9fMS5nZW9DZW50cm9pZChmZWF0dXJlKTtcbiAgICB9LFxuICAgIGdlb0NlbnRyb2lkQnlOYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gZDNfZ2VvXzEuZ2VvQ2VudHJvaWQodGhpcy5nZW9GZWF0dXJlQnlOYW1lKG5hbWUpKTtcbiAgICB9LFxuICAgIGdlb0Rpc3RhbmNlOiBmdW5jdGlvbiAocDEsIHAyKSB7XG4gICAgICAgIHJldHVybiBkM19nZW9fMS5nZW9EaXN0YW5jZShwMSwgcDIpO1xuICAgIH0sXG4gICAgZ2VvTGVuZ3RoOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICByZXR1cm4gZDNfZ2VvXzEuZ2VvTGVuZ3RoKGZlYXR1cmUpO1xuICAgIH0sXG4gICAgZ2VvTGVuZ3RoQnlOYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gZDNfZ2VvXzEuZ2VvTGVuZ3RoKHRoaXMuZ2VvRmVhdHVyZUJ5TmFtZShuYW1lKSk7XG4gICAgfSxcbiAgICBnZW9Db250YWluczogZnVuY3Rpb24gKGZlYXR1cmUsIHBvc2l0aW9uIC8qIFtsb25naXR1ZGUsIGxhdGl0dWRlXSAqLykge1xuICAgICAgICByZXR1cm4gZDNfZ2VvXzEuZ2VvQ29udGFpbnMoZmVhdHVyZSwgcG9zaXRpb24pO1xuICAgIH0sXG4gICAgZ2VvRmVhdHVyZUJ5TmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHJvd3MgPSB0aGlzLnJvd3M7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHJvd3Muc29tZShmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICAgICAgaWYgKGZlYXR1cmUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZlYXR1cmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgZ2VvRmVhdHVyZUJ5UG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB2YXIgcm93cyA9IHRoaXMucm93cztcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgcm93cy5zb21lKGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgICAgICBpZiAoZDNfZ2VvXzEuZ2VvQ29udGFpbnMoZmVhdHVyZSwgcG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmVhdHVyZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBnZW9OYW1lQnlQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gdGhpcy5nZW9GZWF0dXJlQnlQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIGlmIChmZWF0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmVhdHVyZS5uYW1lO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBwcm9qZWN0aW9uXG4gICAgLy8gZXhwb3J0IGdldEdlb1Byb2plY3Rpb24gZm9yIGN1c3RvbSB1c2VkLlxuICAgIGdldEdlb1Byb2plY3Rpb246IGdldF9nZW9fcHJvamVjdGlvbl8xLmRlZmF1bHQsXG4gICAgZ2VvUHJvamVjdDogZnVuY3Rpb24gKGZlYXR1cmUsIHByb2plY3Rpb24sIGV4cG9ydFJhdykge1xuICAgICAgICBwcm9qZWN0aW9uID0gZ2V0X2dlb19wcm9qZWN0aW9uXzEuZGVmYXVsdChwcm9qZWN0aW9uLCBleHBvcnRSYXcpO1xuICAgICAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb25fMS5nZW9Qcm9qZWN0KGZlYXR1cmUsIHByb2plY3Rpb24pO1xuICAgIH0sXG4gICAgZ2VvUHJvamVjdEJ5TmFtZTogZnVuY3Rpb24gKG5hbWUsIHByb2plY3Rpb24sIGV4cG9ydFJhdykge1xuICAgICAgICBwcm9qZWN0aW9uID0gZ2V0X2dlb19wcm9qZWN0aW9uXzEuZGVmYXVsdChwcm9qZWN0aW9uLCBleHBvcnRSYXcpO1xuICAgICAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb25fMS5nZW9Qcm9qZWN0KHRoaXMuZ2VvRmVhdHVyZUJ5TmFtZShuYW1lKSwgcHJvamVjdGlvbik7XG4gICAgfSxcbiAgICBnZW9Qcm9qZWN0UG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbiwgcHJvamVjdGlvbiwgZXhwb3J0UmF3KSB7XG4gICAgICAgIHZhciBmdW5jID0gZ2V0X2dlb19wcm9qZWN0aW9uXzEuZGVmYXVsdChwcm9qZWN0aW9uLCBleHBvcnRSYXcpO1xuICAgICAgICByZXR1cm4gZnVuYyhwb3NpdGlvbik7XG4gICAgfSxcbiAgICBnZW9Qcm9qZWN0SW52ZXJ0OiBmdW5jdGlvbiAocG9zaXRpb24gLyogW3gsIHldICovLCBwcm9qZWN0aW9uLCBleHBvcnRSYXcpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBnZXRfZ2VvX3Byb2plY3Rpb25fMS5kZWZhdWx0KHByb2plY3Rpb24sIGV4cG9ydFJhdyk7XG4gICAgICAgIHJldHVybiBmdW5jLmludmVydChwb3NpdGlvbik7XG4gICAgfSxcbn07XG51dGlsXzEuYXNzaWduKHZpZXdfMS5WaWV3LnByb3RvdHlwZSwgYXBpKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9hcGkvaGllcmFyY2h5LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvYXBpL2hpZXJhcmNoeS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIHZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3ZpZXcgKi8gXCIuL3NyYy92aWV3LnRzXCIpO1xudXRpbF8xLmFzc2lnbih2aWV3XzEuVmlldy5wcm90b3R5cGUsIHtcbiAgICBnZXRBbGxOb2RlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgIGlmIChyb290ICYmIHJvb3QuZWFjaCkge1xuICAgICAgICAgICAgLy8gZDMtaGllcmFyY2h5XG4gICAgICAgICAgICByb290LmVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm9vdCAmJiByb290LmVhY2hOb2RlKSB7XG4gICAgICAgICAgICAvLyBAYW50di9oaWVyYXJjaHlcbiAgICAgICAgICAgIHJvb3QuZWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH0sXG4gICAgZ2V0QWxsTGlua3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpbmtzID0gW107XG4gICAgICAgIHZhciBub2RlcyA9IFt0aGlzLnJvb3RdO1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgd2hpbGUgKChub2RlID0gbm9kZXMucG9wKCkpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGNoaWxkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmtzO1xuICAgIH0sXG59KTtcbnV0aWxfMS5hc3NpZ24odmlld18xLlZpZXcucHJvdG90eXBlLCB7XG4gICAgZ2V0QWxsRWRnZXM6IHZpZXdfMS5WaWV3LnByb3RvdHlwZS5nZXRBbGxMaW5rcyxcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2FwaS9wYXJ0aXRpb24udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9hcGkvcGFydGl0aW9uLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBwYXJ0aXRpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvcGFydGl0aW9uICovIFwiLi9zcmMvdXRpbC9wYXJ0aXRpb24udHNcIikpO1xudmFyIHZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3ZpZXcgKi8gXCIuL3NyYy92aWV3LnRzXCIpO1xudXRpbF8xLmFzc2lnbih2aWV3XzEuVmlldy5wcm90b3R5cGUsIHtcbiAgICBwYXJ0aXRpb246IGZ1bmN0aW9uIChncm91cF9ieSwgb3JkZXJfYnkpIHtcbiAgICAgICAgaWYgKG9yZGVyX2J5ID09PSB2b2lkIDApIHsgb3JkZXJfYnkgPSBbXTsgfVxuICAgICAgICByZXR1cm4gcGFydGl0aW9uXzEuZGVmYXVsdCh0aGlzLnJvd3MsIGdyb3VwX2J5LCBvcmRlcl9ieSk7XG4gICAgfSxcbiAgICBncm91cDogZnVuY3Rpb24gKGdyb3VwX2J5LCBvcmRlcl9ieSkge1xuICAgICAgICBpZiAob3JkZXJfYnkgPT09IHZvaWQgMCkgeyBvcmRlcl9ieSA9IFtdOyB9XG4gICAgICAgIHZhciBncm91cHMgPSB0aGlzLnBhcnRpdGlvbihncm91cF9ieSwgb3JkZXJfYnkpO1xuICAgICAgICByZXR1cm4gdXRpbF8xLnZhbHVlcyhncm91cHMpO1xuICAgIH0sXG4gICAgZ3JvdXBzOiBmdW5jdGlvbiAoZ3JvdXBfYnksIG9yZGVyX2J5KSB7XG4gICAgICAgIGlmIChvcmRlcl9ieSA9PT0gdm9pZCAwKSB7IG9yZGVyX2J5ID0gW107IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXAoZ3JvdXBfYnksIG9yZGVyX2J5KTtcbiAgICB9LFxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvYXBpL3N0YXRpc3RpY3MudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvYXBpL3N0YXRpc3RpY3MudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIHNpbXBsZVN0YXRpc3RpY3MgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzaW1wbGUtc3RhdGlzdGljcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19zaW1wbGUtc3RhdGlzdGljc0A2LjEuMUBzaW1wbGUtc3RhdGlzdGljcy9kaXN0L3NpbXBsZS1zdGF0aXN0aWNzLm1pbi5qc1wiKSk7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIHZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3ZpZXcgKi8gXCIuL3NyYy92aWV3LnRzXCIpO1xudmFyIHBfYnlfZnJhY3Rpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvcC1ieS1mcmFjdGlvbiAqLyBcIi4vc3JjL3V0aWwvcC1ieS1mcmFjdGlvbi50c1wiKSk7XG52YXIgY29uc3RhbnRzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9jb25zdGFudHMgKi8gXCIuL3NyYy9jb25zdGFudHMudHNcIikpO1xudmFyIFNUQVRJU1RJQ1NfTUVUSE9EUyA9IGNvbnN0YW50c18xLmRlZmF1bHQuU1RBVElTVElDU19NRVRIT0RTO1xuZnVuY3Rpb24gZ2V0Q29sdW1uVmFsdWVzKHZpZXcsIGNvbHVtbikge1xuICAgIHZhciB2YWx1ZXMgPSB2aWV3LmdldENvbHVtbihjb2x1bW4pO1xuICAgIGlmICh1dGlsXzEuaXNBcnJheSh2YWx1ZXMpICYmIHV0aWxfMS5pc0FycmF5KHZhbHVlc1swXSkpIHtcbiAgICAgICAgdmFsdWVzID0gdXRpbF8xLmZsYXR0ZW5EZWVwKHZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG4vLyBzdGF0aXN0aWNzXG5TVEFUSVNUSUNTX01FVEhPRFMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgLy8gQHRzLWlnbm9yZTtcbiAgICB2aWV3XzEuVmlldy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gc2ltcGxlU3RhdGlzdGljc1ttZXRob2RdKGdldENvbHVtblZhbHVlcyh0aGlzLCBjb2x1bW4pKTtcbiAgICB9O1xufSk7XG52YXIgcXVhbnRpbGUgPSBzaW1wbGVTdGF0aXN0aWNzLnF1YW50aWxlO1xudXRpbF8xLmFzc2lnbih2aWV3XzEuVmlldy5wcm90b3R5cGUsIHtcbiAgICBhdmVyYWdlOiB2aWV3XzEuVmlldy5wcm90b3R5cGUubWVhbixcbiAgICBxdWFudGlsZTogZnVuY3Rpb24gKGNvbHVtbiwgcCkge1xuICAgICAgICByZXR1cm4gcXVhbnRpbGUoZ2V0Q29sdW1uVmFsdWVzKHRoaXMsIGNvbHVtbiksIHApO1xuICAgIH0sXG4gICAgcXVhbnRpbGVzOiBmdW5jdGlvbiAoY29sdW1uLCBwQXJyKSB7XG4gICAgICAgIHZhciBjb2x1bW5BcnIgPSBnZXRDb2x1bW5WYWx1ZXModGhpcywgY29sdW1uKTtcbiAgICAgICAgcmV0dXJuIHBBcnIubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBxdWFudGlsZShjb2x1bW5BcnIsIHApOyB9KTtcbiAgICB9LFxuICAgIHF1YW50aWxlc0J5RnJhY3Rpb246IGZ1bmN0aW9uIChjb2x1bW4sIGZyYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YW50aWxlcyhjb2x1bW4sIHBfYnlfZnJhY3Rpb25fMS5kZWZhdWx0KGZyYWN0aW9uKSk7XG4gICAgfSxcbiAgICByYW5nZTogZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gW3RoaXMubWluKGNvbHVtbiksIHRoaXMubWF4KGNvbHVtbildO1xuICAgIH0sXG4gICAgZXh0ZW50OiBmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIC8vIGFsaWFzXG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlKGNvbHVtbik7XG4gICAgfSxcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2Nvbm5lY3Rvci9kZWZhdWx0LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2Nvbm5lY3Rvci9kZWZhdWx0LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyQ29ubmVjdG9yKCdkZWZhdWx0JywgZnVuY3Rpb24gKGRhdGEsIGRhdGFTZXQpIHtcbiAgICB2YXIgdmlldztcbiAgICBpZiAodXRpbF8xLmlzU3RyaW5nKGRhdGEpKSB7XG4gICAgICAgIHZpZXcgPSBkYXRhU2V0LmdldFZpZXcoZGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3ID0gZGF0YTtcbiAgICB9XG4gICAgaWYgKCF2aWV3KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZGF0YVZpZXcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWxfMS5kZWVwTWl4KFtdLCB2aWV3LnJvd3MpO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29ubmVjdG9yL2Rzdi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2Nvbm5lY3Rvci9kc3YudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkM19kc3ZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLWRzdiAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1kc3ZAMS4yLjBAZDMtZHN2L2Rpc3QvZDMtZHN2LmpzXCIpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyQ29ubmVjdG9yKCdkc3YnLCBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgZGVsaW1pdGVyID0gb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJywnO1xuICAgIGlmICghdXRpbF8xLmlzU3RyaW5nKGRlbGltaXRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBkZWxpbWl0ZXI6IG11c3QgYmUgYSBzdHJpbmchJyk7XG4gICAgfVxuICAgIHJldHVybiBkM19kc3ZfMS5kc3ZGb3JtYXQoZGVsaW1pdGVyKS5wYXJzZShzdHIpO1xufSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJDb25uZWN0b3IoJ2NzdicsIGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gZDNfZHN2XzEuY3N2UGFyc2Uoc3RyKTtcbn0pO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyQ29ubmVjdG9yKCd0c3YnLCBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIGQzX2Rzdl8xLnRzdlBhcnNlKHN0cik7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb25uZWN0b3IvZ2VvLWdyYXRpY3VsZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb25uZWN0b3IvZ2VvLWdyYXRpY3VsZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGQzX2dlb18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtZ2VvICovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWdlb0AxLjYuNEBkMy1nZW8vYnVpbGQvZDMtZ2VvLmpzXCIpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xuZnVuY3Rpb24gY29ubmVjdG9yKF9vcHRpb25zLCBkYXRhVmlldykge1xuICAgIGRhdGFWaWV3LmRhdGFUeXBlID0gJ2dlby1ncmF0aWN1bGUnO1xuICAgIHZhciBkYXRhID0gZDNfZ2VvXzEuZ2VvR3JhdGljdWxlKCkubGluZXMoKTtcbiAgICBkYXRhLm1hcChmdW5jdGlvbiAocm93LCBpbmRleCkge1xuICAgICAgICByb3cuaW5kZXggPSBcIlwiICsgaW5kZXg7XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgfSk7XG4gICAgZGF0YVZpZXcucm93cyA9IGRhdGE7XG4gICAgcmV0dXJuIGRhdGE7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBjb25uZWN0b3I7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJDb25uZWN0b3IoJ2dlby1ncmF0aWN1bGUnLCBjb25uZWN0b3IpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2Nvbm5lY3Rvci9nZW9qc29uLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2Nvbm5lY3Rvci9nZW9qc29uLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciBwb2ludF9hdF9sZW5ndGhfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIHBvaW50LWF0LWxlbmd0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL19wb2ludC1hdC1sZW5ndGhAMS4xLjBAcG9pbnQtYXQtbGVuZ3RoL2luZGV4LmpzXCIpKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZDNfZ2VvXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1nZW8gKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtZ2VvQDEuNi40QGQzLWdlby9idWlsZC9kMy1nZW8uanNcIik7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgZ2VvUGF0aEdlbmVyYXRvciA9IGQzX2dlb18xLmdlb1BhdGgoKTtcbmZ1bmN0aW9uIEdlb0pTT05Db25uZWN0b3IoZGF0YSwgX29wdGlvbnMsIGRhdGFWaWV3KSB7XG4gICAgZGF0YVZpZXcuZGF0YVR5cGUgPSBkYXRhX3NldF8xLkRhdGFTZXQuQ09OU1RBTlRTLkdFTztcbiAgICB2YXIgZmVhdHVyZXMgPSB1dGlsXzEuZGVlcE1peChbXSwgZGF0YS5mZWF0dXJlcyk7XG4gICAgLy8gcHJlLXByb2Nlc3NcbiAgICBmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGZlYXR1cmUubmFtZSA9IGZlYXR1cmUucHJvcGVydGllcy5uYW1lO1xuICAgICAgICBmZWF0dXJlLmxvbmdpdHVkZSA9IFtdO1xuICAgICAgICBmZWF0dXJlLmxhdGl0dWRlID0gW107XG4gICAgICAgIHZhciBwYXRoRGF0YSA9IChmZWF0dXJlLnBhdGhEYXRhID0gZ2VvUGF0aEdlbmVyYXRvcihmZWF0dXJlKSk7XG4gICAgICAgIHZhciBwb2ludHMgPSBwb2ludF9hdF9sZW5ndGhfMS5kZWZhdWx0KHBhdGhEYXRhKTtcbiAgICAgICAgcG9pbnRzLl9wYXRoLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICBmZWF0dXJlLmxvbmdpdHVkZS5wdXNoKHBvaW50WzFdKTtcbiAgICAgICAgICAgIGZlYXR1cmUubGF0aXR1ZGUucHVzaChwb2ludFsyXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2VudHJvaWQgPSBnZW9QYXRoR2VuZXJhdG9yLmNlbnRyb2lkKGZlYXR1cmUpO1xuICAgICAgICBmZWF0dXJlLmNlbnRyb2lkWCA9IGNlbnRyb2lkWzBdO1xuICAgICAgICBmZWF0dXJlLmNlbnRyb2lkWSA9IGNlbnRyb2lkWzFdO1xuICAgIH0pO1xuICAgIC8vIGRhdGFWaWV3Lm9yaWdpbiA9IGZlYXR1cmVzO1xuICAgIHJldHVybiBmZWF0dXJlcztcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlckNvbm5lY3RvcignZ2VvJywgR2VvSlNPTkNvbm5lY3Rvcik7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJDb25uZWN0b3IoJ2dlb2pzb24nLCBHZW9KU09OQ29ubmVjdG9yKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlckNvbm5lY3RvcignR2VvSlNPTicsIEdlb0pTT05Db25uZWN0b3IpO1xuZXhwb3J0cy5kZWZhdWx0ID0gR2VvSlNPTkNvbm5lY3RvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb25uZWN0b3IvZ3JhcGgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2Nvbm5lY3Rvci9ncmFwaC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIG5vZGVzOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICByZXR1cm4gZC5ub2RlcztcbiAgICB9LFxuICAgIGVkZ2VzOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICByZXR1cm4gZC5lZGdlcztcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNvbm5lY3RvcihkYXRhLCBvcHRpb25zLCBkYXRhVmlldykge1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIGRhdGFWaWV3LmRhdGFUeXBlID0gZGF0YV9zZXRfMS5EYXRhU2V0LkNPTlNUQU5UUy5HUkFQSDtcbiAgICB2YXIgbm9kZXMgPSBvcHRpb25zLm5vZGVzLCBlZGdlcyA9IG9wdGlvbnMuZWRnZXM7XG4gICAgaWYgKG5vZGVzICYmICF1dGlsXzEuaXNGdW5jdGlvbihub2RlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBub2RlczogbXVzdCBiZSBhIGZ1bmN0aW9uIScpO1xuICAgIH1cbiAgICBpZiAoZWRnZXMgJiYgIXV0aWxfMS5pc0Z1bmN0aW9uKGVkZ2VzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGVkZ2VzOiBtdXN0IGJlIGEgZnVuY3Rpb24hJyk7XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBkYXRhVmlldy5yb3dzID0gZGF0YVZpZXcuZ3JhcGggPSB7XG4gICAgICAgIG5vZGVzOiBub2RlcyhkYXRhKSxcbiAgICAgICAgZWRnZXM6IGVkZ2VzKGRhdGEpLFxuICAgIH07XG4gICAgdXRpbF8xLmFzc2lnbihkYXRhVmlldywgZGF0YVZpZXcuZ3JhcGgpO1xuICAgIHJldHVybiBkYXRhVmlldy5yb3dzO1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyQ29ubmVjdG9yKCdncmFwaCcsIGNvbm5lY3Rvcik7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJDb25uZWN0b3IoJ2RpYWdyYW0nLCBjb25uZWN0b3IpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2Nvbm5lY3Rvci9oZXhqc29uLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2Nvbm5lY3Rvci9oZXhqc29uLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGQzX2hleGpzb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLWhleGpzb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtaGV4anNvbkAxLjEuMEBkMy1oZXhqc29uL2J1aWxkL2QzLWhleGpzb24uanNcIik7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIHdpZHRoOiAxLFxuICAgIGhlaWdodDogMSxcbn07XG5mdW5jdGlvbiBwcm9jZXNzUm93KHJvdykge1xuICAgIHJvdy5jeCA9IHJvdy54O1xuICAgIHJvdy5jeSA9IHJvdy55O1xuICAgIHJvdy54ID0gW107XG4gICAgcm93LnkgPSBbXTtcbiAgICByb3cudmVydGljZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICByb3cueC5wdXNoKHYueCArIHJvdy5jeCk7XG4gICAgICAgIHJvdy55LnB1c2godi55ICsgcm93LmN5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcm93O1xufVxuZnVuY3Rpb24gSGV4SlNPTkNvbm5lY3RvcihkYXRhLCBvcHRpb25zLCBkYXRhVmlldykge1xuICAgIGRhdGFWaWV3LmRhdGFUeXBlID0gZGF0YV9zZXRfMS5EYXRhU2V0LkNPTlNUQU5UUy5IRVg7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIHdpZHRoID0gb3B0aW9ucy53aWR0aCwgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgdmFyIEhleEpTT04gPSB1dGlsXzEuZGVlcE1peChbXSwgZGF0YSk7XG4gICAgZGF0YVZpZXcuX0hleEpTT04gPSBIZXhKU09OO1xuICAgIHZhciBncmlkID0gKGRhdGFWaWV3Ll9HcmlkSGV4SlNPTiA9IGQzX2hleGpzb25fMS5nZXRHcmlkRm9ySGV4SlNPTihIZXhKU09OKSk7XG4gICAgdmFyIHJvd3MgPSAoZGF0YVZpZXcucm93cyA9IGQzX2hleGpzb25fMS5yZW5kZXJIZXhKU09OKEhleEpTT04sIHdpZHRoLCBoZWlnaHQpLm1hcChwcm9jZXNzUm93KSk7XG4gICAgZGF0YVZpZXcuX2dyaWRSb3dzID0gZDNfaGV4anNvbl8xLnJlbmRlckhleEpTT04oZ3JpZCwgd2lkdGgsIGhlaWdodCkubWFwKHByb2Nlc3NSb3cpO1xuICAgIHJldHVybiByb3dzO1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyQ29ubmVjdG9yKCdoZXgnLCBIZXhKU09OQ29ubmVjdG9yKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlckNvbm5lY3RvcignaGV4anNvbicsIEhleEpTT05Db25uZWN0b3IpO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyQ29ubmVjdG9yKCdoZXgtanNvbicsIEhleEpTT05Db25uZWN0b3IpO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyQ29ubmVjdG9yKCdIZXhKU09OJywgSGV4SlNPTkNvbm5lY3Rvcik7XG5leHBvcnRzLmRlZmF1bHQgPSBIZXhKU09OQ29ubmVjdG9yO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2Nvbm5lY3Rvci9oaWVyYXJjaHkudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb25uZWN0b3IvaGllcmFyY2h5LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZDNfaGllcmFyY2h5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1oaWVyYXJjaHkgKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtaGllcmFyY2h5QDEuMS45QGQzLWhpZXJhcmNoeS9kaXN0L2QzLWhpZXJhcmNoeS5qc1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbmZ1bmN0aW9uIGNvbm5lY3RvcihkYXRhLCBvcHRpb25zLCBkYXRhVmlldykge1xuICAgIGRhdGFWaWV3LmRhdGFUeXBlID0gZGF0YV9zZXRfMS5EYXRhU2V0LkNPTlNUQU5UUy5ISUVSQVJDSFk7XG4gICAgdmFyIGNoaWxkcmVuID0gb3B0aW9ucyAmJiBvcHRpb25zLmNoaWxkcmVuID8gb3B0aW9ucy5jaGlsZHJlbiA6IG51bGw7XG4gICAgaWYgKGNoaWxkcmVuICYmICF1dGlsXzEuaXNGdW5jdGlvbihjaGlsZHJlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGlsZHJlbjogbXVzdCBiZSBhIGZ1bmN0aW9uIScpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMucHVyZURhdGEpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBkYXRhVmlldy5yb3dzID0gZGF0YVZpZXcucm9vdCA9IGQzX2hpZXJhcmNoeV8xLmhpZXJhcmNoeShkYXRhLCBjaGlsZHJlbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkYXRhVmlldy5yb3dzID0gZGF0YVZpZXcucm9vdCA9IGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyQ29ubmVjdG9yKCdoaWVyYXJjaHknLCBjb25uZWN0b3IpO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyQ29ubmVjdG9yKCd0cmVlJywgY29ubmVjdG9yKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb25uZWN0b3IvdG9wb2pzb24udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2Nvbm5lY3Rvci90b3BvanNvbi50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciB0b3BvanNvbl9jbGllbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRvcG9qc29uLWNsaWVudCAqLyBcIi4vbm9kZV9tb2R1bGVzL190b3BvanNvbi1jbGllbnRAMy4xLjBAdG9wb2pzb24tY2xpZW50L2Rpc3QvdG9wb2pzb24tY2xpZW50LmpzXCIpO1xudmFyIGdlb2pzb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2VvanNvbiAqLyBcIi4vc3JjL2Nvbm5lY3Rvci9nZW9qc29uLnRzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbmZ1bmN0aW9uIFRvcG9KU09OQ29ubmVjdG9yKGRhdGEsIG9wdGlvbnMsIGRhdGFWaWV3KSB7XG4gICAgdmFyIG9iamVjdCA9IG9wdGlvbnMub2JqZWN0O1xuICAgIGlmICghdXRpbF8xLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvYmplY3Q6IG11c3QgYmUgYSBzdHJpbmchJyk7XG4gICAgfVxuICAgIHZhciBnZW9EYXRhID0gdG9wb2pzb25fY2xpZW50XzEuZmVhdHVyZShkYXRhLCBkYXRhLm9iamVjdHNbb2JqZWN0XSk7XG4gICAgcmV0dXJuIGdlb2pzb25fMS5kZWZhdWx0KGdlb0RhdGEsIHVuZGVmaW5lZCwgZGF0YVZpZXcpO1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyQ29ubmVjdG9yKCd0b3BvanNvbicsIFRvcG9KU09OQ29ubmVjdG9yKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlckNvbm5lY3RvcignVG9wb0pTT04nLCBUb3BvSlNPTkNvbm5lY3Rvcik7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29uc3RhbnRzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb25zdGFudHMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgSElFUkFSQ0hZOiAnaGllcmFyY2h5JyxcbiAgICBHRU86ICdnZW8nLFxuICAgIEhFWDogJ2hleCcsXG4gICAgR1JBUEg6ICdncmFwaCcsXG4gICAgVEFCTEU6ICd0YWJsZScsXG4gICAgR0VPX0dSQVRJQ1VMRTogJ2dlby1ncmF0aWN1bGUnLFxuICAgIFNUQVRJU1RJQ1NfTUVUSE9EUzogW1xuICAgICAgICAnbWF4JyxcbiAgICAgICAgJ21lYW4nLFxuICAgICAgICAnbWVkaWFuJyxcbiAgICAgICAgJ21pbicsXG4gICAgICAgICdtb2RlJyxcbiAgICAgICAgJ3Byb2R1Y3QnLFxuICAgICAgICAnc3RhbmRhcmREZXZpYXRpb24nLFxuICAgICAgICAnc3VtJyxcbiAgICAgICAgJ3N1bVNpbXBsZScsXG4gICAgICAgICd2YXJpYW5jZScsXG4gICAgXSxcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGF0YS1zZXQudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGF0YS1zZXQudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciB3b2xmeTg3X2V2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgd29sZnk4Ny1ldmVudGVtaXR0ZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fd29sZnk4Ny1ldmVudGVtaXR0ZXJANS4yLjlAd29sZnk4Ny1ldmVudGVtaXR0ZXIvRXZlbnRFbWl0dGVyLmpzXCIpKTtcbnZhciB2aWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ZpZXcgKi8gXCIuL3NyYy92aWV3LnRzXCIpO1xudmFyIGNvbnN0YW50c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25zdGFudHMgKi8gXCIuL3NyYy9jb25zdGFudHMudHNcIikpO1xuLyoqXG4gKiDmlbDmja7pm4ZcbiAqIEBwdWJsaWNcbiAqL1xudmFyIERhdGFTZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGF0YVNldCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaW5pdGlhbFByb3BzIC0g5Yid5aeL54q25oCBXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGF0YVNldChpbml0aWFsUHJvcHMpIHtcbiAgICAgICAgaWYgKGluaXRpYWxQcm9wcyA9PT0gdm9pZCAwKSB7IGluaXRpYWxQcm9wcyA9IHsgc3RhdGU6IHt9IH07IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQpuaYryBEYXRhU2V0XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5pc0RhdGFTZXQgPSB0cnVlO1xuICAgICAgICBfdGhpcy5fb25DaGFuZ2VUaW1lciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmiYDmnInmjILlnKjmlbDmja7pm4bkuIrnmoTmlbDmja7op4blm77vvIhrZXktdmFsdWUg5a+577yJXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy52aWV3cyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICog5a2Y5YKo5pWw5o2u6ZuG5LiK55qE54q25oCB6YeP77yIa2V5LXZhbHVlIOWvue+8iVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7fTtcbiAgICAgICAgLy8gYXNzaWduKG1lLCBpbml0aWFsUHJvcHMpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IGluaXRpYWxQcm9wcy5zdGF0ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDms6jlhozkuIDkuKrmlbDmja7ov57mjqXlh73mlbDvvIzms6jlhozlkI7miYDmnInmlbDmja7op4blm77pg73lj6/ku6Xkvb/nlKggbmFtZSDmnaXlvJXnlKjov5nkuKrmlbDmja7ov57mjqXlh73mlbDvvIzku47ogIzmjqXlhaXmn5Dnp43mlbDmja7mupDjgIJcbiAgICAgKiBAcGFyYW0gbmFtZSAtIOexu+Wei1xuICAgICAqIEBwYXJhbSBjb25uZWN0b3IgLSDop6PmnpDpgLvovpFcbiAgICAgKi9cbiAgICBEYXRhU2V0LnJlZ2lzdGVyQ29ubmVjdG9yID0gZnVuY3Rpb24gKG5hbWUsIGNvbm5lY3Rvcikge1xuICAgICAgICBEYXRhU2V0LmNvbm5lY3RvcnNbbmFtZV0gPSBjb25uZWN0b3I7XG4gICAgfTtcbiAgICBEYXRhU2V0LmdldENvbm5lY3RvciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBEYXRhU2V0LmNvbm5lY3RvcnNbbmFtZV0gfHwgRGF0YVNldC5jb25uZWN0b3JzLmRlZmF1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDms6jlhozkuIDkuKrmlbDmja7lpITnkIblh73mlbDvvIzms6jlhozlkI7miYDmnInmlbDmja7op4blm77pg73lj6/ku6Xkvb/nlKggbmFtZSDmnaXlvJXnlKjov5nkuKrmlbDmja7lpITnkIblh73mlbDvvIzku47ogIzov5vooYzmn5Dnp43mlbDmja7lpITnkIZcbiAgICAgKiBAcGFyYW0gbmFtZSAtIHRyYW5zZm9ybSDnsbvlnotcbiAgICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gdHJhbnNmb3Jt6YC76L6RXG4gICAgICovXG4gICAgRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChuYW1lLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgRGF0YVNldC50cmFuc2Zvcm1zW25hbWVdID0gdHJhbnNmb3JtO1xuICAgIH07XG4gICAgRGF0YVNldC5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gRGF0YVNldC50cmFuc2Zvcm1zW25hbWVdIHx8IERhdGFTZXQudHJhbnNmb3Jtcy5kZWZhdWx0O1xuICAgIH07XG4gICAgRGF0YVNldC5wcm90b3R5cGUuX2dldFVuaXF1ZVZpZXdOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmFtZSA9IHV0aWxfMS51bmlxdWVJZCgndmlld18nKTtcbiAgICAgICAgd2hpbGUgKHRoaXMudmlld3NbbmFtZV0pIHtcbiAgICAgICAgICAgIG5hbWUgPSB1dGlsXzEudW5pcXVlSWQoJ3ZpZXdfJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcbiAgICBEYXRhU2V0LnByb3RvdHlwZS5jcmVhdGVWaWV3ID0gZnVuY3Rpb24gKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHV0aWxfMS5pc05pbChuYW1lKSkge1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMuX2dldFVuaXF1ZVZpZXdOYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWxfMS5pc09iamVjdChuYW1lKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG5hbWU7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy5fZ2V0VW5pcXVlVmlld05hbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aWV3c1tuYW1lXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGF0YSB2aWV3IGV4aXN0czogXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmlldyA9IG5ldyB2aWV3XzEuVmlldyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy52aWV3c1tuYW1lXSA9IHZpZXc7XG4gICAgICAgIHJldHVybiB2aWV3O1xuICAgIH07XG4gICAgLyoqXG4gICAgICog6L+U5ZueIG5hbWUg5a+55bqU55qE5pWw5o2u6KeG5Zu+5a6e5L6LXG4gICAgICogQHBhcmFtIG5hbWUgLSBuYW1lXG4gICAgICovXG4gICAgRGF0YVNldC5wcm90b3R5cGUuZ2V0VmlldyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdzW25hbWVdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICog6K6+572uIG5hbWUg5a+55bqU55qE5pWw5o2u6KeG5Zu+5a6e5L6L5Li6IGR2XG4gICAgICogQHBhcmFtIG5hbWUgLSDlkI3np7BcbiAgICAgKiBAcGFyYW0gdmlldyAtIGRhdGEgdmlld1xuICAgICAqL1xuICAgIERhdGFTZXQucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbiAobmFtZSwgdmlldykge1xuICAgICAgICB0aGlzLnZpZXdzW25hbWVdID0gdmlldztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIOiuvue9rueKtuaAgemHjyBuYW1lIOeahOWAvOS4uiB2YWx1ZVxuICAgICAqIEBwYXJhbSBuYW1lIC0g54q25oCB5ZCNXG4gICAgICogQHBhcmFtIHZhbHVlIC0g5YC8XG4gICAgICovXG4gICAgRGF0YVNldC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdGF0ZVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2VUaW1lcikge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9vbkNoYW5nZVRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29uQ2hhbmdlVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KCdzdGF0ZWNoYW5nZScsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSwgMTYpOyAvLyBleGVjdXRlIGFmdGVyIG9uZSBmcmFtZVxuICAgIH07XG4gICAgLyoqXG4gICAgICog5bi46YeP77yM6K2s5aaCIERhdGFTZXQuQ09OU1RBTlRTLkhJRVJBUkNIWSDmmK/moJHlvaLnu5PmnoTnmoTlkI3np7BcbiAgICAgKi9cbiAgICBEYXRhU2V0LkNPTlNUQU5UUyA9IGNvbnN0YW50c18xLmRlZmF1bHQ7XG4gICAgLyoqXG4gICAgICog5rOo5YaM55qEIENvbm5lY3Rvcu+8iGtleS12YWx1ZSDlr7nvvIlcbiAgICAgKi9cbiAgICBEYXRhU2V0LmNvbm5lY3RvcnMgPSB7fTtcbiAgICAvKipcbiAgICAgKiDlt7Lms6jlhoznmoQgVHJhbnNmb3Jt77yIa2V5LXZhbHVlIOWvue+8iVxuICAgICAqL1xuICAgIERhdGFTZXQudHJhbnNmb3JtcyA9IHt9O1xuICAgIERhdGFTZXQuRGF0YVNldCA9IERhdGFTZXQ7XG4gICAgRGF0YVNldC5EYXRhVmlldyA9IHZpZXdfMS5WaWV3OyAvLyBhbGlhc1xuICAgIERhdGFTZXQuVmlldyA9IHZpZXdfMS5WaWV3O1xuICAgIERhdGFTZXQudmVyc2lvbiA9ICdfX19fREFUQVNFVF9WRVJTSU9OX19fXyc7XG4gICAgcmV0dXJuIERhdGFTZXQ7XG59KHdvbGZ5ODdfZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5EYXRhU2V0ID0gRGF0YVNldDtcbi8vIEB0cy1pZ25vcmVcbnV0aWxfMS5hc3NpZ24oRGF0YVNldCwgY29uc3RhbnRzXzEuZGVmYXVsdCk7XG4vLyBAdHMtaWdub3JlXG51dGlsXzEuYXNzaWduKERhdGFTZXQucHJvdG90eXBlLCB7XG4gICAgdmlldzogRGF0YVNldC5wcm90b3R5cGUuY3JlYXRlVmlldyxcbn0pO1xudmlld18xLlZpZXcuRGF0YVNldCA9IERhdGFTZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGV4dHJhIEFQSXNcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYXBpL2dlbyAqLyBcIi4vc3JjL2FwaS9nZW8udHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FwaS9oaWVyYXJjaHkgKi8gXCIuL3NyYy9hcGkvaGllcmFyY2h5LnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hcGkvcGFydGl0aW9uICovIFwiLi9zcmMvYXBpL3BhcnRpdGlvbi50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYXBpL3N0YXRpc3RpY3MgKi8gXCIuL3NyYy9hcGkvc3RhdGlzdGljcy50c1wiKTtcbi8vIGNvbm5lY3RvcnNcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29ubmVjdG9yL2RlZmF1bHQgKi8gXCIuL3NyYy9jb25uZWN0b3IvZGVmYXVsdC50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29ubmVjdG9yL2RzdiAqLyBcIi4vc3JjL2Nvbm5lY3Rvci9kc3YudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Nvbm5lY3Rvci9nZW8tZ3JhdGljdWxlICovIFwiLi9zcmMvY29ubmVjdG9yL2dlby1ncmF0aWN1bGUudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Nvbm5lY3Rvci9nZW9qc29uICovIFwiLi9zcmMvY29ubmVjdG9yL2dlb2pzb24udHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Nvbm5lY3Rvci9ncmFwaCAqLyBcIi4vc3JjL2Nvbm5lY3Rvci9ncmFwaC50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29ubmVjdG9yL2hleGpzb24gKi8gXCIuL3NyYy9jb25uZWN0b3IvaGV4anNvbi50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29ubmVjdG9yL2hpZXJhcmNoeSAqLyBcIi4vc3JjL2Nvbm5lY3Rvci9oaWVyYXJjaHkudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Nvbm5lY3Rvci90b3BvanNvbiAqLyBcIi4vc3JjL2Nvbm5lY3Rvci90b3BvanNvbi50c1wiKTtcbi8vIHRyYW5zZm9ybXNcbi8vIHN0YXRpY1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vZGVmYXVsdCAqLyBcIi4vc3JjL3RyYW5zZm9ybS9kZWZhdWx0LnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vZmlsdGVyICovIFwiLi9zcmMvdHJhbnNmb3JtL2ZpbHRlci50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2ZvbGQgKi8gXCIuL3NyYy90cmFuc2Zvcm0vZm9sZC50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL21hcCAqLyBcIi4vc3JjL3RyYW5zZm9ybS9tYXAudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9wYXJ0aXRpb24gKi8gXCIuL3NyYy90cmFuc2Zvcm0vcGFydGl0aW9uLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vcGVyY2VudCAqLyBcIi4vc3JjL3RyYW5zZm9ybS9wZXJjZW50LnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vcGljayAqLyBcIi4vc3JjL3RyYW5zZm9ybS9waWNrLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vcHJvcG9ydGlvbiAqLyBcIi4vc3JjL3RyYW5zZm9ybS9wcm9wb3J0aW9uLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vcmVuYW1lICovIFwiLi9zcmMvdHJhbnNmb3JtL3JlbmFtZS50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL3JldmVyc2UgKi8gXCIuL3NyYy90cmFuc2Zvcm0vcmV2ZXJzZS50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL3NvcnQgKi8gXCIuL3NyYy90cmFuc2Zvcm0vc29ydC50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL3NvcnQtYnkgKi8gXCIuL3NyYy90cmFuc2Zvcm0vc29ydC1ieS50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL3N1YnNldCAqLyBcIi4vc3JjL3RyYW5zZm9ybS9zdWJzZXQudHNcIik7XG4vLyBpbXB1dGF0aW9uXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9maWxsLXJvd3MgKi8gXCIuL3NyYy90cmFuc2Zvcm0vZmlsbC1yb3dzLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vaW1wdXRlICovIFwiLi9zcmMvdHJhbnNmb3JtL2ltcHV0ZS50c1wiKTtcbi8vIHN0YXRpc3RpY3Ncbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2FnZ3JlZ2F0ZSAqLyBcIi4vc3JjL3RyYW5zZm9ybS9hZ2dyZWdhdGUudHNcIik7XG4vLyByZWdyZXNzaW9uXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9yZWdyZXNzaW9uICovIFwiLi9zcmMvdHJhbnNmb3JtL3JlZ3Jlc3Npb24udHNcIik7XG4vLyBLREVcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2tkZSAqLyBcIi4vc3JjL3RyYW5zZm9ybS9rZGUudHNcIik7XG4vLyBiaW5uaW5nXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9iaW4vaGV4YWdvbiAqLyBcIi4vc3JjL3RyYW5zZm9ybS9iaW4vaGV4YWdvbi50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2Jpbi9oaXN0b2dyYW0gKi8gXCIuL3NyYy90cmFuc2Zvcm0vYmluL2hpc3RvZ3JhbS50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2Jpbi9xdWFudGlsZSAqLyBcIi4vc3JjL3RyYW5zZm9ybS9iaW4vcXVhbnRpbGUudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9iaW4vcmVjdGFuZ2xlICovIFwiLi9zcmMvdHJhbnNmb3JtL2Jpbi9yZWN0YW5nbGUudHNcIik7XG4vLyBnZW9cbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2dlby9jZW50cm9pZCAqLyBcIi4vc3JjL3RyYW5zZm9ybS9nZW8vY2VudHJvaWQudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9nZW8vcHJvamVjdGlvbiAqLyBcIi4vc3JjL3RyYW5zZm9ybS9nZW8vcHJvamVjdGlvbi50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2dlby9yZWdpb24gKi8gXCIuL3NyYy90cmFuc2Zvcm0vZ2VvL3JlZ2lvbi50c1wiKTtcbi8vIGRpYWdyYW1cbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2RpYWdyYW0vYXJjICovIFwiLi9zcmMvdHJhbnNmb3JtL2RpYWdyYW0vYXJjLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vZGlhZ3JhbS9kYWdyZSAqLyBcIi4vc3JjL3RyYW5zZm9ybS9kaWFncmFtL2RhZ3JlLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vZGlhZ3JhbS9zYW5rZXkgKi8gXCIuL3NyYy90cmFuc2Zvcm0vZGlhZ3JhbS9zYW5rZXkudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9kaWFncmFtL3Zvcm9ub2kgKi8gXCIuL3NyYy90cmFuc2Zvcm0vZGlhZ3JhbS92b3Jvbm9pLnRzXCIpO1xuLy8gaGllcmFyY2h5XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9oaWVyYXJjaHkvY2x1c3RlciAqLyBcIi4vc3JjL3RyYW5zZm9ybS9oaWVyYXJjaHkvY2x1c3Rlci50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2hpZXJhcmNoeS9jb21wYWN0LWJveCAqLyBcIi4vc3JjL3RyYW5zZm9ybS9oaWVyYXJjaHkvY29tcGFjdC1ib3gudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9oaWVyYXJjaHkvZGVuZHJvZ3JhbSAqLyBcIi4vc3JjL3RyYW5zZm9ybS9oaWVyYXJjaHkvZGVuZHJvZ3JhbS50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2hpZXJhcmNoeS9pbmRlbnRlZCAqLyBcIi4vc3JjL3RyYW5zZm9ybS9oaWVyYXJjaHkvaW5kZW50ZWQudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9oaWVyYXJjaHkvcGFjayAqLyBcIi4vc3JjL3RyYW5zZm9ybS9oaWVyYXJjaHkvcGFjay50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2hpZXJhcmNoeS9wYXJ0aXRpb24gKi8gXCIuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L3BhcnRpdGlvbi50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2hpZXJhcmNoeS90cmVlICovIFwiLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS90cmVlLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vaGllcmFyY2h5L3RyZWVtYXAgKi8gXCIuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L3RyZWVtYXAudHNcIik7XG4vLyB0YWcgY2xvdWRcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL3RhZy1jbG91ZCAqLyBcIi4vc3JjL3RyYW5zZm9ybS90YWctY2xvdWQudHNcIik7XG4vLyB3YWZmbGVcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL3dhZmZsZSAqLyBcIi4vc3JjL3RyYW5zZm9ybS93YWZmbGUudHNcIik7XG4vLyBrZXJuZWwgc21vb3RoaW5nXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9rZXJuZWwtc21vb3RoL2RlbnNpdHkgKi8gXCIuL3NyYy90cmFuc2Zvcm0va2VybmVsLXNtb290aC9kZW5zaXR5LnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0va2VybmVsLXNtb290aC9yZWdyZXNzaW9uICovIFwiLi9zcmMvdHJhbnNmb3JtL2tlcm5lbC1zbW9vdGgvcmVncmVzc2lvbi50c1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBkYXRhX3NldF8xLkRhdGFTZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2FnZ3JlZ2F0ZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9hZ2dyZWdhdGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIHNpbXBsZVN0YXRpc3RpY3MgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzaW1wbGUtc3RhdGlzdGljcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19zaW1wbGUtc3RhdGlzdGljc0A2LjEuMUBzaW1wbGUtc3RhdGlzdGljcy9kaXN0L3NpbXBsZS1zdGF0aXN0aWNzLm1pbi5qc1wiKSk7XG52YXIgcGFydGl0aW9uXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL3BhcnRpdGlvbiAqLyBcIi4vc3JjL3V0aWwvcGFydGl0aW9uLnRzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciByZWdpc3RlclRyYW5zZm9ybSA9IGRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIGFzOiBbXSxcbiAgICBmaWVsZHM6IFtdLFxuICAgIGdyb3VwQnk6IFtdLFxuICAgIG9wZXJhdGlvbnM6IFtdLFxufTtcbnZhciBERUZBVUxUX09QRVJBVElPTiA9ICdjb3VudCc7XG52YXIgYWdncmVnYXRlcyA9IHtcbiAgICBjb3VudDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoO1xuICAgIH0sXG4gICAgZGlzdGluY3Q6IGZ1bmN0aW9uIChkYXRhLCBmaWVsZCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gdXRpbF8xLnVuaXEoZGF0YS5tYXAoZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcm93W2ZpZWxkXTsgfSkpO1xuICAgICAgICByZXR1cm4gdmFsdWVzLmxlbmd0aDtcbiAgICB9LFxufTtcbmRhdGFfc2V0XzEuRGF0YVNldC5DT05TVEFOVFMuU1RBVElTVElDU19NRVRIT0RTLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIGFnZ3JlZ2F0ZXNbbWV0aG9kXSA9IGZ1bmN0aW9uIChkYXRhLCBmaWVsZCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gZGF0YS5tYXAoZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcm93W2ZpZWxkXTsgfSk7XG4gICAgICAgIGlmICh1dGlsXzEuaXNBcnJheSh2YWx1ZXMpICYmIHV0aWxfMS5pc0FycmF5KHZhbHVlc1swXSkpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHV0aWxfMS5mbGF0dGVuRGVlcCh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIHNpbXBsZVN0YXRpc3RpY3NbbWV0aG9kXSh2YWx1ZXMpO1xuICAgIH07XG59KTtcbmFnZ3JlZ2F0ZXMuYXZlcmFnZSA9IGFnZ3JlZ2F0ZXMubWVhbjtcbmZ1bmN0aW9uIHRyYW5zZm9ybShkYXRhVmlldywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBmaWVsZHMgPSBvcHRpb25fcGFyc2VyXzEuZ2V0RmllbGRzKG9wdGlvbnMpO1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGZpZWxkczogaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIG9uZSBvciBtb3JlIHN0cmluZ3MhJyk7XG4gICAgfVxuICAgIHZhciBvdXRwdXROYW1lcyA9IG9wdGlvbnMuYXMgfHwgW107XG4gICAgaWYgKHV0aWxfMS5pc1N0cmluZyhvdXRwdXROYW1lcykpIHtcbiAgICAgICAgb3V0cHV0TmFtZXMgPSBbb3V0cHV0TmFtZXNdO1xuICAgIH1cbiAgICB2YXIgb3BlcmF0aW9ucyA9IG9wdGlvbnMub3BlcmF0aW9ucztcbiAgICBpZiAodXRpbF8xLmlzU3RyaW5nKG9wZXJhdGlvbnMpKSB7XG4gICAgICAgIG9wZXJhdGlvbnMgPSBbb3BlcmF0aW9uc107XG4gICAgfVxuICAgIHZhciBERUZBVUxUX09QRVJBVElPTlMgPSBbREVGQVVMVF9PUEVSQVRJT05dO1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkob3BlcmF0aW9ucykgfHwgIW9wZXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybignb3BlcmF0aW9ucyBpcyBub3QgZGVmaW5lZCwgd2lsbCB1c2UgWyBcImNvdW50XCIgXSBkaXJlY3RseS4nKTtcbiAgICAgICAgb3BlcmF0aW9ucyA9IERFRkFVTFRfT1BFUkFUSU9OUztcbiAgICAgICAgb3V0cHV0TmFtZXMgPSBvcGVyYXRpb25zO1xuICAgIH1cbiAgICBpZiAoIShvcGVyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBvcGVyYXRpb25zWzBdID09PSBERUZBVUxUX09QRVJBVElPTikpIHtcbiAgICAgICAgaWYgKG9wZXJhdGlvbnMubGVuZ3RoICE9PSBmaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBvcGVyYXRpb25zOiBpdCdzIGxlbmd0aCBtdXN0IGJlIHRoZSBzYW1lIGFzIGZpZWxkcyFcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG91dHB1dE5hbWVzLmxlbmd0aCAhPT0gZmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXM6IGl0J3MgbGVuZ3RoIG11c3QgYmUgdGhlIHNhbWUgYXMgZmllbGRzIVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZ3JvdXBzID0gcGFydGl0aW9uXzEuZGVmYXVsdChkYXRhVmlldy5yb3dzLCBvcHRpb25zLmdyb3VwQnkpO1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdXRpbF8xLmZvckluKGdyb3VwcywgZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBncm91cFswXTtcbiAgICAgICAgb3BlcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcGVyYXRpb24sIGkpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXROYW1lID0gb3V0cHV0TmFtZXNbaV07XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgICAgICByZXN1bHRbb3V0cHV0TmFtZV0gPSBhZ2dyZWdhdGVzW29wZXJhdGlvbl0oZ3JvdXAsIGZpZWxkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgIH0pO1xuICAgIGRhdGFWaWV3LnJvd3MgPSByZXN1bHRzO1xufVxucmVnaXN0ZXJUcmFuc2Zvcm0oJ2FnZ3JlZ2F0ZScsIHRyYW5zZm9ybSk7XG5yZWdpc3RlclRyYW5zZm9ybSgnc3VtbWFyeScsIHRyYW5zZm9ybSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgVkFMSURfQUdHUkVHQVRFUzogdXRpbF8xLmtleXMoYWdncmVnYXRlcyksXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9iaW4vaGV4YWdvbi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2Jpbi9oZXhhZ29uLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgYXM6IFsneCcsICd5JywgJ2NvdW50J10sXG4gICAgYmluczogWzMwLCAzMF0sXG4gICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgc2l6ZUJ5Q291bnQ6IGZhbHNlLFxufTtcbnZhciBTUVJUMyA9IE1hdGguc3FydCgzKTtcbnZhciBUSElSRF9QSSA9IE1hdGguUEkgLyAzO1xudmFyIEFOR0xFUyA9IFswLCBUSElSRF9QSSwgMiAqIFRISVJEX1BJLCAzICogVEhJUkRfUEksIDQgKiBUSElSRF9QSSwgNSAqIFRISVJEX1BJXTtcbmZ1bmN0aW9uIGRpc3RhbmNlKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgoeDAgLSB4MSkgKiAoeDAgLSB4MSkgKyAoeTAgLSB5MSkgKiAoeTAgLSB5MSkpO1xufVxuZnVuY3Rpb24gbmVhcmVzdEJpbnNDZW50ZXJzKHZhbHVlLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgdmFyIHRlbXAgPSB2YWx1ZSAtIG9mZnNldDtcbiAgICBzY2FsZSA9IHNjYWxlIC8gMjtcbiAgICB2YXIgZGl2ID0gTWF0aC5mbG9vcih0ZW1wIC8gc2NhbGUpO1xuICAgIHZhciByb3VuZGVkID0gc2NhbGUgKiAoZGl2ICsgKE1hdGguYWJzKGRpdiAlIDIpID09PSAxID8gMSA6IDApKTtcbiAgICB2YXIgcm91bmRlZFNjYWxlZCA9IHNjYWxlICogKGRpdiArIChNYXRoLmFicyhkaXYgJSAyKSA9PT0gMSA/IDAgOiAxKSk7XG4gICAgcmV0dXJuIFtyb3VuZGVkICsgb2Zmc2V0LCByb3VuZGVkU2NhbGVkICsgb2Zmc2V0XTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQmlucyhwb2ludHMsIGJpbldpZHRoLCBvZmZzZXQpIHtcbiAgICBpZiAoYmluV2lkdGggPT09IHZvaWQgMCkgeyBiaW5XaWR0aCA9IFsxLCAxXTsgfVxuICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSBbMCwgMF07IH1cbiAgICAvLyBwcm9jZXNzaW5nIGFsaWduZWQgZGF0YVxuICAgIHZhciBiaW5zID0ge307XG4gICAgdmFyIF9hID0gdHNsaWJfMS5fX3JlYWQoYmluV2lkdGgsIDIpLCBiaW5XaWR0aFggPSBfYVswXSwgYmluV2lkdGhZID0gX2FbMV07XG4gICAgdmFyIF9iID0gdHNsaWJfMS5fX3JlYWQob2Zmc2V0LCAyKSwgb2Zmc2V0WCA9IF9iWzBdLCBvZmZzZXRZID0gX2JbMV07XG4gICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBfYyA9IHRzbGliXzEuX19yZWFkKHBvaW50LCAyKSwgeCA9IF9jWzBdLCB5ID0gX2NbMV07XG4gICAgICAgIC8vIHN0ZXAzLjE6IG5lYXJlc3QgdHdvIGNlbnRlcnNcbiAgICAgICAgdmFyIF9kID0gdHNsaWJfMS5fX3JlYWQobmVhcmVzdEJpbnNDZW50ZXJzKHgsIGJpbldpZHRoWCwgb2Zmc2V0WCksIDIpLCB4Um91bmRlZCA9IF9kWzBdLCB4Um91bmRlZFNjYWxlZCA9IF9kWzFdO1xuICAgICAgICB2YXIgX2UgPSB0c2xpYl8xLl9fcmVhZChuZWFyZXN0Qmluc0NlbnRlcnMoeSwgYmluV2lkdGhZLCBvZmZzZXRZKSwgMiksIHlSb3VuZGVkID0gX2VbMF0sIHlSb3VuZGVkU2NhbGVkID0gX2VbMV07XG4gICAgICAgIC8vIHN0ZXAzLjI6IGNvbXBhcmUgZGlzdGFuY2VzXG4gICAgICAgIHZhciBkMSA9IGRpc3RhbmNlKHgsIHksIHhSb3VuZGVkLCB5Um91bmRlZCk7XG4gICAgICAgIHZhciBkMiA9IGRpc3RhbmNlKHgsIHksIHhSb3VuZGVkU2NhbGVkLCB5Um91bmRlZFNjYWxlZCk7XG4gICAgICAgIHZhciBiaW5LZXk7XG4gICAgICAgIHZhciBiaW5YO1xuICAgICAgICB2YXIgYmluWTtcbiAgICAgICAgaWYgKGQxIDwgZDIpIHtcbiAgICAgICAgICAgIGJpbktleSA9IFwieFwiICsgeFJvdW5kZWQgKyBcInlcIiArIHlSb3VuZGVkO1xuICAgICAgICAgICAgX2EgPSB0c2xpYl8xLl9fcmVhZChbeFJvdW5kZWQsIHlSb3VuZGVkXSwgMiksIGJpblggPSBfYVswXSwgYmluWSA9IF9hWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmluS2V5ID0gXCJ4XCIgKyB4Um91bmRlZFNjYWxlZCArIFwieVwiICsgeVJvdW5kZWRTY2FsZWQ7XG4gICAgICAgICAgICBfYiA9IHRzbGliXzEuX19yZWFkKFt4Um91bmRlZFNjYWxlZCwgeVJvdW5kZWRTY2FsZWRdLCAyKSwgYmluWCA9IF9iWzBdLCBiaW5ZID0gX2JbMV07XG4gICAgICAgIH1cbiAgICAgICAgYmluc1tiaW5LZXldID0gYmluc1tiaW5LZXldIHx8IHtcbiAgICAgICAgICAgIHg6IGJpblgsXG4gICAgICAgICAgICB5OiBiaW5ZLFxuICAgICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGJpbnNbYmluS2V5XS5jb3VudCsrO1xuICAgIH0pO1xuICAgIHJldHVybiBiaW5zO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgLy8gc3RlcDE6IGdldCBiaW5XaWR0aCwgZXRjLlxuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBmaWVsZHMgPSBvcHRpb25fcGFyc2VyXzEuZ2V0RmllbGRzKG9wdGlvbnMpO1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkoZmllbGRzKSB8fCBmaWVsZHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZmllbGRzOiBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggMiBzdHJpbmdzIScpO1xuICAgIH1cbiAgICB2YXIgX2EgPSB0c2xpYl8xLl9fcmVhZChmaWVsZHMsIDIpLCBmaWVsZFggPSBfYVswXSwgZmllbGRZID0gX2FbMV07XG4gICAgdmFyIHJhbmdlRmllbGRYID0gZGF0YVZpZXcucmFuZ2UoZmllbGRYKTtcbiAgICB2YXIgcmFuZ2VGaWVsZFkgPSBkYXRhVmlldy5yYW5nZShmaWVsZFkpO1xuICAgIHZhciB3aWR0aFggPSByYW5nZUZpZWxkWFsxXSAtIHJhbmdlRmllbGRYWzBdO1xuICAgIHZhciB3aWR0aFkgPSByYW5nZUZpZWxkWVsxXSAtIHJhbmdlRmllbGRZWzBdO1xuICAgIHZhciBiaW5XaWR0aCA9IG9wdGlvbnMuYmluV2lkdGggfHwgW107XG4gICAgaWYgKGJpbldpZHRoLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB2YXIgX2IgPSB0c2xpYl8xLl9fcmVhZChvcHRpb25zLmJpbnMsIDIpLCBiaW5zWCA9IF9iWzBdLCBiaW5zWSA9IF9iWzFdO1xuICAgICAgICBpZiAoYmluc1ggPD0gMCB8fCBiaW5zWSA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGJpbnM6IG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0d28gcG9zaXRpdmUgbnVtYmVycyAoZS5nLiBbIDMwLCAzMCBdKSEnKTtcbiAgICAgICAgfVxuICAgICAgICBiaW5XaWR0aCA9IFt3aWR0aFggLyBiaW5zWCwgd2lkdGhZIC8gYmluc1ldO1xuICAgIH1cbiAgICAvLyBzdGVwMjogYWxpZ24gc2NhbGUgKHNxdWFzaCBZKVxuICAgIC8qXG4gICAgICogYmluV2lkdGhYIC8gYmluV2lkdGhZIHNob3VsZCBiZSBNYXRoLnNxcnQzIC8gMS41XG4gICAgICogLTogYmluV2lkdGhYIHw6IGJpbldpZHRoWVxuICAgICAqICAgICAgICAgICAzXG4gICAgICogICAgICAgICAgIHxcbiAgICAgKiAgIDQgICAgICAgfCAgICAgICAgMlxuICAgICAqICAgICAgICAgICB8XG4gICAgICogICAgICAgICAgIHxcbiAgICAgKiAgIDUtLS0tLS0tLS0tLS0tLS0tMVxuICAgICAqXG4gICAgICogICAgICAgICAgIDBcbiAgICAgKi9cbiAgICB2YXIgX2MgPSB0c2xpYl8xLl9fcmVhZChvcHRpb25zLm9mZnNldCwgMiksIG9mZnNldFggPSBfY1swXSwgb2Zmc2V0WSA9IF9jWzFdO1xuICAgIHZhciB5U2NhbGUgPSAoMyAqIGJpbldpZHRoWzBdKSAvIChTUVJUMyAqIGJpbldpZHRoWzFdKTtcbiAgICAvLyBjb25zdCB5U2NhbGUgPSBiaW5XaWR0aFswXSAvIChTUVJUMyAqIGJpbldpZHRoWzFdKTtcbiAgICB2YXIgcG9pbnRzID0gZGF0YVZpZXcucm93cy5tYXAoZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gW3Jvd1tmaWVsZFhdLCB5U2NhbGUgKiByb3dbZmllbGRZXV07IH0pO1xuICAgIC8vIHN0ZXAzOiBiaW5uaW5nXG4gICAgdmFyIGJpbnMgPSBnZW5lcmF0ZUJpbnMocG9pbnRzLCBbYmluV2lkdGhbMF0sIHlTY2FsZSAqIGJpbldpZHRoWzFdXSwgW29mZnNldFgsIHlTY2FsZSAqIG9mZnNldFldKTtcbiAgICAvLyBzdGVwNDogcmVzdG9yZSBzY2FsZSAoZm9yIFkpXG4gICAgdmFyIF9kID0gdHNsaWJfMS5fX3JlYWQob3B0aW9ucy5hcywgMyksIGFzWCA9IF9kWzBdLCBhc1kgPSBfZFsxXSwgYXNDb3VudCA9IF9kWzJdO1xuICAgIGlmICghYXNYIHx8ICFhc1kgfHwgIWFzQ291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhczogaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHRocmVlIGVsZW1lbnRzIChlLmcuIFsgXCJ4XCIsIFwieVwiLCBcImNvdW50XCIgXSkhJyk7XG4gICAgfVxuICAgIHZhciByYWRpdXMgPSBiaW5XaWR0aFswXSAvIFNRUlQzO1xuICAgIHZhciBoZXhhZ29uUG9pbnRzID0gQU5HTEVTLm1hcChmdW5jdGlvbiAoYW5nbGUpIHsgcmV0dXJuIFtNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsIC1NYXRoLmNvcyhhbmdsZSkgKiByYWRpdXNdOyB9KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIG1heENvdW50ID0gMDtcbiAgICBpZiAob3B0aW9ucy5zaXplQnlDb3VudCkge1xuICAgICAgICB1dGlsXzEuZm9ySW4oYmlucywgZnVuY3Rpb24gKGJpbikge1xuICAgICAgICAgICAgaWYgKGJpbi5jb3VudCA+IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgbWF4Q291bnQgPSBiaW4uY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1dGlsXzEuZm9ySW4oYmlucywgZnVuY3Rpb24gKGJpbikge1xuICAgICAgICB2YXIgeCA9IGJpbi54LCB5ID0gYmluLnksIGNvdW50ID0gYmluLmNvdW50O1xuICAgICAgICB2YXIgcm93ID0ge307XG4gICAgICAgIHJvd1thc0NvdW50XSA9IGNvdW50O1xuICAgICAgICBpZiAob3B0aW9ucy5zaXplQnlDb3VudCkge1xuICAgICAgICAgICAgcm93W2FzWF0gPSBoZXhhZ29uUG9pbnRzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4geCArIChiaW4uY291bnQgLyBtYXhDb3VudCkgKiBwWzBdOyB9KTtcbiAgICAgICAgICAgIHJvd1thc1ldID0gaGV4YWdvblBvaW50cy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuICh5ICsgKGJpbi5jb3VudCAvIG1heENvdW50KSAqIHBbMV0pIC8geVNjYWxlOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvd1thc1hdID0gaGV4YWdvblBvaW50cy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHggKyBwWzBdOyB9KTtcbiAgICAgICAgICAgIHJvd1thc1ldID0gaGV4YWdvblBvaW50cy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuICh5ICsgcFsxXSkgLyB5U2NhbGU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHJvdyk7XG4gICAgfSk7XG4gICAgZGF0YVZpZXcucm93cyA9IHJlc3VsdDtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnYmluLmhleGFnb24nLCB0cmFuc2Zvcm0pO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdiaW4uaGV4JywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnaGV4YmluJywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vYmluL2hpc3RvZ3JhbS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vYmluL2hpc3RvZ3JhbS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIHBhcnRpdGlvbl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9wYXJ0aXRpb24gKi8gXCIuL3NyYy91dGlsL3BhcnRpdGlvbi50c1wiKSk7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgb3B0aW9uX3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvdXRpbC9vcHRpb24tcGFyc2VyLnRzXCIpO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBhczogWyd4JywgJ2NvdW50J10sXG4gICAgYmluczogMzAsXG4gICAgb2Zmc2V0OiAwLFxuICAgIGdyb3VwQnk6IFtdLFxufTtcbmZ1bmN0aW9uIG5lYXJlc3RCaW4odmFsdWUsIHNjYWxlLCBvZmZzZXQpIHtcbiAgICB2YXIgdGVtcCA9IHZhbHVlIC0gb2Zmc2V0O1xuICAgIHZhciBkaXYgPSBNYXRoLmZsb29yKHRlbXAgLyBzY2FsZSk7XG4gICAgcmV0dXJuIFtkaXYgKiBzY2FsZSArIG9mZnNldCwgKGRpdiArIDEpICogc2NhbGUgKyBvZmZzZXRdO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGZpZWxkID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkKG9wdGlvbnMpO1xuICAgIGlmIChkYXRhVmlldy5yb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByYW5nZSA9IGRhdGFWaWV3LnJhbmdlKGZpZWxkKTtcbiAgICB2YXIgd2lkdGggPSByYW5nZVsxXSAtIHJhbmdlWzBdO1xuICAgIHZhciBiaW5XaWR0aCA9IG9wdGlvbnMuYmluV2lkdGg7XG4gICAgaWYgKCFiaW5XaWR0aCkge1xuICAgICAgICB2YXIgYmlucyA9IG9wdGlvbnMuYmlucztcbiAgICAgICAgaWYgKGJpbnMgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBiaW5zOiBpdCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyIScpO1xuICAgICAgICB9XG4gICAgICAgIGJpbldpZHRoID0gd2lkdGggLyBiaW5zO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgJSBiaW5XaWR0aDtcbiAgICAvLyBncm91cGluZ1xuICAgIHZhciByb3dzID0gW107XG4gICAgdmFyIGdyb3VwQnkgPSBvcHRpb25zLmdyb3VwQnk7XG4gICAgdmFyIGdyb3VwcyA9IHBhcnRpdGlvbl8xLmRlZmF1bHQoZGF0YVZpZXcucm93cywgZ3JvdXBCeSk7XG4gICAgdXRpbF8xLmZvckluKGdyb3VwcywgZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIHZhciBiaW5zID0ge307XG4gICAgICAgIHZhciBjb2x1bW4gPSBncm91cC5tYXAoZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcm93W2ZpZWxkXTsgfSk7XG4gICAgICAgIGNvbHVtbi5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF9hID0gdHNsaWJfMS5fX3JlYWQobmVhcmVzdEJpbih2YWx1ZSwgYmluV2lkdGgsIG9mZnNldCksIDIpLCB4MCA9IF9hWzBdLCB4MSA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIGJpbktleSA9IHgwICsgXCItXCIgKyB4MTtcbiAgICAgICAgICAgIGJpbnNbYmluS2V5XSA9IGJpbnNbYmluS2V5XSB8fCB7XG4gICAgICAgICAgICAgICAgeDA6IHgwLFxuICAgICAgICAgICAgICAgIHgxOiB4MSxcbiAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBiaW5zW2JpbktleV0uY291bnQrKztcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfYSA9IHRzbGliXzEuX19yZWFkKG9wdGlvbnMuYXMsIDIpLCBhc1ggPSBfYVswXSwgYXNDb3VudCA9IF9hWzFdO1xuICAgICAgICBpZiAoIWFzWCB8fCAhYXNDb3VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhczogaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIDIgZWxlbWVudHMgKGUuZy4gWyBcInhcIiwgXCJjb3VudFwiIF0pIScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXRhID0gdXRpbF8xLnBpY2soZ3JvdXBbMF0sIGdyb3VwQnkpO1xuICAgICAgICB1dGlsXzEuZm9ySW4oYmlucywgZnVuY3Rpb24gKGJpbikge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHV0aWxfMS5hc3NpZ24oe30sIG1ldGEpO1xuICAgICAgICAgICAgcm93W2FzWF0gPSBbYmluLngwLCBiaW4ueDFdO1xuICAgICAgICAgICAgcm93W2FzQ291bnRdID0gYmluLmNvdW50O1xuICAgICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGRhdGFWaWV3LnJvd3MgPSByb3dzO1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdiaW4uaGlzdG9ncmFtJywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnYmluLmRvdCcsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2Jpbi9xdWFudGlsZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9iaW4vcXVhbnRpbGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIHNpbXBsZV9zdGF0aXN0aWNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzaW1wbGUtc3RhdGlzdGljcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19zaW1wbGUtc3RhdGlzdGljc0A2LjEuMUBzaW1wbGUtc3RhdGlzdGljcy9kaXN0L3NpbXBsZS1zdGF0aXN0aWNzLm1pbi5qc1wiKTtcbnZhciBwYXJ0aXRpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvcGFydGl0aW9uICovIFwiLi9zcmMvdXRpbC9wYXJ0aXRpb24udHNcIikpO1xudmFyIHBfYnlfZnJhY3Rpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvcC1ieS1mcmFjdGlvbiAqLyBcIi4vc3JjL3V0aWwvcC1ieS1mcmFjdGlvbi50c1wiKSk7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgcmVnaXN0ZXJUcmFuc2Zvcm0gPSBkYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm07XG52YXIgb3B0aW9uX3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvdXRpbC9vcHRpb24tcGFyc2VyLnRzXCIpO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBhczogJ19iaW4nLFxuICAgIGdyb3VwQnk6IFtdLFxuICAgIGZyYWN0aW9uOiA0LFxufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShkYXRhVmlldywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBmaWVsZCA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZChvcHRpb25zKTtcbiAgICB2YXIgYXMgPSBvcHRpb25zLmFzO1xuICAgIGlmICghdXRpbF8xLmlzU3RyaW5nKGFzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFzOiBpdCBtdXN0IGJlIGEgc3RyaW5nIChlLmcuIFwiX2JpblwiKSEnKTtcbiAgICB9XG4gICAgdmFyIHBBcnJheSA9IG9wdGlvbnMucDtcbiAgICB2YXIgZnJhY3Rpb24gPSBvcHRpb25zLmZyYWN0aW9uO1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkocEFycmF5KSB8fCBwQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHBBcnJheSA9IHBfYnlfZnJhY3Rpb25fMS5kZWZhdWx0KGZyYWN0aW9uKTtcbiAgICB9XG4gICAgdmFyIHJvd3MgPSBkYXRhVmlldy5yb3dzO1xuICAgIHZhciBncm91cEJ5ID0gb3B0aW9ucy5ncm91cEJ5O1xuICAgIHZhciBncm91cHMgPSBwYXJ0aXRpb25fMS5kZWZhdWx0KHJvd3MsIGdyb3VwQnkpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB1dGlsXzEuZm9ySW4oZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgLy8gY29uc3QgcmVzdWx0Um93ID0gcGljayhncm91cFswXSwgZ3JvdXBCeSk7XG4gICAgICAgIHZhciByZXN1bHRSb3cgPSBncm91cFswXTtcbiAgICAgICAgdmFyIGJpbm5pbmdDb2x1bW4gPSBncm91cC5tYXAoZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcm93W2ZpZWxkXTsgfSk7XG4gICAgICAgIHZhciBxdWFudGlsZXMgPSBwQXJyYXkubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBzaW1wbGVfc3RhdGlzdGljc18xLnF1YW50aWxlKGJpbm5pbmdDb2x1bW4sIHApOyB9KTtcbiAgICAgICAgcmVzdWx0Um93W2FzXSA9IHF1YW50aWxlcztcbiAgICAgICAgcmVzdWx0LnB1c2gocmVzdWx0Um93KTtcbiAgICB9KTtcbiAgICBkYXRhVmlldy5yb3dzID0gcmVzdWx0O1xufVxucmVnaXN0ZXJUcmFuc2Zvcm0oJ2Jpbi5xdWFudGlsZScsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2Jpbi9yZWN0YW5nbGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2Jpbi9yZWN0YW5nbGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciByZWdpc3RlclRyYW5zZm9ybSA9IGRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIGFzOiBbJ3gnLCAneScsICdjb3VudCddLFxuICAgIGJpbnM6IFszMCwgMzBdLFxuICAgIG9mZnNldDogWzAsIDBdLFxuICAgIHNpemVCeUNvdW50OiBmYWxzZSxcbn07XG5mdW5jdGlvbiBuZWFyZXN0QmluKHZhbHVlLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgdmFyIHRlbXAgPSB2YWx1ZSAtIG9mZnNldDtcbiAgICB2YXIgZGl2ID0gTWF0aC5mbG9vcih0ZW1wIC8gc2NhbGUpO1xuICAgIHJldHVybiBbZGl2ICogc2NhbGUgKyBvZmZzZXQsIChkaXYgKyAxKSAqIHNjYWxlICsgb2Zmc2V0XTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybShkYXRhVmlldywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBfYSA9IHRzbGliXzEuX19yZWFkKG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZHMob3B0aW9ucyksIDIpLCBmaWVsZFggPSBfYVswXSwgZmllbGRZID0gX2FbMV07XG4gICAgaWYgKCFmaWVsZFggfHwgIWZpZWxkWSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGZpZWxkczogbXVzdCBiZSBhbiBhcnJheSB3aXRoIDIgc3RyaW5ncyEnKTtcbiAgICB9XG4gICAgdmFyIHJhbmdlRmllbGRYID0gZGF0YVZpZXcucmFuZ2UoZmllbGRYKTtcbiAgICB2YXIgcmFuZ2VGaWVsZFkgPSBkYXRhVmlldy5yYW5nZShmaWVsZFkpO1xuICAgIHZhciB3aWR0aFggPSByYW5nZUZpZWxkWFsxXSAtIHJhbmdlRmllbGRYWzBdO1xuICAgIHZhciB3aWR0aFkgPSByYW5nZUZpZWxkWVsxXSAtIHJhbmdlRmllbGRZWzBdO1xuICAgIHZhciBiaW5XaWR0aCA9IG9wdGlvbnMuYmluV2lkdGggfHwgW107XG4gICAgaWYgKGJpbldpZHRoLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB2YXIgX2IgPSB0c2xpYl8xLl9fcmVhZChvcHRpb25zLmJpbnMsIDIpLCBiaW5zWCA9IF9iWzBdLCBiaW5zWSA9IF9iWzFdO1xuICAgICAgICBpZiAoYmluc1ggPD0gMCB8fCBiaW5zWSA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGJpbnM6IG11c3QgYmUgYW4gYXJyYXkgd2l0aCAyIHBvc2l0aXZlIG51bWJlcnMgKGUuZy4gWyAzMCwgMzAgXSkhJyk7XG4gICAgICAgIH1cbiAgICAgICAgYmluV2lkdGggPSBbd2lkdGhYIC8gYmluc1gsIHdpZHRoWSAvIGJpbnNZXTtcbiAgICB9XG4gICAgdmFyIHBvaW50cyA9IGRhdGFWaWV3LnJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIFtyb3dbZmllbGRYXSwgcm93W2ZpZWxkWV1dOyB9KTtcbiAgICB2YXIgYmlucyA9IHt9O1xuICAgIHZhciBfYyA9IHRzbGliXzEuX19yZWFkKG9wdGlvbnMub2Zmc2V0LCAyKSwgb2Zmc2V0WCA9IF9jWzBdLCBvZmZzZXRZID0gX2NbMV07XG4gICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHZhciBfYSA9IHRzbGliXzEuX19yZWFkKG5lYXJlc3RCaW4ocG9pbnRbMF0sIGJpbldpZHRoWzBdLCBvZmZzZXRYKSwgMiksIHgwID0gX2FbMF0sIHgxID0gX2FbMV07XG4gICAgICAgIHZhciBfYiA9IHRzbGliXzEuX19yZWFkKG5lYXJlc3RCaW4ocG9pbnRbMV0sIGJpbldpZHRoWzFdLCBvZmZzZXRZKSwgMiksIHkwID0gX2JbMF0sIHkxID0gX2JbMV07XG4gICAgICAgIHZhciBiaW5LZXkgPSB4MCArIFwiLVwiICsgeDEgKyBcIi1cIiArIHkwICsgXCItXCIgKyB5MTtcbiAgICAgICAgYmluc1tiaW5LZXldID0gYmluc1tiaW5LZXldIHx8IHtcbiAgICAgICAgICAgIHgwOiB4MCxcbiAgICAgICAgICAgIHgxOiB4MSxcbiAgICAgICAgICAgIHkwOiB5MCxcbiAgICAgICAgICAgIHkxOiB5MSxcbiAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICB9O1xuICAgICAgICBiaW5zW2JpbktleV0uY291bnQrKztcbiAgICB9KTtcbiAgICB2YXIgcm93cyA9IFtdO1xuICAgIHZhciBfZCA9IHRzbGliXzEuX19yZWFkKG9wdGlvbnMuYXMsIDMpLCBhc1ggPSBfZFswXSwgYXNZID0gX2RbMV0sIGFzQ291bnQgPSBfZFsyXTtcbiAgICBpZiAoIWFzWCB8fCAhYXNZIHx8ICFhc0NvdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXM6IGl0IG11c3QgYmUgYW4gYXJyYXkgd2l0aCAzIHN0cmluZ3MgKGUuZy4gWyBcInhcIiwgXCJ5XCIsIFwiY291bnRcIiBdKSEnKTtcbiAgICB9XG4gICAgLyogcG9pbnRzXG4gICAgICogMy0tLTJcbiAgICAgKiB8ICAgfFxuICAgICAqIDAtLS0xXG4gICAgICovXG4gICAgaWYgKCFvcHRpb25zLnNpemVCeUNvdW50KSB7XG4gICAgICAgIHV0aWxfMS5mb3JJbihiaW5zLCBmdW5jdGlvbiAoYmluKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0ge307XG4gICAgICAgICAgICByb3dbYXNYXSA9IFtiaW4ueDAsIGJpbi54MSwgYmluLngxLCBiaW4ueDBdO1xuICAgICAgICAgICAgcm93W2FzWV0gPSBbYmluLnkwLCBiaW4ueTAsIGJpbi55MSwgYmluLnkxXTtcbiAgICAgICAgICAgIHJvd1thc0NvdW50XSA9IGJpbi5jb3VudDtcbiAgICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBtYXhDb3VudF8xID0gMDtcbiAgICAgICAgdXRpbF8xLmZvckluKGJpbnMsIGZ1bmN0aW9uIChiaW4pIHtcbiAgICAgICAgICAgIGlmIChiaW4uY291bnQgPiBtYXhDb3VudF8xKSB7XG4gICAgICAgICAgICAgICAgbWF4Q291bnRfMSA9IGJpbi5jb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHV0aWxfMS5mb3JJbihiaW5zLCBmdW5jdGlvbiAoYmluKSB7XG4gICAgICAgICAgICB2YXIgeDAgPSBiaW4ueDAsIHgxID0gYmluLngxLCB5MCA9IGJpbi55MCwgeTEgPSBiaW4ueTEsIGNvdW50ID0gYmluLmNvdW50O1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gY291bnQgLyBtYXhDb3VudF8xO1xuICAgICAgICAgICAgdmFyIF9hID0gdHNsaWJfMS5fX3JlYWQoWyh4MCArIHgxKSAvIDIsICh5MCArIHkxKSAvIDJdLCAyKSwgY3ggPSBfYVswXSwgY3kgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciByeCA9ICgoeDEgLSB4MCkgKiBzY2FsZSkgLyAyO1xuICAgICAgICAgICAgdmFyIHJ5ID0gKCh5MSAtIHkwKSAqIHNjYWxlKSAvIDI7XG4gICAgICAgICAgICB2YXIgeDAxID0gY3ggLSByeDtcbiAgICAgICAgICAgIHZhciB4MTEgPSBjeCArIHJ4O1xuICAgICAgICAgICAgdmFyIHkwMSA9IGN5IC0gcnk7XG4gICAgICAgICAgICB2YXIgeTExID0gY3kgKyByeTtcbiAgICAgICAgICAgIHZhciByb3cgPSB7fTtcbiAgICAgICAgICAgIHJvd1thc1hdID0gW3gwMSwgeDExLCB4MTEsIHgwMV07XG4gICAgICAgICAgICByb3dbYXNZXSA9IFt5MDEsIHkwMSwgeTExLCB5MTFdO1xuICAgICAgICAgICAgcm93W2FzQ291bnRdID0gY291bnQ7XG4gICAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGFWaWV3LnJvd3MgPSByb3dzO1xufVxucmVnaXN0ZXJUcmFuc2Zvcm0oJ2Jpbi5yZWN0YW5nbGUnLCB0cmFuc2Zvcm0pO1xucmVnaXN0ZXJUcmFuc2Zvcm0oJ2Jpbi5yZWN0JywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vZGVmYXVsdC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vZGVmYXVsdC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdkZWZhdWx0JywgZnVuY3Rpb24gKGRhdGFWaWV3KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2RpYWdyYW0vYXJjLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vZGlhZ3JhbS9hcmMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKlxuICogZm9yIEFyYyBEaWFncmFtIChlZGdlcyB3aXRob3V0IHdlaWdodCkgLyBDaG9yZCBEaWFncmFtIChlZGdlcyB3aXRoIHNvdXJjZSBhbmQgdGFyZ2V0IHdlaWdodClcbiAqIGdyYXBoIGRhdGEgcmVxdWlyZWQgKG5vZGVzLCBlZGdlcylcbiAqL1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgeTogMCxcbiAgICB0aGlja25lc3M6IDAuMDUsXG4gICAgd2VpZ2h0OiBmYWxzZSxcbiAgICBtYXJnaW5SYXRpbzogMC4xLFxuICAgIGlkOiBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5pZDsgfSxcbiAgICBzb3VyY2U6IGZ1bmN0aW9uIChlZGdlKSB7IHJldHVybiBlZGdlLnNvdXJjZTsgfSxcbiAgICB0YXJnZXQ6IGZ1bmN0aW9uIChlZGdlKSB7IHJldHVybiBlZGdlLnRhcmdldDsgfSxcbiAgICBzb3VyY2VXZWlnaHQ6IGZ1bmN0aW9uIChlZGdlKSB7IHJldHVybiBlZGdlLnZhbHVlIHx8IDE7IH0sXG4gICAgdGFyZ2V0V2VpZ2h0OiBmdW5jdGlvbiAoZWRnZSkgeyByZXR1cm4gZWRnZS52YWx1ZSB8fCAxOyB9LFxuICAgIHNvcnRCeTogbnVsbCxcbn07XG5mdW5jdGlvbiBfbm9kZXNGcm9tRWRnZXMoZWRnZXMsIG9wdGlvbnMsIG1hcCkge1xuICAgIGlmIChtYXAgPT09IHZvaWQgMCkgeyBtYXAgPSB7fTsgfVxuICAgIGVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgdmFyIHNJZCA9IG9wdGlvbnMuZWRnZVNvdXJjZShlZGdlKTtcbiAgICAgICAgdmFyIHRJZCA9IG9wdGlvbnMuZWRnZVRhcmdldChlZGdlKTtcbiAgICAgICAgaWYgKCFtYXBbc0lkXSkge1xuICAgICAgICAgICAgbWFwW3NJZF0gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IHNJZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXBbdElkXSkge1xuICAgICAgICAgICAgbWFwW3RJZF0gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IHRJZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdXRpbF8xLnZhbHVlcyhtYXApO1xufVxuZnVuY3Rpb24gX3Byb2Nlc3NHcmFwaChub2RlQnlJZCwgZWRnZXMsIG9wdGlvbnMpIHtcbiAgICB1dGlsXzEuZm9ySW4obm9kZUJ5SWQsIGZ1bmN0aW9uIChub2RlLCBpZCkge1xuICAgICAgICAvLyBpbiBlZGdlcywgb3V0IGVkZ2VzXG4gICAgICAgIG5vZGUuaW5FZGdlcyA9IGVkZ2VzLmZpbHRlcihmdW5jdGlvbiAoZWRnZSkgeyByZXR1cm4gXCJcIiArIG9wdGlvbnMudGFyZ2V0KGVkZ2UpID09PSBcIlwiICsgaWQ7IH0pO1xuICAgICAgICBub2RlLm91dEVkZ2VzID0gZWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlZGdlKSB7IHJldHVybiBcIlwiICsgb3B0aW9ucy5zb3VyY2UoZWRnZSkgPT09IFwiXCIgKyBpZDsgfSk7XG4gICAgICAgIC8vIGZyZXF1ZW5jeVxuICAgICAgICBub2RlLmVkZ2VzID0gbm9kZS5vdXRFZGdlcy5jb25jYXQobm9kZS5pbkVkZ2VzKTtcbiAgICAgICAgbm9kZS5mcmVxdWVuY3kgPSBub2RlLmVkZ2VzLmxlbmd0aDtcbiAgICAgICAgLy8gd2VpZ2h0XG4gICAgICAgIG5vZGUudmFsdWUgPSAwO1xuICAgICAgICBub2RlLmluRWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSArPSBvcHRpb25zLnRhcmdldFdlaWdodChlZGdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGUub3V0RWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSArPSBvcHRpb25zLnNvdXJjZVdlaWdodChlZGdlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBfc29ydE5vZGVzKG5vZGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIHNvcnRNZXRob2RzID0ge1xuICAgICAgICB3ZWlnaHQ6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiLnZhbHVlIC0gYS52YWx1ZTsgfSxcbiAgICAgICAgZnJlcXVlbmN5OiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYi5mcmVxdWVuY3kgLSBhLmZyZXF1ZW5jeTsgfSxcbiAgICAgICAgaWQ6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoXCJcIiArIG9wdGlvbnMuaWQoYSkpLmxvY2FsZUNvbXBhcmUoXCJcIiArIG9wdGlvbnMuaWQoYikpOyB9LFxuICAgIH07XG4gICAgdmFyIG1ldGhvZCA9IHNvcnRNZXRob2RzW29wdGlvbnMuc29ydEJ5XTtcbiAgICBpZiAoIW1ldGhvZCAmJiB1dGlsXzEuaXNGdW5jdGlvbihvcHRpb25zLnNvcnRCeSkpIHtcbiAgICAgICAgbWV0aG9kID0gb3B0aW9ucy5zb3J0Qnk7XG4gICAgfVxuICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgbm9kZXMuc29ydChtZXRob2QpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9sYXlvdXROb2Rlcyhub2Rlcywgb3B0aW9ucykge1xuICAgIHZhciBsZW4gPSBub2Rlcy5sZW5ndGg7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgbm9kZXM6IGl0J3MgZW1wdHkhXCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53ZWlnaHQpIHtcbiAgICAgICAgdmFyIG1hcmdpblJhdGlvXzEgPSBvcHRpb25zLm1hcmdpblJhdGlvO1xuICAgICAgICBpZiAobWFyZ2luUmF0aW9fMSA8IDAgfHwgbWFyZ2luUmF0aW9fMSA+PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1hcmdpblJhdGlvOiBpdCBtdXN0IGJlIGluIHJhbmdlIFswLCAxKSEnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFyZ2luXzEgPSBtYXJnaW5SYXRpb18xIC8gKDIgKiBsZW4pO1xuICAgICAgICB2YXIgdGhpY2tuZXNzXzEgPSBvcHRpb25zLnRoaWNrbmVzcztcbiAgICAgICAgaWYgKHRoaWNrbmVzc18xIDw9IDAgfHwgdGhpY2tuZXNzXzEgPj0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0aGlja25lc3M6IGl0IG11c3QgYmUgaW4gcmFuZ2UgKDAsIDEpIScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3RhbFZhbHVlXzEgPSAwO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB0b3RhbFZhbHVlXzEgKz0gbm9kZS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUud2VpZ2h0ID0gbm9kZS52YWx1ZSAvIHRvdGFsVmFsdWVfMTtcbiAgICAgICAgICAgIG5vZGUud2lkdGggPSBub2RlLndlaWdodCAqICgxIC0gbWFyZ2luUmF0aW9fMSk7XG4gICAgICAgICAgICBub2RlLmhlaWdodCA9IHRoaWNrbmVzc18xO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIHhcbiAgICAgICAgICAgIHZhciBkZWx0YVggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBkZWx0YVggKz0gbm9kZXNbaV0ud2lkdGggKyAyICogbWFyZ2luXzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWluWCA9IChub2RlLm1pblggPSBtYXJnaW5fMSArIGRlbHRhWCk7XG4gICAgICAgICAgICB2YXIgbWF4WCA9IChub2RlLm1heFggPSBub2RlLm1pblggKyBub2RlLndpZHRoKTtcbiAgICAgICAgICAgIHZhciBtaW5ZID0gKG5vZGUubWluWSA9IG9wdGlvbnMueSAtIHRoaWNrbmVzc18xIC8gMik7XG4gICAgICAgICAgICB2YXIgbWF4WSA9IChub2RlLm1heFkgPSBtaW5ZICsgdGhpY2tuZXNzXzEpO1xuICAgICAgICAgICAgbm9kZS54ID0gW21pblgsIG1heFgsIG1heFgsIG1pblhdO1xuICAgICAgICAgICAgbm9kZS55ID0gW21pblksIG1pblksIG1heFksIG1heFldO1xuICAgICAgICAgICAgLyogcG9pbnRzXG4gICAgICAgICAgICAgKiAzLS0tMlxuICAgICAgICAgICAgICogfCAgIHxcbiAgICAgICAgICAgICAqIDAtLS0xXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIG5vZGUueCA9IG1pblggKyAwLjUgKiBub2RlLndpZHRoO1xuICAgICAgICAgICAgLy8gbm9kZS55ID0gb3B0aW9ucy55O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBkZWx0YVhfMSA9IDEgLyBsZW47XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUsIGluZGV4KSB7XG4gICAgICAgICAgICBub2RlLnggPSAoaW5kZXggKyAwLjUpICogZGVsdGFYXzE7XG4gICAgICAgICAgICBub2RlLnkgPSBvcHRpb25zLnk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9sb2NhdGluZ0VkZ2VzKG5vZGVCeUlkLCBlZGdlcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLndlaWdodCkge1xuICAgICAgICB2YXIgdmFsdWVCeUlkXzEgPSB7fTtcbiAgICAgICAgdXRpbF8xLmZvckluKG5vZGVCeUlkLCBmdW5jdGlvbiAobm9kZSwgaWQpIHtcbiAgICAgICAgICAgIHZhbHVlQnlJZF8xW2lkXSA9IG5vZGUudmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICB2YXIgc0lkID0gb3B0aW9ucy5zb3VyY2UoZWRnZSk7XG4gICAgICAgICAgICB2YXIgdElkID0gb3B0aW9ucy50YXJnZXQoZWRnZSk7XG4gICAgICAgICAgICB2YXIgc05vZGUgPSBub2RlQnlJZFtzSWRdO1xuICAgICAgICAgICAgdmFyIHROb2RlID0gbm9kZUJ5SWRbdElkXTtcbiAgICAgICAgICAgIGlmIChzTm9kZSAmJiB0Tm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBzVmFsdWUgPSB2YWx1ZUJ5SWRfMVtzSWRdO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U1ZhbHVlID0gb3B0aW9ucy5zb3VyY2VXZWlnaHQoZWRnZSk7XG4gICAgICAgICAgICAgICAgdmFyIHNTdGFydCA9IHNOb2RlLm1pblggKyAoKHNOb2RlLnZhbHVlIC0gc1ZhbHVlKSAvIHNOb2RlLnZhbHVlKSAqIHNOb2RlLndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBzRW5kID0gc1N0YXJ0ICsgKGN1cnJlbnRTVmFsdWUgLyBzTm9kZS52YWx1ZSkgKiBzTm9kZS53aWR0aDtcbiAgICAgICAgICAgICAgICB2YWx1ZUJ5SWRfMVtzSWRdIC09IGN1cnJlbnRTVmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHRWYWx1ZSA9IHZhbHVlQnlJZF8xW3RJZF07XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUVmFsdWUgPSBvcHRpb25zLnRhcmdldFdlaWdodChlZGdlKTtcbiAgICAgICAgICAgICAgICB2YXIgdFN0YXJ0ID0gdE5vZGUubWluWCArICgodE5vZGUudmFsdWUgLSB0VmFsdWUpIC8gdE5vZGUudmFsdWUpICogdE5vZGUud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIHRFbmQgPSB0U3RhcnQgKyAoY3VycmVudFRWYWx1ZSAvIHROb2RlLnZhbHVlKSAqIHROb2RlLndpZHRoO1xuICAgICAgICAgICAgICAgIHZhbHVlQnlJZF8xW3RJZF0gLT0gY3VycmVudFRWYWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IG9wdGlvbnMueTtcbiAgICAgICAgICAgICAgICBlZGdlLnggPSBbc1N0YXJ0LCBzRW5kLCB0U3RhcnQsIHRFbmRdO1xuICAgICAgICAgICAgICAgIGVkZ2UueSA9IFt5LCB5LCB5LCB5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICB2YXIgc05vZGUgPSBub2RlQnlJZFtvcHRpb25zLnNvdXJjZShlZGdlKV07XG4gICAgICAgICAgICB2YXIgdE5vZGUgPSBub2RlQnlJZFtvcHRpb25zLnRhcmdldChlZGdlKV07XG4gICAgICAgICAgICBpZiAoc05vZGUgJiYgdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBlZGdlLnggPSBbc05vZGUueCwgdE5vZGUueF07XG4gICAgICAgICAgICAgICAgZWRnZS55ID0gW3NOb2RlLnksIHROb2RlLnldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZHYsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB2YXIgbm9kZUJ5SWQgPSB7fTtcbiAgICB2YXIgbm9kZXMgPSBkdi5ub2RlcztcbiAgICB2YXIgZWRnZXMgPSBkdi5lZGdlcztcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KG5vZGVzKSB8fCBub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbm9kZXMgPSBfbm9kZXNGcm9tRWRnZXMoZWRnZXMsIG9wdGlvbnMsIG5vZGVCeUlkKTtcbiAgICB9XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgaWQgPSBvcHRpb25zLmlkKG5vZGUpO1xuICAgICAgICBub2RlQnlJZFtpZF0gPSBub2RlO1xuICAgIH0pO1xuICAgIF9wcm9jZXNzR3JhcGgobm9kZUJ5SWQsIGVkZ2VzLCBvcHRpb25zKTtcbiAgICBfc29ydE5vZGVzKG5vZGVzLCBvcHRpb25zKTtcbiAgICBfbGF5b3V0Tm9kZXMobm9kZXMsIG9wdGlvbnMpO1xuICAgIF9sb2NhdGluZ0VkZ2VzKG5vZGVCeUlkLCBlZGdlcywgb3B0aW9ucyk7XG4gICAgZHYubm9kZXMgPSBub2RlcztcbiAgICBkdi5lZGdlcyA9IGVkZ2VzO1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdkaWFncmFtLmFyYycsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2FyYycsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2RpYWdyYW0vZGFncmUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2RpYWdyYW0vZGFncmUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xuLypcbiAqIGZvciBEQUdcbiAqIGdyYXBoIGRhdGEgcmVxdWlyZWQgKG5vZGVzLCBlZGdlcylcbiAqL1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkYWdyZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZGFncmUgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvaW5kZXguanNcIikpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICAvLyBub2RlSWQ6IG5vZGUgPT4gbm9kZS5pbmRleCxcbiAgICByYW5rZGlyOiAnVEInLFxuICAgIGFsaWduOiAnVEInLFxuICAgIG5vZGVzZXA6IDUwLFxuICAgIGVkZ2VzZXA6IDEwLFxuICAgIHJhbmtzZXA6IDUwLFxuICAgIHNvdXJjZTogZnVuY3Rpb24gKGVkZ2UpIHsgcmV0dXJuIGVkZ2Uuc291cmNlOyB9LFxuICAgIHRhcmdldDogZnVuY3Rpb24gKGVkZ2UpIHsgcmV0dXJuIGVkZ2UudGFyZ2V0OyB9LFxufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShkdiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBnID0gbmV3IGRhZ3JlXzEuZGVmYXVsdC5ncmFwaGxpYi5HcmFwaCgpO1xuICAgIC8vIFNldCBhbiBvYmplY3QgZm9yIHRoZSBncmFwaCBsYWJlbFxuICAgIGcuc2V0R3JhcGgoe30pO1xuICAgIC8vIERlZmF1bHQgdG8gYXNzaWduaW5nIGEgbmV3IG9iamVjdCBhcyBhIGxhYmVsIGZvciBlYWNoIG5ldyBlZGdlLlxuICAgIGcuc2V0RGVmYXVsdEVkZ2VMYWJlbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9KTtcbiAgICBkdi5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBvcHRpb25zLm5vZGVJZCA/IG9wdGlvbnMubm9kZUlkKG5vZGUpIDogbm9kZS5pZDtcbiAgICAgICAgaWYgKCFub2RlLmhlaWdodCAmJiAhbm9kZS53aWR0aCkge1xuICAgICAgICAgICAgbm9kZS5oZWlnaHQgPSBub2RlLndpZHRoID0gb3B0aW9ucy5lZGdlc2VwO1xuICAgICAgICB9XG4gICAgICAgIGcuc2V0Tm9kZShub2RlSWQsIG5vZGUpO1xuICAgIH0pO1xuICAgIGR2LmVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgZy5zZXRFZGdlKG9wdGlvbnMuc291cmNlKGVkZ2UpLCBvcHRpb25zLnRhcmdldChlZGdlKSk7XG4gICAgfSk7XG4gICAgZGFncmVfMS5kZWZhdWx0LmxheW91dChnKTtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgZWRnZXMgPSBbXTtcbiAgICBnLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgbiA9IGcubm9kZShub2RlKTtcbiAgICAgICAgdmFyIHggPSBuLngsIHkgPSBuLnksIGhlaWdodCA9IG4uaGVpZ2h0LCB3aWR0aCA9IG4ud2lkdGg7XG4gICAgICAgIC8qIHBvaW50c1xuICAgICAgICAgKiAzLS0tMlxuICAgICAgICAgKiB8ICAgfFxuICAgICAgICAgKiAwLS0tMVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBuLnggPSBbeCAtIHdpZHRoIC8gMiwgeCArIHdpZHRoIC8gMiwgeCArIHdpZHRoIC8gMiwgeCAtIHdpZHRoIC8gMl07XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbi55ID0gW3kgKyBoZWlnaHQgLyAyLCB5ICsgaGVpZ2h0IC8gMiwgeSAtIGhlaWdodCAvIDIsIHkgLSBoZWlnaHQgLyAyXTtcbiAgICAgICAgbm9kZXMucHVzaChuKTtcbiAgICB9KTtcbiAgICBnLmVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICB2YXIgcG9pbnRzID0gZy5lZGdlKGVkZ2UpLnBvaW50cztcbiAgICAgICAgdmFyIGUgPSB7fTtcbiAgICAgICAgZS54ID0gcG9pbnRzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC54OyB9KTtcbiAgICAgICAgZS55ID0gcG9pbnRzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC55OyB9KTtcbiAgICAgICAgZWRnZXMucHVzaChlKTtcbiAgICB9KTtcbiAgICBkdi5ub2RlcyA9IG5vZGVzO1xuICAgIGR2LmVkZ2VzID0gZWRnZXM7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2RpYWdyYW0uZGFncmUnLCB0cmFuc2Zvcm0pO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdkYWdyZScsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2RpYWdyYW0vc2Fua2V5LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vZGlhZ3JhbS9zYW5rZXkudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKlxuICogZm9yIFNhbmtleSBEaWFncmFtXG4gKiBncmFwaCBkYXRhIHJlcXVpcmVkIChub2RlcywgZWRnZXMpXG4gKi9cbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZDNfc2Fua2V5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1zYW5rZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtc2Fua2V5QDAuOS4xQGQzLXNhbmtleS9kaXN0L2QzLXNhbmtleS5qc1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBBTElHTl9NRVRIT0QgPSB7XG4gICAgc2Fua2V5TGVmdDogZDNfc2Fua2V5XzEuc2Fua2V5TGVmdCxcbiAgICBzYW5rZXlSaWdodDogZDNfc2Fua2V5XzEuc2Fua2V5UmlnaHQsXG4gICAgc2Fua2V5Q2VudGVyOiBkM19zYW5rZXlfMS5zYW5rZXlDZW50ZXIsXG4gICAgc2Fua2V5SnVzdGlmeTogZDNfc2Fua2V5XzEuc2Fua2V5SnVzdGlmeSxcbn07XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIC8vIG5vZGVJZDogbm9kZSA9PiBub2RlLmluZGV4LFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52YWx1ZTsgfSxcbiAgICBzb3VyY2U6IGZ1bmN0aW9uIChlZGdlKSB7IHJldHVybiBlZGdlLnNvdXJjZTsgfSxcbiAgICB0YXJnZXQ6IGZ1bmN0aW9uIChlZGdlKSB7IHJldHVybiBlZGdlLnRhcmdldDsgfSxcbiAgICBub2RlQWxpZ246ICdzYW5rZXlKdXN0aWZ5JyxcbiAgICBub2RlV2lkdGg6IDAuMDIsXG4gICAgbm9kZVBhZGRpbmc6IDAuMDIsXG4gICAgc29ydDogdW5kZWZpbmVkLFxufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShkdiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBub2RlQWxpZ24gPSBudWxsO1xuICAgIGlmICh1dGlsXzEuaXNTdHJpbmcob3B0aW9ucy5ub2RlQWxpZ24pKSB7XG4gICAgICAgIG5vZGVBbGlnbiA9IEFMSUdOX01FVEhPRFtvcHRpb25zLm5vZGVBbGlnbl07XG4gICAgfVxuICAgIGVsc2UgaWYgKHV0aWxfMS5pc0Z1bmN0aW9uKG9wdGlvbnMubm9kZUFsaWduKSkge1xuICAgICAgICBub2RlQWxpZ24gPSBvcHRpb25zLm5vZGVBbGlnbjtcbiAgICB9XG4gICAgdmFyIHNhbmtleVByb2Nlc3NvciA9IGQzX3NhbmtleV8xLnNhbmtleSgpXG4gICAgICAgIC5ub2RlU29ydChvcHRpb25zLnNvcnQpXG4gICAgICAgIC5saW5rcyhmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5lZGdlczsgfSlcbiAgICAgICAgLm5vZGVXaWR0aChvcHRpb25zLm5vZGVXaWR0aClcbiAgICAgICAgLm5vZGVQYWRkaW5nKG9wdGlvbnMubm9kZVBhZGRpbmcpXG4gICAgICAgIC5leHRlbnQoW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFsxLCAxXSxcbiAgICBdKTtcbiAgICBpZiAodXRpbF8xLmlzRnVuY3Rpb24ob3B0aW9ucy5ub2RlSWQpKSB7XG4gICAgICAgIHNhbmtleVByb2Nlc3Nvci5ub2RlSWQob3B0aW9ucy5ub2RlSWQpO1xuICAgIH1cbiAgICBpZiAobm9kZUFsaWduKSB7XG4gICAgICAgIHNhbmtleVByb2Nlc3Nvci5ub2RlQWxpZ24obm9kZUFsaWduKTtcbiAgICB9XG4gICAgLy8gVE9ETzpcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgc2Fua2V5UHJvY2Vzc29yKGR2KTtcbiAgICAvLyBwb3N0IHByb2Nlc3MgKHgsIHkpLCBldGMuXG4gICAgZHYubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgeDAgPSBub2RlLngwLCB4MSA9IG5vZGUueDEsIHkwID0gbm9kZS55MCwgeTEgPSBub2RlLnkxO1xuICAgICAgICAvKiBwb2ludHNcbiAgICAgICAgICogMy0tLTJcbiAgICAgICAgICogfCAgIHxcbiAgICAgICAgICogMC0tLTFcbiAgICAgICAgICovXG4gICAgICAgIG5vZGUueCA9IFt4MCwgeDEsIHgxLCB4MF07XG4gICAgICAgIG5vZGUueSA9IFt5MCwgeTAsIHkxLCB5MV07XG4gICAgfSk7XG4gICAgZHYuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICB2YXIgc291cmNlID0gZWRnZS5zb3VyY2UsIHRhcmdldCA9IGVkZ2UudGFyZ2V0O1xuICAgICAgICB2YXIgc3ggPSBzb3VyY2UueDE7XG4gICAgICAgIHZhciB0eCA9IHRhcmdldC54MDtcbiAgICAgICAgZWRnZS54ID0gW3N4LCBzeCwgdHgsIHR4XTtcbiAgICAgICAgdmFyIG9mZnNldCA9IGVkZ2Uud2lkdGggLyAyO1xuICAgICAgICBlZGdlLnkgPSBbZWRnZS55MCArIG9mZnNldCwgZWRnZS55MCAtIG9mZnNldCwgZWRnZS55MSArIG9mZnNldCwgZWRnZS55MSAtIG9mZnNldF07XG4gICAgfSk7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2RpYWdyYW0uc2Fua2V5JywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnc2Fua2V5JywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vZGlhZ3JhbS92b3Jvbm9pLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2RpYWdyYW0vdm9yb25vaS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciBkM1Zvcm9ub2kgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy12b3Jvbm9pICovIFwiLi9ub2RlX21vZHVsZXMvX2QzLXZvcm9ub2lAMS4xLjRAZDMtdm9yb25vaS9kaXN0L2QzLXZvcm9ub2kuanNcIikpO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciByZWdpc3RlclRyYW5zZm9ybSA9IGRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIC8vIGZpZWxkczogWyAneCcsICd5JyBdIC8vIGZpZWxkIHggYW5kIGZpZWxkIHksIHJlcXVpcmVkXG4gICAgLy8gZXh0ZW5kOiBbW3gwLCB5MF0sIFt4MSwgeTFdXSwgLy8gb3B0aW9uYWxcbiAgICAvLyBzaXplOiBbd2lkdGgsIGhlaWdodF0sIC8vIG9wdGlvbmFsXG4gICAgYXM6IFsnX3gnLCAnX3knXSxcbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB2YXIgYXMgPSBvcHRpb25zLmFzO1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkoYXMpIHx8IGFzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFzOiBtdXN0IGJlIGFuIGFycmF5IHdpdGggdHdvIHN0cmluZ3MhJyk7XG4gICAgfVxuICAgIHZhciB4RmllbGQgPSBhc1swXTtcbiAgICB2YXIgeUZpZWxkID0gYXNbMV07XG4gICAgdmFyIGZpZWxkcyA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZHMob3B0aW9ucyk7XG4gICAgaWYgKCF1dGlsXzEuaXNBcnJheShmaWVsZHMpIHx8IGZpZWxkcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBmaWVsZHM6IG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0d28gc3RyaW5ncyEnKTtcbiAgICB9XG4gICAgdmFyIHggPSBmaWVsZHNbMF07XG4gICAgdmFyIHkgPSBmaWVsZHNbMV07XG4gICAgdmFyIHJvd3MgPSBkYXRhVmlldy5yb3dzO1xuICAgIHZhciBkYXRhID0gcm93cy5tYXAoZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gW3Jvd1t4XSwgcm93W3ldXTsgfSk7XG4gICAgdmFyIHZvcm9ub2kgPSBkM1Zvcm9ub2kudm9yb25vaSgpO1xuICAgIGlmIChvcHRpb25zLmV4dGVuZCkge1xuICAgICAgICB2b3Jvbm9pLmV4dGVudChvcHRpb25zLmV4dGVuZCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNpemUpIHtcbiAgICAgICAgdm9yb25vaS5zaXplKG9wdGlvbnMuc2l6ZSk7XG4gICAgfVxuICAgIHZhciBwb2x5Z29ucyA9IHZvcm9ub2koZGF0YSkucG9seWdvbnMoKTtcbiAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdywgaSkge1xuICAgICAgICB2YXIgcG9seWdvbiA9IHBvbHlnb25zW2ldLmZpbHRlcihmdW5jdGlvbiAocG9pbnQpIHsgcmV0dXJuICEhcG9pbnQ7IH0pOyAvLyBzb21lIHBvaW50cyBhcmUgbnVsbFxuICAgICAgICByb3dbeEZpZWxkXSA9IHBvbHlnb24ubWFwKGZ1bmN0aW9uIChwb2ludCkgeyByZXR1cm4gcG9pbnRbMF07IH0pO1xuICAgICAgICByb3dbeUZpZWxkXSA9IHBvbHlnb24ubWFwKGZ1bmN0aW9uIChwb2ludCkgeyByZXR1cm4gcG9pbnRbMV07IH0pO1xuICAgIH0pO1xufVxucmVnaXN0ZXJUcmFuc2Zvcm0oJ2RpYWdyYW0udm9yb25vaScsIHRyYW5zZm9ybSk7XG5yZWdpc3RlclRyYW5zZm9ybSgndm9yb25vaScsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2ZpbGwtcm93cy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9maWxsLXJvd3MudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIHBhcnRpdGlvbl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9wYXJ0aXRpb24gKi8gXCIuL3NyYy91dGlsL3BhcnRpdGlvbi50c1wiKSk7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIGZpbGxCeTogJ2dyb3VwJyxcbiAgICBncm91cEJ5OiBbXSxcbiAgICBvcmRlckJ5OiBbXSxcbn07XG5mdW5jdGlvbiBhcnJheURpZmZlcmVuY2UoYXJyMSwgYXJyMikge1xuICAgIC8vIGFycmF5RGlmZmVyZW5jZShbMSwgMSwgMSwgMl0sIFsxLCAyXSkgPT4gWzEsIDFdXG4gICAgdmFyIHNoYWRvdyA9IGFycjEubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtOyB9KTsgLy8gc2hhZG93IGNvcHlcbiAgICBhcnIyLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc2hhZG93LmluZGV4T2YoaXRlbSk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBzaGFkb3cuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzaGFkb3c7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB2YXIgcm93cyA9IGRhdGFWaWV3LnJvd3M7XG4gICAgdmFyIGdyb3VwQnkgPSBvcHRpb25zLmdyb3VwQnk7XG4gICAgdmFyIG9yZGVyQnkgPSBvcHRpb25zLm9yZGVyQnk7XG4gICAgdmFyIGdyb3VwcyA9IHBhcnRpdGlvbl8xLmRlZmF1bHQocm93cywgZ3JvdXBCeSwgb3JkZXJCeSk7XG4gICAgdmFyIG1heExlbmd0aCA9IDA7XG4gICAgdmFyIHJlZmVyZW5jZUdyb3VwID0gW107XG4gICAgdXRpbF8xLmZvckluKGdyb3VwcywgZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIGlmIChncm91cC5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIG1heExlbmd0aCA9IGdyb3VwLmxlbmd0aDtcbiAgICAgICAgICAgIHJlZmVyZW5jZUdyb3VwID0gZ3JvdXA7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgcmVmZXJlbmNlT3JkZXJCeUtleXMgPSBbXTtcbiAgICB2YXIgcmVmZXJlbmNlUm93QnlPcmRlckJ5S2V5ID0ge307XG4gICAgcmVmZXJlbmNlR3JvdXAuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBrZXkgPSBvcmRlckJ5Lm1hcChmdW5jdGlvbiAoY29sKSB7IHJldHVybiByb3dbY29sXTsgfSkuam9pbignLScpO1xuICAgICAgICByZWZlcmVuY2VPcmRlckJ5S2V5cy5wdXNoKGtleSk7XG4gICAgICAgIHJlZmVyZW5jZVJvd0J5T3JkZXJCeUtleVtrZXldID0gcm93O1xuICAgIH0pO1xuICAgIGlmIChvcHRpb25zLmZpbGxCeSA9PT0gJ29yZGVyJykge1xuICAgICAgICB2YXIgZmlyc3RfMSA9IHJlZmVyZW5jZUdyb3VwWzBdO1xuICAgICAgICB2YXIgYWxsT3JkZXJCeUtleXNfMSA9IFtdO1xuICAgICAgICB2YXIgcm93QnlPcmRlckJ5S2V5XzEgPSB7fTtcbiAgICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBvcmRlckJ5Lm1hcChmdW5jdGlvbiAoY29sKSB7IHJldHVybiByb3dbY29sXTsgfSkuam9pbignLScpO1xuICAgICAgICAgICAgaWYgKGFsbE9yZGVyQnlLZXlzXzEuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGFsbE9yZGVyQnlLZXlzXzEucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIHJvd0J5T3JkZXJCeUtleV8xW2tleV0gPSByb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX21pc3NpbmdPcmRlckJ5S2V5cyA9IGFycmF5RGlmZmVyZW5jZShhbGxPcmRlckJ5S2V5c18xLCByZWZlcmVuY2VPcmRlckJ5S2V5cyk7XG4gICAgICAgIF9taXNzaW5nT3JkZXJCeUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgcm93ID0ge307XG4gICAgICAgICAgICBncm91cEJ5LmZvckVhY2goZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICAgICAgICAgIHJvd1tjb2xdID0gZmlyc3RfMVtjb2xdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvcmRlckJ5LmZvckVhY2goZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICAgICAgICAgIHJvd1tjb2xdID0gcm93QnlPcmRlckJ5S2V5XzFba2V5XVtjb2xdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICAgIHJlZmVyZW5jZUdyb3VwLnB1c2gocm93KTtcbiAgICAgICAgICAgIHJlZmVyZW5jZU9yZGVyQnlLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHJlZmVyZW5jZVJvd0J5T3JkZXJCeUtleVtrZXldID0gcm93O1xuICAgICAgICB9KTtcbiAgICAgICAgbWF4TGVuZ3RoID0gcmVmZXJlbmNlR3JvdXAubGVuZ3RoO1xuICAgIH1cbiAgICB1dGlsXzEuZm9ySW4oZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgaWYgKGdyb3VwICE9PSByZWZlcmVuY2VHcm91cCAmJiBncm91cC5sZW5ndGggPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdF8yID0gZ3JvdXBbMF07XG4gICAgICAgICAgICAvLyBtaXNzaW5nIG9yZGVyQnkga2V5c1xuICAgICAgICAgICAgdmFyIG9yZGVyQnlLZXlzXzEgPSBbXTtcbiAgICAgICAgICAgIGdyb3VwLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICAgIG9yZGVyQnlLZXlzXzEucHVzaChvcmRlckJ5Lm1hcChmdW5jdGlvbiAoY29sKSB7IHJldHVybiByb3dbY29sXTsgfSkuam9pbignLScpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG1pc3NpbmdPcmRlckJ5S2V5cyA9IGFycmF5RGlmZmVyZW5jZShyZWZlcmVuY2VPcmRlckJ5S2V5cywgb3JkZXJCeUtleXNfMSk7XG4gICAgICAgICAgICBtaXNzaW5nT3JkZXJCeUtleXMuc29tZShmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gbWF4TGVuZ3RoIC0gZ3JvdXAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdyb3VwIGxlbmd0aCBvdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlZmVyZW5jZVJvdyA9IHJlZmVyZW5jZVJvd0J5T3JkZXJCeUtleVtrZXldO1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSB7fTtcbiAgICAgICAgICAgICAgICBncm91cEJ5LmZvckVhY2goZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICAgICAgICAgICAgICByb3dbY29sXSA9IGZpcnN0XzJbY29sXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvcmRlckJ5LmZvckVhY2goZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICAgICAgICAgICAgICByb3dbY29sXSA9IHJlZmVyZW5jZVJvd1tjb2xdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2ZpbGwtcm93cycsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2ZpbGxSb3dzJywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vZmlsdGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2ZpbHRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG5mdW5jdGlvbiBkZWZhdWx0Q2FsbGJhY2socm93KSB7XG4gICAgcmV0dXJuICEhcm93O1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdmaWx0ZXInLCBmdW5jdGlvbiAoZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBkYXRhVmlldy5yb3dzID0gZGF0YVZpZXcucm93cy5maWx0ZXIob3B0aW9ucy5jYWxsYmFjayB8fCBkZWZhdWx0Q2FsbGJhY2spO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2ZvbGQudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2ZvbGQudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgb3B0aW9uX3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvdXRpbC9vcHRpb24tcGFyc2VyLnRzXCIpO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBmaWVsZHM6IFtdLFxuICAgIGtleTogJ2tleScsXG4gICAgcmV0YWluczogW10sXG4gICAgdmFsdWU6ICd2YWx1ZScsXG59O1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdmb2xkJywgZnVuY3Rpb24gKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbHVtbnMgPSBkYXRhVmlldy5nZXRDb2x1bW5OYW1lcygpO1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBmaWVsZHMgPSBvcHRpb25fcGFyc2VyXzEuZ2V0RmllbGRzKG9wdGlvbnMpO1xuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybignd2FybmluZzogb3B0aW9uIGZpZWxkcyBpcyBub3Qgc3BlY2lmaWVkLCB3aWxsIGZvbGQgYWxsIGNvbHVtbnMuJyk7XG4gICAgICAgIGZpZWxkcyA9IGNvbHVtbnM7XG4gICAgfVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciByZXRhaW5zID0gb3B0aW9ucy5yZXRhaW5zO1xuICAgIGlmICghcmV0YWlucyB8fCByZXRhaW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXRhaW5zID0gdXRpbF8xLmRpZmZlcmVuY2UoY29sdW1ucywgZmllbGRzKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdFJvd3MgPSBbXTtcbiAgICBkYXRhVmlldy5yb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRSb3cgPSB1dGlsXzEucGljayhyb3csIHJldGFpbnMpO1xuICAgICAgICAgICAgcmVzdWx0Um93W2tleV0gPSBmaWVsZDtcbiAgICAgICAgICAgIHJlc3VsdFJvd1t2YWx1ZV0gPSByb3dbZmllbGRdO1xuICAgICAgICAgICAgcmVzdWx0Um93cy5wdXNoKHJlc3VsdFJvdyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGRhdGFWaWV3LnJvd3MgPSByZXN1bHRSb3dzO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2dlby9jZW50cm9pZC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9nZW8vY2VudHJvaWQudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciByZWdpc3RlclRyYW5zZm9ybSA9IGRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIC8vIGZpZWxkOiAnbmFtZScsIC8vIHJlcXVpcmVkXG4gICAgLy8gZ2VvVmlldzogdmlldywgLy8gcmVxdWlyZWRcbiAgICAvLyBnZW9EYXRhVmlldzogdmlldywgLy8gYWxpYXNcbiAgICBhczogWydfY2VudHJvaWRfeCcsICdfY2VudHJvaWRfeSddLFxufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybSh2aWV3LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGZpZWxkID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkKG9wdGlvbnMpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB2YXIgZ2VvVmlldyA9IG9wdGlvbnMuZ2VvVmlldyB8fCBvcHRpb25zLmdlb0RhdGFWaWV3OyAvLyBhbGlhc1xuICAgIGlmICh1dGlsXzEuaXNTdHJpbmcoZ2VvVmlldykgJiYgdmlldy5kYXRhU2V0KSB7XG4gICAgICAgIGdlb1ZpZXcgPSB2aWV3LmRhdGFTZXQuZ2V0VmlldyhnZW9WaWV3KTtcbiAgICB9XG4gICAgaWYgKCFnZW9WaWV3IHx8IGdlb1ZpZXcuZGF0YVR5cGUgIT09ICdnZW8nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZ2VvVmlldzogbXVzdCBiZSBhIERhdGFWaWV3IG9mIEdFTyBkYXRhVHlwZSEnKTtcbiAgICB9XG4gICAgdmFyIGFzID0gb3B0aW9ucy5hcztcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGFzKSB8fCBhcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhczogaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIDIgc3RyaW5ncyAoZS5nLiBbIFwiY1hcIiwgXCJjWVwiIF0pIScpO1xuICAgIH1cbiAgICB2YXIgY2VudHJvaWRYID0gYXNbMF07XG4gICAgdmFyIGNlbnRyb2lkWSA9IGFzWzFdO1xuICAgIHZpZXcucm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBnZW9WaWV3Lmdlb0ZlYXR1cmVCeU5hbWUocm93W2ZpZWxkXSk7XG4gICAgICAgIGlmIChmZWF0dXJlKSB7XG4gICAgICAgICAgICBpZiAoZ2VvVmlldy5fcHJvamVjdGVkQXMpIHtcbiAgICAgICAgICAgICAgICByb3dbY2VudHJvaWRYXSA9IGZlYXR1cmVbZ2VvVmlldy5fcHJvamVjdGVkQXNbMl1dO1xuICAgICAgICAgICAgICAgIHJvd1tjZW50cm9pZFldID0gZmVhdHVyZVtnZW9WaWV3Ll9wcm9qZWN0ZWRBc1szXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3dbY2VudHJvaWRYXSA9IGZlYXR1cmUuY2VudHJvaWRYO1xuICAgICAgICAgICAgICAgIHJvd1tjZW50cm9pZFldID0gZmVhdHVyZS5jZW50cm9pZFk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbnJlZ2lzdGVyVHJhbnNmb3JtKCdnZW8uY2VudHJvaWQnLCB0cmFuc2Zvcm0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9nZW8vcHJvamVjdGlvbi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2dlby9wcm9qZWN0aW9uLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGQzX2dlb18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtZ2VvICovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWdlb0AxLjYuNEBkMy1nZW8vYnVpbGQvZDMtZ2VvLmpzXCIpO1xudmFyIHBvaW50X2F0X2xlbmd0aF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcG9pbnQtYXQtbGVuZ3RoICovIFwiLi9ub2RlX21vZHVsZXMvX3BvaW50LWF0LWxlbmd0aEAxLjEuMEBwb2ludC1hdC1sZW5ndGgvaW5kZXguanNcIikpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIHJlZ2lzdGVyVHJhbnNmb3JtID0gZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtO1xudmFyIGdldF9nZW9fcHJvamVjdGlvbl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9nZXQtZ2VvLXByb2plY3Rpb24gKi8gXCIuL3NyYy91dGlsL2dldC1nZW8tcHJvamVjdGlvbi50c1wiKSk7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIC8vIHByb2plY3Rpb246ICcnLCAvLyBkZWZhdWx0IHRvIG51bGxcbiAgICBhczogWydfeCcsICdfeScsICdfY2VudHJvaWRfeCcsICdfY2VudHJvaWRfeSddLFxufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShkYXRhVmlldywgb3B0aW9ucykge1xuICAgIGlmIChkYXRhVmlldy5kYXRhVHlwZSAhPT0gJ2dlbycgJiYgZGF0YVZpZXcuZGF0YVR5cGUgIT09ICdnZW8tZ3JhdGljdWxlJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGRhdGFWaWV3OiB0aGlzIHRyYW5zZm9ybSBpcyBmb3IgR2VvIGRhdGEgb25seSEnKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIHByb2plY3Rpb24gPSBvcHRpb25zLnByb2plY3Rpb247XG4gICAgaWYgKCFwcm9qZWN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcHJvamVjdGlvbiEnKTtcbiAgICB9XG4gICAgcHJvamVjdGlvbiA9IGdldF9nZW9fcHJvamVjdGlvbl8xLmRlZmF1bHQocHJvamVjdGlvbik7XG4gICAgLy8gQHRzLWlnbm9yZTtcbiAgICB2YXIgZ2VvUGF0aEdlbmVyYXRvciA9IGQzX2dlb18xLmdlb1BhdGgocHJvamVjdGlvbik7XG4gICAgdmFyIGFzID0gb3B0aW9ucy5hcztcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGFzKSB8fCBhcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhczogaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIDQgc3RyaW5ncyAoZS5nLiBbIFwieFwiLCBcInlcIiwgXCJjWFwiLCBcImNZXCIgXSkhJyk7XG4gICAgfVxuICAgIGRhdGFWaWV3Ll9wcm9qZWN0ZWRBcyA9IGFzO1xuICAgIHZhciBfYSA9IHRzbGliXzEuX19yZWFkKGFzLCA0KSwgbG9uRmllbGQgPSBfYVswXSwgbGF0RmllbGQgPSBfYVsxXSwgY2VudHJvaWRYID0gX2FbMl0sIGNlbnRyb2lkWSA9IF9hWzNdO1xuICAgIGRhdGFWaWV3LnJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJvd1tsb25GaWVsZF0gPSBbXTtcbiAgICAgICAgcm93W2xhdEZpZWxkXSA9IFtdO1xuICAgICAgICB2YXIgcGF0aERhdGEgPSBnZW9QYXRoR2VuZXJhdG9yKHJvdyk7XG4gICAgICAgIGlmIChwYXRoRGF0YSkge1xuICAgICAgICAgICAgLy8gVE9ETyBwcm9qZWN0aW9uIHJldHVybnMgbnVsbFxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHBvaW50X2F0X2xlbmd0aF8xLmRlZmF1bHQocGF0aERhdGEpO1xuICAgICAgICAgICAgcG9pbnRzLl9wYXRoLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgcm93W2xvbkZpZWxkXS5wdXNoKHBvaW50WzFdKTtcbiAgICAgICAgICAgICAgICByb3dbbGF0RmllbGRdLnB1c2gocG9pbnRbMl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgY2VudHJvaWQgPSBnZW9QYXRoR2VuZXJhdG9yLmNlbnRyb2lkKHJvdyk7XG4gICAgICAgICAgICByb3dbY2VudHJvaWRYXSA9IGNlbnRyb2lkWzBdO1xuICAgICAgICAgICAgcm93W2NlbnRyb2lkWV0gPSBjZW50cm9pZFsxXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGRhdGFWaWV3LnJvd3MgPSBkYXRhVmlldy5yb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7IHJldHVybiByb3dbbG9uRmllbGRdLmxlbmd0aCAhPT0gMDsgfSk7XG59XG5yZWdpc3RlclRyYW5zZm9ybSgnZ2VvLnByb2plY3Rpb24nLCB0cmFuc2Zvcm0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9nZW8vcmVnaW9uLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9nZW8vcmVnaW9uLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIHJlZ2lzdGVyVHJhbnNmb3JtID0gZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgLy8gZmllbGQ6ICduYW1lJywgLy8gcmVxdWlyZWRcbiAgICAvLyBnZW9WaWV3OiB2aWV3LCAvLyByZXF1aXJlZFxuICAgIC8vIGdlb0RhdGFWaWV3OiB2aWV3LCAvLyBhbGlhc1xuICAgIGFzOiBbJ194JywgJ195J10sXG59O1xuZnVuY3Rpb24gdHJhbnNmb3JtKHZpZXcsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB2YXIgZmllbGQgPSBvcHRpb25fcGFyc2VyXzEuZ2V0RmllbGQob3B0aW9ucyk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBnZW9WaWV3ID0gb3B0aW9ucy5nZW9WaWV3IHx8IG9wdGlvbnMuZ2VvRGF0YVZpZXc7IC8vIGFsaWFzXG4gICAgaWYgKHV0aWxfMS5pc1N0cmluZyhnZW9WaWV3KSkge1xuICAgICAgICBnZW9WaWV3ID0gdmlldy5kYXRhU2V0LmdldFZpZXcoZ2VvVmlldyk7XG4gICAgfVxuICAgIGlmICghZ2VvVmlldyB8fCBnZW9WaWV3LmRhdGFUeXBlICE9PSAnZ2VvJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGdlb1ZpZXc6IG11c3QgYmUgYSBEYXRhVmlldyBvZiBHRU8gZGF0YVR5cGUhJyk7XG4gICAgfVxuICAgIHZhciBhcyA9IG9wdGlvbnMuYXM7XG4gICAgaWYgKCF1dGlsXzEuaXNBcnJheShhcykgfHwgYXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXM6IGl0IG11c3QgYmUgYW4gYXJyYXkgd2l0aCAyIHN0cmluZ3MgKGUuZy4gWyBcInhcIiwgXCJ5XCIgXSkhJyk7XG4gICAgfVxuICAgIHZhciBsb25GaWVsZCA9IGFzWzBdO1xuICAgIHZhciBsYXRGaWVsZCA9IGFzWzFdO1xuICAgIHZpZXcucm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBnZW9WaWV3Lmdlb0ZlYXR1cmVCeU5hbWUocm93W2ZpZWxkXSk7XG4gICAgICAgIGlmIChmZWF0dXJlKSB7XG4gICAgICAgICAgICBpZiAoZ2VvVmlldy5fcHJvamVjdGVkQXMpIHtcbiAgICAgICAgICAgICAgICByb3dbbG9uRmllbGRdID0gZmVhdHVyZVtnZW9WaWV3Ll9wcm9qZWN0ZWRBc1swXV07XG4gICAgICAgICAgICAgICAgcm93W2xhdEZpZWxkXSA9IGZlYXR1cmVbZ2VvVmlldy5fcHJvamVjdGVkQXNbMV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm93W2xvbkZpZWxkXSA9IGZlYXR1cmUubG9uZ2l0dWRlO1xuICAgICAgICAgICAgICAgIHJvd1tsYXRGaWVsZF0gPSBmZWF0dXJlLmxhdGl0dWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5yZWdpc3RlclRyYW5zZm9ybSgnZ2VvLnJlZ2lvbicsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS9jbHVzdGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L2NsdXN0ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciBkM0hpZXJhcmNoeSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLWhpZXJhcmNoeSAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1oaWVyYXJjaHlAMS4xLjlAZDMtaGllcmFyY2h5L2Rpc3QvZDMtaGllcmFyY2h5LmpzXCIpKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgb3B0aW9uX3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvdXRpbC9vcHRpb24tcGFyc2VyLnRzXCIpO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBmaWVsZDogJ3ZhbHVlJyxcbiAgICBzaXplOiBbMSwgMV0sXG4gICAgbm9kZVNpemU6IG51bGwsXG4gICAgc2VwYXJhdGlvbjogbnVsbCxcbiAgICBhczogWyd4JywgJ3knXSxcbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBpZiAoZGF0YVZpZXcuZGF0YVR5cGUgIT09IGRhdGFfc2V0XzEuRGF0YVNldC5DT05TVEFOVFMuSElFUkFSQ0hZIHx8ICFkYXRhVmlldy5yb290KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgRGF0YVZpZXc6IFRoaXMgdHJhbnNmb3JtIGlzIGZvciBIaWVyYXJjaHkgZGF0YSBvbmx5IScpO1xuICAgIH1cbiAgICB2YXIgcm9vdCA9IGRhdGFWaWV3LnJvb3Q7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGFzID0gb3B0aW9ucy5hcztcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGFzKSB8fCBhcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhczogaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIDIgc3RyaW5ncyAoZS5nLiBbIFwieFwiLCBcInlcIiBdKSEnKTtcbiAgICB9XG4gICAgdmFyIGZpZWxkID0gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICAgIGZpZWxkID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgfVxuICAgIGlmIChmaWVsZCkge1xuICAgICAgICByb290LnN1bShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFtmaWVsZF07IH0pO1xuICAgIH1cbiAgICB2YXIgY2x1c3RlckxheW91dCA9IGQzSGllcmFyY2h5LmNsdXN0ZXIoKTtcbiAgICBjbHVzdGVyTGF5b3V0LnNpemUob3B0aW9ucy5zaXplKTtcbiAgICBpZiAob3B0aW9ucy5ub2RlU2l6ZSkge1xuICAgICAgICBjbHVzdGVyTGF5b3V0Lm5vZGVTaXplKG9wdGlvbnMubm9kZVNpemUpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zZXBhcmF0aW9uKSB7XG4gICAgICAgIGNsdXN0ZXJMYXlvdXQuc2VwYXJhdGlvbihvcHRpb25zLnNlcGFyYXRpb24pO1xuICAgIH1cbiAgICBjbHVzdGVyTGF5b3V0KHJvb3QpO1xuICAgIHZhciB4ID0gYXNbMF07XG4gICAgdmFyIHkgPSBhc1sxXTtcbiAgICByb290LmVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZVt4XSA9IG5vZGUueDtcbiAgICAgICAgbm9kZVt5XSA9IG5vZGUueTtcbiAgICB9KTtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnaGllcmFyY2h5LmNsdXN0ZXInLCB0cmFuc2Zvcm0pO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdkZW5kcm9ncmFtJywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L2NvbXBhY3QtYm94LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS9jb21wYWN0LWJveC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciBoaWVyYXJjaHlfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L2hpZXJhcmNoeSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl9oaWVyYXJjaHlAMC42LjJAQGFudHYvaGllcmFyY2h5L2J1aWxkL2hpZXJhcmNoeS5qc1wiKSk7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge307XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICB2YXIgcm9vdCA9IGRhdGFWaWV3LnJvb3Q7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgaWYgKGRhdGFWaWV3LmRhdGFUeXBlICE9PSBkYXRhX3NldF8xLkRhdGFTZXQuQ09OU1RBTlRTLkhJRVJBUkNIWSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERhdGFWaWV3OiBUaGlzIHRyYW5zZm9ybSBpcyBmb3IgSGllcmFyY2h5IGRhdGEgb25seSEnKTtcbiAgICB9XG4gICAgZGF0YVZpZXcucm9vdCA9IGhpZXJhcmNoeV8xLmRlZmF1bHQuY29tcGFjdEJveChyb290LCBvcHRpb25zKTtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnaGllcmFyY2h5LmNvbXBhY3QtYm94JywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnY29tcGFjdC1ib3gtdHJlZScsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ25vbi1sYXllcmVkLXRpZHktdHJlZScsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ21pbmRtYXAtbG9naWNhbCcsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS9kZW5kcm9ncmFtLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L2RlbmRyb2dyYW0udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciBoaWVyYXJjaHlfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L2hpZXJhcmNoeSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl9oaWVyYXJjaHlAMC42LjJAQGFudHYvaGllcmFyY2h5L2J1aWxkL2hpZXJhcmNoeS5qc1wiKSk7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge307XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICB2YXIgcm9vdCA9IGRhdGFWaWV3LnJvb3Q7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgaWYgKGRhdGFWaWV3LmRhdGFUeXBlICE9PSBkYXRhX3NldF8xLkRhdGFTZXQuQ09OU1RBTlRTLkhJRVJBUkNIWSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERhdGFWaWV3OiBUaGlzIHRyYW5zZm9ybSBpcyBmb3IgSGllcmFyY2h5IGRhdGEgb25seSEnKTtcbiAgICB9XG4gICAgZGF0YVZpZXcucm9vdCA9IGhpZXJhcmNoeV8xLmRlZmF1bHQuZGVuZHJvZ3JhbShyb290LCBvcHRpb25zKTtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnaGllcmFyY2h5LmRlbmRyb2dyYW0nLCB0cmFuc2Zvcm0pO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdkZW5kcm9ncmFtJywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L2luZGVudGVkLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS9pbmRlbnRlZC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciBoaWVyYXJjaHlfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L2hpZXJhcmNoeSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl9oaWVyYXJjaHlAMC42LjJAQGFudHYvaGllcmFyY2h5L2J1aWxkL2hpZXJhcmNoeS5qc1wiKSk7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge307XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICB2YXIgcm9vdCA9IGRhdGFWaWV3LnJvb3Q7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgaWYgKGRhdGFWaWV3LmRhdGFUeXBlICE9PSBkYXRhX3NldF8xLkRhdGFTZXQuQ09OU1RBTlRTLkhJRVJBUkNIWSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERhdGFWaWV3OiBUaGlzIHRyYW5zZm9ybSBpcyBmb3IgSGllcmFyY2h5IGRhdGEgb25seSEnKTtcbiAgICB9XG4gICAgZGF0YVZpZXcucm9vdCA9IGhpZXJhcmNoeV8xLmRlZmF1bHQuaW5kZW50ZWQocm9vdCwgb3B0aW9ucyk7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2hpZXJhcmNoeS5pbmRlbnRlZCcsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2luZGVudGVkLXRyZWUnLCB0cmFuc2Zvcm0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9oaWVyYXJjaHkvcGFjay50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS9wYWNrLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGQzSGllcmFyY2h5ID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtaGllcmFyY2h5ICovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWhpZXJhcmNoeUAxLjEuOUBkMy1oaWVyYXJjaHkvZGlzdC9kMy1oaWVyYXJjaHkuanNcIikpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgZmllbGQ6ICd2YWx1ZScsXG4gICAgc2l6ZTogWzEsIDFdLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgYXM6IFsneCcsICd5JywgJ3InXSxcbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBpZiAoZGF0YVZpZXcuZGF0YVR5cGUgIT09IGRhdGFfc2V0XzEuRGF0YVNldC5DT05TVEFOVFMuSElFUkFSQ0hZKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgRGF0YVZpZXc6IFRoaXMgdHJhbnNmb3JtIGlzIGZvciBIaWVyYXJjaHkgZGF0YSBvbmx5IScpO1xuICAgIH1cbiAgICB2YXIgcm9vdCA9IGRhdGFWaWV3LnJvb3Q7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGFzID0gb3B0aW9ucy5hcztcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGFzKSB8fCBhcy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhczogaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIDMgc3RyaW5ncyAoZS5nLiBbIFwieFwiLCBcInlcIiwgXCJyXCIgXSkhJyk7XG4gICAgfVxuICAgIHZhciBmaWVsZDtcbiAgICB0cnkge1xuICAgICAgICBmaWVsZCA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZChvcHRpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgIH1cbiAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgcm9vdC5zdW0oZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbZmllbGRdOyB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiW2ZpZWxkXSAtIGFbZmllbGRdOyB9KTtcbiAgICB9XG4gICAgdmFyIHBhY2tMYXlvdXQgPSBkM0hpZXJhcmNoeS5wYWNrKCk7XG4gICAgcGFja0xheW91dC5zaXplKG9wdGlvbnMuc2l6ZSk7XG4gICAgaWYgKG9wdGlvbnMucGFkZGluZykge1xuICAgICAgICBwYWNrTGF5b3V0LnBhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgICB9XG4gICAgcGFja0xheW91dChyb290KTtcbiAgICB2YXIgeCA9IGFzWzBdO1xuICAgIHZhciB5ID0gYXNbMV07XG4gICAgdmFyIHIgPSBhc1syXTtcbiAgICByb290LmVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZVt4XSA9IG5vZGUueDtcbiAgICAgICAgbm9kZVt5XSA9IG5vZGUueTtcbiAgICAgICAgbm9kZVtyXSA9IG5vZGUucjtcbiAgICB9KTtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnaGllcmFyY2h5LnBhY2snLCB0cmFuc2Zvcm0pO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdoaWVyYXJjaHkuY2lyY2xlLXBhY2tpbmcnLCB0cmFuc2Zvcm0pO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdjaXJjbGUtcGFja2luZycsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS9wYXJ0aXRpb24udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS9wYXJ0aXRpb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIGQzSGllcmFyY2h5ID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtaGllcmFyY2h5ICovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWhpZXJhcmNoeUAxLjEuOUBkMy1oaWVyYXJjaHkvZGlzdC9kMy1oaWVyYXJjaHkuanNcIikpO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIGZpZWxkOiAndmFsdWUnLFxuICAgIHNpemU6IFsxLCAxXSxcbiAgICByb3VuZDogZmFsc2UsXG4gICAgLy8gcmF0aW86IDEuNjE4MDMzOTg4NzQ5ODk1LCAvLyBnb2xkZW4gcmF0aW9cbiAgICBwYWRkaW5nOiAwLFxuICAgIHNvcnQ6IHRydWUsXG4gICAgYXM6IFsneCcsICd5J10sXG59O1xuZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgaWYgKGRhdGFWaWV3LmRhdGFUeXBlICE9PSBkYXRhX3NldF8xLkRhdGFTZXQuQ09OU1RBTlRTLkhJRVJBUkNIWSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERhdGFWaWV3OiBUaGlzIHRyYW5zZm9ybSBpcyBmb3IgSGllcmFyY2h5IGRhdGEgb25seSEnKTtcbiAgICB9XG4gICAgdmFyIHJvb3QgPSBkYXRhVmlldy5yb290O1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBhcyA9IG9wdGlvbnMuYXM7XG4gICAgaWYgKCF1dGlsXzEuaXNBcnJheShhcykgfHwgYXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXM6IGl0IG11c3QgYmUgYW4gYXJyYXkgd2l0aCAyIHN0cmluZ3MgKGUuZy4gWyBcInhcIiwgXCJ5XCIgXSkhJyk7XG4gICAgfVxuICAgIHZhciBmaWVsZDtcbiAgICB0cnkge1xuICAgICAgICBmaWVsZCA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZChvcHRpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgIH1cbiAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgcm9vdC5zdW0oZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbZmllbGRdOyB9KTtcbiAgICB9XG4gICAgdmFyIHBhcnRpdGlvbkxheW91dCA9IGQzSGllcmFyY2h5LnBhcnRpdGlvbigpO1xuICAgIHBhcnRpdGlvbkxheW91dFxuICAgICAgICAuc2l6ZShvcHRpb25zLnNpemUpXG4gICAgICAgIC5yb3VuZChvcHRpb25zLnJvdW5kKVxuICAgICAgICAucGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICAgIHBhcnRpdGlvbkxheW91dChyb290KTtcbiAgICAvKlxuICAgICAqIHBvaW50czpcbiAgICAgKiAgIDMgIDJcbiAgICAgKiAgIDAgIDFcbiAgICAgKi9cbiAgICB2YXIgeCA9IGFzWzBdO1xuICAgIHZhciB5ID0gYXNbMV07XG4gICAgcm9vdC5lYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGVbeF0gPSBbbm9kZS54MCwgbm9kZS54MSwgbm9kZS54MSwgbm9kZS54MF07XG4gICAgICAgIG5vZGVbeV0gPSBbbm9kZS55MSwgbm9kZS55MSwgbm9kZS55MCwgbm9kZS55MF07XG4gICAgICAgIFsneDAnLCAneDEnLCAneTAnLCAneTEnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoYXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2hpZXJhcmNoeS5wYXJ0aXRpb24nLCB0cmFuc2Zvcm0pO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdhZGphY2VuY3knLCB0cmFuc2Zvcm0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9oaWVyYXJjaHkvdHJlZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS90cmVlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgZDNIaWVyYXJjaHkgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1oaWVyYXJjaHkgKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtaGllcmFyY2h5QDEuMS45QGQzLWhpZXJhcmNoeS9kaXN0L2QzLWhpZXJhcmNoeS5qc1wiKSk7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgZmllbGQ6ICd2YWx1ZScsXG4gICAgc2l6ZTogWzEsIDFdLFxuICAgIG5vZGVTaXplOiBudWxsLFxuICAgIHNlcGFyYXRpb246IG51bGwsXG4gICAgYXM6IFsneCcsICd5J10sXG59O1xuZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgaWYgKGRhdGFWaWV3LmRhdGFUeXBlICE9PSBkYXRhX3NldF8xLkRhdGFTZXQuQ09OU1RBTlRTLkhJRVJBUkNIWSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERhdGFWaWV3OiBUaGlzIHRyYW5zZm9ybSBpcyBmb3IgSGllcmFyY2h5IGRhdGEgb25seSEnKTtcbiAgICB9XG4gICAgdmFyIHJvb3QgPSBkYXRhVmlldy5yb290O1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBhcyA9IG9wdGlvbnMuYXM7XG4gICAgaWYgKCF1dGlsXzEuaXNBcnJheShhcykgfHwgYXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXM6IGl0IG11c3QgYmUgYW4gYXJyYXkgd2l0aCAyIHN0cmluZ3MgKGUuZy4gWyBcInhcIiwgXCJ5XCIgXSkhJyk7XG4gICAgfVxuICAgIHZhciBmaWVsZDtcbiAgICB0cnkge1xuICAgICAgICBmaWVsZCA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZChvcHRpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgIH1cbiAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgcm9vdC5zdW0oZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbZmllbGRdOyB9KTtcbiAgICB9XG4gICAgdmFyIHRyZWVMYXlvdXQgPSBkM0hpZXJhcmNoeS50cmVlKCk7XG4gICAgdHJlZUxheW91dC5zaXplKG9wdGlvbnMuc2l6ZSk7XG4gICAgaWYgKG9wdGlvbnMubm9kZVNpemUpIHtcbiAgICAgICAgdHJlZUxheW91dC5ub2RlU2l6ZShvcHRpb25zLm5vZGVTaXplKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2VwYXJhdGlvbikge1xuICAgICAgICB0cmVlTGF5b3V0LnNlcGFyYXRpb24ob3B0aW9ucy5zZXBhcmF0aW9uKTtcbiAgICB9XG4gICAgdHJlZUxheW91dChyb290KTtcbiAgICB2YXIgeCA9IGFzWzBdO1xuICAgIHZhciB5ID0gYXNbMV07XG4gICAgcm9vdC5lYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGVbeF0gPSBub2RlLng7XG4gICAgICAgIG5vZGVbeV0gPSBub2RlLnk7XG4gICAgfSk7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2hpZXJhcmNoeS50cmVlJywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgndHJlZScsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS90cmVlbWFwLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L3RyZWVtYXAudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciBkM0hpZXJhcmNoeSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLWhpZXJhcmNoeSAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1oaWVyYXJjaHlAMS4xLjlAZDMtaGllcmFyY2h5L2Rpc3QvZDMtaGllcmFyY2h5LmpzXCIpKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgb3B0aW9uX3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvdXRpbC9vcHRpb24tcGFyc2VyLnRzXCIpO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBmaWVsZDogJ3ZhbHVlJyxcbiAgICB0aWxlOiAndHJlZW1hcFNxdWFyaWZ5JyxcbiAgICBzaXplOiBbMSwgMV0sXG4gICAgcm91bmQ6IGZhbHNlLFxuICAgIC8vIHJhdGlvOiAxLjYxODAzMzk4ODc0OTg5NSwgLy8gZ29sZGVuIHJhdGlvXG4gICAgcGFkZGluZzogMCxcbiAgICBwYWRkaW5nSW5uZXI6IDAsXG4gICAgcGFkZGluZ091dGVyOiAwLFxuICAgIHBhZGRpbmdUb3A6IDAsXG4gICAgcGFkZGluZ1JpZ2h0OiAwLFxuICAgIHBhZGRpbmdCb3R0b206IDAsXG4gICAgcGFkZGluZ0xlZnQ6IDAsXG4gICAgYXM6IFsneCcsICd5J10sXG59O1xuZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgaWYgKGRhdGFWaWV3LmRhdGFUeXBlICE9PSBkYXRhX3NldF8xLkRhdGFTZXQuQ09OU1RBTlRTLkhJRVJBUkNIWSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERhdGFWaWV3OiBUaGlzIHRyYW5zZm9ybSBpcyBmb3IgSGllcmFyY2h5IGRhdGEgb25seSEnKTtcbiAgICB9XG4gICAgdmFyIHJvb3QgPSBkYXRhVmlldy5yb290O1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBhcyA9IG9wdGlvbnMuYXM7XG4gICAgaWYgKCF1dGlsXzEuaXNBcnJheShhcykgfHwgYXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXM6IGl0IG11c3QgYmUgYW4gYXJyYXkgd2l0aCAyIHN0cmluZ3MgKGUuZy4gWyBcInhcIiwgXCJ5XCIgXSkhJyk7XG4gICAgfVxuICAgIHZhciBmaWVsZDtcbiAgICB0cnkge1xuICAgICAgICBmaWVsZCA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZChvcHRpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgIH1cbiAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgcm9vdC5zdW0oZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbZmllbGRdOyB9KTtcbiAgICB9XG4gICAgdmFyIHRyZWVtYXBMYXlvdXQgPSBkM0hpZXJhcmNoeS50cmVlbWFwKCk7XG4gICAgdHJlZW1hcExheW91dFxuICAgICAgICAudGlsZShkM0hpZXJhcmNoeVtvcHRpb25zLnRpbGVdKVxuICAgICAgICAuc2l6ZShvcHRpb25zLnNpemUpXG4gICAgICAgIC5yb3VuZChvcHRpb25zLnJvdW5kKVxuICAgICAgICAucGFkZGluZyhvcHRpb25zLnBhZGRpbmcpXG4gICAgICAgIC5wYWRkaW5nSW5uZXIob3B0aW9ucy5wYWRkaW5nSW5uZXIpXG4gICAgICAgIC5wYWRkaW5nT3V0ZXIob3B0aW9ucy5wYWRkaW5nT3V0ZXIpXG4gICAgICAgIC5wYWRkaW5nVG9wKG9wdGlvbnMucGFkZGluZ1RvcClcbiAgICAgICAgLnBhZGRpbmdSaWdodChvcHRpb25zLnBhZGRpbmdSaWdodClcbiAgICAgICAgLnBhZGRpbmdCb3R0b20ob3B0aW9ucy5wYWRkaW5nQm90dG9tKVxuICAgICAgICAucGFkZGluZ0xlZnQob3B0aW9ucy5wYWRkaW5nTGVmdCk7XG4gICAgdHJlZW1hcExheW91dChyb290KTtcbiAgICAvKlxuICAgICAqIHBvaW50czpcbiAgICAgKiAgIDMgIDJcbiAgICAgKiAgIDAgIDFcbiAgICAgKi9cbiAgICB2YXIgeCA9IGFzWzBdO1xuICAgIHZhciB5ID0gYXNbMV07XG4gICAgcm9vdC5lYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGVbeF0gPSBbbm9kZS54MCwgbm9kZS54MSwgbm9kZS54MSwgbm9kZS54MF07XG4gICAgICAgIG5vZGVbeV0gPSBbbm9kZS55MSwgbm9kZS55MSwgbm9kZS55MCwgbm9kZS55MF07XG4gICAgICAgIFsneDAnLCAneDEnLCAneTAnLCAneTEnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoYXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2hpZXJhcmNoeS50cmVlbWFwJywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgndHJlZW1hcCcsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2ltcHV0ZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9pbXB1dGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIHNpbXBsZVN0YXRpc3RpY3MgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzaW1wbGUtc3RhdGlzdGljcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19zaW1wbGUtc3RhdGlzdGljc0A2LjEuMUBzaW1wbGUtc3RhdGlzdGljcy9kaXN0L3NpbXBsZS1zdGF0aXN0aWNzLm1pbi5qc1wiKSk7XG52YXIgcGFydGl0aW9uXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL3BhcnRpdGlvbiAqLyBcIi4vc3JjL3V0aWwvcGFydGl0aW9uLnRzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIC8vIGZpZWxkOiAnJywgLy8gcmVxdWlyZWRcbiAgICAvLyBtZXRob2Q6ICd2YWx1ZScsIC8vIHJlcXVpcmVkXG4gICAgLy8gdmFsdWU6IDEwLCAvLyByZXF1aXJlZCBpZiAobWV0aG9kID09PSAndmFsdWUnKVxuICAgIGdyb3VwQnk6IFtdLFxufTtcbmZ1bmN0aW9uIG5vdFVuZGVmaW5lZFZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICF1dGlsXzEuaXNVbmRlZmluZWQodmFsdWUpOyB9KTtcbn1cbnZhciBTVEFUSVNUSUNTX01FVEhPRFMgPSBbJ21lYW4nLCAnbWVkaWFuJywgJ21heCcsICdtaW4nXTtcbnZhciBpbXB1dGF0aW9ucyA9IHt9O1xuU1RBVElTVElDU19NRVRIT0RTLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpbXB1dGF0aW9uc1ttZXRob2RdID0gZnVuY3Rpb24gKHJvdywgdmFsdWVzKSB7IHJldHVybiBzaW1wbGVTdGF0aXN0aWNzW21ldGhvZF0odmFsdWVzKTsgfTtcbn0pO1xuaW1wdXRhdGlvbnMudmFsdWUgPSBmdW5jdGlvbiAoX3JvdywgX3ZhbHVlcywgdmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGZpZWxkID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkKG9wdGlvbnMpO1xuICAgIHZhciBtZXRob2QgPSBvcHRpb25zLm1ldGhvZDtcbiAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1ldGhvZCEnKTtcbiAgICB9XG4gICAgaWYgKG1ldGhvZCA9PT0gJ3ZhbHVlJyAmJiAhdXRpbF8xLmhhcyhvcHRpb25zLCAndmFsdWUnKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHZhbHVlOiBpdCBpcyBuaWwuJyk7XG4gICAgfVxuICAgIHZhciBjb2x1bW4gPSBub3RVbmRlZmluZWRWYWx1ZXMoZGF0YVZpZXcuZ2V0Q29sdW1uKGZpZWxkKSk7XG4gICAgdmFyIGdyb3VwcyA9IHBhcnRpdGlvbl8xLmRlZmF1bHQoZGF0YVZpZXcucm93cywgb3B0aW9ucy5ncm91cEJ5KTtcbiAgICB1dGlsXzEuZm9ySW4oZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgdmFyIGZpZWxkVmFsdWVzID0gbm90VW5kZWZpbmVkVmFsdWVzKGdyb3VwLm1hcChmdW5jdGlvbiAocm93KSB7IHJldHVybiByb3dbZmllbGRdOyB9KSk7XG4gICAgICAgIGlmIChmaWVsZFZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWVzID0gY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGdyb3VwLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgaWYgKHV0aWxfMS5pc1VuZGVmaW5lZChyb3dbZmllbGRdKSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsXzEuaXNGdW5jdGlvbihtZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tmaWVsZF0gPSBtZXRob2Qocm93LCBmaWVsZFZhbHVlcywgb3B0aW9ucy52YWx1ZSwgZ3JvdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1dGlsXzEuaXNTdHJpbmcobWV0aG9kKSkge1xuICAgICAgICAgICAgICAgICAgICByb3dbZmllbGRdID0gaW1wdXRhdGlvbnNbbWV0aG9kXShyb3csIGZpZWxkVmFsdWVzLCBvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIG1ldGhvZDogbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIG9uZSBvZiBcIiArIFNUQVRJU1RJQ1NfTUVUSE9EUy5qb2luKCcsICcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdpbXB1dGUnLCB0cmFuc2Zvcm0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9rZGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0va2RlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xuLypcbiAqIGtlcm5lbCBkZW5zaXR5IGVzdGltYXRpb25cbiAqL1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBnZXRfc2VyaWVzX3ZhbHVlc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9nZXQtc2VyaWVzLXZhbHVlcyAqLyBcIi4vc3JjL3V0aWwvZ2V0LXNlcmllcy12YWx1ZXMudHNcIikpO1xudmFyIGtlcm5lbF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9rZXJuZWwgKi8gXCIuL3NyYy91dGlsL2tlcm5lbC50c1wiKSk7XG52YXIgYmFuZHdpZHRoID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9iYW5kd2lkdGggKi8gXCIuL3NyYy91dGlsL2JhbmR3aWR0aC50c1wiKSk7XG52YXIgcGFydGl0aW9uXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL3BhcnRpdGlvbiAqLyBcIi4vc3JjL3V0aWwvcGFydGl0aW9uLnRzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgc2ltcGxlX3N0YXRpc3RpY3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHNpbXBsZS1zdGF0aXN0aWNzICovIFwiLi9ub2RlX21vZHVsZXMvX3NpbXBsZS1zdGF0aXN0aWNzQDYuMS4xQHNpbXBsZS1zdGF0aXN0aWNzL2Rpc3Qvc2ltcGxlLXN0YXRpc3RpY3MubWluLmpzXCIpO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBtaW5TaXplOiAwLjAxLFxuICAgIGFzOiBbJ2tleScsICd5JywgJ3NpemUnXSxcbiAgICAvLyBmaWVsZHM6IFsgJ3kxJywgJ3kyJyBdLCAvLyByZXF1aXJlZCwgb25lIG9yIG1vcmUgZmllbGRzXG4gICAgZXh0ZW50OiBbXSxcbiAgICBtZXRob2Q6ICdnYXVzc2lhbicsXG4gICAgYmFuZHdpZHRoOiAnbnJkJyxcbiAgICBzdGVwOiAwLFxuICAgIGdyb3VwQnk6IFtdLFxufTtcbnZhciBLRVJORUxfTUVUSE9EUyA9IHV0aWxfMS5rZXlzKGtlcm5lbF8xLmRlZmF1bHQpO1xudmFyIEJBTkRXSURUSF9NRVRIT0RTID0gdXRpbF8xLmtleXMoYmFuZHdpZHRoKTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShkdiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBmaWVsZHMgPSBvcHRpb25fcGFyc2VyXzEuZ2V0RmllbGRzKG9wdGlvbnMpO1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkoZmllbGRzKSB8fCBmaWVsZHMubGVuZ3RoIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGZpZWxkczogbXVzdCBiZSBhbiBhcnJheSBvZiBhdCBsZWFzdCAxIHN0cmluZ3MhJyk7XG4gICAgfVxuICAgIHZhciBhcyA9IG9wdGlvbnMuYXM7XG4gICAgaWYgKCF1dGlsXzEuaXNBcnJheShhcykgfHwgYXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXM6IG11c3QgYmUgYW4gYXJyYXkgb2YgMyBzdHJpbmdzIScpO1xuICAgIH1cbiAgICB2YXIgbWV0aG9kID0gb3B0aW9ucy5tZXRob2Q7XG4gICAgaWYgKHV0aWxfMS5pc1N0cmluZyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChLRVJORUxfTUVUSE9EUy5pbmRleE9mKG1ldGhvZCkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBtZXRob2Q6IFwiICsgbWV0aG9kICsgXCIuIE11c3QgYmUgb25lIG9mIFwiICsgS0VSTkVMX01FVEhPRFMuam9pbignLCAnKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWV0aG9kID0ga2VybmVsXzEuZGVmYXVsdFttZXRob2RdO1xuICAgIH1cbiAgICBpZiAoIXV0aWxfMS5pc0Z1bmN0aW9uKG1ldGhvZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBtZXRob2Q6IGtlcm5lbCBtZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uIScpO1xuICAgIH1cbiAgICB2YXIgZXh0ZW50ID0gb3B0aW9ucy5leHRlbnQ7XG4gICAgaWYgKCF1dGlsXzEuaXNBcnJheShleHRlbnQpIHx8IGV4dGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIHJhbmdlQXJyXzEgPSBbXTtcbiAgICAgICAgdXRpbF8xLmVhY2goZmllbGRzLCBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGR2LnJhbmdlKGZpZWxkKTtcbiAgICAgICAgICAgIHJhbmdlQXJyXzEgPSByYW5nZUFycl8xLmNvbmNhdChyYW5nZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBleHRlbnQgPSBbTWF0aC5taW4uYXBwbHkoTWF0aCwgdHNsaWJfMS5fX3NwcmVhZChyYW5nZUFycl8xKSksIE1hdGgubWF4LmFwcGx5KE1hdGgsIHRzbGliXzEuX19zcHJlYWQocmFuZ2VBcnJfMSkpXTtcbiAgICB9XG4gICAgdmFyIGJ3ID0gb3B0aW9ucy5iYW5kd2lkdGg7XG4gICAgaWYgKHV0aWxfMS5pc1N0cmluZyhidykgJiYgYmFuZHdpZHRoW2J3XSkge1xuICAgICAgICBidyA9IGJhbmR3aWR0aFtid10oZHYuZ2V0Q29sdW1uKGZpZWxkc1swXSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh1dGlsXzEuaXNGdW5jdGlvbihidykpIHtcbiAgICAgICAgYncgPSBidyhkdi5nZXRDb2x1bW4oZmllbGRzWzBdKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCF1dGlsXzEuaXNOdW1iZXIoYncpIHx8IGJ3IDw9IDApIHtcbiAgICAgICAgYncgPSBiYW5kd2lkdGgubnJkKGR2LmdldENvbHVtbihmaWVsZHNbMF0pKTtcbiAgICB9XG4gICAgdmFyIHNlcmllc1ZhbHVlcyA9IGdldF9zZXJpZXNfdmFsdWVzXzEuZGVmYXVsdChleHRlbnQsIG9wdGlvbnMuc3RlcCA/IG9wdGlvbnMuc3RlcCA6IGJ3KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGdyb3VwQnkgPSBvcHRpb25zLmdyb3VwQnk7XG4gICAgdmFyIGdyb3VwcyA9IHBhcnRpdGlvbl8xLmRlZmF1bHQoZHYucm93cywgZ3JvdXBCeSk7XG4gICAgdXRpbF8xLmZvckluKGdyb3VwcywgZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIHZhciBwcm9iYWxpdHlEZW5zaXR5RnVuY3Rpb25CeUZpZWxkID0ge307XG4gICAgICAgIHV0aWxfMS5lYWNoKGZpZWxkcywgZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gdXRpbF8xLnBpY2soZ3JvdXBbMF0sIGdyb3VwQnkpO1xuICAgICAgICAgICAgcHJvYmFsaXR5RGVuc2l0eUZ1bmN0aW9uQnlGaWVsZFtmaWVsZF0gPSBzaW1wbGVfc3RhdGlzdGljc18xLmtlcm5lbERlbnNpdHlFc3RpbWF0aW9uKGdyb3VwLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbVtmaWVsZF07IH0pLCBtZXRob2QsIGJ3KTtcbiAgICAgICAgICAgIHZhciBfYSA9IHRzbGliXzEuX19yZWFkKGFzLCAzKSwga2V5ID0gX2FbMF0sIHkgPSBfYVsxXSwgc2l6ZSA9IF9hWzJdO1xuICAgICAgICAgICAgcm93W2tleV0gPSBmaWVsZDtcbiAgICAgICAgICAgIHJvd1t5XSA9IFtdO1xuICAgICAgICAgICAgcm93W3NpemVdID0gW107XG4gICAgICAgICAgICB1dGlsXzEuZWFjaChzZXJpZXNWYWx1ZXMsIGZ1bmN0aW9uICh5VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZVZhbHVlID0gcHJvYmFsaXR5RGVuc2l0eUZ1bmN0aW9uQnlGaWVsZFtmaWVsZF0oeVZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZVZhbHVlID49IG9wdGlvbnMubWluU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICByb3dbeV0ucHVzaCh5VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByb3dbc2l6ZV0ucHVzaChzaXplVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgZHYucm93cyA9IHJlc3VsdDtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgna2VybmVsLWRlbnNpdHktZXN0aW1hdGlvbicsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2tkZScsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ0tERScsIHRyYW5zZm9ybSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgS0VSTkVMX01FVEhPRFM6IEtFUk5FTF9NRVRIT0RTLFxuICAgIEJBTkRXSURUSF9NRVRIT0RTOiBCQU5EV0lEVEhfTUVUSE9EUyxcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2tlcm5lbC1zbW9vdGgvZGVuc2l0eS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9rZXJuZWwtc21vb3RoL2RlbnNpdHkudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG4vKlxuICogQHJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL1BsYW5lc2hpZnRlci9rZXJuZWwtc21vb3RoL2Jsb2IvbWFzdGVyL2xpYi9pbmRleC5qc1xuICovXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGdldF9zZXJpZXNfdmFsdWVzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2dldC1zZXJpZXMtdmFsdWVzICovIFwiLi9zcmMvdXRpbC9nZXQtc2VyaWVzLXZhbHVlcy50c1wiKSk7XG52YXIga2VybmVsXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2tlcm5lbCAqLyBcIi4vc3JjL3V0aWwva2VybmVsLnRzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgYmFuZHdpZHRoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2JhbmR3aWR0aCAqLyBcIi4vc3JjL3V0aWwvYmFuZHdpZHRoLnRzXCIpO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBhczogWyd4JywgJ3knLCAneiddLFxuICAgIC8vIGZpZWxkczogWyAneCcsICd5JyBdLCAvLyByZXF1aXJlZCwgb25lIG9yIHR3byBmaWVsZHNcbiAgICBtZXRob2Q6ICdnYXVzc2lhbicsXG59O1xudmFyIEtFUk5FTF9NRVRIT0RTID0gdXRpbF8xLmtleXMoa2VybmVsXzEuZGVmYXVsdCk7XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZHYsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBmaWVsZHMgPSBvcHRpb25fcGFyc2VyXzEuZ2V0RmllbGRzKG9wdGlvbnMpO1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkoZmllbGRzKSB8fCBmaWVsZHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZmllbGRzOiBtdXN0IGJlIGFuIGFycmF5IG9mIDIgc3RyaW5ncyEnKTtcbiAgICB9XG4gICAgdmFyIF9jID0gdHNsaWJfMS5fX3JlYWQob3B0aW9ucy5hcywgMyksIGFzWCA9IF9jWzBdLCBhc1kgPSBfY1sxXSwgYXNaID0gX2NbMl07XG4gICAgaWYgKCF1dGlsXzEuaXNTdHJpbmcoYXNYKSB8fCAhdXRpbF8xLmlzU3RyaW5nKGFzWSkgfHwgIXV0aWxfMS5pc1N0cmluZyhhc1opKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXM6IG11c3QgYmUgYW4gYXJyYXkgb2YgMyBzdHJpbmdzIScpO1xuICAgIH1cbiAgICB2YXIgbWV0aG9kO1xuICAgIGlmICh1dGlsXzEuaXNTdHJpbmcob3B0aW9ucy5tZXRob2QpKSB7XG4gICAgICAgIGlmIChLRVJORUxfTUVUSE9EUy5pbmRleE9mKG9wdGlvbnMubWV0aG9kKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIG1ldGhvZDogXCIgKyBvcHRpb25zLm1ldGhvZCArIFwiLiBNdXN0IGJlIG9uZSBvZiBcIiArIEtFUk5FTF9NRVRIT0RTLmpvaW4oJywgJykpO1xuICAgICAgICB9XG4gICAgICAgIG1ldGhvZCA9IGtlcm5lbF8xLmRlZmF1bHRbb3B0aW9ucy5tZXRob2RdO1xuICAgIH1cbiAgICB2YXIgX2QgPSB0c2xpYl8xLl9fcmVhZChmaWVsZHMsIDIpLCB4RmllbGQgPSBfZFswXSwgeUZpZWxkID0gX2RbMV07XG4gICAgdmFyIGV4dGVudCA9IG9wdGlvbnMuZXh0ZW50LCBiYW5kd2lkdGggPSBvcHRpb25zLmJhbmR3aWR0aDtcbiAgICB2YXIgZXh0ZW50WDtcbiAgICB2YXIgZXh0ZW50WTtcbiAgICBpZiAoZXh0ZW50ICYmIEFycmF5LmlzQXJyYXkoZXh0ZW50KSAmJiBBcnJheS5pc0FycmF5KGV4dGVudFswXSkgJiYgQXJyYXkuaXNBcnJheShleHRlbnRbMV0pKSB7XG4gICAgICAgIF9hID0gdHNsaWJfMS5fX3JlYWQoZXh0ZW50LCAyKSwgZXh0ZW50WCA9IF9hWzBdLCBleHRlbnRZID0gX2FbMV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBleHRlbnRYID0gZHYucmFuZ2UoeEZpZWxkKTtcbiAgICAgICAgZXh0ZW50WSA9IGR2LnJhbmdlKHlGaWVsZCk7XG4gICAgfVxuICAgIHZhciBid1gsIGJ3WTtcbiAgICBpZiAoYmFuZHdpZHRoICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkoYmFuZHdpZHRoKSAmJlxuICAgICAgICBiYW5kd2lkdGguc2xpY2UoMCwgMikuZXZlcnkodXRpbF8xLmlzTnVtYmVyKSAmJlxuICAgICAgICBiYW5kd2lkdGguc2xpY2UoMCwgMikuZXZlcnkoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0gPiAwOyB9KSkge1xuICAgICAgICBfYiA9IHRzbGliXzEuX19yZWFkKGJhbmR3aWR0aCwgMiksIGJ3WCA9IF9iWzBdLCBid1kgPSBfYlsxXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJ3WCA9IGJhbmR3aWR0aF8xLnNpbHZlcm1hbihkdi5nZXRDb2x1bW4oeEZpZWxkKSk7XG4gICAgICAgIGJ3WSA9IGJhbmR3aWR0aF8xLnNpbHZlcm1hbihkdi5nZXRDb2x1bW4oeUZpZWxkKSk7XG4gICAgfVxuICAgIHZhciBzZXJpZXNWYWx1ZXNYID0gZ2V0X3Nlcmllc192YWx1ZXNfMS5kZWZhdWx0KGV4dGVudFgsIGJ3WCk7XG4gICAgdmFyIHNlcmllc1ZhbHVlc1kgPSBnZXRfc2VyaWVzX3ZhbHVlc18xLmRlZmF1bHQoZXh0ZW50WSwgYndZKTtcbiAgICB2YXIgY291bnQgPSBkdi5yb3dzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXJpZXNWYWx1ZXNYLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VyaWVzVmFsdWVzWS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICB2YXIgeCA9IHNlcmllc1ZhbHVlc1hbaV07XG4gICAgICAgICAgICB2YXIgeSA9IHNlcmllc1ZhbHVlc1lbal07XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGNvdW50OyBrKyspIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gbWV0aG9kKCh4IC0gZHYucm93c1trXVt4RmllbGRdKSAvIGJ3WCkgKiBtZXRob2QoKHkgLSBkdi5yb3dzW2tdW3lGaWVsZF0pIC8gYndZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB6ID0gKDEgLyAoY291bnQgKiBid1ggKiBid1kpKSAqIHN1bTtcbiAgICAgICAgICAgIHZhciByb3cgPSB7fTtcbiAgICAgICAgICAgIHJvd1thc1hdID0geDtcbiAgICAgICAgICAgIHJvd1thc1ldID0geTtcbiAgICAgICAgICAgIHJvd1thc1pdID0gejtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJvdyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHYucm93cyA9IHJlc3VsdDtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgna2VybmVsLXNtb290aC5kZW5zaXR5JywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgna2VybmVsLmRlbnNpdHknLCB0cmFuc2Zvcm0pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIEtFUk5FTF9NRVRIT0RTOiBLRVJORUxfTUVUSE9EUyxcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2tlcm5lbC1zbW9vdGgvcmVncmVzc2lvbi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9rZXJuZWwtc21vb3RoL3JlZ3Jlc3Npb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG4vKlxuICogQHJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL1BsYW5lc2hpZnRlci9rZXJuZWwtc21vb3RoL2Jsb2IvbWFzdGVyL2xpYi9pbmRleC5qc1xuICovXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGdldF9zZXJpZXNfdmFsdWVzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2dldC1zZXJpZXMtdmFsdWVzICovIFwiLi9zcmMvdXRpbC9nZXQtc2VyaWVzLXZhbHVlcy50c1wiKSk7XG52YXIga2VybmVsXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2tlcm5lbCAqLyBcIi4vc3JjL3V0aWwva2VybmVsLnRzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBzaW1wbGVfc3RhdGlzdGljc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc2ltcGxlLXN0YXRpc3RpY3MgKi8gXCIuL25vZGVfbW9kdWxlcy9fc2ltcGxlLXN0YXRpc3RpY3NANi4xLjFAc2ltcGxlLXN0YXRpc3RpY3MvZGlzdC9zaW1wbGUtc3RhdGlzdGljcy5taW4uanNcIik7XG52YXIgb3B0aW9uX3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvdXRpbC9vcHRpb24tcGFyc2VyLnRzXCIpO1xudmFyIGJhbmR3aWR0aF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9iYW5kd2lkdGggKi8gXCIuL3NyYy91dGlsL2JhbmR3aWR0aC50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgYXM6IFsneCcsICd5J10sXG4gICAgLy8gZmllbGRzOiBbICd4JywgJ3knIF0sIC8vIHJlcXVpcmVkLCBvbmUgb3IgdHdvIGZpZWxkc1xuICAgIG1ldGhvZDogJ2dhdXNzaWFuJyxcbn07XG52YXIgS0VSTkVMX01FVEhPRFMgPSB1dGlsXzEua2V5cyhrZXJuZWxfMS5kZWZhdWx0KTtcbi8vIGNhbGN1bGF0ZXMgd2VpZ2h0IGZvciBpLXRoIG9ic1xuZnVuY3Rpb24gd2VpZ2h0KGtlcm5lbCwgYmFuZHdpZHRoLCB4XzAsIHhfaSkge1xuICAgIHZhciBhcmcgPSAoeF9pIC0geF8wKSAvIGJhbmR3aWR0aDtcbiAgICByZXR1cm4ga2VybmVsKGFyZyk7XG59XG4vLyBjYWxjdWxhdGVzIHdlaWdodCBmb3IgaS10aCBvYnMgd2hlbiBwID4gMVxuLy8gZnVuY3Rpb24gd2VpZ2h0X3ZlY3RvcnMoa2VybmVsLCBiYW5kd2lkdGgsIHhfMCwgeF9pKSB7XG4vLyAgIGNvbnN0IGFyZyA9IGVuY2xpZGVhbkRpc3RhbmNlKHhfaSwgeF8wKSAvIGJhbmR3aWR0aDtcbi8vICAgcmV0dXJuIGtlcm5lbChhcmcpO1xuLy8gfVxuZnVuY3Rpb24gdmVjdG9yaXplKGZ1bikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoIXV0aWxfMS5pc0FycmF5KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuKHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4Lm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bih4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybShkdiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBmaWVsZHMgPSBvcHRpb25fcGFyc2VyXzEuZ2V0RmllbGRzKG9wdGlvbnMpO1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkoZmllbGRzKSB8fCAhKGZpZWxkcy5sZW5ndGggPT09IDEgfHwgZmllbGRzLmxlbmd0aCA9PT0gMikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBmaWVsZHM6IG11c3QgYmUgYW4gYXJyYXkgb2YgMSBvciAyIHN0cmluZ3MhJyk7XG4gICAgfVxuICAgIHZhciBfYSA9IHRzbGliXzEuX19yZWFkKG9wdGlvbnMuYXMsIDIpLCBhc1ggPSBfYVswXSwgYXNZID0gX2FbMV07XG4gICAgaWYgKCF1dGlsXzEuaXNTdHJpbmcoYXNYKSB8fCAhdXRpbF8xLmlzU3RyaW5nKGFzWSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhczogbXVzdCBiZSBhbiBhcnJheSBvZiAyIHN0cmluZ3MhJyk7XG4gICAgfVxuICAgIHZhciBmdW5jO1xuICAgIHZhciBtZXRob2QgPSBvcHRpb25zLm1ldGhvZDtcbiAgICBpZiAodXRpbF8xLmlzU3RyaW5nKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKEtFUk5FTF9NRVRIT0RTLmluZGV4T2YobWV0aG9kKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIG1ldGhvZDogXCIgKyBtZXRob2QgKyBcIi4gTXVzdCBiZSBvbmUgb2YgXCIgKyBLRVJORUxfTUVUSE9EUy5qb2luKCcsICcpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jID0ga2VybmVsXzEuZGVmYXVsdFttZXRob2RdO1xuICAgIH1cbiAgICB2YXIgX2IgPSB0c2xpYl8xLl9fcmVhZChmaWVsZHMsIDIpLCB4RmllbGQgPSBfYlswXSwgeUZpZWxkID0gX2JbMV07XG4gICAgdmFyIHhzID0gZHYuZ2V0Q29sdW1uKHhGaWVsZCk7XG4gICAgdmFyIGV4dGVudCA9IG9wdGlvbnMuZXh0ZW50O1xuICAgIGlmIChleHRlbnQgfHwgIXV0aWxfMS5pc0FycmF5KGV4dGVudCkpIHtcbiAgICAgICAgZXh0ZW50ID0gZHYucmFuZ2UoeEZpZWxkKTtcbiAgICB9XG4gICAgdmFyIGJhbmR3aWR0aCA9IG9wdGlvbnMuYmFuZHdpZHRoO1xuICAgIGlmICghYmFuZHdpZHRoIHx8ICF1dGlsXzEuaXNOdW1iZXIoYmFuZHdpZHRoKSB8fCBiYW5kd2lkdGggPD0gMCkge1xuICAgICAgICBiYW5kd2lkdGggPSBiYW5kd2lkdGhfMS5zaWx2ZXJtYW4oeHMpO1xuICAgIH1cbiAgICB2YXIgc2VyaWVzVmFsdWVzID0gZ2V0X3Nlcmllc192YWx1ZXNfMS5kZWZhdWx0KGV4dGVudCwgYmFuZHdpZHRoKTtcbiAgICB2YXIgeENvdW50ID0geHMubGVuZ3RoO1xuICAgIHZhciB3ZWlnaHRGdW5jID0gd2VpZ2h0LmJpbmQobnVsbCwgZnVuYywgYmFuZHdpZHRoKTtcbiAgICB2YXIga2VybmVsU21vb3RoZXI7XG4gICAgaWYgKHV0aWxfMS5pc05pbCh5RmllbGQpKSB7XG4gICAgICAgIC8vIEtERVxuICAgICAgICBrZXJuZWxTbW9vdGhlciA9IHZlY3Rvcml6ZShmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgdmFyIHdlaWdodHMgPSB4cy5tYXAoZnVuY3Rpb24gKHhfaSkgeyByZXR1cm4gd2VpZ2h0RnVuYyh4LCB4X2kpOyB9KTtcbiAgICAgICAgICAgIHZhciBudW0gPSBzaW1wbGVfc3RhdGlzdGljc18xLnN1bSh3ZWlnaHRzKTtcbiAgICAgICAgICAgIHZhciBkZW5vbSA9IHhDb3VudCAqIGJhbmR3aWR0aDtcbiAgICAgICAgICAgIGlmICghbnVtIHx8ICFkZW5vbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIHJldHVybiBudW0gLyBkZW5vbTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBrZXJuZWwgcmVncmVzc2lvbiBzbW9vdGhpbmdcbiAgICAgICAgdmFyIHlzXzEgPSBkdi5nZXRDb2x1bW4oeUZpZWxkKTtcbiAgICAgICAga2VybmVsU21vb3RoZXIgPSB2ZWN0b3JpemUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHZhciB3ZWlnaHRzID0geHMubWFwKGZ1bmN0aW9uICh4X2kpIHsgcmV0dXJuIHdlaWdodEZ1bmMoeCwgeF9pKTsgfSk7XG4gICAgICAgICAgICB2YXIgbnVtID0gc2ltcGxlX3N0YXRpc3RpY3NfMS5zdW0od2VpZ2h0cy5tYXAoZnVuY3Rpb24gKHcsIGkpIHsgcmV0dXJuIHcgKiB5c18xW2ldOyB9KSk7XG4gICAgICAgICAgICB2YXIgZGVub20gPSBzaW1wbGVfc3RhdGlzdGljc18xLnN1bSh3ZWlnaHRzKTtcbiAgICAgICAgICAgIGlmICghbnVtIHx8ICFkZW5vbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIHJldHVybiBudW0gLyBkZW5vbTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBzZXJpZXNWYWx1ZXMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByb3cgPSB7fTtcbiAgICAgICAgcm93W2FzWF0gPSB4O1xuICAgICAgICByb3dbYXNZXSA9IGtlcm5lbFNtb290aGVyKHgpO1xuICAgICAgICByZXR1cm4gcm93O1xuICAgIH0pO1xuICAgIGR2LnJvd3MgPSByZXN1bHQ7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2tlcm5lbC1zbW9vdGgucmVncmVzc2lvbicsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2tlcm5lbC5yZWdyZXNzaW9uJywgdHJhbnNmb3JtKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBLRVJORUxfTUVUSE9EUzogS0VSTkVMX01FVEhPRFMsXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9tYXAudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vbWFwLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbmZ1bmN0aW9uIGRlZmF1bHRDYWxsYmFjayhyb3cpIHtcbiAgICByZXR1cm4gcm93O1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdtYXAnLCBmdW5jdGlvbiAoZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBkYXRhVmlldy5yb3dzID0gZGF0YVZpZXcucm93cy5tYXAob3B0aW9ucy5jYWxsYmFjayB8fCBkZWZhdWx0Q2FsbGJhY2spO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL3BhcnRpdGlvbi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9wYXJ0aXRpb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIHBhcnRpdGlvbl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9wYXJ0aXRpb24gKi8gXCIuL3NyYy91dGlsL3BhcnRpdGlvbi50c1wiKSk7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIGdyb3VwQnk6IFtdLFxuICAgIG9yZGVyQnk6IFtdLFxufTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgncGFydGl0aW9uJywgZnVuY3Rpb24gKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgLy8gVE9ETzogcm93cyDmmK/lkKbpg73lj6rog73mmK/mlbDnu4RcbiAgICAvLyBAdHMtaWdub3JlO1xuICAgIGRhdGFWaWV3LnJvd3MgPSBwYXJ0aXRpb25fMS5kZWZhdWx0KGRhdGFWaWV3LnJvd3MsIG9wdGlvbnMuZ3JvdXBCeSwgb3B0aW9ucy5vcmRlckJ5KTtcbn0pO1xuZnVuY3Rpb24gZ3JvdXAoZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICBkYXRhVmlldy5yb3dzID0gdXRpbF8xLnZhbHVlcyhwYXJ0aXRpb25fMS5kZWZhdWx0KGRhdGFWaWV3LnJvd3MsIG9wdGlvbnMuZ3JvdXBCeSwgb3B0aW9ucy5vcmRlckJ5KSk7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2dyb3VwJywgZ3JvdXApO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdncm91cHMnLCBncm91cCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL3BlcmNlbnQudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL3BlcmNlbnQudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBzaW1wbGVfc3RhdGlzdGljc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc2ltcGxlLXN0YXRpc3RpY3MgKi8gXCIuL25vZGVfbW9kdWxlcy9fc2ltcGxlLXN0YXRpc3RpY3NANi4xLjFAc2ltcGxlLXN0YXRpc3RpY3MvZGlzdC9zaW1wbGUtc3RhdGlzdGljcy5taW4uanNcIik7XG52YXIgcGFydGl0aW9uXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL3BhcnRpdGlvbiAqLyBcIi4vc3JjL3V0aWwvcGFydGl0aW9uLnRzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIC8vIGZpZWxkOiAneScsIC8vIHJlcXVpcmVkXG4gICAgLy8gZGltZW5zaW9uOiAneCcsIC8vIHJlcXVpcmVkXG4gICAgZ3JvdXBCeTogW10sXG4gICAgYXM6ICdfcGVyY2VudCcsXG59O1xuZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGZpZWxkID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkKG9wdGlvbnMpO1xuICAgIHZhciBkaW1lbnNpb24gPSBvcHRpb25zLmRpbWVuc2lvbiwgZ3JvdXBCeSA9IG9wdGlvbnMuZ3JvdXBCeTtcbiAgICB2YXIgYXMgPSBvcHRpb25zLmFzO1xuICAgIGlmICghdXRpbF8xLmlzU3RyaW5nKGRpbWVuc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBkaW1lbnNpb246IG11c3QgYmUgYSBzdHJpbmchJyk7XG4gICAgfVxuICAgIGlmICh1dGlsXzEuaXNBcnJheShhcykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGFzOiBtdXN0IGJlIGEgc3RyaW5nLCB3aWxsIHVzZSB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgYXJyYXkgc3BlY2lmaWVkLicpO1xuICAgICAgICBhcyA9IGFzWzBdO1xuICAgIH1cbiAgICBpZiAoIXV0aWxfMS5pc1N0cmluZyhhcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhczogbXVzdCBiZSBhIHN0cmluZyEnKTtcbiAgICB9XG4gICAgdmFyIHJvd3MgPSBkYXRhVmlldy5yb3dzO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgZ3JvdXBzID0gcGFydGl0aW9uXzEuZGVmYXVsdChyb3dzLCBncm91cEJ5KTtcbiAgICB1dGlsXzEuZm9ySW4oZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgdmFyIHRvdGFsU3VtID0gc2ltcGxlX3N0YXRpc3RpY3NfMS5zdW0oZ3JvdXAubWFwKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHJvd1tmaWVsZF07IH0pKTtcbiAgICAgICAgaWYgKHRvdGFsU3VtID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIGRhdGE6IHRvdGFsIHN1bSBvZiBmaWVsZCBcIiArIGZpZWxkICsgXCIgaXMgMCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlubmVyR3JvdXBzID0gcGFydGl0aW9uXzEuZGVmYXVsdChncm91cCwgW2RpbWVuc2lvbl0pO1xuICAgICAgICB1dGlsXzEuZm9ySW4oaW5uZXJHcm91cHMsIGZ1bmN0aW9uIChpbm5lckdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgaW5uZXJTdW0gPSBzaW1wbGVfc3RhdGlzdGljc18xLnN1bShpbm5lckdyb3VwLm1hcChmdW5jdGlvbiAocm93KSB7IHJldHVybiByb3dbZmllbGRdOyB9KSk7XG4gICAgICAgICAgICAvLyBjb25zdCByZXN1bHRSb3cgPSBwaWNrKGlubmVyR3JvdXBbMF0sIHVuaW9uKGdyb3VwQnksIFsgZGltZW5zaW9uIF0pKTtcbiAgICAgICAgICAgIHZhciByZXN1bHRSb3cgPSBpbm5lckdyb3VwWzBdO1xuICAgICAgICAgICAgLy8gRklYTUUgaW4gY2FzZSBkaW1lbnNpb24gYW5kIGZpZWxkIGlzIHRoZSBzYW1lXG4gICAgICAgICAgICB2YXIgZGltZW5zaW9uVmFsdWUgPSByZXN1bHRSb3dbZGltZW5zaW9uXTtcbiAgICAgICAgICAgIHJlc3VsdFJvd1tmaWVsZF0gPSBpbm5lclN1bTtcbiAgICAgICAgICAgIHJlc3VsdFJvd1tkaW1lbnNpb25dID0gZGltZW5zaW9uVmFsdWU7XG4gICAgICAgICAgICBpZiAodG90YWxTdW0gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRSb3dbYXNdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFJvd1thc10gPSBpbm5lclN1bSAvIHRvdGFsU3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gocmVzdWx0Um93KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgZGF0YVZpZXcucm93cyA9IHJlc3VsdDtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgncGVyY2VudCcsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL3BpY2sudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL3BpY2sudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgb3B0aW9uX3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvdXRpbC9vcHRpb24tcGFyc2VyLnRzXCIpO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdwaWNrJywgZnVuY3Rpb24gKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbHVtbnMgPSBvcHRpb25fcGFyc2VyXzEuZ2V0RmllbGRzKG9wdGlvbnMsIGRhdGFWaWV3LmdldENvbHVtbk5hbWVzKCkpO1xuICAgIGRhdGFWaWV3LnJvd3MgPSBkYXRhVmlldy5yb3dzLm1hcChmdW5jdGlvbiAocm93KSB7IHJldHVybiB1dGlsXzEucGljayhyb3csIGNvbHVtbnMpOyB9KTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9wcm9wb3J0aW9uLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9wcm9wb3J0aW9uLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgcGFydGl0aW9uXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL3BhcnRpdGlvbiAqLyBcIi4vc3JjL3V0aWwvcGFydGl0aW9uLnRzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIC8vIGZpZWxkOiAneScsIC8vIHJlcXVpcmVkXG4gICAgLy8gZGltZW5zaW9uOiAneCcsIC8vIHJlcXVpcmVkXG4gICAgZ3JvdXBCeTogW10sXG4gICAgYXM6ICdfcHJvcG9ydGlvbicsXG59O1xuZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGZpZWxkID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkKG9wdGlvbnMpO1xuICAgIHZhciBkaW1lbnNpb24gPSBvcHRpb25zLmRpbWVuc2lvbjtcbiAgICB2YXIgZ3JvdXBCeSA9IG9wdGlvbnMuZ3JvdXBCeTtcbiAgICB2YXIgYXMgPSBvcHRpb25zLmFzO1xuICAgIGlmICghdXRpbF8xLmlzU3RyaW5nKGRpbWVuc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBkaW1lbnNpb246IG11c3QgYmUgYSBzdHJpbmchJyk7XG4gICAgfVxuICAgIGlmICh1dGlsXzEuaXNBcnJheShhcykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGFzOiBtdXN0IGJlIGEgc3RyaW5nLCB3aWxsIHVzZSB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgYXJyYXkgc3BlY2lmaWVkLicpO1xuICAgICAgICBhcyA9IGFzWzBdO1xuICAgIH1cbiAgICBpZiAoIXV0aWxfMS5pc1N0cmluZyhhcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhczogbXVzdCBiZSBhIHN0cmluZyEnKTtcbiAgICB9XG4gICAgdmFyIHJvd3MgPSBkYXRhVmlldy5yb3dzO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgZ3JvdXBzID0gcGFydGl0aW9uXzEuZGVmYXVsdChyb3dzLCBncm91cEJ5KTtcbiAgICB1dGlsXzEuZm9ySW4oZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgdmFyIHRvdGFsQ291bnQgPSBncm91cC5sZW5ndGg7XG4gICAgICAgIHZhciBpbm5lckdyb3VwcyA9IHBhcnRpdGlvbl8xLmRlZmF1bHQoZ3JvdXAsIFtkaW1lbnNpb25dKTtcbiAgICAgICAgdXRpbF8xLmZvckluKGlubmVyR3JvdXBzLCBmdW5jdGlvbiAoaW5uZXJHcm91cCkge1xuICAgICAgICAgICAgdmFyIGlubmVyQ291bnQgPSBpbm5lckdyb3VwLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGNvbnN0IHJlc3VsdFJvdyA9IHBpY2soaW5uZXJHcm91cFswXSwgdW5pb24oZ3JvdXBCeSwgWyBkaW1lbnNpb24gXSkpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdFJvdyA9IGlubmVyR3JvdXBbMF07XG4gICAgICAgICAgICAvLyBGSVhNRSBpbiBjYXNlIGRpbWVuc2lvbiBhbmQgZmllbGQgaXMgdGhlIHNhbWVcbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25WYWx1ZSA9IHJlc3VsdFJvd1tkaW1lbnNpb25dO1xuICAgICAgICAgICAgcmVzdWx0Um93W2ZpZWxkXSA9IGlubmVyQ291bnQ7XG4gICAgICAgICAgICByZXN1bHRSb3dbZGltZW5zaW9uXSA9IGRpbWVuc2lvblZhbHVlO1xuICAgICAgICAgICAgcmVzdWx0Um93W2FzXSA9IGlubmVyQ291bnQgLyB0b3RhbENvdW50O1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocmVzdWx0Um93KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgZGF0YVZpZXcucm93cyA9IHJlc3VsdDtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgncHJvcG9ydGlvbicsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL3JlZ3Jlc3Npb24udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL3JlZ3Jlc3Npb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIHJlZ3Jlc3Npb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIHJlZ3Jlc3Npb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fcmVncmVzc2lvbkAyLjAuMUByZWdyZXNzaW9uL2Rpc3QvcmVncmVzc2lvbi5qc1wiKSk7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGdldF9zZXJpZXNfdmFsdWVzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2dldC1zZXJpZXMtdmFsdWVzICovIFwiLi9zcmMvdXRpbC9nZXQtc2VyaWVzLXZhbHVlcy50c1wiKSk7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgb3B0aW9uX3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvdXRpbC9vcHRpb24tcGFyc2VyLnRzXCIpO1xudmFyIGJhbmR3aWR0aF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9iYW5kd2lkdGggKi8gXCIuL3NyYy91dGlsL2JhbmR3aWR0aC50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgYXM6IFsneCcsICd5J10sXG4gICAgLy8gZmllbGRzOiBbICd4JywgJ3knIF0sIC8vIHJlcXVpcmVkIHR3byBmaWVsZHNcbiAgICBtZXRob2Q6ICdsaW5lYXInLFxuICAgIC8vIGV4dGVudDogW10sIC8vIGV4dGVudCB0byBleGVjdXRlIHJlZ3Jlc3Npb24gZnVuY3Rpb24sIGRlZmF1bHQ6IFsgbWluKHgpLCBtYXgoeCkgXVxuICAgIC8vIGJhbmR3aWR0aDogMSwgLy8gYmFuZFdpZHRoIHRvIGV4ZWN1dGUgcmVncmVzc2lvbiBmdW5jdGlvblxuICAgIG9yZGVyOiAyLFxuICAgIHByZWNpc2lvbjogMixcbn07XG52YXIgUkVHUkVTU0lPTl9NRVRIT0RTID0gWydsaW5lYXInLCAnZXhwb25lbnRpYWwnLCAnbG9nYXJpdGhtaWMnLCAncG93ZXInLCAncG9seW5vbWlhbCddO1xuZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGZpZWxkcyA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZHMob3B0aW9ucyk7XG4gICAgaWYgKCF1dGlsXzEuaXNBcnJheShmaWVsZHMpIHx8IGZpZWxkcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBmaWVsZHM6IG11c3QgYmUgYW4gYXJyYXkgb2YgMiBzdHJpbmdzLicpO1xuICAgIH1cbiAgICB2YXIgX2EgPSB0c2xpYl8xLl9fcmVhZChmaWVsZHMsIDIpLCB4RmllbGQgPSBfYVswXSwgeUZpZWxkID0gX2FbMV07XG4gICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kO1xuICAgIGlmIChSRUdSRVNTSU9OX01FVEhPRFMuaW5kZXhPZihtZXRob2QpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBtZXRob2Q6IFwiICsgbWV0aG9kICsgXCIuIE11c3QgYmUgb25lIG9mIFwiICsgUkVHUkVTU0lPTl9NRVRIT0RTLmpvaW4oJywgJykpO1xuICAgIH1cbiAgICB2YXIgcG9pbnRzID0gZGF0YVZpZXcucm93cy5tYXAoZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gW3Jvd1t4RmllbGRdLCByb3dbeUZpZWxkXV07IH0pO1xuICAgIHZhciByZWdyZXNzaW9uUmVzdWx0ID0gcmVncmVzc2lvbl8xLmRlZmF1bHRbbWV0aG9kXShwb2ludHMsIG9wdGlvbnMpO1xuICAgIHZhciBleHRlbnQgPSBvcHRpb25zLmV4dGVudDtcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGV4dGVudCkgfHwgZXh0ZW50Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICBleHRlbnQgPSBkYXRhVmlldy5yYW5nZSh4RmllbGQpO1xuICAgIH1cbiAgICB2YXIgYmFuZHdpZHRoID0gb3B0aW9ucy5iYW5kd2lkdGg7XG4gICAgaWYgKCF1dGlsXzEuaXNOdW1iZXIoYmFuZHdpZHRoKSB8fCBiYW5kd2lkdGggPD0gMCkge1xuICAgICAgICBiYW5kd2lkdGggPSBiYW5kd2lkdGhfMS5zaWx2ZXJtYW4oZGF0YVZpZXcuZ2V0Q29sdW1uKHhGaWVsZCkpO1xuICAgIH1cbiAgICB2YXIgdmFsdWVzVG9QcmVkaWN0ID0gZ2V0X3Nlcmllc192YWx1ZXNfMS5kZWZhdWx0KGV4dGVudCwgYmFuZHdpZHRoKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIF9iID0gdHNsaWJfMS5fX3JlYWQob3B0aW9ucy5hcywgMiksIGFzWCA9IF9iWzBdLCBhc1kgPSBfYlsxXTtcbiAgICB2YWx1ZXNUb1ByZWRpY3QuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJvdyA9IHt9O1xuICAgICAgICB2YXIgX2EgPSB0c2xpYl8xLl9fcmVhZChyZWdyZXNzaW9uUmVzdWx0LnByZWRpY3QodmFsdWUpLCAyKSwgeCA9IF9hWzBdLCB5ID0gX2FbMV07XG4gICAgICAgIHJvd1thc1hdID0geDtcbiAgICAgICAgcm93W2FzWV0gPSB5O1xuICAgICAgICBpZiAoaXNGaW5pdGUoeSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJvdyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkYXRhVmlldy5yb3dzID0gcmVzdWx0O1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdyZWdyZXNzaW9uJywgdHJhbnNmb3JtKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBSRUdSRVNTSU9OX01FVEhPRFM6IFJFR1JFU1NJT05fTUVUSE9EUyxcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL3JlbmFtZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9yZW5hbWUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShkYXRhVmlldywgb3B0aW9ucykge1xuICAgIHZhciBtYXAgPSBvcHRpb25zLm1hcCB8fCB7fTtcbiAgICB2YXIgY2xlYW5NYXAgPSB7fTtcbiAgICBpZiAodXRpbF8xLmlzUGxhaW5PYmplY3QobWFwKSkge1xuICAgICAgICB1dGlsXzEuZm9ySW4obWFwLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgaWYgKHV0aWxfMS5pc1N0cmluZyh2YWx1ZSkgJiYgdXRpbF8xLmlzU3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjbGVhbk1hcFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkYXRhVmlldy5yb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB1dGlsXzEuZm9ySW4oY2xlYW5NYXAsIGZ1bmN0aW9uIChuZXdLZXksIGtleSkge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSByb3dba2V5XTtcbiAgICAgICAgICAgIGRlbGV0ZSByb3dba2V5XTtcbiAgICAgICAgICAgIHJvd1tuZXdLZXldID0gdGVtcDtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ3JlbmFtZScsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ3JlbmFtZS1maWVsZHMnLCB0cmFuc2Zvcm0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9yZXZlcnNlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9yZXZlcnNlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ3JldmVyc2UnLCBmdW5jdGlvbiAoZGF0YVZpZXcpIHtcbiAgICBkYXRhVmlldy5yb3dzLnJldmVyc2UoKTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9zb3J0LWJ5LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9zb3J0LWJ5LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbi8qXG4gKiBvcHRpb25zOiB7XG4gKiAgIHR5cGU6ICdzb3J0LWJ5JyxcbiAqICAgZmllbGRzOiBbXSxcbiAqICAgb3JkZXI6ICdBU0MnIC8vICdERVNDJ1xuICogfVxuICovXG52YXIgVkFMSURfT1JERVJTID0gWydBU0MnLCAnREVTQyddO1xuZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgdmFyIGZpZWxkcyA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZHMob3B0aW9ucywgW2RhdGFWaWV3LmdldENvbHVtbk5hbWUoMCldKTtcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGZpZWxkcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBmaWVsZHM6IG11c3QgYmUgYW4gYXJyYXkgd2l0aCBzdHJpbmdzIScpO1xuICAgIH1cbiAgICBkYXRhVmlldy5yb3dzID0gdXRpbF8xLnNvcnRCeShkYXRhVmlldy5yb3dzLCBmaWVsZHMpO1xuICAgIHZhciBvcmRlciA9IG9wdGlvbnMub3JkZXI7XG4gICAgaWYgKG9yZGVyICYmIFZBTElEX09SREVSUy5pbmRleE9mKG9yZGVyKSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgb3JkZXI6IFwiICsgb3JkZXIgKyBcIiBtdXN0IGJlIG9uZSBvZiBcIiArIFZBTElEX09SREVSUy5qb2luKCcsICcpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3JkZXIgPT09ICdERVNDJykge1xuICAgICAgICBkYXRhVmlldy5yb3dzLnJldmVyc2UoKTtcbiAgICB9XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ3NvcnQtYnknLCB0cmFuc2Zvcm0pO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdzb3J0QnknLCB0cmFuc2Zvcm0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9zb3J0LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9zb3J0LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ3NvcnQnLCBmdW5jdGlvbiAoZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29sdW1uTmFtZSA9IGRhdGFWaWV3LmdldENvbHVtbk5hbWUoMCk7XG4gICAgZGF0YVZpZXcucm93cy5zb3J0KG9wdGlvbnMuY2FsbGJhY2sgfHwgKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhW2NvbHVtbk5hbWVdIC0gYltjb2x1bW5OYW1lXTsgfSkpO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL3N1YnNldC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9zdWJzZXQudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnc3Vic2V0JywgZnVuY3Rpb24gKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBvcHRpb25zLnN0YXJ0Um93SW5kZXggfHwgMDtcbiAgICB2YXIgZW5kSW5kZXggPSBvcHRpb25zLmVuZFJvd0luZGV4IHx8IGRhdGFWaWV3LnJvd3MubGVuZ3RoIC0gMTtcbiAgICB2YXIgY29sdW1ucyA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZHMob3B0aW9ucywgZGF0YVZpZXcuZ2V0Q29sdW1uTmFtZXMoKSk7XG4gICAgZGF0YVZpZXcucm93cyA9IGRhdGFWaWV3LmdldFN1YnNldChzdGFydEluZGV4LCBlbmRJbmRleCwgY29sdW1ucyk7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vdGFnLWNsb3VkLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL3RhZy1jbG91ZC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgdGFnX2Nsb3VkXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL3RhZy1jbG91ZCAqLyBcIi4vc3JjL3V0aWwvdGFnLWNsb3VkLnRzXCIpKTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIGZpZWxkczogWyd0ZXh0JywgJ3ZhbHVlJ10sXG4gICAgZm9udDogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ3NlcmlmJzsgfSxcbiAgICBwYWRkaW5nOiAxLFxuICAgIHNpemU6IFs1MDAsIDUwMF0sXG4gICAgc3BpcmFsOiAnYXJjaGltZWRlYW4nLFxuICAgIC8vIHRpbWVJbnRlcnZhbDogSW5maW5pdHkgLy8gbWF4IGV4ZWN1dGUgdGltZVxuICAgIHRpbWVJbnRlcnZhbDogNTAwLFxufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShkYXRhVmlldywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBsYXlvdXQgPSB0YWdfY2xvdWRfMS5kZWZhdWx0KCk7XG4gICAgWydmb250JywgJ2ZvbnRTaXplJywgJ3BhZGRpbmcnLCAncm90YXRlJywgJ3NpemUnLCAnc3BpcmFsJywgJ3RpbWVJbnRlcnZhbCddLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChvcHRpb25zW2tleV0pIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGxheW91dFtrZXldKG9wdGlvbnNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgZmllbGRzID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkcyhvcHRpb25zKTtcbiAgICB2YXIgX2EgPSB0c2xpYl8xLl9fcmVhZChmaWVsZHMsIDIpLCB0ZXh0ID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XG4gICAgaWYgKCF1dGlsXzEuaXNTdHJpbmcodGV4dCkgfHwgIXV0aWxfMS5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBmaWVsZHM6IG11c3QgYmUgYW4gYXJyYXkgd2l0aCAyIHN0cmluZ3MgKGUuZy4gWyBcInRleHRcIiwgXCJ2YWx1ZVwiIF0pIScpO1xuICAgIH1cbiAgICB2YXIgd29yZHMgPSBkYXRhVmlldy5yb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJvdy50ZXh0ID0gcm93W3RleHRdO1xuICAgICAgICByb3cudmFsdWUgPSByb3dbdmFsdWVdO1xuICAgICAgICByZXR1cm4gcm93O1xuICAgIH0pO1xuICAgIGxheW91dC53b3Jkcyh3b3Jkcyk7XG4gICAgaWYgKG9wdGlvbnMuaW1hZ2VNYXNrKSB7XG4gICAgICAgIGxheW91dC5jcmVhdGVNYXNrKG9wdGlvbnMuaW1hZ2VNYXNrKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGxheW91dC5zdGFydCgpO1xuICAgIHZhciB0YWdzID0gcmVzdWx0Ll90YWdzO1xuICAgIHZhciBib3VuZHMgPSByZXN1bHQuX2JvdW5kcztcbiAgICB0YWdzLmZvckVhY2goZnVuY3Rpb24gKHRhZykge1xuICAgICAgICB0YWcueCArPSBvcHRpb25zLnNpemVbMF0gLyAyO1xuICAgICAgICB0YWcueSArPSBvcHRpb25zLnNpemVbMV0gLyAyO1xuICAgIH0pO1xuICAgIHZhciBfYiA9IHRzbGliXzEuX19yZWFkKG9wdGlvbnMuc2l6ZSwgMiksIHcgPSBfYlswXSwgaCA9IF9iWzFdO1xuICAgIHZhciBoYXNJbWFnZSA9IHJlc3VsdC5oYXNJbWFnZTtcbiAgICB0YWdzLnB1c2goe1xuICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgIHg6IGhhc0ltYWdlID8gMCA6IGJvdW5kc1swXS54LFxuICAgICAgICB5OiBoYXNJbWFnZSA/IDAgOiBib3VuZHNbMF0ueSxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICB9KTtcbiAgICB0YWdzLnB1c2goe1xuICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgIHg6IGhhc0ltYWdlID8gdyA6IGJvdW5kc1sxXS54LFxuICAgICAgICB5OiBoYXNJbWFnZSA/IGggOiBib3VuZHNbMV0ueSxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICB9KTtcbiAgICBkYXRhVmlldy5yb3dzID0gdGFncztcbiAgICBkYXRhVmlldy5fdGFnQ2xvdWQgPSByZXN1bHQ7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ3RhZy1jbG91ZCcsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ3dvcmQtY2xvdWQnLCB0cmFuc2Zvcm0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS93YWZmbGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vd2FmZmxlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBzaW1wbGVfc3RhdGlzdGljc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc2ltcGxlLXN0YXRpc3RpY3MgKi8gXCIuL25vZGVfbW9kdWxlcy9fc2ltcGxlLXN0YXRpc3RpY3NANi4xLjFAc2ltcGxlLXN0YXRpc3RpY3MvZGlzdC9zaW1wbGUtc3RhdGlzdGljcy5taW4uanNcIik7XG52YXIgcGFydGl0aW9uXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL3BhcnRpdGlvbiAqLyBcIi4vc3JjL3V0aWwvcGFydGl0aW9uLnRzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIGZpZWxkczogWyduYW1lJywgJ3ZhbHVlJ10sXG4gICAgcm93czogNSxcbiAgICBzaXplOiBbMSwgMV0sXG4gICAgc2NhbGU6IDEsXG4gICAgZ3JvdXBCeTogW10sXG4gICAgbWF4Q291bnQ6IDEwMDAsXG4gICAgZ2FwUmF0aW86IDAuMSxcbiAgICBhczogWyd4JywgJ3knXSxcbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB2YXIgZmllbGRzID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkcyhvcHRpb25zKTtcbiAgICB2YXIgX2EgPSB0c2xpYl8xLl9fcmVhZChmaWVsZHMsIDIpLCBuYW1lRmllbGQgPSBfYVswXSwgdmFsdWVGaWVsZCA9IF9hWzFdO1xuICAgIHZhciBfYiA9IHRzbGliXzEuX19yZWFkKG9wdGlvbnMuYXMsIDIpLCBhc1ggPSBfYlswXSwgYXNZID0gX2JbMV07XG4gICAgdmFyIGdyb3VwQnkgPSBvcHRpb25zLmdyb3VwQnk7XG4gICAgdmFyIGdyb3VwcyA9IHBhcnRpdGlvbl8xLmRlZmF1bHQoZGF0YVZpZXcucm93cywgZ3JvdXBCeSk7XG4gICAgdmFyIGdyb3VwS2V5cyA9IHV0aWxfMS5rZXlzKGdyb3Vwcyk7XG4gICAgdmFyIF9jID0gdHNsaWJfMS5fX3JlYWQob3B0aW9ucy5zaXplLCAyKSwgd2lkdGggPSBfY1swXSwgaGVpZ2h0ID0gX2NbMV07XG4gICAgdmFyIG1heENvdW50ID0gb3B0aW9ucy5tYXhDb3VudDtcbiAgICB2YXIgZ3JvdXBDb3VudCA9IGdyb3VwS2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhcnRIZWlnaHQgPSBoZWlnaHQgLyBncm91cENvdW50O1xuICAgIHZhciByb3dzID0gb3B0aW9ucy5yb3dzO1xuICAgIHZhciBnYXBSYXRpbyA9IG9wdGlvbnMuZ2FwUmF0aW87XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzY2FsZSA9IG9wdGlvbnMuc2NhbGU7XG4gICAgdmFyIGN1cnJlbnRHcm91cEluZGV4ID0gMDtcbiAgICB2YXIgd1N0ZXAgPSAwO1xuICAgIC8vIGdldHRpbmcgc3VpdGFibGUgc2NhbGUgYW5kIHdpZHRoIHN0ZXBcbiAgICB1dGlsXzEuZm9ySW4oZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgdmFyIHRvdGFsVmFsdWUgPSBzaW1wbGVfc3RhdGlzdGljc18xLnN1bSh1dGlsXzEubWFwKGdyb3VwLCBmdW5jdGlvbiAocm93KSB7IHJldHVybiByb3dbdmFsdWVGaWVsZF07IH0pKTtcbiAgICAgICAgdmFyIGNvbHMgPSBNYXRoLmNlaWwoKHRvdGFsVmFsdWUgKiBzY2FsZSkgLyByb3dzKTtcbiAgICAgICAgaWYgKHRvdGFsVmFsdWUgKiBzY2FsZSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICBzY2FsZSA9IG1heENvdW50IC8gdG90YWxWYWx1ZTtcbiAgICAgICAgICAgIGNvbHMgPSBNYXRoLmNlaWwoKHRvdGFsVmFsdWUgKiBzY2FsZSkgLyByb3dzKTtcbiAgICAgICAgfVxuICAgICAgICB3U3RlcCA9IHdpZHRoIC8gY29scztcbiAgICB9KTtcbiAgICAvLyBkaXN0cmlidXRpbmcgdmFsdWVzIGludG8gZ3JpZFxuICAgIHV0aWxfMS5mb3JJbihncm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICB2YXIgaGVpZ2h0UmFuZ2UgPSBbY3VycmVudEdyb3VwSW5kZXggKiBwYXJ0SGVpZ2h0LCAoY3VycmVudEdyb3VwSW5kZXggKyAxKSAqIHBhcnRIZWlnaHRdO1xuICAgICAgICB2YXIgaCA9IGhlaWdodFJhbmdlWzFdIC0gaGVpZ2h0UmFuZ2VbMF07XG4gICAgICAgIHZhciBoU3RlcCA9IChoICogKDEgLSBnYXBSYXRpbykpIC8gcm93cztcbiAgICAgICAgdmFyIGN1cnJlbnRDb2wgPSAwO1xuICAgICAgICB2YXIgY3VycmVudFJvdyA9IDA7XG4gICAgICAgIHV0aWxfMS5lYWNoKGdyb3VwLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSByb3dbdmFsdWVGaWVsZF07XG4gICAgICAgICAgICB2YXIgY291bnQgPSBNYXRoLnJvdW5kKHZhbHVlICogc2NhbGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSb3cgPT09IHJvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvdyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb2wrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdFJvdyA9IHV0aWxfMS5waWNrKHJvdywgW25hbWVGaWVsZCwgdmFsdWVGaWVsZF0uY29uY2F0KGdyb3VwQnkpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRSb3dbYXNYXSA9IGN1cnJlbnRDb2wgKiB3U3RlcCArIHdTdGVwIC8gMjtcbiAgICAgICAgICAgICAgICByZXN1bHRSb3dbYXNZXSA9IGN1cnJlbnRSb3cgKiBoU3RlcCArIGhTdGVwIC8gMiArIGhlaWdodFJhbmdlWzBdO1xuICAgICAgICAgICAgICAgIHJlc3VsdFJvdy5fd1N0ZXAgPSB3U3RlcDtcbiAgICAgICAgICAgICAgICByZXN1bHRSb3cuX2hTdGVwID0gaFN0ZXA7XG4gICAgICAgICAgICAgICAgY3VycmVudFJvdysrO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlc3VsdFJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjdXJyZW50R3JvdXBJbmRleCArPSAxO1xuICAgIH0pO1xuICAgIGRhdGFWaWV3LnJvd3MgPSByZXN1bHQ7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ3dhZmZsZScsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9iYW5kd2lkdGgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9iYW5kd2lkdGgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzaW1wbGVfc3RhdGlzdGljc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc2ltcGxlLXN0YXRpc3RpY3MgKi8gXCIuL25vZGVfbW9kdWxlcy9fc2ltcGxlLXN0YXRpc3RpY3NANi4xLjFAc2ltcGxlLXN0YXRpc3RpY3MvZGlzdC9zaW1wbGUtc3RhdGlzdGljcy5taW4uanNcIik7XG5mdW5jdGlvbiBzaWx2ZXJtYW4oYXJyKSB7XG4gICAgdmFyIHN0ZGV2ID0gc2ltcGxlX3N0YXRpc3RpY3NfMS5zdGFuZGFyZERldmlhdGlvbihhcnIpO1xuICAgIHZhciBudW0gPSA0ICogTWF0aC5wb3coc3RkZXYsIDUpO1xuICAgIHZhciBkZW5vbSA9IDMgKiBhcnIubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLnBvdyhudW0gLyBkZW5vbSwgMC4yKTtcbn1cbmV4cG9ydHMuc2lsdmVybWFuID0gc2lsdmVybWFuO1xuZnVuY3Rpb24gbnJkKGFycikge1xuICAgIHZhciBzID0gc2ltcGxlX3N0YXRpc3RpY3NfMS5zdGFuZGFyZERldmlhdGlvbihhcnIpO1xuICAgIHZhciBpcXIgPSBzaW1wbGVfc3RhdGlzdGljc18xLmludGVycXVhcnRpbGVSYW5nZShhcnIpO1xuICAgIGlmICh0eXBlb2YgaXFyID09PSAnbnVtYmVyJykge1xuICAgICAgICBzID0gTWF0aC5taW4ocywgaXFyIC8gMS4zNCk7XG4gICAgfVxuICAgIHJldHVybiAxLjA2ICogcyAqIE1hdGgucG93KGFyci5sZW5ndGgsIC0wLjIpO1xufVxuZXhwb3J0cy5ucmQgPSBucmQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9nZXQtZ2VvLXByb2plY3Rpb24udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9nZXQtZ2VvLXByb2plY3Rpb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkM0dlbyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLWdlbyAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1nZW9AMS42LjRAZDMtZ2VvL2J1aWxkL2QzLWdlby5qc1wiKSk7XG52YXIgZDNHZW9Qcm9qZWN0aW9uID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtZ2VvLXByb2plY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtZ2VvLXByb2plY3Rpb25AMi4xLjJAZDMtZ2VvLXByb2plY3Rpb24vYnVpbGQvZDMtZ2VvLXByb2plY3Rpb24uanNcIikpO1xudmFyIGQzQ29tcG9zaXRlUHJvamVjdGlvbiA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLWNvbXBvc2l0ZS1wcm9qZWN0aW9ucyAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1jb21wb3NpdGUtcHJvamVjdGlvbnNAMS4zLjJAZDMtY29tcG9zaXRlLXByb2plY3Rpb25zL2QzLWNvbXBvc2l0ZS1wcm9qZWN0aW9ucy5qc1wiKSk7XG4vKlxuICogZ2V0R2VvUHJvamVjdGlvblxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSBwcm9qZWN0aW9uICBwcm9qZWN0aW9uIG5hbWUgb3IgcHJvamVjdGlvbiBmdW5jdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbZXhwb3J0UmF3ID0gZmFsc2VdIC0gd2hldGhlciByZXR1cm4gdGhlIHJhdyBwcm9qZWN0aW9uIG9yIG5vdFxuICogKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAocHJvamVjdGlvbiwgZXhwb3J0UmF3KSB7XG4gICAgaWYgKGV4cG9ydFJhdyA9PT0gdm9pZCAwKSB7IGV4cG9ydFJhdyA9IGZhbHNlOyB9XG4gICAgaWYgKHV0aWxfMS5pc0Z1bmN0aW9uKHByb2plY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRSYXcgPyBwcm9qZWN0aW9uIDogcHJvamVjdGlvbigpO1xuICAgIH1cbiAgICBpZiAodXRpbF8xLmlzU3RyaW5nKHByb2plY3Rpb24pKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGQzR2VvW3Byb2plY3Rpb25dKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0UmF3ID8gZDNHZW9bcHJvamVjdGlvbl0gOiBkM0dlb1twcm9qZWN0aW9uXSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkM0dlb1Byb2plY3Rpb25bcHJvamVjdGlvbl0pIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRSYXcgPyBkM0dlb1Byb2plY3Rpb25bcHJvamVjdGlvbl0gOiBkM0dlb1Byb2plY3Rpb25bcHJvamVjdGlvbl0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZDNDb21wb3NpdGVQcm9qZWN0aW9uW3Byb2plY3Rpb25dKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0UmF3ID8gZDNDb21wb3NpdGVQcm9qZWN0aW9uW3Byb2plY3Rpb25dIDogZDNDb21wb3NpdGVQcm9qZWN0aW9uW3Byb2plY3Rpb25dKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL2dldC1zZXJpZXMtdmFsdWVzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9nZXQtc2VyaWVzLXZhbHVlcy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoZXh0ZW50LCBidykge1xuICAgIHZhciBiYW5kd2lkdGggPSBidyB8fCAxO1xuICAgIHZhciBfYSA9IHRzbGliXzEuX19yZWFkKGV4dGVudCwgMiksIG1pbiA9IF9hWzBdLCBtYXggPSBfYVsxXTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIHRtcCA9IG1pbjtcbiAgICB3aGlsZSAodG1wIDwgbWF4KSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHRtcCk7XG4gICAgICAgIHRtcCArPSBiYW5kd2lkdGg7XG4gICAgfVxuICAgIHZhbHVlcy5wdXNoKG1heCk7XG4gICAgcmV0dXJuIHZhbHVlcztcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwva2VybmVsLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwva2VybmVsLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKlxuICogQHJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL2phc29uZGF2aWVzL3NjaWVuY2UuanMvYmxvYi9tYXN0ZXIvc3JjL3N0YXRzL2tlcm5lbC5qc1xuICogQHJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL1BsYW5lc2hpZnRlci9rZXJuZWwtc21vb3RoL2Jsb2IvbWFzdGVyL2xpYi9pbmRleC5qcyNMMTZcbiAqL1xuZnVuY3Rpb24gdW5pZm9ybSh1KSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHUpIDw9IDEgPyAwLjUgOiAwO1xufVxuZnVuY3Rpb24gdHJpY3ViZWQodSkge1xuICAgIHZhciBhYnMgPSAxIC0gTWF0aC5wb3coTWF0aC5hYnModSksIDMpO1xuICAgIHJldHVybiBNYXRoLnBvdyhhYnMsIDMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIGJveGNhcjogdW5pZm9ybSxcbiAgICBjb3NpbmU6IGZ1bmN0aW9uICh1KSB7XG4gICAgICAgIGlmIChNYXRoLmFicyh1KSA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gKE1hdGguUEkgLyA0KSAqIE1hdGguY29zKChNYXRoLlBJIC8gMikgKiB1KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIGVwYW5lY2huaWtvdjogZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHUpIDwgMSA/IDAuNzUgKiAoMSAtIHUgKiB1KSA6IDA7XG4gICAgfSxcbiAgICBnYXVzc2lhbjogZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgLy8gcmV0dXJuIDEgLyBNYXRoLnNxcnQoMiAqIE1hdGguUEkpICogTWF0aC5leHAoLTAuNSAqIHUgKiB1KTtcbiAgICAgICAgcmV0dXJuIDAuMzk4OTQyMjgwNCAqIE1hdGguZXhwKC0wLjUgKiB1ICogdSk7XG4gICAgfSxcbiAgICBxdWFydGljOiBmdW5jdGlvbiAodSkge1xuICAgICAgICBpZiAoTWF0aC5hYnModSkgPCAxKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gMSAtIHUgKiB1O1xuICAgICAgICAgICAgcmV0dXJuICgxNSAvIDE2KSAqIHRtcCAqIHRtcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHRyaWFuZ3VsYXI6IGZ1bmN0aW9uICh1KSB7XG4gICAgICAgIHZhciBhYnMgPSBNYXRoLmFicyh1KTtcbiAgICAgICAgcmV0dXJuIGFicyA8IDEgPyAxIC0gYWJzIDogMDtcbiAgICB9LFxuICAgIHRyaWN1YmU6IGZ1bmN0aW9uICh1KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh1KSA8IDEgPyAoNzAgLyA4MSkgKiB0cmljdWJlZCh1KSA6IDA7XG4gICAgfSxcbiAgICB0cml3ZWlnaHQ6IGZ1bmN0aW9uICh1KSB7XG4gICAgICAgIGlmIChNYXRoLmFicyh1KSA8IDEpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSAxIC0gdSAqIHU7XG4gICAgICAgICAgICByZXR1cm4gKDM1IC8gMzIpICogdG1wICogdG1wICogdG1wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgdW5pZm9ybTogdW5pZm9ybSxcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9vcHRpb24tcGFyc2VyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIElOVkFMSURfRklFTERfRVJSX01TRyA9ICdJbnZhbGlkIGZpZWxkOiBpdCBtdXN0IGJlIGEgc3RyaW5nISc7XG52YXIgSU5WQUxJRF9GSUVMRFNfRVJSX01TRyA9ICdJbnZhbGlkIGZpZWxkczogaXQgbXVzdCBiZSBhbiBhcnJheSEnO1xuZnVuY3Rpb24gZ2V0RmllbGQob3B0aW9ucywgZGVmYXVsdEZpZWxkKSB7XG4gICAgdmFyIGZpZWxkID0gb3B0aW9ucy5maWVsZCwgZmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgaWYgKHV0aWxfMS5pc1N0cmluZyhmaWVsZCkpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgIH1cbiAgICBpZiAodXRpbF8xLmlzQXJyYXkoZmllbGQpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihJTlZBTElEX0ZJRUxEX0VSUl9NU0cpO1xuICAgICAgICByZXR1cm4gZmllbGRbMF07XG4gICAgfVxuICAgIGNvbnNvbGUud2FybihJTlZBTElEX0ZJRUxEX0VSUl9NU0cgKyBcIiB3aWxsIHRyeSB0byBnZXQgZmllbGRzIGluc3RlYWQuXCIpO1xuICAgIGlmICh1dGlsXzEuaXNTdHJpbmcoZmllbGRzKSkge1xuICAgICAgICByZXR1cm4gZmllbGRzO1xuICAgIH1cbiAgICBpZiAodXRpbF8xLmlzQXJyYXkoZmllbGRzKSAmJiBmaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmaWVsZHNbMF07XG4gICAgfVxuICAgIGlmIChkZWZhdWx0RmllbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRGaWVsZDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihJTlZBTElEX0ZJRUxEX0VSUl9NU0cpO1xufVxuZXhwb3J0cy5nZXRGaWVsZCA9IGdldEZpZWxkO1xuZnVuY3Rpb24gZ2V0RmllbGRzKG9wdGlvbnMsIGRlZmF1bHRGaWVsZHMpIHtcbiAgICB2YXIgZmllbGQgPSBvcHRpb25zLmZpZWxkLCBmaWVsZHMgPSBvcHRpb25zLmZpZWxkcztcbiAgICBpZiAodXRpbF8xLmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgICByZXR1cm4gZmllbGRzO1xuICAgIH1cbiAgICBpZiAodXRpbF8xLmlzU3RyaW5nKGZpZWxkcykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKElOVkFMSURfRklFTERTX0VSUl9NU0cpO1xuICAgICAgICByZXR1cm4gW2ZpZWxkc107XG4gICAgfVxuICAgIGNvbnNvbGUud2FybihJTlZBTElEX0ZJRUxEU19FUlJfTVNHICsgXCIgd2lsbCB0cnkgdG8gZ2V0IGZpZWxkIGluc3RlYWQuXCIpO1xuICAgIGlmICh1dGlsXzEuaXNTdHJpbmcoZmllbGQpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihJTlZBTElEX0ZJRUxEU19FUlJfTVNHKTtcbiAgICAgICAgcmV0dXJuIFtmaWVsZF07XG4gICAgfVxuICAgIGlmICh1dGlsXzEuaXNBcnJheShmaWVsZCkgJiYgZmllbGQubGVuZ3RoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihJTlZBTElEX0ZJRUxEU19FUlJfTVNHKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdEZpZWxkcykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEZpZWxkcztcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihJTlZBTElEX0ZJRUxEU19FUlJfTVNHKTtcbn1cbmV4cG9ydHMuZ2V0RmllbGRzID0gZ2V0RmllbGRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvcC1ieS1mcmFjdGlvbi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9wLWJ5LWZyYWN0aW9uLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChmcmFjdGlvbikge1xuICAgIHZhciBzdGVwID0gMSAvIGZyYWN0aW9uO1xuICAgIHZhciBwQXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gMTsgaSA9IGkgKyBzdGVwKSB7XG4gICAgICAgIHBBcnIucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBBcnI7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL3BhcnRpdGlvbi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL3BhcnRpdGlvbi50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIHNpbXBsZV9zb3J0X2J5XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NpbXBsZS1zb3J0LWJ5ICovIFwiLi9zcmMvdXRpbC9zaW1wbGUtc29ydC1ieS50c1wiKSk7XG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKHJvd3MsIGdyb3VwX2J5LCBvcmRlcl9ieSkge1xuICAgIGlmIChvcmRlcl9ieSA9PT0gdm9pZCAwKSB7IG9yZGVyX2J5ID0gW107IH1cbiAgICB2YXIgbmV3Um93cyA9IHJvd3M7XG4gICAgaWYgKG9yZGVyX2J5ICYmIG9yZGVyX2J5Lmxlbmd0aCkge1xuICAgICAgICBuZXdSb3dzID0gc2ltcGxlX3NvcnRfYnlfMS5kZWZhdWx0KHJvd3MsIG9yZGVyX2J5KTtcbiAgICB9XG4gICAgdmFyIGdyb3VwaW5nRm47XG4gICAgaWYgKHV0aWxfMS5pc0Z1bmN0aW9uKGdyb3VwX2J5KSkge1xuICAgICAgICBncm91cGluZ0ZuID0gZ3JvdXBfYnk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHV0aWxfMS5pc0FycmF5KGdyb3VwX2J5KSkge1xuICAgICAgICBncm91cGluZ0ZuID0gZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gXCJfXCIgKyBncm91cF9ieS5tYXAoZnVuY3Rpb24gKGNvbCkgeyByZXR1cm4gcm93W2NvbF07IH0pLmpvaW4oJy0nKTsgfTtcbiAgICAgICAgLy8gTk9URTogT2JqZWN0LmtleXMoeydiJzogJ2InLCAnMic6ICcyJywgJzEnOiAnMScsICdhJzogJ2EnfSkgPT4gWyAnMScsICcyJywgJ2InLCAnYScgXVxuICAgICAgICAvLyB0aGF0IGlzIHdoeSB3ZSBoYXZlIHRvIGFkZCBhIHByZWZpeFxuICAgIH1cbiAgICBlbHNlIGlmICh1dGlsXzEuaXNTdHJpbmcoZ3JvdXBfYnkpKSB7XG4gICAgICAgIGdyb3VwaW5nRm4gPSBmdW5jdGlvbiAocm93KSB7IHJldHVybiBcIl9cIiArIHJvd1tncm91cF9ieV07IH07XG4gICAgfVxuICAgIHZhciBncm91cHMgPSB1dGlsXzEuZ3JvdXBCeShuZXdSb3dzLCBncm91cGluZ0ZuKTtcbiAgICByZXR1cm4gZ3JvdXBzO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9zaW1wbGUtc29ydC1ieS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvc2ltcGxlLXNvcnQtYnkudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIHNvcnRCeShhcnIsIGtleXMpIHtcbiAgICBpZiAoa2V5cyA9PT0gdm9pZCAwKSB7IGtleXMgPSBbXTsgfVxuICAgIHZhciBjb21wYXJlciA9IHVuZGVmaW5lZDtcbiAgICBpZiAodXRpbF8xLmlzRnVuY3Rpb24oa2V5cykpIHtcbiAgICAgICAgY29tcGFyZXIgPSBrZXlzO1xuICAgIH1cbiAgICBlbHNlIGlmICh1dGlsXzEuaXNBcnJheShrZXlzKSkge1xuICAgICAgICBjb21wYXJlciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYVtrZXldIDwgYltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFba2V5XSA+IGJba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodXRpbF8xLmlzU3RyaW5nKGtleXMpKSB7XG4gICAgICAgIGNvbXBhcmVyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhW2tleXNdIDwgYltrZXlzXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhW2tleXNdID4gYltrZXlzXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhcnIuc29ydChjb21wYXJlcik7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBzb3J0Qnk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC90YWctY2xvdWQudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC90YWctY2xvdWQudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gKiBTeW5jaHJvbm91cyB2ZXJzaW9uIG9mIGQzLWNsb3VkXG4gKi9cbi8vIFdvcmQgY2xvdWQgbGF5b3V0IGJ5IEphc29uIERhdmllcywgaHR0cHM6Ly93d3cuamFzb25kYXZpZXMuY29tL3dvcmRjbG91ZC9cbi8vIEFsZ29yaXRobSBkdWUgdG8gSm9uYXRoYW4gRmVpbmJlcmcsIGh0dHA6Ly9zdGF0aWMubXJmZWluYmVyZy5jb20vYnZfY2gwMy5wZGZcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJldHVybi1hc3NpZ24sIG5vLWNvbmQtYXNzaWduICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciBjbG91ZFJhZGlhbnMgPSBNYXRoLlBJIC8gMTgwLCBjdyA9ICgxIDw8IDExKSA+PiA1LCBjaCA9IDEgPDwgMTE7XG5mdW5jdGlvbiBjbG91ZFRleHQoZCkge1xuICAgIHJldHVybiBkLnRleHQ7XG59XG5mdW5jdGlvbiBjbG91ZEZvbnQoKSB7XG4gICAgcmV0dXJuICdzZXJpZic7XG59XG5mdW5jdGlvbiBjbG91ZEZvbnROb3JtYWwoKSB7XG4gICAgcmV0dXJuICdub3JtYWwnO1xufVxuZnVuY3Rpb24gY2xvdWRGb250U2l6ZShkKSB7XG4gICAgcmV0dXJuIGQudmFsdWU7XG59XG5mdW5jdGlvbiBjbG91ZFJvdGF0ZSgpIHtcbiAgICByZXR1cm4gfn4oTWF0aC5yYW5kb20oKSAqIDIpICogOTA7XG59XG5mdW5jdGlvbiBjbG91ZFBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIDE7XG59XG4vLyBGZXRjaGVzIGEgbW9ub2Nocm9tZSBzcHJpdGUgYml0bWFwIGZvciB0aGUgc3BlY2lmaWVkIHRleHQuXG4vLyBMb2FkIGluIGJhdGNoZXMgZm9yIHNwZWVkLlxuZnVuY3Rpb24gY2xvdWRTcHJpdGUoY29udGV4dEFuZFJhdGlvLCBkLCBkYXRhLCBkaSkge1xuICAgIGlmIChkLnNwcml0ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBjID0gY29udGV4dEFuZFJhdGlvLmNvbnRleHQsIHJhdGlvID0gY29udGV4dEFuZFJhdGlvLnJhdGlvO1xuICAgIGMuY2xlYXJSZWN0KDAsIDAsIChjdyA8PCA1KSAvIHJhdGlvLCBjaCAvIHJhdGlvKTtcbiAgICB2YXIgeCA9IDAsIHkgPSAwLCBtYXhoID0gMDtcbiAgICB2YXIgbiA9IGRhdGEubGVuZ3RoO1xuICAgIC0tZGk7XG4gICAgd2hpbGUgKCsrZGkgPCBuKSB7XG4gICAgICAgIGQgPSBkYXRhW2RpXTtcbiAgICAgICAgYy5zYXZlKCk7XG4gICAgICAgIGMuZm9udCA9IGQuc3R5bGUgKyAnICcgKyBkLndlaWdodCArICcgJyArIH5+KChkLnNpemUgKyAxKSAvIHJhdGlvKSArICdweCAnICsgZC5mb250O1xuICAgICAgICB2YXIgdyA9IGMubWVhc3VyZVRleHQoZC50ZXh0ICsgJ20nKS53aWR0aCAqIHJhdGlvLCBoID0gZC5zaXplIDw8IDE7XG4gICAgICAgIGlmIChkLnJvdGF0ZSkge1xuICAgICAgICAgICAgdmFyIHNyID0gTWF0aC5zaW4oZC5yb3RhdGUgKiBjbG91ZFJhZGlhbnMpLCBjciA9IE1hdGguY29zKGQucm90YXRlICogY2xvdWRSYWRpYW5zKSwgd2NyID0gdyAqIGNyLCB3c3IgPSB3ICogc3IsIGhjciA9IGggKiBjciwgaHNyID0gaCAqIHNyO1xuICAgICAgICAgICAgdyA9ICgoTWF0aC5tYXgoTWF0aC5hYnMod2NyICsgaHNyKSwgTWF0aC5hYnMod2NyIC0gaHNyKSkgKyAweDFmKSA+PiA1KSA8PCA1O1xuICAgICAgICAgICAgaCA9IH5+TWF0aC5tYXgoTWF0aC5hYnMod3NyICsgaGNyKSwgTWF0aC5hYnMod3NyIC0gaGNyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3ID0gKCh3ICsgMHgxZikgPj4gNSkgPDwgNTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaCA+IG1heGgpXG4gICAgICAgICAgICBtYXhoID0gaDtcbiAgICAgICAgaWYgKHggKyB3ID49IGN3IDw8IDUpIHtcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgeSArPSBtYXhoO1xuICAgICAgICAgICAgbWF4aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgKyBoID49IGNoKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGMudHJhbnNsYXRlKCh4ICsgKHcgPj4gMSkpIC8gcmF0aW8sICh5ICsgKGggPj4gMSkpIC8gcmF0aW8pO1xuICAgICAgICBpZiAoZC5yb3RhdGUpXG4gICAgICAgICAgICBjLnJvdGF0ZShkLnJvdGF0ZSAqIGNsb3VkUmFkaWFucyk7XG4gICAgICAgIGMuZmlsbFRleHQoZC50ZXh0LCAwLCAwKTtcbiAgICAgICAgaWYgKGQucGFkZGluZykge1xuICAgICAgICAgICAgYy5saW5lV2lkdGggPSAyICogZC5wYWRkaW5nO1xuICAgICAgICAgICAgYy5zdHJva2VUZXh0KGQudGV4dCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgYy5yZXN0b3JlKCk7XG4gICAgICAgIGQud2lkdGggPSB3O1xuICAgICAgICBkLmhlaWdodCA9IGg7XG4gICAgICAgIGQueG9mZiA9IHg7XG4gICAgICAgIGQueW9mZiA9IHk7XG4gICAgICAgIGQueDEgPSB3ID4+IDE7XG4gICAgICAgIGQueTEgPSBoID4+IDE7XG4gICAgICAgIGQueDAgPSAtZC54MTtcbiAgICAgICAgZC55MCA9IC1kLnkxO1xuICAgICAgICBkLmhhc1RleHQgPSB0cnVlO1xuICAgICAgICB4ICs9IHc7XG4gICAgfVxuICAgIHZhciBwaXhlbHMgPSBjLmdldEltYWdlRGF0YSgwLCAwLCAoY3cgPDwgNSkgLyByYXRpbywgY2ggLyByYXRpbykuZGF0YSwgc3ByaXRlID0gW107XG4gICAgd2hpbGUgKC0tZGkgPj0gMCkge1xuICAgICAgICBkID0gZGF0YVtkaV07XG4gICAgICAgIGlmICghZC5oYXNUZXh0KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciB3ID0gZC53aWR0aCwgdzMyID0gdyA+PiA1O1xuICAgICAgICB2YXIgaCA9IGQueTEgLSBkLnkwO1xuICAgICAgICAvLyBaZXJvIHRoZSBidWZmZXJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoICogdzMyOyBpKyspXG4gICAgICAgICAgICBzcHJpdGVbaV0gPSAwO1xuICAgICAgICB4ID0gZC54b2ZmO1xuICAgICAgICBpZiAoeCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB5ID0gZC55b2ZmO1xuICAgICAgICB2YXIgc2VlbiA9IDAsIHNlZW5Sb3cgPSAtMTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSB3MzIgKiBqICsgKGkgPj4gNSksIG0gPSBwaXhlbHNbKCh5ICsgaikgKiAoY3cgPDwgNSkgKyAoeCArIGkpKSA8PCAyXSA/IDEgPDwgKDMxIC0gKGkgJSAzMikpIDogMDtcbiAgICAgICAgICAgICAgICBzcHJpdGVba10gfD0gbTtcbiAgICAgICAgICAgICAgICBzZWVuIHw9IG07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VlbilcbiAgICAgICAgICAgICAgICBzZWVuUm93ID0gajtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGQueTArKztcbiAgICAgICAgICAgICAgICBoLS07XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgIHkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkLnkxID0gZC55MCArIHNlZW5Sb3c7XG4gICAgICAgIGQuc3ByaXRlID0gc3ByaXRlLnNsaWNlKDAsIChkLnkxIC0gZC55MCkgKiB3MzIpO1xuICAgIH1cbn1cbi8vIFVzZSBtYXNrLWJhc2VkIGNvbGxpc2lvbiBkZXRlY3Rpb24uXG5mdW5jdGlvbiBjbG91ZENvbGxpZGUodGFnLCBib2FyZCwgc3cpIHtcbiAgICBzdyA+Pj0gNTtcbiAgICB2YXIgc3ByaXRlID0gdGFnLnNwcml0ZSwgdyA9IHRhZy53aWR0aCA+PiA1LCBseCA9IHRhZy54IC0gKHcgPDwgNCksIHN4ID0gbHggJiAweDdmLCBtc3ggPSAzMiAtIHN4LCBoID0gdGFnLnkxIC0gdGFnLnkwO1xuICAgIHZhciB4ID0gKHRhZy55ICsgdGFnLnkwKSAqIHN3ICsgKGx4ID4+IDUpLCBsYXN0O1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaDsgaisrKSB7XG4gICAgICAgIGxhc3QgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB3OyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoKGxhc3QgPDwgbXN4KSB8IChpIDwgdyA/IChsYXN0ID0gc3ByaXRlW2ogKiB3ICsgaV0pID4+PiBzeCA6IDApKSAmIGJvYXJkW3ggKyBpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB4ICs9IHN3O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjbG91ZEJvdW5kcyhib3VuZHMsIGQpIHtcbiAgICB2YXIgYjAgPSBib3VuZHNbMF0sIGIxID0gYm91bmRzWzFdO1xuICAgIGlmIChkLnggKyBkLngwIDwgYjAueClcbiAgICAgICAgYjAueCA9IGQueCArIGQueDA7XG4gICAgaWYgKGQueSArIGQueTAgPCBiMC55KVxuICAgICAgICBiMC55ID0gZC55ICsgZC55MDtcbiAgICBpZiAoZC54ICsgZC54MSA+IGIxLngpXG4gICAgICAgIGIxLnggPSBkLnggKyBkLngxO1xuICAgIGlmIChkLnkgKyBkLnkxID4gYjEueSlcbiAgICAgICAgYjEueSA9IGQueSArIGQueTE7XG59XG5mdW5jdGlvbiBjb2xsaWRlUmVjdHMoYSwgYikge1xuICAgIHJldHVybiBhLnggKyBhLngxID4gYlswXS54ICYmIGEueCArIGEueDAgPCBiWzFdLnggJiYgYS55ICsgYS55MSA+IGJbMF0ueSAmJiBhLnkgKyBhLnkwIDwgYlsxXS55O1xufVxuZnVuY3Rpb24gYXJjaGltZWRlYW5TcGlyYWwoc2l6ZSkge1xuICAgIHZhciBlID0gc2l6ZVswXSAvIHNpemVbMV07XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBbZSAqICh0ICo9IDAuMSkgKiBNYXRoLmNvcyh0KSwgdCAqIE1hdGguc2luKHQpXTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVjdGFuZ3VsYXJTcGlyYWwoc2l6ZSkge1xuICAgIHZhciBkeSA9IDQsIGR4ID0gKGR5ICogc2l6ZVswXSkgLyBzaXplWzFdO1xuICAgIHZhciB4ID0gMCwgeSA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBzaWduID0gdCA8IDAgPyAtMSA6IDE7XG4gICAgICAgIC8vIFNlZSB0cmlhbmd1bGFyIG51bWJlcnM6IFRfbiA9IG4gKiAobiArIDEpIC8gMi5cbiAgICAgICAgc3dpdGNoICgoTWF0aC5zcXJ0KDEgKyA0ICogc2lnbiAqIHQpIC0gc2lnbikgJiAzKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgeCArPSBkeDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB5ICs9IGR5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHggLT0gZHg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHkgLT0gZHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9O1xufVxuLy8gVE9ETyByZXVzZSBhcnJheXM/XG5mdW5jdGlvbiB6ZXJvQXJyYXkobikge1xuICAgIHZhciBhID0gW107XG4gICAgdmFyIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgYVtpXSA9IDA7XG4gICAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBjbG91ZENhbnZhcygpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG59XG5mdW5jdGlvbiBmdW5jdG9yKGQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBkXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH07XG59XG52YXIgc3BpcmFscyA9IHtcbiAgICBhcmNoaW1lZGVhbjogYXJjaGltZWRlYW5TcGlyYWwsXG4gICAgcmVjdGFuZ3VsYXI6IHJlY3Rhbmd1bGFyU3BpcmFsLFxufTtcbmZ1bmN0aW9uIGRlZmF1bHRfMSgpIHtcbiAgICB2YXIgc2l6ZSA9IFsyNTYsIDI1Nl0sIHRleHQgPSBjbG91ZFRleHQsIGZvbnQgPSBjbG91ZEZvbnQsIGZvbnRTaXplID0gY2xvdWRGb250U2l6ZSwgZm9udFN0eWxlID0gY2xvdWRGb250Tm9ybWFsLCBmb250V2VpZ2h0ID0gY2xvdWRGb250Tm9ybWFsLCByb3RhdGUgPSBjbG91ZFJvdGF0ZSwgcGFkZGluZyA9IGNsb3VkUGFkZGluZywgc3BpcmFsID0gYXJjaGltZWRlYW5TcGlyYWwsIHdvcmRzID0gW10sIHRpbWVJbnRlcnZhbCA9IEluZmluaXR5LCByYW5kb20gPSBNYXRoLnJhbmRvbSwgY2FudmFzID0gY2xvdWRDYW52YXM7XG4gICAgdmFyIGNsb3VkID0ge307XG4gICAgY2xvdWQuY2FudmFzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKGNhbnZhcyA9IGZ1bmN0b3IoXykpLCBjbG91ZCkgOiBjYW52YXM7XG4gICAgfTtcbiAgICBjbG91ZC5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdHNsaWJfMS5fX3JlYWQoc2l6ZSwgMiksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgICAgICB2YXIgY29udGV4dEFuZFJhdGlvID0gZ2V0Q29udGV4dChjYW52YXMoKSksIGJvYXJkID0gY2xvdWQuYm9hcmQgPyBjbG91ZC5ib2FyZCA6IHplcm9BcnJheSgoc2l6ZVswXSA+PiA1KSAqIHNpemVbMV0pLCBuID0gd29yZHMubGVuZ3RoLCB0YWdzID0gW10sIGRhdGEgPSB3b3Jkc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgZC50ZXh0ID0gdGV4dC5jYWxsKHRoaXMsIGQsIGkpO1xuICAgICAgICAgICAgZC5mb250ID0gZm9udC5jYWxsKHRoaXMsIGQsIGkpO1xuICAgICAgICAgICAgZC5zdHlsZSA9IGZvbnRTdHlsZS5jYWxsKHRoaXMsIGQsIGkpO1xuICAgICAgICAgICAgZC53ZWlnaHQgPSBmb250V2VpZ2h0LmNhbGwodGhpcywgZCwgaSk7XG4gICAgICAgICAgICBkLnJvdGF0ZSA9IHJvdGF0ZS5jYWxsKHRoaXMsIGQsIGkpO1xuICAgICAgICAgICAgZC5zaXplID0gfn5mb250U2l6ZS5jYWxsKHRoaXMsIGQsIGkpO1xuICAgICAgICAgICAgZC5wYWRkaW5nID0gcGFkZGluZy5jYWxsKHRoaXMsIGQsIGkpO1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIuc2l6ZSAtIGEuc2l6ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpID0gLTEsIGJvdW5kcyA9ICFjbG91ZC5ib2FyZFxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICB5OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIHN0ZXAoKTtcbiAgICAgICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0IDwgdGltZUludGVydmFsICYmICsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgZC54ID0gKHdpZHRoICogKHJhbmRvbSgpICsgMC41KSkgPj4gMTtcbiAgICAgICAgICAgICAgICBkLnkgPSAoaGVpZ2h0ICogKHJhbmRvbSgpICsgMC41KSkgPj4gMTtcbiAgICAgICAgICAgICAgICBjbG91ZFNwcml0ZShjb250ZXh0QW5kUmF0aW8sIGQsIGRhdGEsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChkLmhhc1RleHQgJiYgcGxhY2UoYm9hcmQsIGQsIGJvdW5kcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFncy5wdXNoKGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm91bmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsb3VkLmhhc0ltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGJvdW5kcyBpZiBpbWFnZSBtYXNrIG5vdCBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG91ZEJvdW5kcyhib3VuZHMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgeDogZC54ICsgZC54MCwgeTogZC55ICsgZC55MCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgeDogZC54ICsgZC54MSwgeTogZC55ICsgZC55MSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUZW1wb3JhcnkgaGFja1xuICAgICAgICAgICAgICAgICAgICBkLnggLT0gc2l6ZVswXSA+PiAxO1xuICAgICAgICAgICAgICAgICAgICBkLnkgLT0gc2l6ZVsxXSA+PiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsb3VkLl90YWdzID0gdGFncztcbiAgICAgICAgICAgIGNsb3VkLl9ib3VuZHMgPSBib3VuZHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb3VkO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dChjYW52YXMpIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XG4gICAgICAgIHZhciByYXRpbyA9IE1hdGguc3FydChjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YS5sZW5ndGggPj4gMik7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IChjdyA8PCA1KSAvIHJhdGlvO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2ggLyByYXRpbztcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIHJldHVybiB7IGNvbnRleHQ6IGNvbnRleHQsIHJhdGlvOiByYXRpbyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwbGFjZShib2FyZCwgdGFnLCBib3VuZHMpIHtcbiAgICAgICAgLy8gY29uc3QgcGVyaW1ldGVyID0gW3sgeDogMCwgeTogMCB9LCB7IHg6IHNpemVbMF0sIHk6IHNpemVbMV0gfV0sXG4gICAgICAgIHZhciBzdGFydFggPSB0YWcueCwgc3RhcnRZID0gdGFnLnksIG1heERlbHRhID0gTWF0aC5zcXJ0KHNpemVbMF0gKiBzaXplWzBdICsgc2l6ZVsxXSAqIHNpemVbMV0pLCBzID0gc3BpcmFsKHNpemUpLCBkdCA9IHJhbmRvbSgpIDwgMC41ID8gMSA6IC0xO1xuICAgICAgICB2YXIgZHhkeSwgdCA9IC1kdCwgZHgsIGR5O1xuICAgICAgICB3aGlsZSAoKGR4ZHkgPSBzKCh0ICs9IGR0KSkpKSB7XG4gICAgICAgICAgICBkeCA9IH5+ZHhkeVswXTtcbiAgICAgICAgICAgIGR5ID0gfn5keGR5WzFdO1xuICAgICAgICAgICAgaWYgKE1hdGgubWluKE1hdGguYWJzKGR4KSwgTWF0aC5hYnMoZHkpKSA+PSBtYXhEZWx0YSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHRhZy54ID0gc3RhcnRYICsgZHg7XG4gICAgICAgICAgICB0YWcueSA9IHN0YXJ0WSArIGR5O1xuICAgICAgICAgICAgaWYgKHRhZy54ICsgdGFnLngwIDwgMCB8fCB0YWcueSArIHRhZy55MCA8IDAgfHwgdGFnLnggKyB0YWcueDEgPiBzaXplWzBdIHx8IHRhZy55ICsgdGFnLnkxID4gc2l6ZVsxXSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIFRPRE8gb25seSBjaGVjayBmb3IgY29sbGlzaW9ucyB3aXRoaW4gY3VycmVudCBib3VuZHMuXG4gICAgICAgICAgICBpZiAoIWJvdW5kcyB8fCAhY2xvdWRDb2xsaWRlKHRhZywgYm9hcmQsIHNpemVbMF0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFib3VuZHMgfHwgY29sbGlkZVJlY3RzKHRhZywgYm91bmRzKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gdGFnLnNwcml0ZSwgdyA9IHRhZy53aWR0aCA+PiA1LCBzdyA9IHNpemVbMF0gPj4gNSwgbHggPSB0YWcueCAtICh3IDw8IDQpLCBzeCA9IGx4ICYgMHg3ZiwgbXN4ID0gMzIgLSBzeCwgaCA9IHRhZy55MSAtIHRhZy55MDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3QgPSB2b2lkIDAsIHggPSAodGFnLnkgKyB0YWcueTApICogc3cgKyAobHggPj4gNSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHc7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvYXJkW3ggKyBpXSB8PSAobGFzdCA8PCBtc3gpIHwgKGkgPCB3ID8gKGxhc3QgPSBzcHJpdGVbaiAqIHcgKyBpXSkgPj4+IHN4IDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN3O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YWcuc3ByaXRlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjbG91ZC5jcmVhdGVNYXNrID0gZnVuY3Rpb24gKGltZykge1xuICAgICAgICB2YXIgY2FuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHZhciBfYSA9IHRzbGliXzEuX19yZWFkKHNpemUsIDIpLCB3aWR0aCA9IF9hWzBdLCBoZWlnaHQgPSBfYVsxXTtcbiAgICAgICAgdmFyIHczMiA9IHdpZHRoID4+IDU7XG4gICAgICAgIHZhciBib2FyZCA9IHplcm9BcnJheSgod2lkdGggPj4gNSkgKiBoZWlnaHQpO1xuICAgICAgICBjYW4ud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FuLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdmFyIGN4dCA9IGNhbi5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjeHQuZHJhd0ltYWdlKGltZywgMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIGltYWdlRGF0YSA9IGN4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoZWlnaHQ7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSB3MzIgKiBqICsgKGkgPj4gNSk7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IChqICogd2lkdGggKyBpKSA8PCAyO1xuICAgICAgICAgICAgICAgIHZhciBmbGFnID0gaW1hZ2VEYXRhW3RtcF0gPj0gMjUwICYmIGltYWdlRGF0YVt0bXAgKyAxXSA+PSAyNTAgJiYgaW1hZ2VEYXRhW3RtcCArIDJdID49IDI1MDtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IGZsYWcgPyAxIDw8ICgzMSAtIChpICUgMzIpKSA6IDA7XG4gICAgICAgICAgICAgICAgYm9hcmRba10gfD0gbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbG91ZC5ib2FyZCA9IGJvYXJkO1xuICAgICAgICBjbG91ZC5oYXNJbWFnZSA9IHRydWU7XG4gICAgfTtcbiAgICBjbG91ZC50aW1lSW50ZXJ2YWwgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgodGltZUludGVydmFsID0gXyA9PSBudWxsID8gSW5maW5pdHkgOiBfKSwgY2xvdWQpIDogdGltZUludGVydmFsO1xuICAgIH07XG4gICAgY2xvdWQud29yZHMgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgod29yZHMgPSBfKSwgY2xvdWQpIDogd29yZHM7XG4gICAgfTtcbiAgICBjbG91ZC5zaXplID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKHNpemUgPSBbK19bMF0sICtfWzFdXSksIGNsb3VkKSA6IHNpemU7XG4gICAgfTtcbiAgICBjbG91ZC5mb250ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKGZvbnQgPSBmdW5jdG9yKF8pKSwgY2xvdWQpIDogZm9udDtcbiAgICB9O1xuICAgIGNsb3VkLmZvbnRTdHlsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChmb250U3R5bGUgPSBmdW5jdG9yKF8pKSwgY2xvdWQpIDogZm9udFN0eWxlO1xuICAgIH07XG4gICAgY2xvdWQuZm9udFdlaWdodCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChmb250V2VpZ2h0ID0gZnVuY3RvcihfKSksIGNsb3VkKSA6IGZvbnRXZWlnaHQ7XG4gICAgfTtcbiAgICBjbG91ZC5yb3RhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgocm90YXRlID0gZnVuY3RvcihfKSksIGNsb3VkKSA6IHJvdGF0ZTtcbiAgICB9O1xuICAgIGNsb3VkLnRleHQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgodGV4dCA9IGZ1bmN0b3IoXykpLCBjbG91ZCkgOiB0ZXh0O1xuICAgIH07XG4gICAgY2xvdWQuc3BpcmFsID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKHNwaXJhbCA9IHNwaXJhbHNbX10gfHwgXyksIGNsb3VkKSA6IHNwaXJhbDtcbiAgICB9O1xuICAgIGNsb3VkLmZvbnRTaXplID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKGZvbnRTaXplID0gZnVuY3RvcihfKSksIGNsb3VkKSA6IGZvbnRTaXplO1xuICAgIH07XG4gICAgY2xvdWQucGFkZGluZyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChwYWRkaW5nID0gZnVuY3RvcihfKSksIGNsb3VkKSA6IHBhZGRpbmc7XG4gICAgfTtcbiAgICBjbG91ZC5yYW5kb20gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgocmFuZG9tID0gXyksIGNsb3VkKSA6IHJhbmRvbTtcbiAgICB9O1xuICAgIHJldHVybiBjbG91ZDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRfMTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy92aWV3LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdmlldy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciB3b2xmeTg3X2V2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgd29sZnk4Ny1ldmVudGVtaXR0ZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fd29sZnk4Ny1ldmVudGVtaXR0ZXJANS4yLjlAd29sZnk4Ny1ldmVudGVtaXR0ZXIvRXZlbnRFbWl0dGVyLmpzXCIpKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG5mdW5jdGlvbiBjbG9uZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB1dGlsXzEuZm9ySW4ob3B0aW9ucywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHV0aWxfMS5pc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUuaXNWaWV3KSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHV0aWxfMS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZS5jb25jYXQoW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHV0aWxfMS5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB1dGlsXzEuY2xvbmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIOaVsOaNruinhuWbvlxuICogQHB1YmxpY1xuICovXG52YXIgVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZpZXcoZGF0YVNldCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5pivVmlld1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaXNWaWV3ID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuaYr1ZpZXdcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmlzRGF0YVZpZXcgPSB0cnVlOyAvLyBhbGlhc1xuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLndhdGNoaW5nU3RhdGVzID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaVsOaNruinhuWbvuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuZGF0YVR5cGUgPSAndGFibGUnO1xuICAgICAgICAvKipcbiAgICAgICAgICog5bey5bqU55So55qEIHRyYW5zZm9ybVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMudHJhbnNmb3JtcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICog5Y6f5aeL5pWw5o2uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vcmlnaW4gPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWtmOWCqOWkhOeQhuWQjueahOaVsOaNrlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMucm93cyA9IFtdO1xuICAgICAgICBpZiAoZGF0YVNldCAmJiBkYXRhU2V0LmlzRGF0YVNldCkge1xuICAgICAgICAgICAgX3RoaXMuZGF0YVNldCA9IGRhdGFTZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5kYXRhU2V0ID0gbnVsbDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkYXRhU2V0O1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmxvb3NlID0gIV90aGlzLmRhdGFTZXQ7XG4gICAgICAgIC8vIFRPRE86XG4gICAgICAgIC8vIGFzc2lnbihtZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBfdGhpcy53YXRjaGluZ1N0YXRlcyA9IG9wdGlvbnMud2F0Y2hpbmdTdGF0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfdGhpcy5sb29zZSkge1xuICAgICAgICAgICAgdmFyIHdhdGNoaW5nU3RhdGVzXzEgPSBfdGhpcy53YXRjaGluZ1N0YXRlcztcbiAgICAgICAgICAgIGRhdGFTZXQub24oJ3N0YXRlY2hhbmdlJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbF8xLmlzQXJyYXkod2F0Y2hpbmdTdGF0ZXNfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhdGNoaW5nU3RhdGVzXzEuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVFeGVjdXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZUV4ZWN1dGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFZpZXcucHJvdG90eXBlLl9wYXJzZVN0YXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByKSB7XG4gICAgICAgIHZhciBkYXRhU2V0ID0gdGhpcy5kYXRhU2V0O1xuICAgICAgICBpZiAoZGF0YVNldCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBtYXRjaGVkID0gL15cXCRzdGF0ZVxcLihcXHcrKS8uZXhlYyhleHByKTtcbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhU2V0LnN0YXRlW21hdGNoZWRbMV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH07XG4gICAgVmlldy5wcm90b3R5cGUuX3ByZXBhcnNlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvcHRpb25zQ2xvbmVkID0gY2xvbmVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5sb29zZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnNDbG9uZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbF8xLmZvckluKG9wdGlvbnNDbG9uZWQsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBpZiAodXRpbF8xLmlzU3RyaW5nKHZhbHVlKSAmJiAvXlxcJHN0YXRlXFwuLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNDbG9uZWRba2V5XSA9IF90aGlzLl9wYXJzZVN0YXRlRXhwcmVzc2lvbih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3B0aW9uc0Nsb25lZDtcbiAgICB9O1xuICAgIC8vIGNvbm5lY3RvcnNcbiAgICBWaWV3LnByb3RvdHlwZS5fcHJlcGFyZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gd2FybmluZyBtZS5vcmlnaW4gaXMgcHJvdGVjdGVkXG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IHsgc291cmNlOiBzb3VyY2UsIG9wdGlvbnM6IG9wdGlvbnMgfTtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgVmlldyB8fCB1dGlsXzEuaXNTdHJpbmcoc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luID0gVmlldy5EYXRhU2V0LmdldENvbm5lY3RvcignZGVmYXVsdCcpKHNvdXJjZSwgdGhpcy5kYXRhU2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWxfMS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGJyYW5jaDogaWYgc291cmNlIGlzIGxpa2UgWydkYXRhdmlldzEnLCAnZGF0YXZpZXcyJ11cbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbiA9IHNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWxfMS5pc09iamVjdChzb3VyY2UpICYmIHNvdXJjZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLl9wcmVwYXJzZU9wdGlvbnMoc291cmNlKTsgLy8gY29ubmVjdG9yIHdpdGhvdXQgc291cmNlXG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnaW4gPSBWaWV3LkRhdGFTZXQuZ2V0Q29ubmVjdG9yKG9wdHMudHlwZSkob3B0cywgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNvdXJjZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLl9wcmVwYXJzZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbiA9IFZpZXcuRGF0YVNldC5nZXRDb25uZWN0b3Iob3B0cy50eXBlKShzb3VyY2UsIG9wdHMsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm93cyA9IHV0aWxfMS5kZWVwTWl4KFtdLCB0aGlzLm9yaWdpbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVmlldy5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9wcmVwYXJlU291cmNlKHNvdXJjZSwgb3B0aW9ucykuX3JlRXhlY3V0ZVRyYW5zZm9ybXMoKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogIOaJp+ihjOaVsOaNruWkhOeQhuaVsOaNruOAguaJp+ihjOWujOi/meS4quWHveaVsOWQju+8jHRyYW5zZm9ybSDkvJrooqvlrZjlgqhcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIOafkOenjeexu+Wei+eahHRyYW5zZm9ybVxuICAgICAqL1xuICAgIFZpZXcucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHlwZSkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1zLnB1c2gob3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl9leGVjdXRlVHJhbnNmb3JtKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVmlldy5wcm90b3R5cGUuX2V4ZWN1dGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5fcHJlcGFyc2VPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gVmlldy5EYXRhU2V0LmdldFRyYW5zZm9ybShvcHRpb25zLnR5cGUpO1xuICAgICAgICB0cmFuc2Zvcm0odGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBWaWV3LnByb3RvdHlwZS5fcmVFeGVjdXRlVHJhbnNmb3JtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1zLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIF90aGlzLl9leGVjdXRlVHJhbnNmb3JtKG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFZpZXcucHJvdG90eXBlLmFkZFJvdyA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdGhpcy5yb3dzLnB1c2gocm93KTtcbiAgICB9O1xuICAgIFZpZXcucHJvdG90eXBlLnJlbW92ZVJvdyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB0aGlzLnJvd3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICAgIFZpZXcucHJvdG90eXBlLnVwZGF0ZVJvdyA9IGZ1bmN0aW9uIChpbmRleCwgbmV3Um93KSB7XG4gICAgICAgIHV0aWxfMS5hc3NpZ24odGhpcy5yb3dzW2luZGV4XSwgbmV3Um93KTtcbiAgICB9O1xuICAgIFZpZXcucHJvdG90eXBlLmZpbmRSb3dzID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHV0aWxfMS5pc01hdGNoKHJvdywgcXVlcnkpOyB9KTtcbiAgICB9O1xuICAgIFZpZXcucHJvdG90eXBlLmZpbmRSb3cgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxfMS5maW5kKHRoaXMucm93cywgcXVlcnkpO1xuICAgIH07XG4gICAgLy8gY29sdW1uc1xuICAgIFZpZXcucHJvdG90eXBlLmdldENvbHVtbk5hbWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmlyc3RSb3cgPSB0aGlzLnJvd3NbMF07XG4gICAgICAgIGlmIChmaXJzdFJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5rZXlzKGZpcnN0Um93KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBWaWV3LnByb3RvdHlwZS5nZXRDb2x1bW5OYW1lID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtbk5hbWVzKClbaW5kZXhdO1xuICAgIH07XG4gICAgVmlldy5wcm90b3R5cGUuZ2V0Q29sdW1uSW5kZXggPSBmdW5jdGlvbiAoY29sdW1uTmFtZSkge1xuICAgICAgICB2YXIgY29sdW1uTmFtZXMgPSB0aGlzLmdldENvbHVtbk5hbWVzKCk7XG4gICAgICAgIHJldHVybiBjb2x1bW5OYW1lcy5pbmRleE9mKGNvbHVtbk5hbWUpO1xuICAgIH07XG4gICAgVmlldy5wcm90b3R5cGUuZ2V0Q29sdW1uID0gZnVuY3Rpb24gKGNvbHVtbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93cy5tYXAoZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcm93W2NvbHVtbk5hbWVdOyB9KTtcbiAgICB9O1xuICAgIFZpZXcucHJvdG90eXBlLmdldENvbHVtbkRhdGEgPSBmdW5jdGlvbiAoY29sdW1uTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW4oY29sdW1uTmFtZSk7XG4gICAgfTtcbiAgICAvLyBkYXRhIHByb2Nlc3NcbiAgICBWaWV3LnByb3RvdHlwZS5nZXRTdWJzZXQgPSBmdW5jdGlvbiAoc3RhcnRSb3dJbmRleCwgZW5kUm93SW5kZXgsIGNvbHVtbk5hbWVzKSB7XG4gICAgICAgIHZhciBzdWJzZXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0Um93SW5kZXg7IGkgPD0gZW5kUm93SW5kZXg7IGkrKykge1xuICAgICAgICAgICAgc3Vic2V0LnB1c2godXRpbF8xLnBpY2sodGhpcy5yb3dzW2ldLCBjb2x1bW5OYW1lcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzZXQ7XG4gICAgfTtcbiAgICBWaWV3LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChwcmV0dHlQcmludCkge1xuICAgICAgICBpZiAocHJldHR5UHJpbnQgPT09IHZvaWQgMCkgeyBwcmV0dHlQcmludCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChwcmV0dHlQcmludCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMucm93cywgbnVsbCwgMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMucm93cyk7XG4gICAgfTtcbiAgICBWaWV3LnByb3RvdHlwZS5fcmVFeGVjdXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9zb3VyY2UsIHNvdXJjZSA9IF9hLnNvdXJjZSwgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3ByZXBhcmVTb3VyY2Uoc291cmNlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fcmVFeGVjdXRlVHJhbnNmb3JtcygpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIFtdKTtcbiAgICB9O1xuICAgIHJldHVybiBWaWV3O1xufSh3b2xmeTg3X2V2ZW50ZW1pdHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuVmlldyA9IFZpZXc7XG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtc2V0LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsUUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///162\n");

/***/ }),

/***/ 344:
/***/ (function(module, exports) {

eval("var containers = []; // will store container HTMLElement references\nvar styleElements = []; // will store {prepend: HTMLElement, append: HTMLElement}\n\nvar usage = 'insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).';\n\nfunction insertCss(css, options) {\n    options = options || {};\n\n    if (css === undefined) {\n        throw new Error(usage);\n    }\n\n    var position = options.prepend === true ? 'prepend' : 'append';\n    var container = options.container !== undefined ? options.container : document.querySelector('head');\n    var containerId = containers.indexOf(container);\n\n    // first time we see this container, create the necessary entries\n    if (containerId === -1) {\n        containerId = containers.push(container) - 1;\n        styleElements[containerId] = {};\n    }\n\n    // try to get the correponding container + position styleElement, create it otherwise\n    var styleElement;\n\n    if (styleElements[containerId] !== undefined && styleElements[containerId][position] !== undefined) {\n        styleElement = styleElements[containerId][position];\n    } else {\n        styleElement = styleElements[containerId][position] = createStyleElement();\n\n        if (position === 'prepend') {\n            container.insertBefore(styleElement, container.childNodes[0]);\n        } else {\n            container.appendChild(styleElement);\n        }\n    }\n\n    // strip potential UTF-8 BOM if css was read from a file\n    if (css.charCodeAt(0) === 0xFEFF) { css = css.substr(1, css.length); }\n\n    // actually add the stylesheet\n    if (styleElement.styleSheet) {\n        styleElement.styleSheet.cssText += css\n    } else {\n        styleElement.textContent += css;\n    }\n\n    return styleElement;\n};\n\nfunction createStyleElement() {\n    var styleElement = document.createElement('style');\n    styleElement.setAttribute('type', 'text/css');\n    return styleElement;\n}\n\nmodule.exports = insertCss;\nmodule.exports.insertCss = insertCss;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2luc2VydC1jc3MvaW5kZXguanM/MWFlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29udGFpbmVycyA9IFtdOyAvLyB3aWxsIHN0b3JlIGNvbnRhaW5lciBIVE1MRWxlbWVudCByZWZlcmVuY2VzXG52YXIgc3R5bGVFbGVtZW50cyA9IFtdOyAvLyB3aWxsIHN0b3JlIHtwcmVwZW5kOiBIVE1MRWxlbWVudCwgYXBwZW5kOiBIVE1MRWxlbWVudH1cblxudmFyIHVzYWdlID0gJ2luc2VydC1jc3M6IFlvdSBuZWVkIHRvIHByb3ZpZGUgYSBDU1Mgc3RyaW5nLiBVc2FnZTogaW5zZXJ0Q3NzKGNzc1N0cmluZ1ssIG9wdGlvbnNdKS4nO1xuXG5mdW5jdGlvbiBpbnNlcnRDc3MoY3NzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoY3NzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb24gPSBvcHRpb25zLnByZXBlbmQgPT09IHRydWUgPyAncHJlcGVuZCcgOiAnYXBwZW5kJztcbiAgICB2YXIgY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29udGFpbmVyIDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpO1xuICAgIHZhciBjb250YWluZXJJZCA9IGNvbnRhaW5lcnMuaW5kZXhPZihjb250YWluZXIpO1xuXG4gICAgLy8gZmlyc3QgdGltZSB3ZSBzZWUgdGhpcyBjb250YWluZXIsIGNyZWF0ZSB0aGUgbmVjZXNzYXJ5IGVudHJpZXNcbiAgICBpZiAoY29udGFpbmVySWQgPT09IC0xKSB7XG4gICAgICAgIGNvbnRhaW5lcklkID0gY29udGFpbmVycy5wdXNoKGNvbnRhaW5lcikgLSAxO1xuICAgICAgICBzdHlsZUVsZW1lbnRzW2NvbnRhaW5lcklkXSA9IHt9O1xuICAgIH1cblxuICAgIC8vIHRyeSB0byBnZXQgdGhlIGNvcnJlcG9uZGluZyBjb250YWluZXIgKyBwb3NpdGlvbiBzdHlsZUVsZW1lbnQsIGNyZWF0ZSBpdCBvdGhlcndpc2VcbiAgICB2YXIgc3R5bGVFbGVtZW50O1xuXG4gICAgaWYgKHN0eWxlRWxlbWVudHNbY29udGFpbmVySWRdICE9PSB1bmRlZmluZWQgJiYgc3R5bGVFbGVtZW50c1tjb250YWluZXJJZF1bcG9zaXRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3R5bGVFbGVtZW50ID0gc3R5bGVFbGVtZW50c1tjb250YWluZXJJZF1bcG9zaXRpb25dO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlRWxlbWVudCA9IHN0eWxlRWxlbWVudHNbY29udGFpbmVySWRdW3Bvc2l0aW9uXSA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3ByZXBlbmQnKSB7XG4gICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgY29udGFpbmVyLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdHJpcCBwb3RlbnRpYWwgVVRGLTggQk9NIGlmIGNzcyB3YXMgcmVhZCBmcm9tIGEgZmlsZVxuICAgIGlmIChjc3MuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7IGNzcyA9IGNzcy5zdWJzdHIoMSwgY3NzLmxlbmd0aCk7IH1cblxuICAgIC8vIGFjdHVhbGx5IGFkZCB0aGUgc3R5bGVzaGVldFxuICAgIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ICs9IGNzc1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlRWxlbWVudC50ZXh0Q29udGVudCArPSBjc3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlRWxlbWVudDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCgpIHtcbiAgICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgcmV0dXJuIHN0eWxlRWxlbWVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRDc3M7XG5tb2R1bGUuZXhwb3J0cy5pbnNlcnRDc3MgPSBpbnNlcnRDc3M7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///344\n");

/***/ })

}]);